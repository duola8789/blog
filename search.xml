<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node15 Node中的事件循环]]></title>
    <url>%2F2019%2F10%2F20%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode15%20Node%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Node中的事件循环，与浏览器中的事件循环，还是有一些不同，下面是学习笔记。 事件循环Node.js是单线程的语言，是通过事件循环处理非阻塞I/O操作的，Node会将这些操作转移到系统内核中，内核会在后台处理多种操作。当其中一个操作完成的时候，内核将通知Node将对应的回调函数加入轮询队列中。 Node的I/O处理使用了自己设计的基于事件驱动的跨平台抽象层libuv，它封装了不同操作系统的一些底层特性，对外提供统一的API，事件循环也是有libuv负责 Node中的每次事件循环都包含了6个阶段： （1）timers阶段：这个阶段执行Timer（setTimeout、setInterval）的回调函数 （2）I/O回调阶段：执行一些系统调用错误的回调（比如网络通信的错误回调函数） （3）idle，prepare阶段：仅供Node内部使用 （4）poll（轮询）阶段：获取新的I/O事件，执行I/O相关的回调函数，适当的条件下将Node阻塞在这里 （5）check阶段：执行setImmediate()的回调函数 （6）close callbacks阶段：执行一些准备关闭的回调函数，比如执行Socket的close事件回调 重点关注timers、poll和check三个阶段，日常开发中的绝大部分异步任务都是在这三个阶段处理的。 timers阶段在这个阶段，Node会检查有无超时的Timer，如果有则把其回调函数压入timer的任务队列中等待执行。 同浏览器环境一样，Node并不能保证Timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受到系统的影响，比如下面的代码setTimeout和setImmediate的执行顺序是不确定的： 1234567setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 0)setImmediate(() =&gt; &#123; console.log('immediate')&#125;) 但是如果在一个I/O回调中，那一定是setImmediate先执行，因为poll阶段后面就是check阶段。 poll阶段这个阶段主要有两个功能： 处理poll队列的事件 如果有超时的timer，则执行timer的回调函数 在这个阶段，Event Loop会同步执行poll队列中的回调函数，直到队列为空，然后Event Loop会去检查check队列中有无预设的setImmediate()： 有预设的setImmediate()，Event Loop将结束poll阶段进入check阶段，并执行check阶段的任务队列 如果没有预设的setImmediate()，Event Loop检查timer队列是否为空，如果timer非空，则Event Loop开始下一轮事件循环 如果timer队列也为空，那么Event Loop将阻塞在该阶段等待。 check阶段setImmediate()的回调函数会被加入check队列中 process.nextTick()从语义角度来看，setImmediate应该与process.nextTick()名字调换。process.nextTick()会在各个阶段之间进行，准确的说，是在当前阶段的尾部执行。一旦执行就要直到nextTick队列被清空，才会进入到下一个事件阶段。 nextTick会在异步任务之前执行。 如果递归调用，会导致Event Loop卡死。 与浏览器事件循环的差异浏览器环境下，微任务Microtask的任务队列是在每个宏任务Macrotask任务执行完成后执行： 在Node中，Microtask会在事件循环的各个阶段之间执行，也就是在一个阶段执行完毕，就回去执行Microtask队列的任务。 总结Node.js的事件循环分为了六个阶段，其中常用的是timers、poll和check阶段 Event Loop在每个阶段都有一个任务队列，当执行到某个阶段时将执行该阶段的任务队列，知道队列清空才会进入下一个阶段。 当所有阶段被顺序执行一次后，事件循环就完成了一个Tick。 浏览器环境和Node环境下，Microtask任务队列的执行时机不同：浏览器的Microtask在事件循环的Macrotask执行完成后执行，Node中Microtask会在各个循环阶段之间执行。 练习1下面的代码在浏览器和Node环境下执行的结果各是什么： 12345678910111213setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0) 浏览器环境下： 1234timer1 promise1timer2promise2 Node环境下： 1234timer1timer2promise1promise2 浏览器环境下比较好理解了，每次执行完一次宏任务，都要去检查并执行微任务队列。 在Node环境下，在timer阶段，先执行timer1后将promsie1放到微任务队列，由于Node中的微任务队列是在各个阶段之间执行的，所以此时不会执行微任务队列，而是继续执行第二个timer2，所以两个setTimeout先后执行，执行完成后在会执行为微任务。 练习212345678910process.nextTick(function A() &#123; console.log(1); process.nextTick(function B() &#123; console.log(2); &#125;);&#125;);setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED');&#125;) 结果是： 12312TIMEOUT FIRED 这是因为process.nextTick会在每个阶段之间进行，也可以理解为在所有阶段之前进行，它会在所有异步任务之前进行，而且其队列清空之前会持续执行。 练习312345678910setImmediate(function A() &#123; console.log(1); setImmediate(function B() &#123; console.log(2); &#125;);&#125;);setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED');&#125;, 0); 上面代码中，1和TIMEOUT FIRED哪个先执行是不确定的，运行结果可能是1--TIMEOUT FIRED--2，也可能是TIMEOUT FIRED--1--2。 但是如果放在了一个I/O回调中，执行顺序就是确定的： 123456789101112131415161718const fs = require('fs');fs.readFile('readme.md', err =&gt; &#123; if (err) &#123; console.log(err); return; &#125; setImmediate(function A() &#123; console.log(1); setImmediate(function B() &#123; console.log(2); &#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;); 在一个I/O回调中，那一定是setImmediate先执行，因为poll阶段后面就是check阶段。 参考 深入理解js事件循环机制（Node.js篇）@lunnelv Node.js 事件循环，定时器和 process.nextTick()@Node.js文档 JavaScript 运行机制详解：再谈Event Loop@阮一峰的网络日志]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS38 两列布局]]></title>
    <url>%2F2019%2F10%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS38%20%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[面试时经常遇到一个比较基础的问题，如何实现一列定宽、一列自适应的两列布局？我实际工作中一般都会使用flex来进行布局，但是有的时候想简单一点，就直接用float布局，结果阴沟里翻了船，手写代码除了错误。所以需要好好总结一下，都有哪些常用的方式。 准备工作HTML结构： 123456&lt;body&gt;&lt;div class="left left1"&gt;固定宽度200px&lt;/div&gt;&lt;div class="right right1"&gt; &lt;p&gt;宽度自适应&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 基础样式： 123456789101112131415* &#123; margin: 0; padding: 0;&#125;.left &#123; width: 200px; height: 100px; background: darkcyan;&#125;.right &#123; height: 200px; background: red;&#125; 此时布局如下： 最终效果： 1 float + margin最基础的float布局就可以实现，要注意的是，默认的块级元素会充满整个父容器的宽度，我们就是利用这一点，来实现right的自适应宽度。 这种方法需要让右侧元素的外边距等于左侧元素的宽度。 1234567.left1 &#123; float: left&#125;.right1 &#123; margin-left: 200px;&#125; 2 float + BFCfloat元素的宽度会自动缩减为能容纳内部元素的最小宽度。上一种方法需要将right的margin-left设定为left的宽度，如果left的宽度不固定就无能为力。 其实可以利用BFC来实现，通过开启右侧元素的overflow可以出发BFC块级格式上下文，触发BFC之后，元素内部布局不再受到外部布局的影响。这样即使左侧元素不固定，也可以实现。 1234567.left1 &#123; float: left&#125;.right1 &#123; overflow: hidden;&#125; 3 绝对定位 + margin原理与第一种方式类似。 123456789.left1 &#123; position: absolute; left: 0; top: 0;&#125;.right1 &#123; margin-left: 200px;&#125; 3 flex布局最常用的布局方式之一了。 我原来都习惯将flex-grow单独写，其实可以直接为子元素设置flex属性，它是flex-grow、flex-shrink和flex-basis的缩写，默认取值为0 1 auto，所以左侧元素可以不进行设置，右侧元素直接设置定为flex: 1，这样右侧元素会自动充满空间。 12345678910body &#123; display: flex;&#125;.left1 &#123;&#125;.right1 &#123; flex: 1;&#125; 要注意的是flex-basis设定的宽度，比直接设定width有更高的优先级。 4 inline-block + calcinline-block后，两个块级元素会并排排列，默认宽度都缩减为最小宽度，所以利用calc计算出右侧元素的宽度，就可以充满剩余空间。 要注意的是，HTML中的空格也会占据一定空间，利用calc计算时会出现误差，所以需要分别设定font-size，让空格不占据空间。 1234567891011121314body &#123; font-size: 0;&#125;.left1 &#123; display: inline-block; font-size: 14px;&#125;.right1 &#123; display: inline-block; width: calc( 100% - 200px); font-size: 14px;&#125; 5 gridgrid实际上是最适合布局的方案了，但是还是需要考虑兼容性的。 fr是网格布局提供的关键字，来指明元素占据剩余空间的比例。 1234body &#123; display: grid; grid-template-columns: 200px 1fr;&#125; 此外，还可以使用table布局，但是在2019年，实现想不到使用table布局的理由了。 参考 Flex 布局教程：语法篇@阮一峰的网络日志 flex-basis@MDN CSS Grid 网格布局教程@阮一峰的网络日志]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>两列布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础04 二叉树遍历]]></title>
    <url>%2F2019%2F09%2F30%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F01%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8004%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树遍历。 深度优先遍历和广度优先遍历二叉树的遍历可以使用深度优先遍历（DFS，Depth-First-Search）和广度优先遍历（BFS，Breadth-First-Search），可以使用递归算法和非递归算法实现。 递归算法性能并无优势，但是可读性好，非递归算法的性能更优。 深度优先遍历按照遍历的次序可以分为三种： 前序遍历（dlr）：根-左-右 中序遍历（ldr）：左-根-右 后序遍历（lrd）：左-右-根 首先构造出一个二叉树： 123456789101112131415161718192021222324252627282930313233const nodes = &#123; node: 100, left: &#123; node: 5, left: &#123; node: 4, left: &#123; node: 6, &#125;, right: &#123; node: 7, left: &#123; node: 200, &#125;, right: &#123; node: 300 &#125; &#125; &#125;, right: &#123; node: 3, right: &#123; node: 8 &#125; &#125; &#125;, right: &#123; node: 2, right: &#123; node: 1 &#125; &#125;&#125;; 结果： 1234567891011/** 100* / \* 5 2* / \ \* 4 3 1* / \ \* 6 7 8* / \* 200 300*/ 深度优先遍历 - 前序遍历先访问根节点，然后访问左节点、右节点： （1）使用递归算法： 如果二叉树为空，则遍历结束，否则 访问根节点 前序遍历根节点的左子树 前序遍历根节点的右子树 1234567891011/** * 深度优先搜索 - 前序遍历 - 递归算法 */function dfs_dlr_1(nodes, result = []) &#123; if (nodes.node) &#123; result.push(nodes.node); nodes.left &amp;&amp; dfs_dlr_1(nodes.left, result); nodes.right &amp;&amp; dfs_dlr_1(nodes.right, result); &#125; return result&#125; （2）使用非递归算法： 需要借助一个栈（后入先出），通过不断的压入和取出来实现，关键点是①使用栈而非队列②先push右子树再push左子树 初始化一个栈，将根节点压入栈中 档栈非空时，循环执行步骤3、4，否则结束 取出栈顶节点，节点值放入结果数组 如果该节点的右子树非空，则将右子树压入栈，如果该节点的左子树非空，则将左子树压入栈 123456789101112131415/** * 深度优先搜索 - 前序遍历 - 非递归算法 */function dfs_dlr_2(nodes) &#123; let result = []; let stack = []; stack.push(nodes); while (stack.length &gt; 0) &#123; const target = stack.pop(); result.push(target.node); target.right &amp;&amp; stack.push(target.right); target.left &amp;&amp; stack.push(target.left); &#125; return result;&#125; 深度优先遍历 - 中序遍历先访问左子树，然后访问根节点，最后访问右子树 （1）使用递归算法： 如果二叉树为空，则遍历结束，否则 中序遍历访问根节点的左子树 访问根节点 中序遍历访问根节点的右子树 1234567891011/** * 深度优先搜索 - 中序遍历 - 递归算法 */function dfs_ldr_1(nodes, result = []) &#123; if (nodes.node) &#123; nodes.left &amp;&amp; dfs_ldr_1(nodes.left, result); result.push(nodes.node); nodes.right &amp;&amp; dfs_ldr_1(nodes.right, result); &#125; return result;&#125; （2）使用非递归算法： 借助一个栈，当栈为空时结束遍历 进入遍历，判断当前节点的左子树是否存在，如果存在则将当前节点压入栈中，然后将当前节点替换为其左子树 当前节点不再存在左子树时，意味着找到了整棵树最左下角的节点，出栈一项，记录当前节点的值 将当前节点替换为出栈项的右子树，重复2 12345678910111213141516171819202122/** * 深度优先搜索 - 中序遍历 - 递归算法 */function dfs_ldr_2(nodes) &#123; let result = [], stack = [], root = nodes; while (true) &#123; while (root) &#123; stack.push(root); root = root.left; &#125; if (stack.length === 0) &#123; break; &#125; const current = stack.pop(); result.push(current.node); root = current.right; &#125; return result;&#125; 深度优先遍历 - 后序遍历先访问子树，然后访问根节点。 （1）递归算法： 如果二叉树为空，则遍历结束，否则 访问根节点 前序遍历根节点的左子树 前序遍历根节点的右子树 1234567891011/** * 深度优先搜索 - 后序遍历 - 递归算法 */function dfs_lrd_1(nodes, result = []) &#123; if (nodes.node) &#123; nodes.left &amp;&amp; dfs_lrd_1(nodes.left, result); nodes.right &amp;&amp; dfs_lrd_1(nodes.right, result); result.push(nodes.node); &#125; return result&#125; （2）使用非递归算法： 可以调整前序遍历的算法，前序遍历计算的是『根-左-右』 可以调整压入栈的顺序，将前序遍历中的先压入右子树调整为限压入左子树，调整后的顺序是『根-右-左』 后续遍历的顺序是『左-右-根』 = 『根-右-左』.reverse(); 123456789101112131415/** * 深度优先搜索 - 后序遍历 - 非递归算法 */function dfs_lrd_2(nodes) &#123; let result = [], stack = [nodes]; while (stack.length &gt; 0) &#123; const current = stack.pop(); result.push(current.node); current.left &amp;&amp; stack.push(current.left); current.right &amp;&amp; stack.push(current.right); &#125; return result.reverse();&#125; 广度优先搜索一层一层从左至右向下遍历 （没有用递归实现） 通过一个队列实现（先入先出），将后续的左节点、右节点分别加入队列 一层一层向下进行 1234567891011121314/** * 广度优先搜索，没有尝试递归算法 */function bfs_1(nodes) &#123; let result = []; let queue = [nodes]; while (queue.length &gt; 0) &#123; const current = queue.shift(); result.push(current.node); current.left &amp;&amp; queue.push(current.left); current.right &amp;&amp; queue.push(current.right); &#125; return result;&#125; 二叉树最大深度思路：使用使用广度优先搜索实现，队列中构造了一个标志level，用来标识当前深度（应该有更好的方式） 1234567891011121314151617/** * 找到二叉树的最大深度 */function getDepth(nodes) &#123; let currentDepth = 0; let queue = [&#123;value: nodes, depth: 1&#125;]; while (queue.length &gt; 0) &#123; const current = queue.shift(); const currentNode = current.value; currentDepth = Math.max(currentDepth, current.depth); currentNode.left &amp;&amp; queue.push(&#123;value: currentNode.left, depth: currentDepth + 1&#125;); currentNode.right &amp;&amp; queue.push(&#123;value: currentNode.right, depth: currentDepth + 1&#125;); &#125; return currentDepth;&#125; 二叉树翻转思路：如果根节点不为空，则将左右子节点交换，然后将左右子节点进行递归调用 12345678const reverseTree = tree =&gt; &#123; if (tree) &#123; [tree.left, tree.right] = [tree.right, tree.left]; reverseTree(tree.left); reverseTree(tree.right) &#125; return tree&#125; 参考 JS二叉树非递归遍历@segmentfault JavaScript 二叉树遍历专题：算法描述与实现@知乎 LeetCode 第 144 号问题：二叉树的前序遍历@Github LeetCode 第 145 号问题：二叉树的后序遍历@Github 二叉树与 JavaScript@掘金]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础19 TCP连接]]></title>
    <url>%2F2019%2F09%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8019%20TCP%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[TCP连接的三次握手和四次挥手笔记。 TCP的特性TCP位于网络模型中的传输层，提供可靠的字节流服务，将大块数据分割成为以报文段（segment）为单位的数据包进行管理，目的是为了传送更大数据。 一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用于TCP TCP使用了校验和确认、重传极致保证可靠传输。要注意，TCP并不能保证数据一定会被对方收到，因为这是不能的。TCP能够做的事如果有可能就把数据递送到接收方，否则就（通过放弃重传并且终端连接这一手段）通知用户。因此准确说TCP也不是100%可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 TCP的三次握手为了确保数据传输的可靠性，TCP协议采取了三次握手(three-way handshaking)策略。握手过程衡中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。 所谓的三次握手，值得是建立一个TCP连接时，需要客户端和服务器总共发送三个包，握手过程如下： （1）第一次握手 客户端首先发送一个带SYN标志（为1）的数据包给对方，指明客户端打算连接服务器的端口等信息。发送完成后，客户算进入SYN_SEND状态 （2）第二次握手 服务器收到后，回送一个带有SYN/ACK标志的数据包以示传达确认信息，发送完成后服务端进入SYN_RCVD状态 （3）第三次握手 最后客户端再回传一个带ACK标志的数据包，代表握手结束，客户端和服务端都进入ESTABLISED状态，TCP握手结束。 TCP的四次挥手TCP的连接断开需要发送四个包，因此称为四次挥手。客户端和服务端均可以主动发起挥手操作 （1）第一次挥手 假设客户端想要关闭连接，发送一个带有FIN标志的数据包给服务器，表明自己已经没有数据可以发送了，但是仍可以接受数据。 发送完毕后客户端进入FIN_WAIT_1状态 （2）第二次挥手 服务端确认客户端的FIN包，发送一个ACK确认包，表明自己接收到了客户端关闭连接的请求，但是还没有准备好关不连接 （3）第三次挥手 服务端准备好关闭连接时，向客户端发送结束连接请求，发送带有FIN标志的数据包。发送完毕后，服务端进入LAST_ACK状态，等待来自客户端的最后一个ACK （4）第四次挥手 客户端接收到服务端的关闭请求，发送一个ACK确认包，进入TIME_WAIT状态，等待可能出现的要求重传的ACK包 服务端接受到这个确认包后，关闭连接，进入CLOSED状态。 客户端等待了某个固定时间之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。 参考 《图解HTTP》 TCP 的特性Q@笔试面试知识整理]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解13 bind函数的实现]]></title>
    <url>%2F2019%2F09%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A313%20bind%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[面试经常遇到的问题，以前的实现考虑还是不太全面，总结了一下。 定义bind的作用和call与apply类似，区别在于使用上。bind的执行的结果返回的是绑定了一个对象的新函数 先看一个使用例子： 123456789var obj = &#123; name: 'Jay' &#125;;function sayName()&#123; console.log(this.name);&#125;var fn = sayName.bind(obj) ;fn() // 'Jay' MDN上的定义： bind()方法创建了一个新的函数，在bind()被调用时，这个新函数的this会被设定为bind方法传入的第一个参数，其余的参数将作为新函数的参数供调用时使用。 从上面的定义来看，bind函数的功能包括： 改变原函数的this指向，绑定this 返回原函数的拷贝，并预传参数 要注意的，当使用new调用bind返回的参数时，bind绑定this失效。这是由于上面提到过的this绑定的优先级，new的优先级高于bind 简易版在面试过程中，无数次遇到过这个问题，如何自己实现一个bind函数，一般情况下，都知道了用apply/call来实现 12345678910111213141516171819202122232425Function.prototype.myBind = function (thisArg) &#123; if (typeof this !== 'function') &#123; return; &#125; const self = this; const args1 = [].slice.call(arguments, 1); return function () &#123; const args2 = [].slice.call(arguments, 0); self.apply(thisArg, args1.concat(args2)) &#125;&#125;;const obj = &#123; age: 1,&#125;;function foo(a, b) &#123; console.log(this.age, a, b);&#125;foo.bind(obj, 2)(3);// 1 2 3foo.myBind(obj, 2)(3);// 1 2 3 貌似没有问题了，实现了bind上面提到的绑定this和复制函数的功能，还附带实现了传参的实现。 但是有一点，对于绑定优先级的处理还有一些问题，this有4种绑定规则： 默认绑定 隐式绑定 显示绑定 new绑定 四种绑定规则的优先级从上到下依次递增，默认绑定的优先级最低，new绑定的优先级最高，而bind方法就是显示绑定的一种，优先级应该低于new绑定 先复习一下new调用构造函数时的过程： 创建一个全新的对象 这个对象被执行[[Prototype]]连接 将这个对象绑定到构造函数中的this 如果函数没有返回其他对象，则new操作符调用的函数则会返回这个对象 先看一下正常的bind后的函数遇到new操作符，表示是如何的： 1234567891011121314const obj = &#123;&#125;;function foo(name) &#123; this.name = name;&#125;const Person = foo.bind(obj);Person('jay');console.log(obj.name);// 'jay'let p2 = new Person('chow');console.log(obj.name); // jayconsole.log(p2.name); // chow 首先直接调用bind后的参数，这时候this指向obj，所以obj.name变成了jay，然后通过new操作符调用Person，根据上面的优先级，new的优先级更高，所以this会绑定为创建的新对象p2，所以对name的更改是对p2的name的更改，obj的name保持不变 再来看看我们的myBind方法遇到this后的表现： 1234567891011121314const obj = &#123;&#125;;function foo(name) &#123; this.name = name;&#125;const Person = foo.myBind(obj);Person('jay');console.log(obj.name);// 'jay'let p2 = new Person('chow');console.log(obj.name); // 'chow'console.log(p2.name); // undefined 而我们的简易版bind方法，一旦绑定了this后，当遇到new操作符后也不会更改，而是固定在obj上，所以在new的过程中绑定的this仍然是我们myBind绑定的对象obj，所以p2.name 所以对简易版的bind还需要优化 优化版想要解决上面的问题，关键点就是在于处理new的第三步，我们的myBind函数识别是new调用，那么就不再将this绑定到我们传入的thisArg对象，而是绑定为函数本身调用的this 那么问题就转换为了，如何判断一个函数是普通调用，还是通过new操作符调用。在new的过程中，会首先建立新建对象的原型继承，然后绑定新建对象到构造函数的this，也就是下面的过程 123456let p1 = new Person();// 1 let p1 = &#123;&#125;;// 2 p1.__proto__ === Person.prototype;// 3 p1 === this;// 4 return p1; 通过第二步和第三步，this就成为了Person的一个实例，可以通过this insetanceof Person来判断，所以可以对上面的myBind进行优化： 12345678910111213Function.prototype.myBind = function (thisArg) &#123; if (typeof this !== 'function') &#123; return; &#125; const self = this; const args1 = [].slice.call(arguments, 1); return function fBound() &#123; // 判断是否 new 调用 const target = this instanceof fBound ? this : thisArg; const args2 = [].slice.call(arguments, 0); self.apply(target, args1.concat(args2)) &#125;;&#125;; 再来验证一下效果： 1234567891011121314const obj = &#123;&#125;;function foo(name) &#123; this.name = name;&#125;const Person = foo.myBind(obj);Person('jay');console.log(obj.name);// 'jay'let p2 = new Person('chow');console.log(obj.name); // 'jay'console.log(p2.name); // 'chow' myBind的效果与原生bind的效果一致，new操作符改变了bind的this指向。 MDN上的bind实现，增加了维护原型关系的步骤，但是我并不是太理解这样做的必要性，我理解new的实现就直接将this与fBound的原型链进行了关联，可以通过instanceof判断 123456789101112131415161718192021222324252627282930313233if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; // 当执行Function.prototype.bind()时, this为Function.prototype // this.prototype(即Function.prototype.prototype)为undefined fNOP.prototype = this.prototype; &#125; // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 这个疑问先放在这里，看以后有没有机会弄明白，或者哪位大神来指点吧。（2019-09-23） 参考 Function.prototype.bind()@MDN bind 函数的实现原理@掘金]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter04 路由懒加载]]></title>
    <url>%2F2019%2F09%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F04%20Vue%20Router%2FVueRouter04%20%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Vue router 路由懒加载学习笔记。 路由懒加载路由懒加载解决的是一次加载的JS包过大的问题，将整个的JS包按照不同的路由对应的组件分割成为不同的代码块，路由访问的时候再加载对应的组件 这样的好处就是首次加载时的速度很加快，但是路由切换的过程，由于组件本身也需要通过网络请求获取，所以性能会降低 实现需要借助Vue的异步组件和Webpack的代码分割功能 实践（1）配置Babel 如果使用了Babel，需要安装syntax-dynamic-import插件，才可以使Babel正确解析下面的语法。Babel@6需要使用babel-plugin-syntax-dynamic-import，Babel@7使用@babel/plugin-syntax-dynamic-import 同时为了防止Eslint报错：Parsing error: Unexpected token import，需要使用babel-eslint，方法参考这里。 （2）需要将异步组件定义为一个返回Promise的工厂函数： 1const Foo = () =&gt; Promise.resolve(&#123; /* 组件定义 */); 也可以提供一个定义异步组件的工厂函数： （3）使用Webpack 2 提供的动态import语法来定义代码分块点 1import('./Foo.vue') // 返回 Promise 实际工作中更常见的是提供一个定义异步组件的工厂函数，我们只要传入组件名让Webpack找到 12// 懒加载工厂函数const lazyLoad = path =&gt; () =&gt; import(/* webpackChunkName: "view-[request]-[index]" */ `@/components/$&#123;path&#125;.vue`); （4）路由配置中，仍然直接引入Foo即可 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125; ]&#125;) 命名Chunk如果想把某个路由下的所有组件都打包在通个异步chunk中，那么需要使用命名chunk（需要Webpack版本2.4+）。 首先需要在Webpack的output配置项中，可以设置打包出的代码块（chunk）的名称chunkFilename，不设置的话chunkFilename默认使用[id].js（文档），我们在import中采用的特殊注释注入的webpackChunkName是无法生效的 此时各个代码块的名字都是默认的id： 想要我们注入的webpackChunkName生效，就需要在Webpack的配置文件webpack.base.conf.js中的output选项中，添加如下配置： 123456module.exports = &#123; output: &#123; filename: '[name].js', chunkFilename: '[name].chunk.js', // 新增 &#125;,&#125; 这样设置后，我们利用特殊的注释语法来设置的webpackChunkName就会替换[name]占位符 123const Foo = () =&gt; import(/* webpackChunkName: "group-foo" */ './Foo.vue')const Bar = () =&gt; import(/* webpackChunkName: "group-foo" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: "group-foo" */ './Baz.vue') 这样三个组件会打打包到同一个chunk中，不会再被分割，也就不会动态加载。 也可以在/* webpackChunkName: &quot;group-foo&quot; */中使用Webpack提供的内置的模板字符串 一般可以使用/* webpackChunkName: &quot;view-[request]-[index]&quot; */，request并没有在上面的模板中列出来，但是它可以输出我们请求这个模板的路径： 这样设置对于调试显示信息可能更全一点，要注意的事是，这个webpackChunkName的设置只能通过Webpack内置的模板字符串传入变量，不支持在业务代码中手动传入值，比如说 12// 懒加载工厂函数const lazyLoad = (view, str) =&gt; () =&gt; import(`/* webpackChunkName: "view$&#123;str&#125;-[request]-[index]" */` `@/components/demos/$&#123;view&#125;.vue`); 这样传入str是不能生效的 优化当路由增多时，routes中每个cmponent都需要按照如上的样式实现懒加载，并且在开发环境中使用懒加载，会导致代码更改的热跟新速度变慢，所以需要区分环境来使用路由的懒加载功能 可以对lazyLoad函数进行优化： 1234567const lazyLoad = path =&gt; &#123; if (process.env.NODE_ENV === 'development') &#123; const comp = require(`@/pages/$&#123;path&#125;.vue`); return comp.default || comp &#125; return () =&gt; import(/* webpackChunkName: "view-[request]-[index]" */ `@/pages/$&#123;path&#125;.vue`);&#125;; 懒加载完整的Demo在这里。 参考 路由懒加载@Vue Router 使用import()配合webpack动态导入模块时，如何指定chunk name？@github 「Vue.js」Vue-Router + Webpack 路由懒加载实现@segmentfault output.chunkFilename@webpack output.filename@webpack]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Router</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter03 提高]]></title>
    <url>%2F2019%2F09%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F04%20Vue%20Router%2FVueRouter03%20%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[Vue router 提高技巧 路由元信息routes中配置的每个路由对象是一条路由记录，路由记录中有一个meta字段，可以向这个字段中添加一些自定义的属性，可以在定义路由的时候配置meat字段： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, children: [ &#123; path: 'bar', component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 访问这个字段可以在各种守卫中通过to（或者组件中的$route对象）中获取到这个字段$route.meat 有时路由匹配会匹配父级路由及子路有，一个路由匹配到的所有路由记录都会暴露为路由对象的matched数组，数组的成员时匹配到的所有父级、子级路由的全部路由对象 下面这个例子，就是通过to.matched访问所有记录，检查meat中设定字段是否符合要求： 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 过渡特效可以用&lt;transition&gt;包围&lt;router-view&gt;，为组件添加过渡特效，这样会给所有路由设置一样的过渡效果 也可以基于当前路由与目标路由的变化关系，动态设置过渡特效： 1234&lt;!-- 使用动态的 transition name --&gt;&lt;transition :name="transitionName"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 在父组件内，watch组件的$route路由对象，动态改变transitionName 123456789// 在父组件内// watch $route 决定使用哪种过渡watch: &#123; '$route' (to, from) &#123; const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length this.transitionName = toDepth &lt; fromDepth ? 'slide-right' : 'slide-left' &#125;&#125; 数据获取有时候进入某个路由后，需要从服务器获取数据，有两种方式： （1）导航完成后获取 先完成导航，渲染组件，在接下来的组件的生命周期钩子（比如created）中获取数据，这也是比较常用的方式 123456789101112131415161718192021export default &#123; data () &#123; return &#123; data: null &#125; &#125;, created () &#123; // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData() &#125;, watch: &#123; // 如果路由有变化，会再次执行该方法 '$route': 'fetchData' &#125;, methods: &#123; fetchData () &#123; // 获取数据 &#125; &#125;&#125; 在组件中，通过$route.params获取网络请求需要的参数，再watch路由对象$route（或者在beforeRouteUpdate中）重新获取数据即可 （2）导航完成前获取 在导航转入新的路由之前获取数据，可以在目标组件的beforeRouterEnter守卫中获取数据，数据获取成功后调用next方法 12345678910111213141516171819202122232425262728293031export default &#123; data () &#123; return &#123; post: null, error: null &#125; &#125;, beforeRouteEnter (to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; &#123; next(vm =&gt; vm.setData(err, post)) &#125;) &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 beforeRouteUpdate (to, from, next) &#123; this.post = null getPost(to.params.id, (err, post) =&gt; &#123; this.setData(err, post) next() &#125;) &#125;, methods: &#123; setData (err, post) &#123; if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125; &#125;&#125; 这种方式，相当于在前一个路由组件中获取下一个路由组件的数据，用户会停留在当前界面。应该在数据获取期间显示进度条用来提示用户，如果数据获取失败，也应该展示全局的错误提醒。 页面滚动创建Router实例时，提供scrollBehavior方法，来定义页面的滚动行为： 123456const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // return 期望滚动到哪个的位置 &#125;&#125;) scrollBehavior方法需要返回滚动位置的对象信息： 12&#123; x: number, y: number &#125;&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125; // offset 只在 2.6.0+ 支持 scrollBehavior方法的第三个参数savedPosition仅当通过浏览器的『前进』『后退』按钮触发才可用，这时候返回savedPosition，就会像浏览器原生表现的一样： 1234567scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; 也可以模拟滚动到锚点的行为： 1234567scrollBehavior (to, from, savedPosition) &#123; if (to.hash) &#123; return &#123; selector: to.hash &#125; &#125;&#125; 也可以返回一个Promise来进行异步的滚动： 1234567scrollBehavior (to, from, savedPosition) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; x: 0, y: 0 &#125;) &#125;, 500) &#125;)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter02 导航守卫]]></title>
    <url>%2F2019%2F09%2F17%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F04%20Vue%20Router%2FVueRouter02%20%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[Vue Router导航守卫学习笔记。 vue-router提供了导航守卫，在路由跳转过程中来对导航进行处理，导航氛围三个级别：全局的、单个路由独享的、组件级的。 动态参数或者参数参数的改变并不会触发进入/离开的守卫，可以watch监听$route对象或者在beforeRouteUpdate函数中进行处理 全局守卫（1）全局前置守卫router.beforeEach注册全局前置守卫： 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 守卫是异步执行，导航跳转过程在所有守卫resolve之前一直处于等待中。 beforeEach接受三个参数，第一个参数to是将要进入的目标的路由对象，第二个参数from是当前导航要离开的路由对象，第三个参数next是一个函数，必须通过执行这个函数来确定导航的状态 123456789101112// 继续向下执行（执行钩子，如果钩子执行完毕确认导航）next();// 中断导航next(false);// 跳转到不同的地址next('/');next(&#123; path: '/'&#125;);// 抛出 Error 实例给 router.onError 回调，终止导航，next(new Error('error')) （2）全局解析守卫（V2.5.0）router.beforeResolve也可以注册全局守卫，与router.beforeEach类似，区别是在导航被确认前，且组件内所有守卫和异步组件被解析后执行 1router.beforeResolve((to, from, next) =&gt; &#123;&#125;); （3）全局后置钩子router.afterEach是全局后置钩子，它不会接受next函数，也不会改变导航本身 路由独享守卫路由配置上定义beforeEnter守卫： 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 它与全局守卫的参数一致，只是会在特定的路由起作用 组件内的守卫组件内可以定义进入、离开、更新三中守卫 （1）进入在组件内定义beforeRouterEnter，会在导航被确认前调用，这时候组件实例还没有创建，所以不能获取到组件实例this 1234const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123;&#125;,&#125; 可以为next传一个回调来访问组件实例，在导航被确认时执行，这个回调的参数就是组件实例： 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 注意，beforeRouterEnter是支持给next传递回调的唯一的守卫。 （2）离开在组件内定义beforeRouterLeave，会在导航离开组件的对应路由前调用，可以访问组件实例this 1234const Foo = &#123; template: `...`, beforeRouteLeave (to, from, next) &#123;&#125;,&#125; 这个守卫一般用next(false)来禁止在用户在还未保存修改前突然离开 （3）更新在组件内定义beforeRouterUpdate，在路由发生改变，组件被复用时会调用 例如动态路由/user/:id的参数id改变时，从/user/1跳转到/user/2时，会访问同一个组件，组件实例会被复用，此时其他导航守卫都不会被调用，只会触发beforeRouterUpdate这个守卫 1234const Foo = &#123; template: `...`, beforeRouteUpdate (to, from, next) &#123;&#125;,&#125; 导航解析流程（1）路由间跳转各种导航解析时，会先从组件离开导航开始执行，然后执行前置→解析→后置，而各种前置导航是从全局到局部的，全局→路由→组件 路由执行next后的顺序与Koa的中间件的原理类似，都是洋葱圈模型，一层层进入后直到afterEach在按照原来的进入的相反顺序离开。 12345678910111213141516171819// 组件离开beforeRouteLeave start// 全局前置beforeEach start// 路由独享前置beforeEnter start// 组件前置beforeRouteEnter start// 全局解析beforeResolve start// 全局后置afterEachbeforeResolve endbeforeRouteEnter endbeforeEnter endbeforeEach endbeforeRouteLeave end （2）路由动态参数变化，组件复用当组件复用时，只会执行全局的前置、解析，以及组件本身的更新 123456789beforeEach startbeforeRouteUpdate startbeforeResolve startafterEachbeforeResolve endbeforeRouteUpdate endbeforeEach end （3）总结 导航被触发 失活的组件里调用离开守卫beforeRouteLeave 调用全局的前置守卫beforeEach 在重用的组件里调用beforeRouteUpdate守卫（注意，只有重用组件才有这一步） 在路由配置里调用路由独享守卫beforeEnter（注意，重用组件不会执行这一步） 解析异步路由组件 在即将要进入的路由组件里调用beforeRouteEnter（注意，重用组件不会执行这一步） 调用全局的解析守卫beforeResolve 导航被确认 调用全局后置钩子afterEach 触发DOM更新 用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。 参考 导航守卫@Vue Router Vue的钩子函数（路由导航守卫、keep-alive、生命周期钩子）@掘金]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Router</tag>
        <tag>导航守卫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解]]></title>
    <url>%2F2019%2F09%2F08%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F09%20%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[《算法图解》读书笔记。 第一章 算法简介二分查找二分查找是一种算法，其输入必须是有序的元素列表。 对于包含n个元素的列表，使用二分查找最多需要$\log_2^n$步 对数运算是幂运算的逆运算 1log_2^n = a → 2^a=n 在使用大O表示法讨论运行时间时，$\log$指的都是$\log_2$（以2为底） 二分法的JS实现： 123456789101112131415161718// 二分法查找const binarySearch = (list, target) =&gt; &#123; let min = 0; let max = list.length - 1; while (min &lt;= max) &#123; const middle = Math.floor((min + max) / 2); if (list[middle] &gt; target) &#123; max = middle - 1; &#125; else if (list[middle] &lt; target) &#123; min = middle + 1 &#125; else &#123; return middle; &#125; &#125; return null&#125;;console.log(binarySearch([1, 3, 5, 7, 9], 3)); 对于Python，如果取非整数索引，会自动向下取整，但是JS中不会，因为JS中的数组本质上是一个对象： 12345678let a = ['x', 'y'];// 等同于&#123; 0: 'x', 1: 'y', length: 2&#125; 所以如果为JS数组的非整数索引赋值，结果如下： 12345let a = [1, 2];a[2.5] = 100;console.log(a); // [1, 2, 2.5: 100] 运行时间线性时间：最多需要查找的次数与列表长度相同$O(n)$ 对数时间：最多需要查找的次数要$\log_2^n$, $O(\log n)$ $O(\log n)$比$O(n)$快，当需要搜索的元素越多，前者比后者快得就越多 大O表示法仅仅知道算法需要多长时间能运行完还不够，还需要知道运行时间如何随列表增长而增加。大O表示法表示的是算法运行时间的增速。 大O表示法指出的是最糟糕的情况下的运行时间。 一些常见的大O运行时间有： $O(\log n)$，对数时间，例如二分查找 $O(n)$，线性时间，例如简单查找 $O(n * \log n)$，例如快速排序，一种比较快的排序算法 $O(n^2)$，例如选择排序，一种比较慢的排序算法 $O(n!)$，例如旅行商问题的解决方案，一种非常慢的算法 算法的速度指的并非时间，而是操作数的增速（随着输入的增加，运行时间将以什么样的速度增加）。 第二章 选择排序内存的工作原理需要将数据存储到内存是，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式：数组和链表 数组数组所分配的内存空间都是紧紧相连的。如果为数组添加新元素时，当前数组占用的内存满了，则需要将数组元素转移到其他地方。可以预留内存，但是都会带来两个缺点： 浪费内存 预留的内存用完后，还需要转移元素 数组的优点：需要随机的读取元素时，数组效率很高。 链表链表中的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在了一起。 链表的优势在与插入元素方面，而且如果需要同时读取所有元素时，链表的效率很高。 在中间插入元素使用链表插入元素很简单，只需要修改它前面的额按个元素指向的地址。使用数组插入元素时，则必须将后面的所有元素都后移。 在中间插入元素，链表是更好的选择。 删除元素需要删除元素，链表也是更好的选择。 数组和链表的比较数组用的更多，因为它支持随机访问，所以数组的读取速度更快。而链表只能顺序访问。 数组和链表常见的操作的运行时间： – 数组 链表 读取 $O(1)$ $O(n)$ 插入 $O(n)$ $O(1)$ 删除 $O(n)$ $O(1)$ Facebook存储用户信息的方法Facebook存储用户信息时用的是链表数组，数组包含26个元素，每个元素指向一个链表。 插入元素时，对数组的移动最多26次，然后再从它指向的链表中进行插入。 读取元素时，可以直接找到数组中的对应元素，然后在链表中查找。 那么查找元素时，会不会效率太低？ 选择排序选择排序的原理就是每一轮在n个元素中进行查找，找出最小元素，放到结果当中。 每一轮的操作时间复杂度为$O(n)$，这样的操作需要执行n次，所以时间复杂度为$O(n^2)$ 有一个问题，每一轮进行后，下一轮要检查的元素会逐渐减少，实际随后检查的元素格式是一个公差为1的等差数列n-1、n-2…2、1，平均每次检查的元素是n/2，因此运行时间为$O(n * n/2)$，但是大O表示法会忽略诸如1/2这样的常数，所以为$O(n^2)$ 选择排序的JS实现：（从小到大排序） 123456789101112function chooseSort (arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; let minIndex = i; for (let j = i; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125; return arr;&#125; 选择排序的速度不是很快，快速排序的速度更快，时间复杂度为$O(n * \log n)$ 第三章 递归递归是一种很多算法都使用的一种编程方法。 递归只是让解决方案更加清晰，并没有性能上的优势。实际上在有些情况下使用循环的性能更好。 基线条件和递归条件编写递归函数时，必须告诉它何时停止。每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件值得是函数不再调用自己，避免造成无限循环。 栈栈是一种简单的数据结构，有两种操作：压入和弹出。 计算机内部使用被称为调用栈的栈。在调用过程中，调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都保留在内存中。 在递归调用栈中，包含着未完成的函数调用，自己无需跟踪哪些函数还没有被执行，栈会完成这个步骤。 使用栈很方便，但是也有性能代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，那么以为这计算机储存了大量函数调用的信息。 解决方法： 改用循环 使用尾递归（尾递归的实现需要确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数） 第四章 快速排序分治法分治法是解决问题的一种思路，一种递归式问题解决方法。 用分治法解决问题有包括两个步骤： 找出基线条件（即递归终止的条件），这种条件必须尽可能简单 不断将问题分解（或者说缩小规模），直到符合基线条件 一道题目：将一个长度为length、宽度为width的矩形均匀地分成方块，并确保分出的方块是最大的 分析这道题，首先要找出递归条件，最容易处理的情况是一条边的长度是另一条边的整数倍。这个时候就可以将矩形均匀地分成方块。 然后找出递归条件，每次递归都需要缩小问题规模。首先找出这块地可容纳的最大方块A，剩余的土地为B，根据欧几里得算法，适用于这小块地的最大方块，也是适用于整块地的最大的方块（就这个算法我就不知道，真做的时候就做出不来）。据此就可以不断的缩小规模，直到满足基线条件： 12345678910111213// 找到一个矩形可以均匀的划分的最大的小方块的尺寸const getMaxSquare = (length, width) =&gt; &#123; if (width &gt; length) &#123; [width, length] = [length, width] &#125; if (length % width === 0) &#123; return width &#125; if (length === width) &#123; return length; &#125; return getMaxSquare(width, length - width)&#125;; tips: 编写设计数组的递归函数时，基线条件通常是数组为空或者只包含一个元素。 快速排序快速排序的思想就是分治法，首先从最简单情况开始分析，找出基线条件，那就是数组为空或者只包含一个元素，然后逐渐增加到两个元素，三个元素。 到了三个元素的时候，首先选出基准值，然后分别找出比基准值小和比基准值大的元素（即分区），这样就得到了三个部分： 小于基准值的数字组成的数组（无序） 基准值 大于基准值组成的数组（无序） 然后对1和3再次进行快速排序，直到满足基线条件（即数组的长度为0或者1）为止。 123456789101112const quickSort = (arr) =&gt; &#123; if (arr.length &lt; 1) &#123; return arr &#125; const middleIndex = Math.floor(arr.length / 2); const middle = arr.splice(middleIndex, 1)[0]; const left = [], right = []; for(let i = 0; i&lt; arr.length; i++) &#123; (middle &gt; arr[i] ? left : right).push(arr[i]) &#125; return quickSort(left).concat(middle, quickSort(right))&#125;; 快速排序的时间复杂度是$O(n * \log n)$ 再谈大$O$表示法c是算法所需要的固定时间量，被称为常量。通常不考虑这个常量，因为如果算法的大$O$运行时间不同，这种常量将无关紧要。 但有时候，常量的影响可能很大，如果运行时间都是$O(n * \log n)$，那么常量就会影响很大。这也是快速排序比合并排序快的原因。 下面要分析一下，快速排序的时间复杂度为什么是$O(n * \log n)$ 快速排序的性能高度依赖于选择基准值，如果总是将第一个元素用作基准值，栈长为n（即总共要调用n次），每一轮要比较n个数字，每轮完成时间为$O(n)$，这就是最糟情况，这时候快速排序的运行时间是$O(n^2)$ 如果总是将中间的元素用作基准值，栈长变成了$O(\log n)$，每一轮仍然要比较n个数字，每轮完成时间为$O(n)$，这就是最佳情况，这时候快速排序的运行时间是$O(n * \log n)$ 要注意的是，最佳情况也是平均情况。只要每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间也就是$O(n * \log n)$。 快速排序是最快的排序算法之一，也是分治法的典范。 第五章 散列表散列函数散列函数是这样的函数，无论输入什么数据，都还给一个数字，即将输入映射到数字，散列函数必须满足： 每次输出的一致性 将不同的输入映射到不同的数字 可以使用散列函数来确定元素的存储位置。 散列函数对于散列表的性能至关终于，良好的散列函数让数组中的值呈均匀分布，SHA函数可以用作散列函数。 散列表使用散列函数和数组，就可以创建一种被称为散列表（hash table）的数据结构。 散列表也被称为散列映射、映射、字典和关联数组。适合用于： 模拟映射关系 防止重复 缓存、记住数据 JavaScript中的对象结构就是语言实现了的散列表结构。 性能散列表的性能： – 平均情况 最糟情况 查找 $O(1)$ $O(n)$ 插入 $O(1)$ $O(n)$ 删除 $O(1)$ $O(n)$ 在平均情况下下，散列表执行各种操作的时间都是$O(1)$。$O(1)$被称为常量时间，它并不意味着马上，而是说不管散列表大多，所需的时间与长度无关，都是相同的数值。 所以在JavaScript中，使用对象存储数据并进行查找的性能大于使用数组存储，可以认为是$O(1)$ 第六章 广度优先搜索（BFS)图算法广度优先搜索算法（breadth-first search，BFS）是一种图算法，可以找出两样东西之间最短的距离，即解决最短路径问题。 解决最短路径问题有两个步骤： 使用图来建立问题模型 使用广度优先搜索解决问题 图用来模拟不同的东西是如何连接的，由节点和边构成 有向图的关系是单向的，边是箭头，箭头指定了关系的方向；无向图没有剪头，关系是双向的。 如果任务A依赖于任务B，在列表中任务A就必须在任务B后面，这被称为拓扑排序。 树是一种特殊的图，其中没有往后指的边。 广度优先搜索广度优先搜索是一种用于图的查找算法，可以解决两类问题： 从节点A出发，有前往节点B的路径吗 从节点A出发，前往节点B的哪条路径最短 在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径，但是一定要按添加顺序检查，队列（queue）是一种可以实现这种目的的数据结构。 队列队列只支持两种操作：入队和出队。队列是一种先进先出（First In First Out）的数据结构，而栈是一种后进先出（Last In Frist Out）的数据结构。 实现算法实现广度优先搜索的关键是，要使用队列来存放要搜索的结果，这个队列是在搜索的过程中不断变增加的。在遍历一层时，如果不是目标，则将这个元素的后代加入到待搜索队列中。同时使用一个对象标记对象是否已经遍历过（针对无向图，防止无限循环出现，对于树结构来说则不需要） 如果是实现最短路径，在将后代元素加入到待搜索队列中时，应该以对象的形式加入，因为要补充一个队列，用来存放当前遍历的路径。 运行时间在整个关系网中进行搜索，以图算法来看，运行时间至少为$O(边数)$，此外还使用了一个队列来存放待搜索元素，将一个元素添加到队列的时间是固定的为$O(1)$，对每个元素都这样做的总时间为$O(n)$。 所以广度优先搜索的运行时间为$O(边数+顶点数)$，通常写作$O(V+E)$，V是顶点数，E是边数。 第七章 迪克斯特拉算法广度优先搜索找出的是段数最少的路径，如果每段路径有着不同的权重，要找出最快的路径，可以使用迪克斯特拉算法 使用迪克斯特拉算法迪克斯特拉算法包含四个步骤 找出“最便宜”的节点，即可在最短时间内到达的节点 更新该节点的邻居的开销 重复这个过程，直到对图中每个节点都这样做了 计算最终路径 迪克斯特拉算法背后的关键理念：找出图中最便宜的节点，确保没有到该节点的更便宜的路径 负权边如果有负权边，就不能使用迪克斯特拉算法。 因为节点一旦被处理，就以为这没有前往该节点的更便宜的路径，但是如果有负权边，那么就会在最片的路径被发现后，在负权边的路径上发现更便宜的节点。 在有负权边的图中，要找出最短路径，可以使用贝尔曼-福德算法。 迪克斯特拉算法的实现迪克斯特拉算法的实现需要四个散列表： 用于存储节点、节点的邻居以及前往节点邻居的开销graph 用于存储每个节点的最短开销costs 用于存储每个节点最短开销情况下的父节点parents 用于存储已经遍历过的节点processed 实际上上面这四个散列表就是迪克斯特拉算法需要的数据结构，需要将图转换为对应的数据结构后，对这种特定的数据结构使用算法，达到目的。 以下面的图距离： 首先实现第一个散列表（也就是JS中的对象）graph 12345678// 用于存储节点、节点的邻居以及前往节点邻居的开销const graph = &#123; start: &#123;a: 5, b: 2&#125;, a: &#123;c: 4, d: 2&#125;, b: &#123;a: 8, d: 7&#125;, c: &#123;d: 6, end: 3&#125;, d: &#123;end: 1&#125;,&#125;; 然后实现第二个对象costs： 12345678// 用于存储每个节点的最短开销const costs = &#123; a: 5, b: 2, c: Infinity, d: Infinity, end: Infinity,&#125;; 其中，没有计算的节点的开销用了Infinity无穷大来表示。 然后实现第三个对象parents 12345678// 用于存储每个节点最短开销情况下的父节点const parents = &#123; a: 'start', b: 'start', c: '', d: '', end:'',&#125;; 第四个对象可以在函数内部声明一个对象实现，也可以直接改造第二个对象，添加一个是否遍历的属性。 构造数据结构完成之后，来实现dijkstra算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 找到开销最小的，并且没有遍历过的节点const findLowestCostNode = (costs, processed) =&gt; &#123; // 筛选出没有遍历过的节点 const unProcessed = Object.keys(costs).filter(key =&gt; !processed[key]); // 如果存在没有遍历过的节点 if (unProcessed &amp;&amp; unProcessed.length &gt; 0) &#123; // 找出开销最小的节点 return unProcessed.sort((a, b) =&gt; costs[a] - costs[b])[0] &#125; // 不存在没有遍历过的节点时 return null;&#125;;// 生成加权图中的最短路径const getFullPath = parents =&gt; &#123; let key = 'end'; let path = []; while (key !== 'start') &#123; path.unshift(key); key = parents[key]; &#125; path.unshift('start'); return path.join('→')&#125;;// 迪科特斯拉算法const dijkstra = (graph, costs, parents) =&gt; &#123; // 记录所有遍历过的节点 let processed = &#123;&#125;; // 找到开销最小的，并且没有遍历过的节点 let node = findLowestCostNode(costs, processed); // while 循环在所有节点都遍历过后结束 while (node) &#123; // 找到当前节点的所有相邻节点 let neighbors = graph[node]; // 找到到达当前节点的开销 let cost = costs[node]; // 对所有相邻节点进行遍历 for (const neighborNode in neighbors) &#123; // for...in 的安全性检查 if (neighbors.hasOwnProperty(neighborNode)) &#123; // 找出新的到达相邻节点的开销 const newCost = cost + neighbors[neighborNode]; // 如果计算出的新的开销小于已记录的开销，则进行更新 if (newCost &lt; costs[neighborNode]) &#123; // 更新开销 costs[neighborNode] = newCost; // 更新父节点 parents[neighborNode] = node; &#125; &#125; &#125; // 将当前节点标记为已经处理过 processed[node] = true; // 找出接下来要处理的节点，并循环，直到所有节点都被处理过 node = findLowestCostNode(costs, processed); &#125; // 返回最终的开销和路径 return &#123; cost: costs['end'], path: getFullPath(parents), &#125;&#125;; 计算结果： 1&#123; cost: 8, path: 'start→a→d→end' &#125; 第八章 贪婪算法教室调度问题教室调度问题可以采用贪婪算法，具体做法如下： 选出最早结束的课 选择第一堂课结束后的，并且结束最早的课 重复上面的步骤 贪婪算法很简单：每一步都采取最优的做法。每步都选择局部最优解，最终得到的就是全局最优解。 背包问题对于背包问题，贪婪算法显然不能获得最优解。些时只需要找到一个能够大致解决问题的算法，此时贪婪算法刚好可以派上用场，因为它们实现起来很容易，得到的结果由于正确结果相当接近。 123456789101112131415161718192021222324252627// 贪婪算法求解背包问题近似解const knapsackProblem = () =&gt; &#123; const bagSize = 4; const items = [ &#123;name: 'sound', size: 4, value: 3000&#125;, &#123;name: 'laptop', size: 3, value: 2000&#125;, &#123;name: 'guitar', size: 1, value: 1500&#125;, &#123;name: 'iphone', size: 1, value: 2000&#125;, ]; let value = 0; let names = []; let remainSize = bagSize; // 从价值最大的开始装，能装多少算多少 items.sort((a, b) =&gt; b.value - a.value).forEach(v =&gt; &#123; if (v.size &lt;= remainSize) &#123; value += v.value; names.push(v.name); remainSize = remainSize - v.size; &#125; &#125;); return &#123; value, names &#125;;&#125;; 集合覆盖问题假设需要将一个广播节目让全美50个州的听众都收听得到，需要在尽可能少的广播台播出，这就是集合覆盖问题。 解决覆盖问题非常难，具体方法如下： 列出每个可能的广播台的集合，被称为幂集，可能的子集有$O(2^n)$个 在这些集合中，选出覆盖全部50个州的最小集合 运行时间为$O(2^n)$，需要一种近似算法 近似算法使用贪婪算法可以得到非常近似的解： 选出这样一个广播台，它覆盖了最多的未覆盖州（即便这个广播台覆盖了一些已覆盖的州，也没有关系） 重复第一步，直到覆盖了所有的州 这是一种近似算法，在获得精确解需要的时间太长时，可以使用近似算法。判断近似算法优劣的标准如下： 速度有多快 得到的近似解与最优解的接近程度 这个例子的贪婪算法的时间复杂度为$O(n^2)$，其中n是广播台的数量。 这种算法的关键是求出statesNeeded（需要覆盖的州）和stateForStation（电台能够覆盖的州）的交集，求出的就是当前广播电台覆盖的所有还未覆盖的州。 在所有没有选择的电台中进行比那里，找出上面提到的交集最大的电台。不断重复这个过程，直到所有的州都被覆盖为止。 NP完全问题为了解决集合覆盖问题，你必须计算每个可能的集合，这与旅行商问题相似，需要计算每条可能的路径。 当有1个城市时，可能的路线有1条 当有2个城市时，可能的路由先2条 当有3个城市时，可能的路由先6条 当有4个城市时，可能的路由先24条 规律就是，每增加一个城市，需要计算的路线数都将增加，可以认为增加一个城市，可能的路径就以任何一个城市为起点（n）个，重复前一种情况的可能的路径数，也就是说当有5个城市时，任选一个作为起点，有5种情况，都是「当有4个城市时」的路径树24，也就是24重复了5遍，也就是120条 这是阶乘函数，如果涉及到的城市非常多，根本就无法找出旅行商问题的正确解。 旅行商问题和集合覆盖问题有一些共同之处：需要计算所有的解，并从中选出最小/最短的那一个。这两个问题都属于NP完全问题。 旅行商问题的近似求解：随便选择出发城市，然后选择要去的下一个城市时，都选择还没去的最近的城市。选择的路径可能不是最短的，但是也比较接近了。 如何识别NP完全问题判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。可以通过以下几点来判断NP完全问题： 元素较少时算法的运行速度非常快，但随着元素数量增加，速度会变得非常慢 涉及“所有组合”的问题通常是NP完全问题 不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题 如果问题涉及序列（如旅行商问题的城市序列）且难以解决，它可能就是NP完全问题 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题 第九章 动态规划动态规划可以在给定约束条件下找到最优解。在问题可以分解为彼此独立且离散的子问题时，就可以使用动态规划来解决。 为动态规划问题建模时的小窍门： 每种动态规划解决方案都涉及网格 单元格中的值通常就是要优化的值 每个单元格都是一个子问题 在绘制网格时，需要回答如下问题： 单元格中的值是什么 如何将这个问题划分为子问题 网格的坐标轴是什么 要注意，最终答案不一定在最后一个单元格中。 背包问题背包问题就是典型的动态规划的应用之一。 动态规划先解决子问题，在逐步解决大问题。每个动态规划算法都从一个网格开始，背包问题的网格如下： 填充的过程是逐行进行的，原则是保证当前单元格的值为此列的最大值。如果装入当前单元格的物品后，重量有剩余，则回退一行，找到剩余重量对应的最大值。 使用的公式为： 通过表格求解子问题，可以合并两个子问题的解来得到更大问题的解。 下面编写代码： （感觉这个代码是为了这个算法生凑出来的，其实关键点把握住就行了，一是上面的公式，而是通过求解子问题，然后通过合并来求解更大问题） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const knapsackProblem = () =&gt; &#123; const bagSize = 4; const items = [ &#123;name: 'sound', size: 4, value: 3000&#125;, &#123;name: 'laptop', size: 3, value: 2000&#125;, &#123;name: 'guitar', size: 1, value: 1500&#125;, ]; // 存储结果的表格 const cell = []; // 空格子 class CellClass &#123; constructor() &#123; this.value = 0; this.names = []; &#125; &#125; // 外层遍历物品 for (let i = 0; i &lt; items.length; i++) &#123; // 声明新的一行 cell[i] = []; // 针对的物品 const item = items[i]; // 当前商品的价值 const currentValue = item.value; // 内层遍历重量 for (let j = 0; j &lt;= bagSize; j++) &#123; // 当前格子装入物品后的剩余空间 const remainSize = j - item.size; // 上一个单元格 const lastCell = (cell[i - 1] &amp;&amp; cell[i - 1][j]) ? cell[i - 1][j] : new CellClass(); // 上一个单元格的值（之前的最大值） const lastCellValue = lastCell.value; // 如果能装下这个物品 if (remainSize &gt;= 0) &#123; // 剩余空间对应的单元格 const remainCell = (cell[i - 1] &amp;&amp; cell[i - 1][remainSize]) ?cell[i - 1][remainSize]: new CellClass(); // 剩余空间的价值 const remainValue = remainCell.value; // 预期的最大值 const currentMaxValue = currentValue + remainValue; // 如果预期的最大值更大 if (currentMaxValue &gt; lastCellValue) &#123; cell[i][j] = &#123;value: currentMaxValue, names: [item.name, ...remainCell.names]&#125; &#125; else &#123; cell[i][j] = &#123;value: lastCellValue, names: lastCell.names&#125; &#125; &#125; else &#123; // 装不下这个物品则取上一个单元格 cell[i][j] = lastCell &#125; &#125; &#125; console.log(cell); return cell[items.length - 1][bagSize]&#125;; 可以偷商品的一部分吗偷商品的一部分，不能使用动态规划处理。动态规划只能处理要么拿走整件商品，要么就不拿的情况，没法判断该不该拿走商品的一部分。 这种情况应该使用贪婪算法来处理，首先尽可能多的拿价值高的商品，如果拿光了在尽可能拿价值次高的商品，以此类推。 可以相互依赖吗如果各个项目之间有依赖情况，那么是没有办法使用动态规划来建模的。 动态规划算法能够解决子问题，并且使用这些答案来解决大问题。但是仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 最长公共子串在填充表格时，没有找出计算公式的简单办法，必须通过尝试才能找出有效的公式。有些算法并非精确的解决步骤，而是帮助你理清思路的框架。 在计算FISH和HISH的最大公共子串时，填写出来的表格和计算公式是： 实现的代码： 1234567891011121314151617181920212223242526const maxSubstring = (string1, string2) =&gt; &#123; let result = &#123; value: 0, string: '' &#125;; let cell = []; for (let i = 0; i &lt; string1.length; i++) &#123; cell[i] = []; for (let j = 0; j &lt; string2.length; j++) &#123; if (string1[i] === string2[j]) &#123; const lastCell = cell[i - 1] &amp;&amp; cell[i - 1][j - 1]; cell[i][j] = &#123; value: lastCell ? lastCell.value + 1 : 1, string: lastCell ? lastCell.string + string1[i] : string1[i] &#125; &#125; else &#123; cell[i][j] = &#123;value: 0, string: ''&#125;; &#125; if (result.value &lt; cell[i][j].value) &#123; result.value = cell[i][j].value; result.string = cell[i][j].string; &#125; &#125; &#125; return result&#125;; 也可以用这个算法来解决之前遇到过的《前端练习10 连续子串最大和》的问题，具体分析过程看那篇笔记吧。 最长公共子序列与最长公共子串不同，最长公共子序列不需要是连续的，比如FOSH与FISH的最长公共子串是SH，长度是2，而最长公共子序列是FSH，长度是3 这个问题在计算单元格数据时使用的公式与最长子串不同： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142// 最长公共子序列const maxSubsequence = (string1, string2) =&gt; &#123; let result = &#123; value: 0, string: '', &#125;; const cell = []; for (let i = 0; i &lt; string1.length; i++) &#123; cell[i] = []; for (let j = 0; j &lt; string2.length; j++) &#123; if (string1[i] === string2[j]) &#123; const lastCell = cell[i - 1] &amp;&amp; cell[i - 1][j - 1]; cell[i][j] = &#123; value: lastCell ? (lastCell.value + 1) : 1, string: lastCell ? (lastCell.string + string1[i]) : string1[i], &#125;; // 更新结果 if(cell[i][j].value &gt; result.value) &#123; result = cell[i][j] &#125; &#125; else &#123; const lastRowCell = cell[i] &amp;&amp; cell[i][j - 1] || &#123; value: 0, string: '',&#125;; const lastColCell = cell[i - 1] &amp;&amp; cell[i - 1][j]|| &#123; value: 0, string: '',&#125;; if (lastRowCell.value &gt; lastColCell.value) &#123; cell[i][j] = &#123; value: lastRowCell.value, string: lastRowCell.string, &#125; &#125; else &#123; cell[i][j] = &#123; value: lastColCell.value, string: lastColCell.string, &#125; &#125; &#125; &#125; &#125; return result;&#125;; 小结 需要在给定约束条件下优化某种指标时，动态规划很有用 问题可以分解为离散的子问题时，可以使用动态规划来解决 每种动态规划解决方案都涉及网格 单元格中的值通常是你要优化的值 每个单元格都是一个子问题，需要考虑如何将问题分解为子问题 没有放之四海而皆准的计算动态规划解决方案的公式 第十章 K最近邻算法K最近邻算法（k-nearest neighbours, KNN）简单的说就是在对一个事物分类时，如果自身没有准确的特征值用来分类，就可以看距离它最近的邻居，借此对目标分类。 创建推荐系统（1）特征抽取 要比较推荐系统的用户，就需要以某种方式将他们放到图表中，需要将每个用户转换为这一组坐标，然后就可以计算他们的距离了。 特征抽取就是将物品转换为一系列可比较的数字。 一种抽取特征值的方法： 通过这些特征值可以计算距离： （2）回归 所谓回归，就是使用KNN来做两项基本工作：分类和回归： 分类就是编组 回归就是预测结果（比如一个数字） 比如，找出与目标最接近的5个邻居，求这些人的平均分，就是回归。 可以使用余弦相似度来代替距离公式，能够更准确的找出相似的邻居。 （3）挑选合适的特征值没有通用的准则，必须考虑各种需要考虑的因素 能够挑选合适的特征事关KNN算法的成败。 机器学习刚才的推荐系统实际上就是一个机器学习的例子，还有其他机器学习的例子 （1）OCR，光学字符识别，要自动识别字符，可以使用KNN 浏览大量的图像，将这些数字的特征提取出来（也就是训练） 遇到新图像时提取该图像的特征，再找出它最近的邻居 大多数及其学习算法都包含训练的步骤，要让计算机完成任务，必须先训练它 （2）垃圾邮件过滤器 垃圾邮件过滤器使用了一种简单算法：朴素贝叶斯分类器，用数据对分类器进行训练后，收到新的邮件，分析邮件中每个单词在垃圾邮件中出现的概率是多少 第十一章 接下来如何做树二叉树查找（binary search tree，BST）的特征： 左子树的所有节点的值都小于或等于它的根节点的值 右子树上所有节点的值均大于或等于它的根节点的值 下面就是一棵典型的二叉查找树： 在利用二叉查找树查找节点时的思想就是二分法查找的思想，平均运行时间为$O(\log n)$，最糟的情况下所需的时间为$O(n)$。在有序数组中查找时即便是最糟情况下所需的时间也只有$O(\log n)$，但这不意味着有序数组比二叉查找树更佳，因为二叉查找树的插入和删除操作的速度快的多： 二叉树的查找的最大次数等同于二叉查找树的高度。 二叉查找树也有一些缺点：不能随机访问，并且如果二叉查找树处于失衡状态下，查找的性能会大打折扣，几乎变成了线性查找： 如何解决二叉树多次插入新节点而导致的不平衡呢？可以使用红黑树来解决，红黑树（Red Black Tree）是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征之外，还有一系列的附加特性，通过每次插入新节点后的处理（变色、反转）来保证自身符合红黑树的附加特性，实现了自平衡 知乎这篇文章讲解二叉查找树和红黑树讲的很好，通俗易懂。 反向索引搜索引擎的工作原理就是使用反向索引这种数据结构：一个散列表，将单词映射到包含它的页面 傅里叶变换（1）傅立叶级数 傅立叶级数实际上就是把$f(x)$看作是圆周运动的组合。只是$x$是不断变大的，而不是绕着圆变换的，所以就画出了函数曲线： 不断增大的$x$就好像是时间流逝，永不回头，所以我们也称为“时域”。 时域是现实存在的，频域却是生造的了，理解起来更加抽象。但频域是傅立叶级数（变换）更本质的内容。 傅里叶技术的一个典型应用就是图像压缩，哪些基上的坐标值特别小，就可以丢掉，这样就可以压缩图像，JPG就是利用傅里叶进行图片压缩的 （2）傅里叶变换 傅立叶级数是基于周期函数的，如果将周期推广到$\infty$，那么也就变为了非周期函数，这就是傅里叶变换 这部分的内容可以参考如何通俗地理解傅立叶变换？和如何理解傅立叶级数公式？ MapReduceMapReduce是一种流行的分布式算法，可以通过流行的开源工具Apache Hadoop来是实现它。 Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。 Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。 分布式算法非常实用用于在短时间内完成海量工作，其中的MapReduce基于两个简单的历年：映射（map）函数和归并（reduce）函数 映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。映射函数是将一个数组转换为另一个数组。而归并函数的理念是将很多项归并为一项，将一个数组转换为一个函数 MapReduce是第一代计算引擎，Tez和Spark是第二代。MapReduce的设计，采用了很简化的计算模型，只有Map和Reduce两个计算过程（中间用Shuffle串联），用这个模型，已经可以处理大数据领域很大一部分问题了。 关于MapReduce的介绍可以看这篇文章。 布隆过滤器和HyperLogLog布隆过滤器是为了解决在海量数据中查找某个键是否存在的技术，它是一种概率性型数据结构，提供的答案有可能不对，但很可能是正确的。 判断网页以前是否已搜集，可以不适用散列表，而是用布隆过滤器，它的优点在于占用的存储空间少，非常适合于不要求答案绝对准确的情况。 关于布隆过滤器的原理可以参考这篇文章。 HyperLoglog是一种类似于布隆过滤器的算法。可以近似地计算集合中不同的元素数，提供不精确的去重计数，它也不能给出准确的答案，但是八九不离十，而占用的内存空间却少得多。关于HypoerLogLog的解释可以阅读这篇文章。 上面的这两种都是概率算法，都要求允许统计巨量数据面前的误差范围可以接受。 SHA算法SHA函数（secure hash algorightm）是一种安全散列算（也就是哈希算法），给定一个字符串，SHA返回其散列值。 有两种应用： （1）比较文件 对于不同的字符串，SHA生成的散列值不同，可以利用SHA来判断两个文件是否相同，在比较超大型文件时很有用，可以计算文件的SHA散列值，再对结果进行比较。 （2）检查密码 SHA能在不知道原始字符串的情况下进行比较，进行密码登陆时，不会直接存储密码，而是比较散列值。网站保存的不是原始密码，而是密码的散列值。 SHA散列算法是单项的，可以根据字符串计算散列值，但是无法根据散列值推出原始字符串。 SHA实际上是一系列散发：SHA-0/SHA-1/SHA-2/SHA-3，SHA-0和SHA-1被发现存在一些缺陷，应该使用SHA-2和SHA-3来计算密码散列值，最安全的散列函数是bcrypt。 关于各种散列算法的介绍可以阅读这篇文章。 局部明暗的散列算法SHA算法是局部不敏感的，对一个字符串，如果只改动了其中一个字符，得到的两个散列值是完全不同的，这就让攻击者无法通过比较散列值是否类似来破解密码。 如果希望散列函数是局部明暗的，可以使用Simhash，对字符串进行细微的修改，Simhash生成的散列值也只存在细微的差别。这就可以通过比较散列值来比较两个字符串的相似程度，应用： Google来判断网页是否被收集 论文查重/资源查重 需要检查两项内容的相似程度时，可以使用Simhash。 Diffie-Hellman密钥交换Diffie-Hellman密钥交换解决了两个问题： 双方无序知道加密算法，不必会面协商使用的加密算法 破解加密非常困难 使用了两个密钥：公钥和私钥。它的替代者是RSA，被广泛使用。 线性规划线性规划用于在给定约束条件下最大限度的改善指定的指标。 所有的图算法都可以使用线性规划来实现，图问题知识线性规划的一个子集。 线性规划使用Simplex算法。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题37 前端代码异常监控]]></title>
    <url>%2F2019%2F08%2F19%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9837%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[前端代码异常监控学习笔记，原文地址：前端代码异常监控实战@掘金 异常处理JavaScript中的异常并不会导致JavaScript引擎崩溃，最多只会让当前执行的任务停止。 12345678&lt;script&gt;console.log(error);console.log('不会执行');&lt;/script&gt;&lt;script&gt;console.log('继续执行');&lt;/script&gt; 在对错误及哦啊本进行上报之前，需要对异常进行处理，程序首先要感知到脚本错误的发生，然后再进行异常上报 我们需要处理的错误根据导致的原因分类有以下几种： 语法错误 运行时错误 网络请求错误 iframe中的错误 根据抛出错误的代码所属的任务队列可以分为： 同步错误 异步错误（非Promise） Promise错误 try...catch异常处理通过使用try...catch结构包裹代码，当try代码块发生错误时，catch能捕获到错误的信息，页面可以继续执行。 12345try &#123; console.log(error); // 运行时错误&#125; catch(e) &#123; console.log('捕捉到了');&#125; 但是try...catch处理异常的能力有限，只能捕获到运行时非异步错误，对于语法错误和异步错误都捕捉不到。 12345try &#123; console.log('error'; // 语法错误，少了半个括号&#125; catch(e) &#123; console.log('捕捉到了', e);&#125; 异步错误： 1234567try &#123; setTimeout(() =&gt; &#123; console.log(error); // 异步错误 &#125;)&#125; catch(e) &#123; console.log('捕捉到了', e);&#125; error事件可以在window.onerror事件中捕获异常，它的捕获异常能力优于try...catch，主要原因在于： window.onerror是全局捕获，而try...catch针对的是具体的代码块 window.onerror可以捕获同步错误以及异步错误 12345window.onerror = function (msg, url, row, col, error) &#123; console.log('捕获到了错误'); console.log(&#123;msg, url, row, col ,error&#125;); return true;&#125;; 同步错误： 1console.log(error); // 同步错误 异步错误： 123setTimeout(() =&gt; &#123; console.log(error); // 异步错误&#125;) 但是window.onerror也无法捕获语法错误。所以在实际使用时，一般使用onerror来捕获预料之外的错误，try...catch用来在可预见情况下监控特定的情况，二者需要结合使用。 有几点需要注意 （1）window.onerror只有在返回true的时候，异常才不会向上抛出，否则即使捕获到了异常，控制台还是会显示Uncaught Error： 123456window.onerror = function (msg, url, row, col, error) &#123; console.log('捕获到了错误'); console.log(&#123;msg, url, row, col ,error&#125;); // return true;&#125;;console.log(error); （2）包含window.onerror代码的脚本最好写在所有脚本的最前面，如果放在某些脚本的后面，那么发生错误就无法捕获 1234567891011&lt;script&gt;console.log(error);&lt;/script&gt;&lt;script&gt;window.onerror = function (msg, url, row, col, error) &#123; console.log('捕获到了错误'); console.log(&#123;msg, url, row, col ,error&#125;); // return true;&#125;;&lt;/script&gt; （3）window.onerror无法捕获网络异常的错误 例如当图片加载失败发返回404的异常时，onerror是捕获不到的： 123456789&lt;script&gt;window.onerror = function (msg, url, row, col, error) &#123; console.log('捕获到了错误'); console.log(&#123;msg, url, row, col ,error&#125;); return true;&#125;;&lt;/script&gt;&lt;img src="./404.jpg"&gt; 这是因为网络请求的错误不会事件冒泡，所以必须在捕获阶段去捕获异常： 123456789&lt;script&gt;window.addEventListener('error', e =&gt; &#123; console.log('捕获到了错误'); console.log(e); return true;&#125;, true)&lt;/script&gt; &lt;img src="./404.jpg"&gt; 虽然可以捕获到网络请求的异常，但是无法具体判断HTTP的状态和返回码，需要配合服务端日志以及对网络请求进行拦截进行排查分析才可以。 unhandledrejectiontry..catch和window.onerror都无法捕获在Promise中抛出的错误： 12345678910window.onerror = function (e) &#123; console.log('捕获到Promise的错误'); return true;&#125;;try &#123; Promise.resolve().then(v =&gt; console.log(error))&#125; catch(e) &#123; console.log('捕获到Promise的错误');&#125; 对于Promise来说，虽然可以再每一个实例后面添加catch来捕获特定的实例中抛出的错误，但是通过unhandledrejection来全局捕获异常也是非常必要的： 1234567window.addEventListener('unhandledrejection', e =&gt; &#123; console.log('捕获到Promise的错误'); console.log(e); e.preventDefault();&#125;);Promise.resolve().then(v =&gt; console.log(error)) 当然如果异常在Promise的实例中进行了捕获，那么在unhandledrejection中就捕获不到了： 1234567window.addEventListener('unhandledrejection', e =&gt; &#123; console.log('全部捕获到了'); console.log(e); e.preventDefault();&#125;);Promise.resolve().then(v =&gt; console.log(error)).catch(e =&gt; console.log('实例中捕获到了')) iframe中的错误如果页面中使用了&lt;iframe&gt;，需要对引入的&lt;iframe&gt;进行异常监控，否则如果引入的页面出现问题，内容显示不出来，但是我们却一无所知。 父窗口直接使用window.error是无法直接捕获&lt;iframe&gt;中的错误的，需要分下面几种情况进行处理： （1）&lt;iframe&gt;页面与当前页面同域名的话，可以直接给&lt;iframe&gt;添加onerror事件： 1234567window.frames[0].onerror = function (msg, url, row, col, error ) &#123; console.log('捕获到了iframe中的错误'); console.log(&#123; msg, url, row, col, error &#125;); return true;&#125; （2）如果嵌入的&lt;iframe&gt;中的页面与当前页面不是同一个域名，那么上面的方法就行不通了。如果我们拥有&lt;iframe&gt;的控制权的话，可以通过与&lt;iframe&gt;通信的方式将异常信息发送给主页面，通信的方式很多，比如postMessage事件等 在iframe中发送消息，注意需要使用window.top进行发送，不能直接使用window 12345678910// iframe 中window.onerror = function(e) &#123; if (window.top !== window) &#123; top.postMessage(e, 'http://localhost:63342/demos/demo36-瀑布流/瀑布流-Flex.html') return true; &#125; return true;&#125;console.log(error); // 错误 在主页面中需要监听message事件： 1234window.addEventListener('message', (e) =&gt; &#123; console.log('捕获到了iframe中的错误'); console.log(e.data);&#125;) （3）&lt;iframe&gt;的域名非同源，并且自己没有控制权，那么除了看控制台之外，没有办法捕获。 异常上报监控拿到报错信息后，需要将捕获到的错误信息上报到信息收集平台上，常用的上报方法有两种： 通过Ajax发送数据 通过动态创建&lt;img&gt;标签 通过Ajax发送数据就是平常的调用接口的形式进行上报即可，而动态创建&lt;img&gt;标签主要是根据信息收集平台的要求，将&lt;img&gt;的src属性拼接指定的错误信息即可： 1234function report(error) &#123; const reportUrl = 'http://xxxx/report'; new Image().src = reportUrl + '?error=' + error;&#125; Script Error在线上的版本，静态资源一般会放在CDN，会导致长访问的页面与脚本来自不同的域名，，如果没有额外的配置，就会产生Script Error 这是因为浏览器同源策略导致的，浏览器出于安全性的考虑，当页面引用非同域名的外部脚本文件发生错误时，当前页面是没有权利知道报错信息的，取而代之的是输出Script Error 解决方法就是为页面上的&lt;script&gt;标签添加crossOrigin属性，可以取值anonymous和use-credentials，如果没有属性值或者非法属性值，会被浏览器默认做anonymous，它的作用有三个： 让浏览器启动CORS访问检查，检查HTTP响应头的Access-Control-Allow-Origin 对于传统&lt;script&gt;需要跨域获取的JS资源，暴露其报错的详细信息 对于module script，控制用于跨域请求的凭据模式 同时服务端需要在返回的响应头中Access-Control-Allow-Origin为对应的域名 12345678910111213141516// http://localhost:8080/index.html&lt;script&gt; window.onerror = function (msg, url, row, col, error) &#123; console.log('我知道错误了，也知道错误信息'); console.log(&#123; msg, url, row, col, error &#125;) return true; &#125;;&lt;/script&gt;&lt;script src="http://localhost:8081/test.js" crossorigin&gt;&lt;/script&gt;// http://localhost:8081/test.jssetTimeout(() =&gt; &#123; console.log(error);&#125;); 这样就可以获得外域脚本的详细的报错信息了，对于JSONP来跨域的时候遇到的错误可以据此解决： 1234const script = document.createElement('script');script.crossOrigin = 'anonymous';script.src = url;document.body.appendChild(script); 如果使用的第三方库加载异步脚本时，如果没有提供crossOrigin的能力时，可以劫持document.createElement，在动态生成的脚本上添加crossOrigin字段，但是这种方式有一定风险，需要谨慎使用 12345678910document.createElement = (function() &#123; const fn = document.createElement.bind(document); return function(type) &#123; const result = fn(type); if(type === 'script') &#123; result.crossOrigin = 'anonymous'; &#125; return result; &#125;&#125;)(); 压缩代码如何定位到脚本异常位置线上的代码都经过了压缩、合并处理，当收到一条报错的信息的时候，可能根本没有办法直接获知变量代表什么、位置在哪里，此时的错误日志是无效的。 解决方法就是利用sourceamp来定位到错误代码的具体位置，详细内容参考《脚本错误量极致优化-让脚本错误一目了然》，最理想的方案可以尝试Sentry开源方案 收集信息太多可以给网站设置采集率： 123456Reporter.send = function (data) &#123; // 只采集 30% if (Math.random() &lt; 0.3) &#123; send(data) // 上报错误信息 &#125;&#125; 这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。 总结异常捕获有三种常用的方式try...catch、window.onerror、unhandledrejection，它们都没有办法捕获语法错误，所以在写代码的时候尽量通过IDE的提示和ESLint的检查避免语法错误 try...catch可以捕获同步错误，无法捕获网络错误、异步错误和Promise的错误 window.onerror可以捕获同步错误、异步错误，需要在事件捕获阶段捕获网络错误（但是信息不详细），无法捕获Promise的错误 unhandledrejection专门用来捕获没有在Promise实例的catch中捕获的Promise中抛出的错误 使用的时候一般： 使用window.onerror来捕获全局的同步错误、异步错误 用unhandledrejection来捕获全局的Promise错误 用try...catch来在预见情况下捕获特定的错误 &lt;iframe&gt;中的错误如果是同源页面，可以直接为其添加onerror事件，如果是非同源但是有控制权，可以通过postMessage传递错误，如果是非同源也无控制权，那么无能为力。 参考 前端代码异常监控实战@掘金 关于 script 标签你应该知道的@Github]]></content>
      <categories>
        <category>零散专题</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS37 镂空遮罩]]></title>
    <url>%2F2019%2F08%2F19%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS37%20%E9%95%82%E7%A9%BA%E9%81%AE%E7%BD%A9%2F</url>
    <content type="text"><![CDATA[镂空遮罩这样实现。 前一阵子面试被问题到这个问题，突然懵逼了，脑子一片空白，以前知道这种效果，比如什么值得买的改版引导页面： 当时再紧张也应该打出一种实现方法，就是什么值得买这种使用图片实现 它首先加了一个半透明的黑色蒙层（background-color: rgba(0,0,0,.8)）然后添加提前制作好的图片作为子元素，然后通过决定定位，让图片与被遮盖的部分的定位相同，制造出一种假的镂空的效果 虽然这种方式处理定位有一些麻烦，并且不适合页面有滚动的情况，滚动的时候可能出现错位。 但是当时怎么也应该答出这种方式，但是确实一面试就紧张，脑子不转了，就想着添加一个伪元素，但是不知道怎么穿透。 回来查了一些资料，找到了几种实现的方法 首先准备好要被遮罩的DOM结构： 12345678&lt;div class="outer"&gt; &lt;div class="content"&gt; &lt;p&gt;这是要露出来的字&lt;/p&gt; &lt;p&gt;这是要露出来的字&lt;/p&gt; &lt;p&gt;这是要露出来的字&lt;/p&gt; &lt;/div&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 以及样式： 12345678910111213141516.outer &#123; position: relative; margin: 20px 0; height: 500px; background: darksalmon; overflow: hidden;&#125;.content &#123; width: 200px; height: 80px; color: #FFF; line-height: 1.5; background: #5b8b7b; margin: 100px 0 0 100px;&#125; 此时的效果： 要实现的效果： 透明边框中间的镂空部分为实际的width和height，为完全透明的背景，而四周半透明的遮罩使用rgba的border来实现 123456789101112.inner &#123; position: absolute; left: 0; top: 0; box-sizing: content-box; width: 200px; height: 80px; border-color: rgba(0, 0, 0, 0.5); border-style: solid; border-width: 100px 1500px 1500px 100px; background: transparent;&#125; 透明轮廓使用边框的地方，大多数时候都可以使用轮廓outline来替代，实际上没有什么不同，只是要注意，outline是不占据文档流空间的，所以定位方式与使用border时不同 12345678910.inner2 &#123; position: absolute; left: 100px; top: 100px; box-sizing: content-box; width: 200px; height: 80px; outline: rgba(0, 0, 0, 0.5) 1500px solid; background: transparent;&#125; 透明阴影还可以使用透明阴影实现，主要利用了阴影的第四个扩展半径这个参数 12345678910.inner3 &#123; position: absolute; left: 100px; top: 100px; box-sizing: content-box; width: 200px; height: 80px; box-shadow: rgba(0, 0, 0, 0.5) 0 0 0 1500px; background: transparent;&#125; 使用Canvas实现可以使用强大的Canvas实现，当然使用Cavnas就需要使用脚本来编写了，虽然有些复杂，但是使用灵活，能够适应各种不同的要求，比如同时镂空多个等等。 使用Canvas也有两种方式来实现，第一种方式是使用clearRect方法，比较简单： 1234567const canvas = document.querySelector('#canvas');const ctx = canvas.getContext('2d');ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';ctx.fillRect(0, 0, 1500, 1500);ctx.clearRect(100, 100, 200, 80); 另一种方式是自己通过path直接画出这样的一个形状，这里就需要介绍一下非零环绕规则 所以在画外围的半透明矩形时顺时针，那么里面镂空的矩形就需要逆时针： 12345678910111213141516171819const canvas = document.querySelector('#canvas2');const ctx = canvas.getContext('2d');// 外围ctx.moveTo(0, 0);ctx.lineTo(1500, 0);ctx.lineTo(1500, 1500);ctx.lineTo(0, 1500);ctx.closePath();// 内层ctx.moveTo(300, 100);ctx.lineTo(100, 100);ctx.lineTo(100, 180);ctx.lineTo(300, 180);ctx.closePath();ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';ctx.fill(); 使用SVG实现我对SVG基本上是不了解的，直接复制修改了一段代码 123456789&lt;svg class="svg" width="1500" height="500"&gt; &lt;defs&gt; &lt;mask id="myMask"&gt; &lt;rect x="0" y="0" width="100%" height="100%" style="stroke:none; fill: #ccc"&gt;&lt;/rect&gt; &lt;rect width="200" height="80" x="100" y="100" style="fill: #000"&gt;&lt;/rect&gt; &lt;/mask&gt; &lt;/defs&gt; &lt;rect x="0" y="0" width="100%" height="100%" style="stroke: none; fill: rgba(0, 0, 0, 0.6); mask: url(#myMask)"&gt;&lt;/rect&gt;&lt;/svg&gt; 也不是很复杂。 总结 如果页面布局尺寸都是固定的，可以使用CSS的三种方法实现 如果实现效果比较复杂，可以使用Canvas或者SVG实现 如果要偷懒，可以让UI出一张图片实现 参考 浏览器中遮罩层镂空效果的多种实现方法@CSDN canvas——-绘制镂空的正方形+非零环绕规则@CSDN HTML5 canvas clearRect() 方法@W3Sschool]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>镂空遮罩</tag>
        <tag>canvas</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS35 可替换元素]]></title>
    <url>%2F2019%2F08%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS35%20%E5%8F%AF%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[为何img、input等内联元素可设置宽高？ 一道面试题在美团面试的时候遇到过这样一个小问题： Q：你知道行内元素和块级元素有什么区别吗？ A：行内元素只会占据内部元素宽度的空间，并且不会以新的一行开始，不能设置宽度；块级元素会占满整个父容器，会新起一行，可以设置宽度； Q：&lt;img&gt;是什么元素？ A: 行内元素 Q：那为什么&lt;img&gt;可以设置宽度？ A：呃….. 答不出来了。其实是一个很基础的问题，但是由于很多时候对基础，尤其是CSS/HTML方面的基础不甚在意，稀里糊涂也能实现想要的效果，不求甚解，真的刨根问题的时候就傻眼了。 先给出答案：因为&lt;img&gt;虽然是行内元素，但是它们也都属于可替换元素。可替换元素一般有内在尺寸和宽高比，所以可以设置宽度和高度 可替换元素从元素本身的特点来说可以分为可替换元素和不可替换元素 HTML大多数元素都是不可替换元素，内容直接由DOM内容确定，直接展现给用户，比如&lt;p&gt;123&lt;/p&gt;，这就是一个不可替换元素，展示的内容就是DOM的文本节点123 与之不同的就是可替换元素，具体显示的内容是由元素的标签和属性确定的，比如&lt;img&gt;显示的内容实际上是由src属性的值来读取图片的信息并展示的 典型的可替换元素： &lt;iframe&gt; &lt;video&gt; &lt;embed&gt; &lt;img&gt; HTML规范规定了&lt;input&gt;元素可替换，因为&lt;image&gt;类型的&lt;input&gt;元素就像&lt;img&gt;一样可替换，但是其他类型的&lt;input&gt;被明确的列为非可替换元素（来源：MDN，但是实际上比如type为text的&lt;input&gt;也是可以设置宽度的，我认为可以将&lt;input&gt;也理解为条可替换元素，因为其展示形式也是与type属性的取值有关系的） 几乎所有的替换元素都是行内元素，替换元素有内在尺寸，所以可以设置width和height。如果不设置其宽度和高度时，就按照其内在尺寸显示。 控制可替换元素中的对象尺寸和位置可以使用某些CSS属性来指定可替换元素中包含的内容对象，在该元素的和区域内的位置的位置和定义方式，比如： object-fit用来指定可替换元素的内容对象在元素盒区域内的填充方式（类似于background-size），取值有contain、cover、fill、none、scale-down 123456img &#123; border: 1px solid red; width: 200px; height: 100px; object-fit: fill; /* 默认值 */&#125; object-position用来指定可替换元素的内容对象在盒元素区域中的位置： 参考 Q:为何img、input等内联元素可设置宽高@掘金 可替换元素@MDN]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>可替换元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS07 瀑布流布局]]></title>
    <url>%2F2019%2F08%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS07%20%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[使用多列布局和Flex布局实现瀑布流的Demo及笔记。 预备知识：Column布局CSS Columns（多列布局）是一种定义了多栏布局的模块，它能够表现出将内容在列之间怎么流动的以及间隙和分割线怎么使用。浏览器的兼容性还是不错的，生产环境建议-moz和-webkit前缀以及不加前缀三种形式共同使用 columnsCSS多列布局可以轻松的实现多列的瀑布流布局，它的两个关键属性是column-count和cloumn-width column-count设置多列布局得的列数，取值： auto，由其他CSS属性来决定列的数量，比如column-width &lt;number&gt;，用来描述元素内容被划分的列数，如果column-width也设置为非零值，此参数仅表示所允许的最大列数 column-width用来设定最佳列宽，取值： auto，由其他CSS属性来决定列的数量，比如column-count &lt;length&gt;，用来描述最理想的列宽，实际列宽可能更宽（用来填充可用空间）也可能更窄（当可用空间比指明的列宽更窄），如果column-width也设置为非零值，此参数仅表示所允许的最大列数 因为这两个属性值没有重叠，可以使用columns来进行简写：1234column-count: 5 → columns: 5column-width: 200px → columns: 200px↓columns: 5 200px 高度一般来说，多列布局的高度是由浏览器自动确定的，但是也可以通过设置height或者max-height来限制列的高度。这样在生成新的一列之前都会仅允许增加到这个高度，剩下的内容会放置到下一列中。（这样会令我们的设置的column-count失效） 未设置高度： 设置最大高度后，列数超出了设置的column-count: 4： 列间隙column-gap属性来设置列之间的间隔，取值： normal，多列布局时默认值为1em，其他类型布局时默认值为0 &lt;length&gt;，非负整数 &lt;percentage&gt;，基于父元素宽度的百分比 列分割线可以通过column-rule属性来为多列布局时各列之间添加分割线，它与border属性类似，也是一个缩写属性，它是由下面三个属性构成： column-rule-width，指定分割线宽度，可以设定具体数值，也可以在thin、medium、thick之间取值 column-rule-style，指定分割线的样式，取值与border-style类似 column-rule-color，指定分割线的颜色 添加这个属性后column-rule: thick inset blue： 使用多列布局实现瀑布流使用多列布局实现瀑布流就十分简单了： DOM结构直接用一个多列布局的容器，内部防止排列的元素即可： 123456789101112131415161718192021&lt;div class="container"&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt;&lt;/div&gt; 关键是设置container的多列布局的相关属性： 12345678910.container &#123; width: 1000px; column-count: 4; column-gap: 1em; column-width: 220px;&#125;.img-container &#123; margin-bottom: 10px;; break-inside: avoid;&#125; 完整代码在这里。 此外，需要在内部元素上添加一个break-inside属性，用来防止多列布局中内容以外中断，取值： auto，不强制也不禁止元素内的页、列中断 avoid，避免元素内的分页符、列中断以及区域中断 aviod-page，避免元素内的分页符 aviod-column，避免元素内的列中断 aviod-region，避免元素内的区域中断 实现的效果： 多列布局来实现瀑布流布局的优点是灵活简单，并且不需要JavaScript参与，且DOM结构很简单，缺点除了需要考虑兼容性之外，我没发现缺点 使用Flex布局实现瀑布流之前面试的时候被问到，如何实现瀑布流，我当时并不知道多列布局，自然而然就想到使用Flex实现。Flex完全可以实现，但是DOM结构会稍微复杂一些 首先需要让父容器成为Flex容器，再使用4个&lt;div&gt;充当列，然后向每个列中分别添加元素即可（网上有一些方案认为列元素内部还需要使用Flex布局，然后flex-direction为column，我觉得没有必要，自然向下排列就可以了吧） 12345678910111213141516171819202122&lt;div class="container"&gt; &lt;div class="col"&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;div class="img-container"&gt;&lt;img src="./images/2.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="img-container"&gt;&lt;img src="./images/1.jpg" alt=""&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS设置并不复杂： 12345.container &#123; display: flex; width: 1000px; justify-content: space-around;&#125; 完整代码在这里。 实现的效果： 这种方法优点是兼容性好，缺点主要是DOM结构复杂一些，而且需要手动的将获取的元素插入到不同的列中，还需要综合考虑各列的高度，放着某一列高度超出其他列太多。 参考 使用CSS的多列布局@MDN column-rule-color@MDN break-inside@MDN 纯css实现瀑布流（multi-column多列及flex布局）@segmentfault]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>瀑布流</tag>
        <tag>多列布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码01 详解 vue 的 diff 算法]]></title>
    <url>%2F2019%2F08%2F09%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F03%20Vue%E6%BA%90%E7%A0%81%2FVue%E6%BA%90%E7%A0%8101%20%E8%AF%A6%E8%A7%A3%20vue%20%E7%9A%84%20diff%20%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[详解 vue 的 diff 算法。 本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/post/5affd01551882542c83301da 本文由 简悦 SimpRead 转码， 原文地址 https://juejin.im/post/5affd01551882542c83301da 前言目标是写一个非常详细的关于 diff 的干货，所以本文有点长。也会用到大量的图片以及代码举例，一起来 get 吧。 先来了解几个点… 1. 当数据发生变化时，vue 是怎么更新节点的？要知道渲染真实 DOM 的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？diff 算法能够帮助我们。 我们先根据真实 DOM 生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使oldVnode的值为Vnode。 diff 的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的 DOM 打补丁。 2. virtual DOM 和真实 DOM 的区别？virtual DOM 是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的 virtual DOM（伪代码）： 1234567var Vnode = &#123; tag: 'div', children: [&#123; tag: 'p', text: '123' &#125;]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） 3. diff 的比较方式？在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个 div 以及第二层的 p 和 span，但是不会拿 div 和 span 作比较。在别处看到的一张很形象的图： diff 流程图当数据发生改变时，set 方法会让调用Dep.notify通知所有订阅者 Watcher，订阅者就会调用patch给真实的 DOM 打补丁，更新相应的视图。 具体分析patch来看看patch是怎么打补丁的（代码只保留核心部分） 1234567891011121314151617function patch(oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode) &#125; else &#123; const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125; patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 123456789function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )&#125; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff 可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…） patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 1234567891011121314151617patchVnode(oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125; else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125; else if (ch) &#123; createEle(vnode) //create el's children dom &#125; else if (oldCh) &#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实 dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下 updateChildren updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768updateChildren(parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125; else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解 updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。（这都是我自己画的，求推荐好用的画图工具…） 粉红色的部分为 oldCh 和 vCh 我们将它们取出来并分别用 s 和 e 指针指向它们的头 child 和尾 child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，这句话有点绕，打个比方 如果是 oldS 和 E 匹配上了，那么真实 dom 中的第一个节点会移到最后 如果是 oldE 和 S 匹配上了，那么真实 dom 中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，分为两种情况 如果新旧子节点都存在 key，那么会根据oldChild的 key 生成一张 hash 表，用S的 key 与 hash 表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实 dom 中将成功的节点移到最前面，否则，将S生成对应的节点插入到 dom 中对应的oldS位置，oldS和S指针向中间移动。 如果没有 key, 则直接将S生成新的节点插入真实DOM（ps：这下可以解释为什么 v-for 的时候需要设置 key 了，如果没有 key 那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了） 再配个图（假设下图中的所有节点都是有 key 的，且 key 为自身的值） 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将 dom 中的 a 节点放到第一个，已经是第一个了就不管了，此时 dom 的位置为：a b d 第二步 123oldS = b, oldE = d；S = c, E = b;复制代码 oldS和E匹配，就将原本的 b 节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，此时 dom 的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时 dom 的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的 index 插入到真实 dom 中去，此时 dom 位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据 index 添加到 dom 中去（如上图） S &gt; E表示 vCh 先遍历完，那么就在真实 dom 中将区间为[oldS, oldE]的多余节点删掉 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode)&#125; 就这样层层递归下去，直到将 oldVnode 和 Vnode 中的所有子节点比对完。也将 dom 的所有补丁都打好啦。那么现在再回过去看 updateChildren 的代码会不会容易很多呢？ 总结以上为 diff 算法的全部过程，放上一张文章开始就发过的总结图，可以试试看着这张图回忆一下 diff 的过程。 欢迎在评论区多多交流。 参考文章 解析 vue2.0 的 diff 算法 VirtualDOM 与 diff(Vue 实现).MarkDown)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>diff</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题36 白屏时间和首屏时间]]></title>
    <url>%2F2019%2F08%2F09%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9836%20%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4%E5%92%8C%E9%A6%96%E5%B1%8F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[关于白屏时间和首屏时间的学习笔记。 定义白屏时间：从浏览器响应用户输入网址地址，到开始显示内容的时间。 首屏时间：从浏览器响应用户输入网址地址，到首屏内容渲染完成的时间。 Performance APIwindow.performance对象提供了一组精确的数据，经过简单的计算就能够得出一些网页性能数据。 注意，现在查到的大多数文章使用的API都是performance.timing这个接口，这个接口返回一个PerformanceTiming对象，包含了页面相关的性能信息，但是这个接口已经被废弃，这样它上面定义的大量的属性，例如navigationStart都已经被废弃，应该使用performance.timeOrigin来代替。 为什么会被废弃呢？因为W3C提供了更全面、更强大的性能分析矩阵，其中最重要的工具之一就是High Resuolution Time这个基础的API，可以提供比Date.now()更精准的时间戳。 所有的规范都是基于这个高精度的时间规范。Date对象提取的时间单位都是毫秒，而使用performance.now()（或者其他performance获取到的时间单位）单位也是毫秒，但是返回变量精度达到了小数点后面10位以上，也就是说，performance.now()精度可以达到微妙级别的精度，精度更高。 performance.now()performance.now()的返回值是一个高精度的时间戳，它与Date.now()的主要区别是： （1）performance.now()精度使用了浮点数达到微秒级别的精确度，精度更高，用于和页面加载、渲染、性能监测等相关的场景 （2） performance.now()兼容性差（IE10+） （3）Date.now()返回的是以1970-01-01T00:00:00Z为起点的时间戳，依赖系统时间；而performance.now()不受到系统时间的影响，返回当前网页自从performance.timeOrigin到当前时间之间的毫秒数，它是规律增长的。 performance.timeOriginperformance.timeOrigin表示性能测试开始的时间点，即所有Performance Timeline起始点的时间，返回的是一个高精度的时间戳起点。 我理解为performance.timeOrigin就是文档开始加载的起点，与之前的performance.timing.navigationStart是相同的（实际上我在demo中测量出的时间，二者还是有一定的区别，不解）。 performance.mark()performance.mark()一般和performance.measure()以及performance.getEntriesByName()一起使用，可以更高精度的测量某个方法的用时 1234567performance.mark('fn_start');fn();performance.mark('fn_end');performance.measure('fn', 'fn_start', 'fn_end');const fnDuration = performance.getEntriesByName('x').duration;console.log(fnDuration); 白屏时间白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素，这里面可能包括了DNS查询、TCP连接、网络请求、加载CSS等步骤。 影响白屏时间的因素：网络、服务端性能、前端页面结构设计。 计算白屏时间「地址栏输入网址后回车」我们用performance.timeOrigin来标识（或者使用以前的performance.timing.navigationStart） 「浏览器出现第一个元素」也就是白屏时间的结束点，通常认为浏览器开始渲染&lt;body&gt;或者解析完&lt;head&gt;的时间就是白屏结束的时间点，具体实现的时候就是在&lt;head&gt;的末尾添加一个&lt;script&gt;脚本，在这个脚本中计算结束时间。 我们可以采取渐进式的方案，如果不支持performance，则使用Date.now()作为降级方案 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;白屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt; &lt;!-- 页面 CSS 资源 --&gt; &lt;link rel="stylesheet" href="styles/base.css"&gt; &lt;link rel="stylesheet" href="styles/default.css"&gt; &lt;script&gt; // 白屏结束时间 window.firstPaint = Date.now(); // 白屏时间 const paintDuration = performance ? performance.now() : firstPaint - pageStartTime; // performance.now() 就相当于 firstPaint - performance.timeOrigin console.log(paintDuration); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 首屏时间对于页面加载时间，DOM提高的API都不能够用来直接计算首屏时间（onload事件可以得到整个页面资源的加载完成，DOMConentLoad事件可以得到页面DOM树构建完成的时间） 由于浏览器处理图片资源是异步的，并不会阻塞其他DOM节点的渲染，所以对于首屏有图片的情况，应当以耗时最长的图片加载完成的时间作为首屏时间的结束，如果没有图片则可以使用DOMConentLoad打点时间 针对有图片的情况，至少要完成以下几个方面的工作： 判断屏幕尺寸 遍历所有图片，获得图片位置信息，筛选出处于首屏内图片 有图片的话，监听图片的onload事件，获取耗时最长的图片的加载时间 没有图片，监听DOMConentLoad事件获取事件 也可以通过MutationObserver来监听页面变化，当首屏DOM节点稳定后，认为首屏加载完成，具体可以参考这两篇文章的实现（《精确并自动化地获取页面首屏时间》、《关于首屏时间采集自动化的解决方案》)。这样的方法有一定误差，并且实现起来也很繁琐。 但是在浏览器没有给出更多便捷的接口之前，可能也只能采取上面的某一种方式来实现了。 参考 Web 性能优化-首屏和白屏时间@lizhen 蚂蚁金服如何把前端性能监控做到极致?@InfoQ Performance@MDN performance.now() vs Date.now()@StackOverflow]]></content>
      <categories>
        <category>零散专题</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>首屏时间</tag>
        <tag>白屏时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git16 Rebase]]></title>
    <url>%2F2019%2F08%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F12%20Git%2FGit16%20Rebase%2F</url>
    <content type="text"><![CDATA[Git rebase 命令学习笔记。 使用Rebase用于把一个分支的修改合并到当前分支，这是它最主要的功能。看下面这个例子： （1）我们从当前的master分支切除一个feature1分支，进行开发： 1$ (master) git checkout -b feature 对应Webstorm中的操作： （2）这时候，同事完成了一次提交，并且合并入了master分支，这时候master已经领先于feature1分支了： 对应Webstorm中的操作： （4）这个时候，我们要同步master的改动，如果使用merge操作： 1$ (feature1) git merger master 那么会产生一次新的用于merge的提交信息: 对应Webstorm中的操作： 这一条commit记录，我们可以认为它是无效的（也许并不是这样，看你如何看待），想要保持一份干净的commit记录，就需要用到git rebase命令了 （4）回退到merge的状态 （5）使用rebase命令： 1$ (feature1) git reabse master 对应Webstorm中的操作：（总是搞不清楚这个操作的主客关系，Rebase Current onto Selected的意思就是将当前分支的基准（feature1）变为选择的分支（master），master是基准。 rebase做了什么操作呢？ Git会将feature1分支里面每个commit取消，临时保存为patch文件，保存在.git/rebase目录下 把feature1分支更新到最新的master分支上（也就是「变基」了） 把上面保存的patch文件应用到feature1分支上 这样的操作后提交记录里面就不会有merge的那条记录，而且feature1是基于更新后的master，自然也就成为了最领先的分支了，可以直接push到master上。 （6）在reabse的过程中，也许会出现冲突conflict，这种情况Git会停止rebase，让你去解决冲突，解决完冲突用git add命令去更新这些内容。 注意，你无需执行git commit，只需要执行git rebase --continue，Git就会继续应用剩下的patch补丁文件 （7）任何情况下，都可以使用--abort来终止rebase过程，并且分支会回到rebase开始前的状态 1$ git reabse --abort 应用场景git rebase存在的价值是，对一个分支做「变基」的操作，最常见的应用场景是：当我们在一个过时的分支上面是，执行rebase以此同步master分支最新改动 危险性在提交到代码到远程仓库前，记录是这样的： 提交之后分支变成了： 但是如果有同事也在feature1开发，它的分支依然基于过时的master： 那么当它push到远程master就会有记录丢失，因为reabse改变了历史，应该谨慎使用。 所以，除非你可以肯定改feature1分支只有你自己操作，否则请谨慎使用。只要你的分支上需要rebase的所有commits历史还没有被push过，就可以安全的使用git rebase来操作。 使用rebase和merge的基本原则 下游分支（featrue1）更新上游分支（master）内容的时候用rebase 上游分支合并下游分支内容的时候使用merge 参考 彻底搞懂 Git-Rebase@Jartto’s blog GIT使用rebase和merge的正确姿势@知乎]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Rebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习08 用栈实现队列]]></title>
    <url>%2F2019%2F08%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F02%20%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A008%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用栈实现队列 题目在组内面试反馈的邮件中看到了用栈实现队列这样一道题目，觉得自己如果面试遇到这个题目还是有点懵的，所以特地上网上找了一下，在Leetcode上找到了这道题目LeetCode 232 用栈实现队列。 题目是这样的：使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。 pop() – 从队列首部移除元素。 peek() – 返回队列首部的元素。 empty() – 返回队列是否为空。 注意：只能使用标准的栈操作，也就是只有push to top，peek/pop from top， size和is empty操作。 实例： 1234567const queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 分析之所以对这道题目有点懵，是因为自己对栈和队列的特点不太了解 栈是先进后出的，队列是先进先出的 标准的栈只有push/pop/size几个方法 因为JavaScript中的数组实际上比队列和栈是更加灵活的，要用栈来模拟队列，实际上可以用数组先模拟栈，然后在模拟队列。也可以直接使用数组来模拟队列，但是只使用数组的push和pop方法。 关键是栈和队列的操作顺序如何实现，我的思路是使用了两个栈（数组）来模拟，一个主栈一个辅栈，当移除的时候，栈移除的是栈底的元素，而队列要移除的是队首的元素，所以将主栈的元素都添加到辅栈中，然后再pop辅栈栈底的元素，就是队列要移除的队首的元素。实际上和我们玩过的汉诺塔的操作过程。 添加的时候可以直接添加，但是要注意辅栈中是否有元素，如果有的话需要先将辅栈的元素移动会主栈，在进行添加。 实现12345678910111213141516171819202122232425262728293031323334353637383940function MyQueue() &#123; // 主栈 this.queue1 = []; // 辅栈 this.queue2 = [];&#125;MyQueue.prototype.push = function (x) &#123; while (this.queue2.length !== 0) &#123; this.queue1.push(this.queue2.pop()) &#125; this.queue1.push(x);&#125;;MyQueue.prototype.pop = function () &#123; if (this.empty()) &#123; return; &#125; while (this.queue1.length !== 0) &#123; this.queue2.push(this.queue1.pop()) &#125; return this.queue2.pop();&#125;;MyQueue.prototype.peek = function () &#123; if (this.empty()) &#123; return; &#125; while (this.queue1.length !== 0) &#123; this.queue2.push(this.queue1.pop()) &#125; const temp = this.queue2.pop(); this.queue2.push(temp); return temp;&#125;;MyQueue.prototype.empty = function () &#123; return this.queue1.length === 0 &amp;&amp; this.queue2.length === 0&#125;; 参考 LeetCode 232 用栈实现队列@leetcode 《剑指offer》— JavaScript（5）用两个栈实现队列@简书]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题35 AST抽象语法树]]></title>
    <url>%2F2019%2F08%2F01%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9835%20AST%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AST抽象语法树学习笔记。 什么是抽象语法树抽象语法树（abstract syntax tree，AST，或者简称语法树）是源代码的抽象语法结构的树状表现形式，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。 之所以说是抽象的，是因为这里的语法并不会表示出真实语法中出现的每个细节，比如嵌套括号被隐含在树结构中，并不会以节点的形式呈现出来。而类似于if...else这样的条件语句，可以使用两个分支的节点来表示。 比如下面这段代码： 12345678while (b !== 0) &#123; if (a &gt; b) &#123; a = a - b &#125; else &#123; b = b - a &#125;&#125;return a; 它的对应的抽象语法树如下： 可以通过astexplorer这个网站，将我们输入的代码转换为AST展示出来，可以展示为书结构，也可以直接以JSON格式展示，比如在左侧输入let a = 123;，对应的语法树： 也可以直接输入JSON： 12345678910111213141516171819202122232425262728293031323334&#123; "type": "Program", "start": 0, "end": 12, "body": [ &#123; "type": "VariableDeclaration", "start": 0, "end": 12, "declarations": [ &#123; "type": "VariableDeclarator", "start": 4, "end": 11, "id": &#123; "type": "Identifier", "start": 4, "end": 5, "name": "a" &#125;, "init": &#123; "type": "Literal", "start": 8, "end": 11, "value": 123, "raw": "123" &#125; &#125; ], "kind": "let" &#125; ], "sourceType": "module"&#125; 语法树中每个元素可以成为一个节点（node），类型包括： 1234567891011121314(parameter) node: Identifier | SimpleLiteral | RegExpLiteral | Program | FunctionDeclaration | FunctionExpression |ArrowFunctionExpression | SwitchCase | CatchClause | VariableDeclarator | ExpressionStatement |BlockStatement | EmptyStatement | DebuggerStatement | WithStatement | ReturnStatement |LabeledStatement | BreakStatement | ContinueStatement | IfStatement | SwitchStatement | ThrowStatement | TryStatement | WhileStatement | DoWhileStatement | ForStatement | ForInStatement | ForOfStatement |VariableDeclaration | ClassDeclaration | ThisExpression | ArrayExpression | ObjectExpression |YieldExpression | UnaryExpression | UpdateExpression | BinaryExpression | AssignmentExpression |LogicalExpression | MemberExpression | ConditionalExpression | SimpleCallExpression | NewExpression |SequenceExpression | TemplateLiteral | TaggedTemplateExpression | ClassExpression | MetaProperty |AwaitExpression | Property | AssignmentProperty | Super | TemplateElement | SpreadElement |ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition |ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration |ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier 使用场景平时我们好像从来没有接触过AST，但是实际上它的适用场景一直相伴左右，比如： JS反编译，语法解析 Babel编译ES6语法 代码高亮 关键字匹配 作用域判断 代码压缩 AST分析使用刚才提到的astexplorer这个网站，解析1 + 2 * 3，得到的AST语法树 从语法树我们开出来，body里面的exporession（表达式）是BinaryExpress（二院表达式），start和end标识了我们这个表达式字符的起止位置，operator是+，然后left属性的值是一个Literal字面量，value是2，right属性的值又是另外一个BinaryExpress，left的值是2，operator是*，right右侧值是3 这样，通过一个树状结构，将我们输入的表达式明明白白展示出来了。 将表达式添加一个括号，变成(1 + 2) * 3，得到的新的语法树： 可以看出来，left值变为了一个BinaryExpress，operator是*，right值是3。 比较两个表达式的语法树，可以发现： 在确定类型为ExpressionSatatement后，会按照代码执行的先后顺序，将表达式BinaryExpression分解为left、operator、right三部分 每部分都标明了类型、起止位置、值等信息 标明了操作符类型 再来看一下常用的箭头函数： 123const fn = (a, b) =&gt; &#123; return a + b&#125;; AST的JSON结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#123; "type": "Program", "start": 0, "end": 40, "body": [ &#123; "type": "VariableDeclaration", "start": 0, "end": 40, "declarations": [ &#123; "type": "VariableDeclarator", "start": 6, "end": 39, "id": &#123; "type": "Identifier", "start": 6, "end": 8, "name": "fn" &#125;, "init": &#123; "type": "ArrowFunctionExpression", "start": 11, "end": 39, "id": null, "expression": false, "generator": false, "params": [ &#123; "type": "Identifier", "start": 12, "end": 13, "name": "a" &#125;, &#123; "type": "Identifier", "start": 15, "end": 16, "name": "b" &#125; ], "body": &#123; "type": "BlockStatement", "start": 21, "end": 39, "body": [ &#123; "type": "ReturnStatement", "start": 25, "end": 37, "argument": &#123; "type": "BinaryExpression", "start": 32, "end": 37, "left": &#123; "type": "Identifier", "start": 32, "end": 33, "name": "a" &#125;, "operator": "+", "right": &#123; "type": "Identifier", "start": 36, "end": 37, "name": "b" &#125; &#125; &#125; ] &#125; &#125; &#125; ], "kind": "const" &#125; ], "sourceType": "module"&#125; 耐下性子，仔细读一下语法树，其实也不难理解，首先body的type变为了VariableDeclaration，declarations是一个数组，首先声明了fn这个变量，然后在init里面是一个type为ArrowFunctionExpression的节点，里面有params、body、ReturnStatement等各种用来标识箭头函数的属性值， 实现从上面可以看出来，抽象语法树其实就是将一类标签转化成通用标识符，从而归纳出的一个类似于树形结构的语法树。 那么这个过程是如何实现的呢？ 简单学习了一下，首先需要几个工具包用来解析JS语法、遍历树结构以及生成新的树结构： 123456789101112131415161718192021const esprima = require('esprima'); // 解析js的语法的包const estraverse = require('estraverse'); // 遍历树的包const escodegen = require('escodegen'); // 生成新的树的包let code = `function getAST()&#123;&#125;`;//解析js的语法let tree = esprima.parseScript(code);//遍历树estraverse.traverse(tree, &#123; enter(node) &#123; console.log('enter: ' + node.type); &#125;, leave(node) &#123; console.log('leave: ' + node.type); &#125;&#125;);//生成新的树let r = escodegen.generate(tree);console.log(r); 通过遍历、修改抽象语法树，我们可以去改变任何输出结果，也就是说，在编译的过程中，借助抽象语法树，我们可以去改变原来的输入，得到想要的结果。 这也就是Babel转义JavaScript代码的原理。 关于BabelBabel使用一个基于ESTree并修改过的AST，它的内核说明文档可以在这里找到。 Babel的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。 （1）解析 接受代码并输出AST，这个步骤又分为两个阶段：词法分析（Lexical Aanalysis）和语法分析（Syntactic Analysis） 词法分析阶段把字符串形式的代码转换为令牌流，可以将令牌看做一个扁平的语法片段数组 12345678910n * n;↓[ &#123; type: &#123; ... &#125;, value: "n", start: 0, end: 1, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: "*", start: 2, end: 3, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: "n", start: 4, end: 5, loc: &#123; ... &#125; &#125;, ...] 其中每一个type都有一组数形来描述该令牌，和AST节点一样也有start、end等属性： 12345678910111213141516&#123; type: &#123; label: 'name', keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null &#125;, ...&#125; 语法分析阶段会吧一个令牌转换成AST的形式，这个阶段会使用令牌中的信息把他们转换成一个AST的表述结构，便于后续操作 （2）转换 接受AST并对其进行遍历，此过程中对节点进行添加、更新和移除等操作。这是Babel最复杂的过程，也是Babel插件接入工作的部分。 （3）生成 深度优先遍历将经过一系列转换后的AST，并将其转换成字符串形式的代码，同时还会创建源码映射。 单元测试覆盖率JavaScript单元测试覆盖率统计方法的核心思想，是在源代码响应的位置注入设定的统计代码，当执行测试代码的时候，代码运行到注入的地方，就会执行对应的统计代码，生成覆盖率统计报告。大概步骤如下： （1）对源代码进行语法分析、解析，然后生成抽象语法树 （2）在语法树相应的位置注入统计代码。 在程序执行到这个位置的时候对相应的全局变量赋值，确保执行之后能够根据全局变量知道代码的执行流程。 （3）通过注入统计代码的抽象语法树，生成对应的JavaScript代码 （4）将生成好的JavaScript代码交给执行环境（Node或者浏览器）运行 （5）执行单元测试，产生的统计信息，放到全局变量里面。 （6）根据全局变量中的覆盖率信息生成特定格式的报告。 总结大致学习了一下AST的知识，并没有很深入，只是了解到AST是对源代码的一种树状结构的表示形式，可以用来在编译阶段对代码进行处理。Babel之所以能够实现JavaScript的转换，就是利用了AST，经历了解析、转换、生成三个步骤，其中转换是最复杂的步骤，各种Babel的插件也是在这个步骤中发挥作用。 参考 抽象语法树@维基百科 AST 抽象语法树@jartto Babel 插件有啥用？@知乎 代码测试覆盖率分析@segmentfault]]></content>
      <categories>
        <category>零散专题</category>
      </categories>
      <tags>
        <tag>Babel</tag>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码学习01 Axios]]></title>
    <url>%2F2019%2F07%2F31%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F13%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A001%20Axios%2F</url>
    <content type="text"><![CDATA[Axios是一个基于Promise的HTTP请求库，可以用在浏览器和Node.js中。平时在Vue项目中，经常使用它来实现HTTP请求。 它的使用简便、灵活，并且有interceptors、数据转换器等强大的功能，以前用的时候并没有仔细研究过这些功能是如何实现的，正好在知乎的大前端专栏看到一篇文章对Axios的源码进行了解读。借着这篇文章的帮助，我开始了自己阅读源码的道路。 以后要多多的读源码，更多的独立完成，向大神们学习。 Axios的目录结构Axios的目录结构相对还是比较简单的 目录里面adapters/目录下定义的是如何发出一个HTTP请求，这也就是为什么Axios技能应用在浏览器中（XHR）又能用在Node.js中（http.request)，core/Axios.js是Axios的核心主类，axios.js是整个Axios的入口。 Axios的实现流程12345678graph TB引入axios--&gt;Axios构造函数实例化Axios构造函数实例化--&gt;Interceptors请求拦截器Interceptors请求拦截器--&gt;dispatchRequest方法dispatchRequest方法--&gt;请求转换器transformRequest请求转换器transformRequest--&gt;http请求适配器adapterhttp请求适配器adapter--&gt;响应转换器transformResponse响应转换器transformResponse--&gt;Interceptors响应拦截器 工具函数的学习forEach这个forEach与原生的数组的forEach并不相同，它可以遍历对象，也可以遍历数组，还可以遍历基本值： 1234567891011121314151617181920212223242526function forEach(obj, fn) &#123; // 如果是空值就返回 if (obj === null || typeof obj === 'undefined') &#123; return; &#125; // 如果是基本类型，则放到数组里面进行遍历 if (typeof obj !== 'object') &#123; /*eslint no-param-reassign:0*/ obj = [obj]; &#125; if (isArray(obj)) &#123; // 遍历数组 for (var i = 0, l = obj.length; i &lt; l; i++) &#123; fn.call(null, obj[i], i, obj); &#125; &#125; else &#123; // 遍历对象 for (var key in obj) &#123; if (Object.prototype.hasOwnProperty.call(obj, key)) &#123; fn.call(null, obj[key], key, obj); &#125; &#125; &#125;&#125; merge和deepMerge用来合并对象，二者的区别只是对于嵌套的深层的对象，deepMerge也会进行深层的拷贝，而不是指针的改变 123456789101112131415161718192021222324252627282930313233function merge(/* obj1, obj2, obj3, ... */) &#123; var result = &#123;&#125;; function assignValue(val, key) &#123; if (typeof result[key] === &apos;object&apos; &amp;&amp; typeof val === &apos;object&apos;) &#123; result[key] = merge(result[key], val); &#125; else &#123; result[key] = val; &#125; &#125; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; forEach(arguments[i], assignValue); &#125; return result;&#125;function deepMerge(/* obj1, obj2, obj3, ... */) &#123; var result = &#123;&#125;; function assignValue(val, key) &#123; if (typeof result[key] === &apos;object&apos; &amp;&amp; typeof val === &apos;object&apos;) &#123; result[key] = deepMerge(result[key], val); &#125; else if (typeof val === &apos;object&apos;) &#123; result[key] = deepMerge(&#123;&#125;, val); &#125; else &#123; result[key] = val; &#125; &#125; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; forEach(arguments[i], assignValue); &#125; return result;&#125; isStandardBrowserEnv用来判断是否是标准的浏览器环境，对于Web Workers， 12typeof window -&gt; undefinedtypeof document -&gt; undefined 对于RN和NativeScript 12345react-native:navigator.product -&gt; &apos;ReactNative&apos;nativescriptnavigator.product -&gt; &apos;NativeScript&apos; or &apos;NS&apos; 所以有： 1234567891011121314151617181920212223242526/** * Determine if we're running in a standard browser environment * * This allows axios to run in a web worker, and react-native. * Both environments support XMLHttpRequest, but not fully standard globals. * * web workers: * typeof window -&gt; undefined * typeof document -&gt; undefined * * react-native: * navigator.product -&gt; 'ReactNative' * nativescript * navigator.product -&gt; 'NativeScript' or 'NS' */function isStandardBrowserEnv() &#123; if (typeof navigator !== 'undefined' &amp;&amp; (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) &#123; return false; &#125; return ( typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined' );&#125; Axios的多种使用方式Axios有多种使用方式： 12345678910111213141516import axios from 'axios';// 第一种 axios(option)axios(&#123; url, method, headers &#125;);// 第二种 axios(url[, option]);axios(url, &#123; method, headers &#125;)// 第三种（对于 get/delete 等方法） axios.[method](url[, option])axios.get(url, &#123; headers &#125;)// 第四种（对于 post/put等方法）axios[.method](url[, data[, option]])axios.post(url, data, &#123; headers &#125;)// 第五种 axios.request(option)axios.request(&#123; url, method, headers &#125;) 下面从入口文件axios.js来分析这些使用方式都是如何实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// axios.js// 用来创建一个 axios 的实例function createInstance(defaultConfig) &#123; // 通过默认配置新建一个 axios 实例 var context = new Axios(defaultConfig); // 通过 bind 方法获取到 instance，并且绑定 this 上下文 // instance 是一个函数，实际上就是 Axios.prototype.request.bind(context)，其上下文指向 context // 所以可以通过 instance(options)的方法调用 var instance = bind(Axios.prototype.request, context); // 将 Axios 原型上的属性和方法复制到 instance 上，作为静态属性和静态方法 // Axios.prototype 上定义了 get/delete/post 等方法，所以可以直接使用 instance.get 这种形式调用 utils.extend(instance, Axios.prototype, context); // 将 context 实例的属性和方法复制到 instance 上，作为静态属性和静态方法 // context.request 指向 Axios.prototype.request，所以可以通过instance.request 这种形式调用 utils.extend(instance, context); // 返回 request 方法，它与 context 的差别仅仅在于它本身是一个函数，可以直接调用 return instance;&#125;// 接受默认配置项作为参数，创建一个 request 方法，具有 Axios 的各种实例属性、方法以及原型属性和方法// 可以认为导出的就是 Axios 的实例var axios = createInstance(defaults);// 暴露 Axios 类，用于继承axios.Axios = Axios;// 实例上定义的 create 方法，可以创建新的 axios 实例axios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;// 暴露出 Cancel 相关的类axios.Cancel = require('./cancel/Cancel');axios.CancelToken = require('./cancel/CancelToken');axios.isCancel = require('./cancel/isCancel');// 暴露出 all 方法，实际上利用的就是 Promise.all方法axios.all = function all(promises) &#123; return Promise.all(promises);&#125;;// 导出一个 apply 的语法糖，用来将多参数作为输入传入函数，功能和 rest 参数相同axios.spread = require('./helpers/spread');// 导出实例module.exports = axios;// Allow use of default import syntax in TypeScriptmodule.exports.default = axios; 有个疑问，为什么createInstance函数需要绕那么大一个弯，而不是直接导出new Axios的实例呢？我的理解是如果直接导出new Axios是没有办法使用axios(option)和axios(url, option)这两种方式来实现调用。 createInstance最终返回的是一个函数，它指向Axios.prototype.request，并且绑定了new Axios实例作为上下文对象，同时这个导出的函数还有Axios.prototype以及new Axios实例的各个方法和属性作为其静态属性和方法，这些方法的上下文都指向new Axios这同一个对象。 上面的代码解释了除了第二种Axios的调用方法之外的调用方法，第二种调用方法是在Axios.prototype.request中对第一个参数的数据类型进行判断来实现的，后面在学习Axios.prototype.request代码时会提到。 Axios类Axios.js是Axios的核心，它声明了Axios这个类，并在原型添加了一些方法，其中最核心的就是request方法，上面提到的各种调用方法都是通过调用request方法实现的。 首先来看Axios类的声明 12345678910function Axios(instanceConfig) &#123; // 将传入的配置保存到实例属性上 this.defaults = instanceConfig; // 声明 interceptors 属性，用来保存请求拦截器和响应拦截器 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125; Axios类只声明了两个实例属性，拦截器属性都是InterceptorManager的实例。InterceptorManager这个类位于core/InterceptorManager.js，并不复杂，定义了一个实例属性来存放拦截器，定义了一些原型方法来对队列中拦截器进行添加、移除和遍历的操作 123456789101112131415161718192021222324252627282930// 定义实例属性 handlers 来存放拦截器function InterceptorManager() &#123; this.handlers = [];&#125;// 添加拦截器到队列中，接受两个参数，分别对应 Promise的 resolve 和 reject// 返回拦截器的 ID， 用来移除它InterceptorManager.prototype.use = function use(fulfilled, rejected) &#123; this.handlers.push(&#123; fulfilled: fulfilled, rejected: rejected &#125;); return this.handlers.length - 1;&#125;;// 在队列中移除拦截器InterceptorManager.prototype.eject = function eject(id) &#123; if (this.handlers[id]) &#123; this.handlers[id] = null; &#125;&#125;;// 用来遍历执行队列中的拦截器InterceptorManager.prototype.forEach = function forEach(fn) &#123; utils.forEach(this.handlers, function forEachHandler(h) &#123; if (h !== null) &#123; fn(h); &#125; &#125;);&#125;; 实际上Axios的实例属性interceptors.request用来存放请求拦截器，interceptors.response用来存放响应拦截器， 然后来看核心的request方法的代码： 12345678910111213141516171819202122232425262728293031323334Axios.prototype.request = function request(config) &#123; // 通过参数的类型判断实现 axios(url[, option]) 的调用方式 if (typeof config === 'string') &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0]; &#125; else &#123; config = config || &#123;&#125;; &#125; // 合并配置项 config = mergeConfig(this.defaults, config); config.method = config.method ? config.method.toLowerCase() : 'get'; // 添加拦截器 var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); // 将请求拦截器添加到 chain 前面 this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; chain.unshift(interceptor.fulfilled, interceptor.rejected); &#125;); // 将响应拦截器添加到 chain 后面 this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; chain.push(interceptor.fulfilled, interceptor.rejected); &#125;); // 对 chain 进行循环 while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; return promise;&#125;; 个人感觉上面的代码十分巧妙，首先生命了chain这个数组，填了两个成员dispatchRequest和undefined，然后定义了一个立刻resolve的Promise对象promise，它返回的是config对象。 我们在添加请求拦截器时： 12345678// 添加请求拦截器const myRequestInterceptor = axios.interceptors.request.use(config =&gt; &#123; // 在发送http请求之前做些什么 return config; // 有且必须有一个config对象被返回&#125;, error =&gt; &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;); 使用了use方法，将请求拦截器添加到了this.interceptors.request.handlers对列中，然后通过forEach方法，对这个队列进行遍历，要注意请求拦截器使用的是unshift方法，添加到dispatchRequest前面，而响应拦截器使用push方法添加到undefined后面，所以对于请求拦截器来说，先添加的拦截器会后执行，对于响应拦截器来说，先添加的拦截器会先执行： 1234axios.interceptors.request.use(fn1, fn1_1);axios.interceptors.request.use(fn2, fn2_1);axios.interceptors.response.use(fn3, fn3_1);axios.interceptors.response.use(fn4, fn4_1); 按照上面的顺序添加的拦截器，存储到chain数组中是这样的： 1[fn2, fn2_1, fn1, fn1_1, dispatchRequest, undefined, fn3, fn3_1, fn4, fn4_1] InterceptorManager.prototype.use方法接受两个参数分别是Promise成功和失败的回调函数，如果之传入一个函数，那么默认失败的情况对应的就是undefined。所以chain数组中是两个成员为一组的，分别对应一次Promise状态改变的两个回调函数。 然后对chain进行循环： 123while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; 在循环过程中对promise重新复制，then方法中的两个参数分别是chain.shift()，chain.shift()的作用有二： 减小chain的长度 将剪切得到的两个chain成员作为then方法的两个参数执行。 Axios规定，在使用拦截器时，请求拦截器必须返回config对象，响应拦截器必须返回response对象，这样才能实现promise的链式调用 在请求拦截器中进行链式调用时，将config对象作为Promise的结果进行传递，使得所有请求拦截器共享config对象，直到真正发出请求的dispatchRequest接收到config对象并发出请求后将接收到的response作为结果返回给后续的响应拦截器，并继续传递。 chain数组中的undefined是作为dispatchRequest一组的then方法的第二个回调函数，它的作用是兜住最后一个响应拦截器的错误对象，不会破坏chain两个回调函数一组的匹配顺序。 Axios.js中还有一些其他的代码，主要的作用是为Axios.prototype添加了get、post等方法，实际上都是调用Axios.prototype.request方法 12345678910111213141516171819202122utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) &#123; // 添加到原型对象 Axios.prototype[method] = function(url, config) &#123; // 调用 Axios.prototype.request 方法 return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url &#125;)); &#125;;&#125;);utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) &#123; // 添加到原型对象 Axios.prototype[method] = function(url, data, config) &#123; // 调用 Axios.prototype.request 方法 return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;); dispathReqeust上面提到的，真正发出HTTP请求的是dispathReqeust方法，dispathReqeust主要完成了三件事： 拿到config对象，进行处理、合并，传递给HTTP请求适配器 HTTP请求适配器根据config对象发起HTTP请求 请求完成后，根据数据转换器对得到的数据进行二次处理，返回response 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 如果取消了请求，则抛出原因function throwIfCancellationRequested(config) &#123; if (config.cancelToken) &#123; config.cancelToken.throwIfRequested(); &#125;&#125;module.exports = function dispatchRequest(config) &#123; // 如果执行了 cancelToken 的回调函数则终端流程， throw 出回调函数传入的 reason // 是否执行 cancelToken 的回调函数就是通过是否有 reason 来判断的 throwIfCancellationRequested(config); // 如果传入的不是绝对地址，并且配置了 baseUrl，则将 baseUrl 与 config.url 组合 if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) &#123; config.url = combineURLs(config.baseURL, config.url); &#125; // 确保 config.headers 是一个对象 config.headers = config.headers || &#123;&#125;; // 如果定义了 config.transformRequest，则据此对 data 和 headers 进行处理 config.data = transformData( config.data, config.headers, config.transformRequest ); // 处理 headers config.headers = utils.merge( config.headers.common || &#123;&#125;, config.headers[config.method] || &#123;&#125;, config.headers || &#123;&#125; ); // 删除各种请求方法下的特定的header // 因为上面都已经合并到 config.headers 中，所以没用了 utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) &#123; delete config.headers[method]; &#125; ); // 指定 HTTP 请求适配器，一般来说默认的适配器就可以满足需要 // 默认的适配器会根据环境自动选择 XHR 或者 Node 的 http.request 方法发送网络请求 // 手动指定适配器需要返回一个 Promise 对象，一般可以用来拦截请求，返回 mock 数据 var adapter = config.adapter || defaults.adapter; return adapter(config).then(function onAdapterResolution(response) &#123; // 请求成功 // 再次判断是否取消 throwIfCancellationRequested(config); // 根据 config.transformResponse 对响应数据和响应头进行处理 response.data = transformData( response.data, response.headers, config.transformResponse ); return response; &#125;, function onAdapterRejection(reason) &#123; // 请求失败 // 判断是否是手动取消导致的失败 if (!isCancel(reason)) &#123; // 如果早晚要取消，不妨再次抛出取消的原因 throwIfCancellationRequested(config); // 根据 config.transformResponse 对响应数据和响应头进行处理 if (reason &amp;&amp; reason.response) &#123; reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); &#125; &#125; // 返回一个 reject 的 Promise // 没有直接 return reason，是因为只有返回 reject 的 Promise，才能走到响应拦截器的第二个参数（处理异常的函数） // 否则就会走到第一个参数（处理正常的函数） return Promise.reject(reason); &#125;);&#125;; dispathReqeust方法返回一个Promise，携带着成功求情后的响应数据，或者是失败后的错误对象。用户就可以在调用axios()方法后的then或者catch中进行业务处理了。 Adapter上面代码的注释里面提到了，在dispatchRequest中通过config.adapter或者defaults.adapter指定HTTP请求适配器，一般来说默认的适配器就可以满足需要，默认的适配器会根据环境自动选择XHR或者Node的http.request方法发送网络请求 在defaults.js中的adatper方法完成的就是根据环境选择HTTP适配器 123456789101112function getDefaultAdapter() &#123; var adapter; // 通过判断 process 是否存在以及类型（toString）来判断是否是 Node 环境 if (typeof process !== 'undefined' &amp;&amp; Object.prototype.toString.call(process) === '[object process]') &#123; // Node 环境使用 http 适配器 adapter = require('./adapters/http'); &#125; else if (typeof XMLHttpRequest !== 'undefined') &#123; // 浏览器环境使用 XHR adapter = require('./adapters/xhr'); &#125; return adapter;&#125; Axios是基于Promise的，而HTTP请求的实现又是通过传统的Ajax实现的，所以adapter/xhr.js的主要功能就是面试时经常遇到的一道题，将Ajax改为Promise的形式。来学习一下Axios是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// xhr.jsmodule.exports = function xhrAdapter(config) &#123; // 返回一个 Promise 对象 return new Promise(function dispatchXhrRequest(resolve, reject) &#123; var requestData = config.data; var requestHeaders = config.headers; // 如果 data 是 FromData ，则删除 Content-Type 的 Header if (utils.isFormData(requestData)) &#123; delete requestHeaders['Content-Type']; // Let the browser set it &#125; // 新建 xhr 对象 var request = new XMLHttpRequest(); // HTTP 认证信息 if (config.auth) &#123; var username = config.auth.username || ''; var password = config.auth.password || ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password); &#125; // 新建一个 AJAX 连接，注意 HTTP 方法都应该是大写的 // 请求的 url 是通过 buildURL 方法创建的，它会将查询参数进行序列化并安全编码，附在 url 后 request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); // 设定超时时间，单位是毫秒 request.timeout = config.timeout; // 监听 ready state 的改变 request.onreadystatechange = function handleLoad() &#123; if (!request || request.readyState !== 4) &#123; return; &#125; // 如果请求出错，并且没有收到响应，这种情况会被 onerror 时间捕获到 // 只有一种例外情况：请求使用的是 file 协议，大多数浏览器会返回的 status 为 0 if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf('file:') === 0)) &#123; return; &#125; // getAllResponseHeaders 方法可以返回所有的响应头 var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; // 提取响应结果 var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; var response = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config: config, // 将 config 对象传递给 response 对象 request: request &#125;; // 根据 response.status 来 resolve 或者 reject 当前的 Promise settle(resolve, reject, response); // 重置 request request = null; &#125;; // 处理浏览器的终止事件，返回 reject 的 Promise // 当一个请求被终止时，request 的 readyState 属性被置为 0 request.onabort = function handleAbort() &#123; if (!request) &#123; return; &#125; // 返回 reject 的 Promise，内容是定制的 Error 对象 reject(createError('Request aborted', config, 'ECONNABORTED', request)); request = null; &#125;; // 处理网络错误导致的资源加载失败 request.onerror = function handleError() &#123; // 真正的错误被浏览器拦截了，只有当网络错误时才会触发 onerror 事件 reject(createError('Network Error', config, null, request)); // Clean up request request = null; &#125;; // 处理超时的情况 request.ontimeout = function handleTimeout() &#123; reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request)); // Clean up request request = null; &#125;; // 添加 xsrf 的请求头，这只适用于在浏览器环境，不适用于 Web Worker 和 RN 无效 if (utils.isStandardBrowserEnv()) &#123; var cookies = require('./../helpers/cookies'); var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) &amp;&amp; config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) &#123; requestHeaders[config.xsrfHeaderName] = xsrfValue; &#125; &#125; // 使用 setRequestHeader 方法来添加请求头 // 此方法必须在 open() 和 send() 之间调用。 // 如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。 if ('setRequestHeader' in request) &#123; utils.forEach(requestHeaders, function setRequestHeader(val, key) &#123; if (typeof requestData === 'undefined' &amp;&amp; key.toLowerCase() === 'content-type') &#123; // 如果没有 data 属性，移除 Content-Type 属性 delete requestHeaders[key]; &#125; else &#123; request.setRequestHeader(key, val); &#125; &#125;); &#125; // 添加 withCredentials 属性 if (config.withCredentials) &#123; request.withCredentials = true; &#125; // 添加 request.responseType // 需要确保服务器所返回的类型和所设置的返回值类型是兼容的。 // 如果两者类型不兼容，服务器返回的数据变成了null，即使服务器返回了数据。 if (config.responseType) &#123; try &#123; request.responseType = config.responseType; &#125; catch (e) &#123; if (config.responseType !== 'json') &#123; throw e; &#125; &#125; &#125; // Handle progress if needed if (typeof config.onDownloadProgress === 'function') &#123; request.addEventListener('progress', config.onDownloadProgress); &#125; // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' &amp;&amp; request.upload) &#123; request.upload.addEventListener('progress', config.onUploadProgress); &#125; // 处理 cancelToken，后面会单独介绍 if (config.cancelToken) &#123; // 也是一个 Promise 对象 config.cancelToken.promise.then(function onCanceled(cancel) &#123; // 如果 cancel 时 request 已经完成，那就返回 if (!request) &#123; return; &#125; // 使用了 abort 事件 request.abort(); reject(cancel); request = null; &#125;); &#125; // 根据标准，如果是 GET 或者 HEAD 请求，应将请求主体设置为 null if (requestData === undefined) &#123; requestData = null; &#125; // 发送请求 request.send(requestData); &#125;);&#125;; xhrAdapter的XHR发送请求成功后会执行Promise对象的resolve方法，将请求的数据传递出去，如果请求失败（超时、网络出错、终止）则执行reject方法，并将自定义的错误信息传递出去。 SettlexhrAdapter中将改变Promise状态的功能抽离成为单独的settle方法 12345678910111213141516171819// settle.jsmodule.exports = function settle(resolve, reject, response) &#123; // 获得配置的 validateStatus 方法 var validateStatus = response.config.validateStatus; // 如果不存在 validateStatus 或者验证通过，resolve if (!validateStatus || validateStatus(response.status)) &#123; resolve(response); &#125; else &#123; reject(createError( 'Request failed with status code ' + response.status, response.config, null, response.request, response )); &#125;&#125;; validateStatus接受response.stastus作为参数，对于给定的HTTP状态码确定其成功失败状态，比如： 123validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的&#125; 数据转换器前面也提到了数据转换器，可以对请求对象和响应和数据进行转换，可以全局使用： 1234567891011// 往现有的请求转换器里增加转换方法axios.defaults.transformRequest.push((data, headers) =&gt; &#123; // ...处理data return data;&#125;);// 往现有的响应转换器里增加转换方法axios.defaults.transformResponse.push((data, headers) =&gt; &#123; // ...处理data return data;&#125;); 也可以在单次请求中使用： 123456789101112131415161718// 往已经存在的转换器里增加转换方法axios.get(url, &#123; // ... transformRequest: [ ...axios.defaults.transformRequest, // 去掉这行代码就等于重写请求转换器了 (data, headers) =&gt; &#123; // ...处理data return data; &#125; ], transformResponse: [ ...axios.defaults.transformResponse, // 去掉这行代码就等于重写响应转换器了 (data, headers) =&gt; &#123; // ...处理data return data; &#125; ],&#125;) 在defaults配置项中已经默认自定义了一个请求转换器和响应转换器 1234567891011121314151617181920212223242526272829303132333435// 请求转换器transformRequest: [ function transformRequest(data, headers) &#123; normalizeHeaderName(headers, 'Accept'); normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) &#123; return data; &#125; if (utils.isArrayBufferView(data)) &#123; return data.buffer; &#125; if (utils.isURLSearchParams(data)) &#123; setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); &#125; if (utils.isObject(data)) &#123; setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); &#125; return data; &#125;],// 响应转换器transformResponse: [ function transformResponse(data) &#123; /*eslint no-param-reassign:0*/ if (typeof data === 'string') &#123; try &#123; data = JSON.parse(data); &#125; catch (e) &#123; /* Ignore */ &#125; &#125; return data; &#125;], 默认的请求转换器对请求数据和请求头进行标准化处理，默认的响应转换器用来自动将字符串解析为JSON对象。 使用的时候是通过transformData这个方法，对数组中的转换器进行遍历： 123456789// transformData.jsmodule.exports = function transformData(data, headers, fns) &#123; /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) &#123; data = fn(data, headers); &#125;); return data;&#125;; 转换器和拦截器都可以对请求和响应的数据进行拦截处理，但是一般情况下，拦截器主要负责拦截修改config配置项，数据转换器主要用来负责拦截转换请求主体和响应数据。 CancelAxios提供了取消请求的功能，有两种使用方法： 12345678910111213141516// 第一种取消方法axios.get(url, &#123; cancelToken: new axios.CancelToken(cancel =&gt; &#123; if (/* 取消条件 */) &#123; cancel('取消日志'); &#125; &#125;)&#125;);// 第二种取消方法const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(url, &#123; cancelToken: source.token&#125;);source.cancel('取消日志'); Axios用了三个模块来实现这个功能，首先是Cancel这个类： 123456789101112// ./cancel/Cancel.jsfunction Cancel(message) &#123; this.message = message;&#125;Cancel.prototype.toString = function toString() &#123; return 'Cancel' + (this.message ? ': ' + this.message : '');&#125;;Cancel.prototype.__CANCEL__ = true;module.exports = Cancel; 主要是定义了Cancel的message实例属性，和原型上的内部用的__CANCEL__属性，还定义了一个toString方法 isCancel返回布尔值，根据是否传入了value以及是否有__CANCEL__属性，判断是否是Cancel实例 核心的代码在CancelToken.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ./cancel/CancelToken.jsfunction CancelToken(executor) &#123; // executor 必须是函数 if (typeof executor !== 'function') &#123; throw new TypeError('executor must be a function.'); &#125; // 通过闭包，将 this.promise 的控制权导出到 resolvePromise 变量上，此时 promise 状态为 pending var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); // 传入一个函数作为 executor 的参数，将 promise 状态的控制权导出到 executor 函数中 // 当 executor 的参数执行时，为 this.reason 赋值，并且改变 this.promise 状态为 resolve var token = this; executor(function cancel(message) &#123; if (token.reason) &#123; // Cancellation has already been requested return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason); &#125;);&#125;// 由于 this.reason 是在 exxcutor 的方法执行后才赋值的，所以据此判断是否已经执行了取消操作// 如果已经执行取消操作，则抛出 this.reasonCancelToken.prototype.throwIfRequested = function throwIfRequested() &#123; if (this.reason) &#123; throw this.reason; &#125;&#125;;// 对应第二种使用方法，相当于默认构建了一个 executor 函数// 导出 token 传入 config，导出 cancel 函数来执行取消操作CancelToken.source = function source() &#123; var cancel; var token = new CancelToken(function executor(c) &#123; cancel = c; &#125;); return &#123; token: token, cancel: cancel &#125;;&#125;; 总结阅读Axios的过程，还是学到了很多东西： Promise的串联操作 拦截器的添加和执行原理 将Promise的控制权导出，让外界决定Promise的状态 还有很繁琐也很重要的一部分没有涉及，就是针对HTTP请求的标准化处理，比如Heder的处理等，这也是大大方便开发者的功能之一，我们不用再担心这些细节的处理，只需要关注核心逻辑的实现。这也是优秀的组件和库的标准之一，暴露出简单、直接的接口让使用者调用，复杂、琐碎的逻辑隐藏在内部。 参考 Axios源码深度剖析 - AJAX新王者@知乎 Axios中文说明@看云 XMLHttpRequest@MDN XMLHttpRequest@whatwg XMLHttpRequest.timeout@MDN XMLHttpRequest.setRequestHeader()@MDN XMLHttpRequest: error 事件@MDN XMLHttpRequest.abort()@MDN XMLHttpRequest.getAllResponseHeaders()@MDN XMLHttpRequest.send()@MDN]]></content>
      <categories>
        <category>源码学习</category>
      </categories>
      <tags>
        <tag>Axios</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习56 表格行数据多级合并]]></title>
    <url>%2F2019%2F07%2F31%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A056%20%E8%A1%A8%E6%A0%BC%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%9A%E7%BA%A7%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[用Vue实现表格行数据的多级合并 题目一个简单的小需求，要实现一个表格 如果表格两行的内容相同，则进行合并，实现的效果如下： 分析表格的行数据合并关键是rowspan属性，想要实现合并，我的思路是，如果两行的数据相同，前一行的rowspan则+1，当前行的数据添加一个hidden属性设置true 这个思路需要两层的循环，外层遍历列，内层遍历行 首先设定一个基准值startRowIndex，取startRowIndex对应的数据与当前遍历行的数据进行比对，如果相同则基准数据的rowspan属性+1，当前行的数据的hidden设置为ture，如果不相同则将基准值startRowIndex设为当前行的序号设置 还有一点是，当外层遍历到第二列及以后时的数据时，是否合并不能光依据上面的逻辑，还要添加一个判断条件，那就是它左侧的数据是否是相同的，比如下面图中的两个宜宾市，分属于四川1和四川，那就不能合并（虽然省份的表格不会出现，但是其他类型的表格也许会有这种情况） 所以用一个单独的函数来判断左侧的列的数据是否相同，如果全都相同才能合并，否则就不行 代码我使用Vue实现的，所以给数据添加了key属性，做了一些额外的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;template&gt; &lt;div&gt; &lt;h1&gt;demo11&lt;/h1&gt; &lt;table class="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th v-for="head in tableHead" :key="head"&gt;&#123;&#123;head&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in tableData" :key="item.key"&gt; &lt;td v-for="data in item.data" :key="data.value" :rowspan="data.rowspan" v-if="!data.hidden"&gt;&#123;&#123;data.value&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'demo36', props: [], data() &#123; return &#123; tableHead: ['省份', '市', '区'], tableBody: [ ['四川', '成都市', '温江区'], ['四川', '宜宾市', '全部市区'], ['四川', '宜宾市', '全部市区2'], ['四川1', '宜宾市', '全部市区3'], ['四川2', '宜宾市', '全部市区4'], ['四川2', '宜宾市4', '全部市区4'], ], &#125; &#125;, methods: &#123; // 合并表格数据 // 将二维数组转换为二维对象数组，如果表格一列的内容相同，则为相同内容的首行添加 rowspan 属性，相同内容的当前行添加 hidden 属性 // 两层遍历，外层遍历列（省份 → 市 → 区），内层遍历行 handleTableData(tableBody, tableHead) &#123; // 判断左侧列的数据是否相同，全部相同返回 true，否则返回 false function prevSame(result, i, j, startRowIndex) &#123; while (j &gt;= 1) &#123; if (result[i][j - 1].value === result[startRowIndex][j - 1].value) &#123; j--; &#125; else &#123; return false &#125; &#125; return true &#125; // 将数组转换为 [[&#123;value: '四川'&#125;] 这种形式 let result = tableBody.map(v =&gt; [...v.map(val =&gt; (&#123; value: val &#125;))]); // 相同内容的起始行的序列 let startRowIndex = 0; // 外层遍历列 for (let j = 0; j &lt; tableHead.length; j++) &#123; // 内层遍历行 for (let i = 0; i &lt; result.length; i++) &#123; // 起始行的表格内容 let rowSpanName = result[startRowIndex][j].value; // 当前行的表格内容 const value = result[i][j].value; // 如果内容相同并且不是首行 if (rowSpanName === value &amp;&amp; i &gt; 0) &#123; // 如果不是第一列，则只有在前面所有列内容相同的情况下才会合并 if (!result[i][j - 1] || prevSame(result, i, j, startRowIndex)) &#123; // 取起始行的 rowspan 属性 let &#123; rowspan &#125; = result[startRowIndex][j]; // 取起始行的 rowspan 属性如果有初值则 +1， 如果没有的话初值赋予 2 result[startRowIndex][j].rowspan = rowspan ? rowspan + 1 : 2; // 当前行表格隐藏 result[i][j].hidden = true; &#125; else &#123; // 如果不相同则重置其实行 startRowIndex = i &#125; &#125; else &#123; // 如果不相同则重置其实行 startRowIndex = i &#125; &#125; &#125; // 返回值放到 data 属性中，并且将后两项的值合并作为列表循环时的 key 值 return result.map(v =&gt; (&#123; data: v, key: v.map(v =&gt; v.value).join('') &#125;)); &#125; &#125;, computed: &#123; tableData() &#123; return this.handleTableData(this.tableBody, this.tableHead) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; h2 &#123; margin: 20px 0 &#125; table, th, td &#123; border: 1px solid black; border-collapse: collapse; &#125; th, td &#123; padding: 10px; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高01 SetState的执行时机]]></title>
    <url>%2F2019%2F07%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9801%20SetState%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[React的setState并不保证是同步执行的，但是也不一定就是异步执行的，准确的说是利用了队列来模拟异步执行，并没有用到任务的异步API。这篇文章分析了setState的执行机制，帮助我理解setState的执行时机有很大帮助。 执行时机先放下结论： setState的实现并没有涉及到任何的异步API 真正更新组件state的是flushBatchedUpdates函数，而setState不一定会调用这个函数，有可能多次setState调用一次这个函数 setState会不会立刻更新state取决于调用setState时是不是已经处于批量更新事务中。 组件的生命周期函数和绑定的事件回调函数都是在批量更新事务中执行的。 延迟调用在componentDidMount生命周期中执行setState： 123456789101112131415161718192021export default class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第一次 &apos;, this.state.val); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.val&#125; &lt;/div&gt; ); &#125;&#125; 执行的结果是什么？ 控制台会打印第一次 0，页面上显示1。这是因为componentDidMount生命周期是批量更新事务，在批量更新事务中调用setState不会立即执行，而是放到队列中等待批量更新事务结束后统一执行。 所以生命周期中打印出来的是0，而render中上一个生命周期的更新已经结束，所以页面显示1 同理，在两个顺序的生命周期中调用setState，第二个生命周期的state就是已经更新过的state： 123456789101112131415161718192021222324252627export default class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; val: 0 &#125;; &#125; componentWillMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第一次 &apos;, this.state.val); &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第二次 &apos;, this.state.val); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.val&#125; &lt;/div&gt; ); &#125;&#125; 结果： 1234第一次 0第二次 1// 页面 2 立刻调用如果要在同一个批量更新事务中立刻获得更新后的state，就要将相关操作放到setState的回调函数中： 12345678910111213141516171819202122export default class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;, () =&gt; &#123; console.log(&apos;第一次 &apos;, this.state.val); &#125;); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.val&#125; &lt;/div&gt; ); &#125;&#125; 结果： 123第一次 1// 页面 1 例子看一个更复杂一些的例子： 1234567891011121314151617181920212223242526272829303132333435export default class Index extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第一次 &apos;, this.state.val); this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第二次 &apos;, this.state.val); setTimeout(() =&gt; &#123; console.log(&apos;第三次 &apos;, this.state.val); this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第四次 &apos;, this.state.val); this.setState(&#123; val: this.state.val + 1 &#125;); console.log(&apos;第五次 &apos;, this.state.val); &#125;, 0); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.val&#125; &lt;/div&gt; ); &#125;&#125; 执行的结果： 1234567第一次 0第二次 0第三次 1第四次 2第五次 3// 页面 3 为什么前两次的结果都是0呢？因为前面提过了，生命周期是批量更新事务，setState会在更新事务结束后统一执行，所以打印的都是0 这两次更新后state的结果是1，并非是2，因为这两次调用时this.state.val都是0，相当于执行this.setState({ val: 1 })两次，所以第三次打印的结果是1 而setTimeout是异步任务，setState并非在批量更新事务中，setState会立即执行。所以后两次的console.log结果可以立刻获取到更新后的state 详细的源码解读放到以后慢慢看吧。 参考 你真的了解 setState 吗？@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程02 创建自己的脚手架工具]]></title>
    <url>%2F2019%2F07%2F17%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B02%20%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前一阵子用Egg做了一个Node服务端项目的重构，发现Egg相比于Koa和Express来说，感觉更适合于现阶段团队的Node开发，因为现在团队Node的代码根本没有任何规范和约定，乱的一坨，所以引入了Node，遵循它的规范，使用它预置的功能，对代码的可维护性提升还是比较大的。 开发完成后，在Egg的基础上增加了一点中间件，配置了一些插件和代码风格控制的配置，将这个模板抽离出来作为团队以后开发Node服务的基准模板，放在了Gitlab上。 原来的时候方法都是直接Clone这个项目，再去更改Git的相关信息等等，不是很方便。所以想试着做一个类似于简易的Vue-Cli这样的工具，能够直接拉取模板，并且直接生成对应的目录，配置一些简单的信息。 因为要实现的脚手架工具比较简单，没有那么多的配置，实现起来还是比较简单的。下面分几个部分记录自己学习的过程。 前言前一阵子用Egg做了一个Node服务端项目的重构，发现Egg相比于Koa和Express来说，感觉更适合于现阶段团队的Node开发，因为现在团队Node的代码根本没有任何规范和约定，乱的一坨，所以引入了Node，遵循它的规范，使用它预置的功能，对代码的可维护性提升还是比较大的。 开发完成后，在Egg的基础上增加了一点中间件，配置了一些插件和代码风格控制的配置，将这个模板抽离出来作为团队以后开发Node服务的基准模板，放在了Gitlab上。 原来的时候方法都是直接Clone这个项目，再去更改Git的相关信息等等，不是很方便。所以想试着做一个类似于简易的Vue-Cli这样的工具，能够直接拉取模板，并且直接生成对应的目录，配置一些简单的信息。 因为要实现的脚手架工具比较简单，没有那么多的配置，实现起来还是比较简单的。下面分几个部分记录自己学习的过程。 控制台交互使用Cli工具，必定要在控制台输入、输出一些相关的信息，可以使用Commander这个包，它可以接受并解析在控制台输入的参数process.argv，它基本的使用方法如下： 123program.version('0.1.0') .option('-i, init [name]', '初始化Egg项目') .parse(process.argv); 通过上面的配置，我们就可以通过program.init拿到用户在控制台输入init a时跟在init后面的输入a，我们将a作为模板的目录名 然后在开始拉取模板之前，我们需要有一个Loading的提示，会更加友好，可以使用ora这个包，它用来在终端展示loading的图标。我们这里使用的也很简单，开始时展示图标和提示语： 1const spinner = ora('正在拉取Create-Egg-App模板...').start(); 拉取成功或者失败后展示对应的图标和文字： 12345// 成功spinner.succeed('拉取成功');// 失败spinner.fail('拉取失败'); 提示的文字我们还希望能带一些颜色，比如成功我们希望是绿色，失败时红色，这样会更加美观，我们就可以使用chalk这个包，它可以用来在终端中展示各种颜色： 1234567const chalk = require('chalk');const success = chalk.blueBright;const error = chalk.bold.red;spinner.succeed(success('拉取成功'));console.error(error('请在init后输入目录名')); 准备工作都就绪了，就差最关键的一步了，就是拉取模板了。 拉取模板拉取模板我们也可以借助第三方的包来实现，要使用的就是download-git-repo这个包了，它可以帮助我们模板代码从各种仓库中拉取下来，它既可以通过SSH协议拉取Github的代码： 12github:owner/name owner/name 也可以直接通过HTTPS拉取代码： 1direct:url 它接受四个参数： 1dowanload(url, pathName, opts, callback) 详细的配置还是参考它的文档吧。整个拉取代码的逻辑就基本完成了 1234567891011121314if (program.init &amp;&amp; typeof program.init === "string") &#123; const spinner = ora('正在拉取Create-Egg-App模板...').start(); download(templateUrl, program.init, &#123; clone: true &#125;, function (err) &#123; if (!err) &#123; spinner.succeed(success('拉取成功')); // 更改 package.json 中的 name 和版本号 changePackage() &#125; else &#123; spinner.fail('拉取成功'); &#125; &#125;);&#125; else &#123; console.error(error('请在init后输入目录名'));&#125; 优化还有一点优化在changePackage这个函数中完成了，这个函数会将模板中的package.json的name和version，这个功能使用了原生的Node来实现 123456789101112const changePackage = () =&gt; &#123; fs.readFile(`$&#123;process.cwd()&#125;/$&#123;program.init&#125;/package.json`, (err, data) =&gt; &#123; if (err) throw err; let _data = JSON.parse(data.toString()); _data.name = program.init; _data.version = '1.0.0'; let str = JSON.stringify(_data, null, 4); fs.writeFile(`$&#123;process.cwd()&#125;/$&#123;program.init&#125;/package.json`, str, function (err) &#123; if (err) throw err; &#125;) &#125;);&#125;; 这段代码基本是Copy第一篇参考文章的，自己的Node并不灵，把这个段代码学习一下。 首先通过fs.readFile来读取package.json文件，查找文件路径时使用了process.cwd，它表示当前执行Node命令时的文件夹路径名 Node中海油几个获取路径的方法，可以来看一下： 1234__dirname： 获得当前执行文件所在目录的完整目录名__filename： 获得当前执行文件的带有完整绝对路径的文件名process.cwd()：获得当前执行node命令时候的文件夹目录名./： 不使用require时候与process.cwd()一样，使用require时候与__dirname一样 我们这里使用的是process.cwd()，就是在执行当前的Node命令时的目录下，因为通过program.init新建的目录是在执行Node命令的目录下 因为package.json文件时JSON格式的，所以可以首先通过data.toString将二进制文件转换为字符串，然后通过JSON.parse()进行解析。 解析完成后修改相关字段，修改完成后再通过JSON.stringify转换为字符串，它额外接受了两个参数，第二个参数用来在序列化过程中替换序列化的内容，第三个参数用来指定缩进空白字符串。 序列化完成后，再将内容通过writeFile写会原来的package.json文件。 使用使用时为了避免全局安装，使用npx来拉取模板是很好的解决防范。具体使用时分为两种情况，一种是模板在内网的Gitlab上，一种是模板在公网的Github上。 先来看在Github上，模板的地址是https://github.com/duola8789/create-egg-app-zh，我们先在NPM上注册账户，并通过npm login登陆，然后将egg-cli-zh发布到NPM上。 1NPM publish 发布成功后，就可以直接使用npx拉取模板了： 1npx egg-cli-zh init [project_name] 但是如果模板在内网的Gitlab上，egg-cli-zh也不能发布到NPM上，那就使用ssh+git来使用即可： 1npx git+ssh://git@gitlab/xxx/template.git init [project_name] 至此，一个简易的脚手架工具就完成了。Egg-Cli-zh脚手架的源代码在这里，Create-Egg-App-zh的源码在这里。 参考 搭建自己的脚手架—“优雅”生成前端工程@掘金 download-git-repo@NPM chalk@NPM Commander@NPM ora@NPM Node.js的dirname，filename，process.cwd()，./的一些坑 #18@Github JSON.stringify()@MDN]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习55 图片对比效果]]></title>
    <url>%2F2019%2F07%2F11%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A055%20%E5%9B%BE%E7%89%87%E5%AF%B9%E6%AF%94%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[今天在整理收藏夹时，发现有一个很不错的网站picdiet，可以用来压缩图片，效果很不错。 不过今天的练习不是关于图片压缩，而是它的官方的一个用来对比压缩前后图片的效果的组 题目今天在整理收藏夹时，发现有一个很不错的网站picdiet，可以用来压缩图片，效果很不错。 不过今天的练习不是关于图片压缩，而是它的官方的一个用来对比压缩前后图片的效果的组件，效果如下： 试着在Vue中实现这个效果 分析分几个模块来实现。在搭起架子后，首先实现中间的分割线，样式不难，两边的小三角也可以用border模拟实现 1234567891011121314151617181920212223242526272829.separator &#123; position: absolute; top: 0; left: 200px; width: 4px; height: 100%; background: darkgray; z-index: 3;&#125;.separator:before, .separator:after &#123; content: ''; display: block; position: absolute; top: 50%; width: 0; height: 0; border: 10px solid transparent;&#125;.separator:before &#123; right: 10px; border-right-color: darkgray;&#125;.separator:after &#123; left: 10px; border-left-color: darkgray;&#125; 然后需要实现随着鼠标的移动，分割线的位置也跟着移动，Vue的模板中可以直接设定它的left属性值即可： 1&lt;div class="separator" :style="&#123; 'left': separatorX + 'px' &#125;"&gt;&lt;/div&gt; 计算separatorX的时候，用到了两个方法，第一个是getBoundingClientRect，它返回了六个属性，分别是元素的宽度高度以及距离适口左上角的各边距离。这个宽度与offsetWidth相同，等于width + bodrer + content，计算left等时是从border出发： 另外在给外围组件绑定mousemove事件的时候，需要获取鼠标的坐标，计算方式如下： 如果能确保页面没有横向的滚动条时，可以直接使用e.clientX来获取鼠标的坐标值，e.clientX获取的是相对于浏览器窗口的坐标值，与滚动条区域的位置尺寸无关： 1234567891011121314151617181920mounted() &#123; const &#123;left, width &#125; = this.$refs.imgContainer.getBoundingClientRect(); this.containerX = left; this.containerWidth = width;&#125;,methods: &#123; mouseMove(e) &#123; const min = 0, max = this.containerWidth - this.separatorWidth; // 当前坐标值 const result = e.clientX - this.containerX; if (result &lt;= max &amp;&amp; result &gt;= min) &#123; this.separatorX = result &#125; else if (result &lt; min) &#123; this.separatorX = min &#125; else &#123; this.separatorX = max &#125; &#125;&#125;, 但是如果出现横向滚动条时，就需要考虑window.scrollX，并且获取鼠标使用e.pageX，它会将滚动区域的尺寸计算在内。并且由于滚动条移动时，getBoundingClientRect结果页在发生变化，所以还需要判断是否移动了滚动条，优化之后如下： 12345678910111213141516171819202122232425262728293031mounted() &#123; this.getBoundingClientRect()&#125;,methods: &#123; getBoundingClientRect() &#123; const &#123; left, width &#125; = this.$refs.imgContainer.getBoundingClientRect(); this.containerX = left; this.containerWidth = width; this.scrollX = window.scrollX &#125;, mouseMove(e) &#123; // 如果移动了滚动条，则重新计算距离 if (this.scrollX !== window.scrollX) &#123; this.getBoundingClientRect(); &#125; const min = 0, max = this.containerWidth - this.separatorWidth; // 当前坐标值 const result = e.pageX - this.containerX - window.scrollX; if (result &lt;= max &amp;&amp; result &gt;= min) &#123; this.separatorX = result &#125; else if (result &lt; min) &#123; this.separatorX = min &#125; else &#123; this.separatorX = max &#125; &#125;&#125;, 剩下的部分，通过重叠两个图片的容器 12&lt;div class="origin-image" :style="&#123; 'width': originWidth + 'px'&#125;"&gt;&lt;/div&gt;&lt;div class="handled-image" :style="&#123; 'width': handledWidth + 'px'&#125;"&gt;&lt;/div&gt; 通过separatorX分别计算两个容器的宽度： 12345678computed: &#123; originWidth() &#123; return this.separatorX &#125;, handledWidth() &#123; return this.containerWidth - this.originWidth - this.separatorWidth &#125;&#125; 最后实现的效果将它的官网没考虑到的滚动条的情况也处理了（虽然这种情况非常少见）。将这个demo替换成为了一个插件的形式，便于复用，完整的代码在这里。 参考 picdiet Element.getBoundingClientRect()@MDN JS04 JS中元素的宽度、高度和位置@CSDB]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS34 1px边框问题的解决方案]]></title>
    <url>%2F2019%2F07%2F11%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS34%201px%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1px边框问题的解决方案的总结 现象及原因在移动端开发时，设计图中的1px的边框，如果我们直接在CSS中设置边框的宽度为1px，实际上在设备上显示的并不是1px。这是因为不同的手机有着不同的像素密度，即window.devicePixelRatio属性，它反应的是物理像素与逻辑像素的比值，IPhone6的dpr是2，也就是说，对于IPhone6来说，CSS的1px显示时会显示为2px的像素 当设置为1px的边框时，移动端的显示： 当设置为0.5px的边框时，移动端的显示： PC端1px的边框： 很明显看出，移动端1px的边框更粗 媒体查询要想解决这个问题，必须针对不同dpr的设备进行不同的处理，完全不必使用JavaScript，而是可以通过媒体查询实现 1234567@media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2)&#123; /* 2倍屏 */&#125;@media screen and (min-device-pixel-ratio: 3), (-webkit-min-device-pixel-ratio: 3)&#123; /* 3倍屏 */&#125; 下面的各种处理方法，都是通过媒体查询进行分类处理，只列出2倍屏的处理方法，都省略了媒体查询的代码 解决方法1：伪元素 + tranform: scaleY这种方法是比较常用，兼容性也比较好的，利用高度为1px的伪元素来模拟边框，在媒体查询中利用tranform: scaleY来进行缩放，需要设置transform: origin(0, 0)保证缩放时伪元素距离父元素的距离 12345678910111213141516171819202122h1 &#123; position: relative;&#125;h1:after &#123; content: ''; display: block; width: 100%; height: 1px; position: absolute; left: 0; bottom: 0; background: red; transform: scaleY(1); transform-origin: 0 0;&#125;@media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) &#123; h1:after &#123; transform: scaleY(0.5); &#125;&#125; 优点：兼容性好，边框圆角也可以实现 缺点：代码量比较大，占据了伪元素，会引起冲突 解决方法2：0.5px边框直接将border设置为0.5px 123.h1 &#123; border-bottom: 0.5px solid #000&#125; 优点：简单直接 缺点：兼容性太差，安卓和低版本的IOS都不支持 解决方法3：伪元素 + liner-gradient + sacle同样是利用伪元素实现，但是使用了liner-gradient来模拟边框，实际上和第一种方法思路是相同的 123456789101112h1:after &#123; display: block; content: ''; height: 1px; background: linear-gradient(0, #fff, #000);&#125;@media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) &#123; h1:after &#123; transform: scaleY(0.5); &#125;&#125; 解决方法4：通过viewport实现可以使用JavaScript来读取window.devicePixelRatio，根据读取到的值来对&lt;meat&gt;的viewport进行改写，当dpr为2时，将页面缩放到原来的一半 12345678910111213const dpr = window.devicePixelRatio;// 创建meta视口标签const meta = document.createElement('meta') // 设置name为viewportmeta.setAttribute('name', 'viewport');// 动态初始缩放、最大缩放、最小缩放比例meta.setAttribute( 'content', `width=device-width, user-scalable=no, initial-scale=$&#123;1/dpr&#125;, maximum-scale=$&#123;1/dpr&#125;, minimum-scale=$&#123;1/dpr&#125;`) 这样做可以直接使用px来定义各处的尺寸，但是就不单单针对边框了，而是针对所有了，需要整体考虑 解决方法4：通过图片模拟可以使用border-image 或者background-image来加载预先设置好的边框图片 这种方法并不是很理想，因为修改颜色的时候都需要替换图片，并且如果边框有圆角的话也需要对图片特殊处理。 总结从兼容性、针对性以及可维护性，还是使用伪元素 + tranform: scaleY的第一种方法最为推荐，其他的方法要不是很麻烦，要不是原理相同。有一些文章介绍了七八种，有的能实现，但是实施起来很麻烦，有的根本就不能实现在移动端实现1px，也不知道是我水平太低，还是作者根本没有亲自试验。 参考 1px边框解决方案总结@掘金 7 种方法解决移动端 Retina 屏幕 1px 边框问题@掘金 移动端1px实现@知乎]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>border</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解04 继承的总结]]></title>
    <url>%2F2019%2F07%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A304%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[继承相关知识还是有点乱，来总结一下。 本质上，JS里面的继承都是通过原型链实现的（除了实例属性之外），原型链继承的关键就是对象的__proto__属性，它应该指向另外一个对象的prototype 构造函数的继承ES5里面最常用的继承方法是以下两种： 在子类内部执行父类（call/apply改变this），继承实例属性 子类的prototype等于父类的一个实例(new 父类)，继承实例属性和原型属性 ES6里面使用class和extends实现的继承 下面具体来看（下面提到的属性，除非特殊说明，都是泛指属性和方法） 继承实例属性在子类的内部让父类调用call或者apply的方法，这样只能继承父类的实例属性，不能继承原型上的属性。 123function Child() &#123; Father.call(this)&#125; 继承原型属性（1）直接让子类的原型等于父类的原型： 12Child.prototype = Father.prototype;Child.prototype.constructor = Child; （2）利用Object.setPrototypeOf方法 使用Object.setPrototypeOf方法来让指定Child.prototype.__proto__等于Father.prototype，实现了原型属性的继承（相当于new过程的一部分） 1Object.setPrototypeOf(Child.prototype, Father.prototype); （3）利用中间函数 第三种种方法是对第一种方法的改进，避免子类的原型更改影响到父类的原型，利用了一个中间函数： 1234const Temp = function()&#123;&#125;;Temp.prototype = Father.prototype;Child.prototype = new Temp()Child.prototype.constructor = Child; （4）通过父类的原型对象进行遍历、拷贝，从而实现继承： 123for (const i in Parent.prototype) &#123; Child.prototype[i] = Parent.prototype[i]&#125; 同时继承实例属性和原型属性（1）让子对象的原型成为父对象的实例： 12Child.prototype = new Father();Child.prototype.constructor = Child; （2）通过ES6中的方法class和extends实现继承： 12345678class Father &#123;&#125;class Child extends Father &#123; constructor() &#123; super(); &#125;&#125; 要注意的是，class只能在原型链上定义方法，所以也只能继承原型方法，而不能继承原型属性。 非构造函数的继承让一个对象去继承一个不相关对象，由于这两个对象都是普通对象，不是构造函数，所以无法使用构造函数方法实现继承。 通过Object.create实现Object.create方法是直接通过原型，而非模拟类，来实现普通对象（非构造函数）之间的继承 1const child = Object.create(father, [childDescriptors]) 实际上实现的是child.__proto__ === father 通过Object.setPrototypeOf实现Object.setPrototypeOf和Object.create都是更改原型链（设置__proto__属性）的手段，Object.getPrototypeOf(a)是用来获取对象的__proto__属性 1Object.setPrototypeOf(child, father) 这个方法实现的也是child.__proto__ === father 通过object函数可以自己编写一个函数，实现上面Object.setPrototypeOf()和Object.create()的（部分）功能 12345function object(parent) &#123; function Child() &#123;&#125; Child.prototype = parent; return new Child(); &#125; 实际上，可以将这个方法看做Object.create()的简易的polyfill。 通过拷贝实现可以父对象进行遍历、拷贝实现 浅拷贝： 12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c; &#125; 深拷贝： 1234567891011121314151617181920212223function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; const type = Object.prototype.toString.call(p[i]).match(/\s(.+)\]/)[1].toLowerCase(); switch (type) &#123; case 'array': &#123; c[i] = []; deepCopy(p[i], c[i]); break; &#125; case 'object': &#123; c[i] = &#123;&#125;; deepCopy(p[i], c[i]); break; &#125; default: &#123; c[i] = p[i]; break; &#125; &#125; &#125; return c;&#125; 关于深拷贝、浅拷贝可以参考以前写过的笔记《JS05 JS中的拷贝》 ES6中的继承ES6里面使用class和extends实现的继承，实际上是ES5中的继承方法的语法糖，它可以实现实例属性、原型方法、静态属性的继承 类的实例属性是通过class内部的constructor里的super实现的 类的原型方法是通过Object.setPrototypeOf(Child.prototype, Father.prototype)实现的（ 类的静态属性是通过Object.setPrototypeOf(Child, Father)实现的 使用ES6的继承方法，与ES5中的继承方法相比，不同点主要有以下下几点： （1）实现的顺序 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。 ES6的继承机制完全不同，子类一开始并没有自己的this，而是需要先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 （2）静态方法和静态属性 ES6的继承方法可以继承父类的静态方法和静态属性，这一点是ES5的继承方法做不到的。 （3）无法继承原型属性，只能继承原型方法 由于在class内部定义在constructor之外的方法实际上都是原型方法，并不能定义原型属性，所以继承的自然也只能是原型方法，而无法继承原型属性 （4）原型方法的可枚举性 由于class内部定义的方法都是不可枚举的，这一点与ES5的行为是不一致的 （5）变量提示 ES5的类是通过函数实现的，存在变量提升；而class不存在变量提升 new的过程在通过构造函数实例化一个对象（new）的过程中 1let p = new Person() 发生了以下的过程： 1234567891011// 1 新建一个对象let p = &#123;&#125;;// 2 修改p的__proto__属性，实现原型链的继承p.__proto__ === Person.protype// 3 将Person的作用域改为p，也就是说让Person中的this指向p，为p添加实例属性Person.call(p)// 4 返回preturn p new运算的返回值默认返回this，但显式的返回值时，如果返回值的是基本类型，则忽略返回值，仍然返回this，如果返回值是引用类型，则直接返回该返回值作为对象的结果]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题34 JavaScript的垃圾回收机制]]></title>
    <url>%2F2019%2F07%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9834%20JavaScript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JavaScript的垃圾回收机制学习笔记。 手动回收？JavaScript在创建变量时自动进行了内存分配，并且在不使用时自动释放。释放的过程叫做垃圾回收。 JavaScript没有暴露任何垃圾回收期的接口，其内存管理是自动执行且不可见的，所以开发者没有办法手动进行强制的垃圾回收，也没有办法干预内存管理。 在多数情况下，开发者也没有必要手动解除对象的引用，只要简单地把变量放在他们应该的地方（局部变量），垃圾就能正确被回收 V8的内存分配当声明变量并赋值时，V8就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量，V8就会继续申请，直到堆的大小到了V8的内存上限为止。 堆内存分为两种分配方式： 静态分配，全局变量、函数之类的分配方式，它们在页面没有关闭之前，是不会被清除的 动态分配，使用new创建出来的，主动要求给分配空间的 可达性JavaScript中内存管理关键的一个概念是可达性，一个变量的“可达性”值得就是它能够被以某种方式访问到或者引用到，被保证存储到内存中。JavaScript引擎中有一个名为“垃圾回收器”的进程，它监视所有对象，并删除不可访问的对象。 一些常见的具有可达性，会常驻内存的情况： （1）全局变量，全局变量会常驻内存，除非刷新页面、离开页面时才会被清理 （2）对象引用 1234567function ob()&#123; var bar = new largeObject(); // 很大一个对象\变量\字符串 bar.someCall(); return bar;&#125;var a = new ob(); 现在有一个指向bar对象的引用，当ob调用结束后，bar对象不会被回收，直到变量a分配其他引用（或者a超出了作用域范围）。 （3）DOM事件，即使DOM元素被移除，其绑定的事件不会被回收，除非使用removeEventListener显式的移除事件 （4）定时器，除非显式的清楚定时器 例子假设定义了这样一个变量： 123let user = &#123; name: 'John'&#125; user这个变量引用了一个对象{name: &#39;John&#39;}： 如果将user的值覆盖user = null，则引用丢失，{name: &#39;John&#39;}会被垃圾回收器清除，分配的内存被回收。 如果不将user的值覆盖，而是把user复制给另一个变量admin： 1let admin = user 这是两个变量都引用了同一个对象{name: &#39;John&#39;}： 这个时候再将user的值覆盖user = null，虽然user不再引用{name: &#39;John&#39;}，但是admin仍然与{name: &#39;John&#39;}保持引用关系，所以{name: &#39;John&#39;}不会被垃圾回收器清除，分配的内存也不会被回收。 复杂些的例子函数marry通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象 123456789101112131415function marry (man, woman) &#123; woman.husban = man; man.wife = woman; return &#123; father: man, mother: woman &#125;&#125;let family = marry(&#123; name: "John"&#125;, &#123; name: "Ann"&#125;) 产生的内存结构: 现在如果想要清除{name: John}这个变量，必须要同时删除外界对它的所有引用： 12delete family.father;delete family.mother.husband; 它对外的引用man.wife是否删除不重要，因为只有外界对变量的引用，才决定了这个变量是否是“可达”的。现在虽然{name: John}仍然通过wife属性引用了{name: &#39;Ann&#39;}，但是外界对它的引用都删除了，所以它是不可达的，所以会被垃圾回收器清除。 也有可能整个对象变的不可访问从而被从内存中删除，例如我们切断family的引用family = null，那么： 虽然{name: John}和{name: &#39;Ann&#39;}仍然相互引用，但是family已经从根上断开了连接，不再有对它们的外界的引用（也就是说无法从局部或者全局变量访问到它们），所以下面整个块都是不可达的，整体都会被删除。 垃圾回收的算法标记-清除算法垃圾回收的基本算法是“标记-清除”，具体步骤如下，会被定期执行： （1）垃圾回收器获取「根」并标记 （2）继续访问并标记所有来自「根」的引用，所有标记过引用都不会被重复访问： （3）继续标记引用的后代引用，直到所有的“可达”（可以从根访问的）的引用全部被标记为止 （4）删除所有未标记的对象，回收它们占用的内存： 这就是JavaScript垃圾回收期的工作原理，JavaScript引擎应用了许多优化，使其运行的更快，并且不影响执行，例如： （1）分代回收 对象分为两组“老对象”和“新对象”，许多新对象出现，完成任务后迅速被解除应用，它们很快被清理。而那些存活时间足够久的对象就会认为是“老对象”，很少接受检查 （2）增量回收 如果试图一次性遍历并标记整个对象集，那么花费时间会很长，因此引擎会试图将垃圾回收分解为多个部分，然后各个部分分别执行。这需要额外的标记来跟踪变化 （3）空闲时间收集 垃圾回收期只在CPU空闲时运行，以减少对正常任务的影响 除了“标记-清除”算法之外，还有其他的多种算法，比如“引用计数”算法，记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接清除回收内存。这篇文章介绍了多种算法，并分析了优缺点，写的很好。 引用计数算法引用计数算法是最初级的垃圾收集算法，此算法把“对象是否不再需要”简化定义为“有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收器回收。 123456789101112131415161718192021var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性 // 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = "yo"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 这种算法没有办法处理循环引用的情况，例如下面的例子，两个对象被创建，并相互引用，形成循环。它们被调用后不再被外部引用，没用了，可以被回收了。但是引用计数算法认为它们都还至少有一次引用，所以不会被回收，一直保存在内存中。 12345678910function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return "azerty";&#125;f(); 经验法则为了使Chrome的垃圾回收器不保留不再需要的对象，有几点需要牢记： 在恰当的作用域中使用变量，尽量在函数作用域中声明变量，尽量声明局部变量，尽量避免全局变量 确保移除不再需要的事件监听器，比如即将被移除的DOM对象所绑定的事件 避免缓存大量不会被重用的数据 少用闭包 不要再生产环境使用console.log()、console.error()、console.dir()等方法打印任何复杂对象，因为这些对象不会被垃圾回收器回收。 参考 前端面试：谈谈 JS 垃圾回收机制@segmentfault chrome v8引擎以及垃圾回收机制（原创）@掘金 几种垃圾回收算法@简书 解读生产环境为何避免使用console.log@segmentfault]]></content>
      <categories>
        <category>零散专题</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS44 页面生命周期]]></title>
    <url>%2F2019%2F07%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS44%20%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[W3C指定了Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。 新的API 生命周期网页的生命周期被分为了六个阶段，每个时刻只可能处于其中一个阶段。 （1）Active 阶段 网页处于可见状态，且拥有输入焦点。 （2）Passive阶段 此阶段网页可见，但是没有输入焦点，无法接受输入。UI更新（比如动画）仍然在执行。 （3）Hidden阶段 此阶段用户的桌面被其他窗口占据，网页不可见，当尚未冻结。UI更新不再执行。 （4）Terminated阶段 由于用户主动关闭窗口或者在同一个窗口但前往其他页面，导致当前页面被浏览器卸载并从内存中清除，页面进入此阶段。 这个阶段总是在Hidden阶段之后发生，此阶段不会自动任何新任务，正在进行的任务可能会被终止。 （5）Frozen阶段 页面处于Hidden阶段时间过长，但网页一直未关闭，页面会被冻结，进入Frozen阶段。也有可能处于可见状态的页面长时间没有操作，也会进入Frozen阶段。 这个阶段，网页不会再被分配CPU资源，定时器、回调函数、网络请求、DOM操作都不会执行，但是正在执行的任务会被执行完。浏览器可能会允许Frozen阶段的页面，周期性复苏一小段时间，短暂变回Hidden阶段，允许一小部分任务执行。 （6）Discarded阶段 网页长时间处于Frozen阶段，用户未唤醒页面，就会进入Discarded阶段。此阶段浏览器自动卸载网页，清楚网页内存占用。Passive阶段的网页如果长时间没有互动，也可能直接进入Discarded阶段。 这个阶段一般是系统强制执行，任何新任务和JavaScript代码都不能执行。 网页Discarded周，Tab窗口还在，如果用户重新访问Tab，浏览器会重新向服务器发出请求，再次加载网页，回到Active阶段 常见场景（1）用户打开网页，切换到其他App，过了一会又重新回到网页 1Active → Hidden → Active （2）用户打开网页，切换到其他App，并且长时间使用后者，导致系统自动丢弃网页 1Active → Hidden → Frozen → Discarded （3）用户打开网页，切换到其他App，然后在任务管理器中将浏览器进程清楚。 1Active → Hidden → Terminated （4）系统丢弃了某个Tab里面的页面后，用户重新打开这个Tab 1Discarded → Active 事件网页的生命周期是在所有帧触发，不管是底层的帧，还是内嵌的帧。也就是说，内嵌的&lt;iframe&gt;网页跟顶层的网页一样，都会同时监听到所有的生命周期事件。 focus事件focus事件在页面获得输入焦点时触发，比如网页从Passive阶段变为Active阶段。 1window.addEventListener('focus', () =&gt; console.log('focus')) blur事件blur事件在页面失去输入焦点时触发，比如页面从Active阶段变为Passive阶段。 1window.addEventListener('blur', (e) =&gt; console.log('blur')) visibilitychange事件visibilitychange事件在网页可见状态发生变化时触发，一般发生在下面的场景： 用户隐藏页面（切换Tab，最小化浏览器），页面由Active阶段变为Hidden阶段 用户重新访问隐藏的页面，页面由Hidden阶段进入Active阶段 用户关闭页面，页面先进入Hidden阶段，然后进入Terminated阶段。 Page Visibility API在document对象上新增了document.visibilityState属性，该属性返回一个字符串，表示页面当前的可见性状态，有三个可能的值： hidden，页面彻底不可见 visibile，页面至少一部分课件 prerender，页面即将或正在渲染，处于不可见状态 通过监听visibilitychange事件，判断document.visibilityState属性，就可以获得页面的可见状态。 1234window.addEventListener('visibilitychange', (e) =&gt; console.log(document.visibilityState));// 或者document.addEventListener('visibilitychange', (e) =&gt; console.log(document.visibilityState)); 由于历史兼容性的原因，document上定义了hidden属性，这是一个只读的属性，返回一个布尔值，表示当前页面是否可见。应当尽量避免使用这个属性。 freezefreeze事件在网页进入Frozen阶段时触发，这个事件的监听函数，最长只能运行500毫秒，并且只能复用已经打开的网络连接，不能发起新的网络请求 1234document.addEventListener('freeze', (e) =&gt; console.log('freeze'))// 或者document.onfreeze = function()&#123;&#125; 注意，从Frozen阶段进入Discarded阶段，不会触发任何事件，无法指定回调函数，只能在进入Frozen阶段时指定。 resume事件resume事件在网页离开Frozen阶段，变为Active/Passive/Hidden阶段时触发 1234document.addEventListener('resume', (e) =&gt; console.log('resume'))// 或者document.resume = function()&#123;&#125; pageshow事件pageshow事件在用户加载网页时触发，有可能是全新的页面加载，也有可能是从缓存中获取的页面。如果是从缓存中获取的页面，则该事件对象的event.persisted为true，否则为false 1window.addEventListener('pageshow', () =&gt; console.log('pageshow')); 这个事件与页面的可见性无关，至于浏览器的History记录变化有关。 pagehide事件pagehide事件在用户离开网页、进入另一个网页时触发。它同样与页面的可见性没有关系，至于浏览器的History记录有关系。 1window.addEventListener('pagehide', () =&gt; console.log('pagehide')); 如果浏览器能够将当前页面添加到缓存以供稍后重用，那么事件对象的event.persisted属性为true，否则为false。如果为true时，页面添加到了缓存，则页面进入Frozen阶段，否则进入Terminated状态。 beforeunload事件beforeunload事件在窗口或文档即将卸载时触发，改时间发生时，文档依然可以见，此时卸载仍可取消。经过这个时间，网页进入Terminated状态。 123window.addEventListener('beforeunload', function (event) &#123; event.returnValue = 'any content';&#125;); 当为event.returnValue显式的设置任何值时，弹出确认窗口让用户自行选择是否关闭当前页面。没有赋值时，该事件不做任何响应。 从2011年5月25日起, HTML5规范声明：在该事件的处理函数中调用下列弹窗相关的方法时,可以忽略不执行,window.showModalDialog(), window.alert(), window.confirm()和window.prompt() 要注意的是，beforeunload事件只应该用于提醒用户尚未保存的更改，如果这些更改已经保存，那么这个事件应该被移除。这个事件不应该无条件的加载到页面，因为这样做在某些情况下会造成性能的问题。 unload事件unload事件在页面正在卸载时触发，经过这个事件，页面进入Terminated状态。 注意，不建议使用unload事件，因为这个时间是不可靠的，并且可能在某些情况下会有性能问题。 获取页面状态如果页面处于Active、Passive、Hidden阶段，可以通过下面代码获取页面状态： 123456789function getState() &#123; if (document.visibilityState === 'hidden') &#123; return 'hidden'; &#125; if (document.hasFocus()) &#123; return 'active'; &#125; return 'passive';&#125; 如果页面处于Frozen和Terminated阶段，由于定时器代码不会执行，只能通过事件监听判断状态，进入Frozen阶段，可以监听freeze时间，进入Terminated阶段，可以监听pageHide阶段 如果某个选项卡处于Frozen阶段，就随时有可能被系统丢弃，进入Terminated阶段。如果用户再次点击该选项卡，浏览器会重新加载该页面。可以通过判断document.wasDicarded属性，为true证明网页曾经被丢弃过。 如果页面被丢弃过，window对象上会新增window.clientId和window.discardedClientId两个属性，用来恢复丢弃前的状态 DOMContentLoaded事件和load事件在页面开始加载时，会先后触发这两个事件。可以通过监听DOMContentLoaded事件和load事件来衡量页面的加载情况。 DOMContentLoaded事件表示DOM树构建完毕，可以安全的访问DOM树所有节点、绑定事件等（不需要等待图片、音视频等资源下载完成），jQuery的ready事件监听的就是这个事件） 而load事件表示所有资源都已经加载完毕，图片、背景内容都完成渲染，页面出于可交互状态，jQuery的load事件监听的就是这个事件 参考 Page Lifecycle API 教程@阮一峰的网络日志 Page Visibility API 教程@阮一峰的网络日志 beforeunload@MDN Page Lifecycle API@Google Developers]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Page Life API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 You-need-to-know-css]]></title>
    <url>%2F2019%2F06%2F30%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F10%20You-need-to-know-css%2F</url>
    <content type="text"><![CDATA[CSS练习项目，每天练一练。前期按照CSS Tricks进行练习。 透明边框默认情况下，背景的颜色会延伸至边框下层，所以如果边框设置为透明色，会被背景色覆盖掉。 可以设置CSS3的属性background-clip设置元素的背景（背景图片或颜色）是否延伸到边框下面。 background-clip取值有四个： border-box: 背景延伸至边框外沿（但是在边框下层） padding-box: 背景延伸至内边距（padding）外沿，不会绘制到边框外 content-box: 背景延伸至内容区（content box）外沿 text：背景剪裁成为文字的前景色。（只有Chrome支持，需加-webkit-前缀） 所以将background-clip设置为padding-box就可以实现透明边框。 参考： 半透明边框@You-need-to-know-css background-clip@MDN 多重边框box-shadowbox-shadow用来产生阴影效果，如果只给出两个数值，那么浏览器解析为x方向偏移量和y方向偏移量；如果给出第三个值，将被解释为模糊半径的大小；如果给出第四个值，将被监事未扩展半径的大小。 另外两个属性是inset属性（声明式）和颜色值。 一直对模糊半径和扩展半径有一些糊涂，从下面这个例子了解box-shadow的生成过程 首先定义出box-shadow属性： 123456.box &#123; width: 300px; height: 200px; background-color: yellowgreen; box-shadow: 30px 50px 20px #000;&#125; （1）首先在box元素生成一个同box大小、形状完全相同的阴影，颜色为设置的颜色#000 此时，阴影在元素的上层 （2）根据offset-x和offset-y，将阴影从上层向右移动30px，向上移动50px （3）然后根据设置的20px的模糊半径，然后在四个方向上，每个方向的阴影边缘为中心，向两侧各扩展10px的区域，作为高斯模糊的半径 以右侧为例： （4）最后一步，将阴影与元素重叠的区域剪裁掉，如下图： （5）得到最终效果： 从上面的例子看出，模糊半径是是以阴影边缘为中心，向两侧扩展一半，作为半径，进行高斯模糊。只能取正值。 扩展半径，是将阴影的面积增大，在它取值为0时，阴影面积是等于元素的面积的，它不等于0时，取值是四个方向增大或者减小的尺寸 123.inner &#123; box-shadow: 30px 50px 0 30px #000;&#125; 上图的虚线尺寸就是增加的扩展半径30px，当设置了扩展半径，模糊半径也会从增大后的阴影边缘向两侧模糊。 可以通过将x-offset、y-offset、模糊半径都设为0，设置不同尺寸的扩展半径，来实现多重边框的效果： 123.inner &#123; box-shadow: 0 0 0 5px darkgoldenrod, 0 0 0 10px darkolivegreen, 0 0 0 15px red;&#125; 优点是很容易实现2条以上的边框，且可以实现圆角边框，缺点是无法实现非实线的边框。 outline + outline-offsetoutline可以设置一个或者或者多个单独轮廓属性，轮廓不占据空间（box-shadow和border都占据空间） outline-offset用来设置一个outline与一个元素边缘或者边框的间隙 将两者结合，就可以实现多种边框，并且可以实现box-shadow无法实现的，非实线的多重边框 12345.inner2 &#123; border: aqua dotted 5px; outline: red dotted 5px; outline-offset: -15px;&#125; 优点是可以实现非实线的边框，缺点是实现2条以上的边框不方便，且无法实现圆角边框。 参考 多重边框@You-need-to-know-css box-shadow@MDN box-shadow详解@掘金 outline@MDN outline-offset@MDN 边框内圆角要实现的效果： 边框外围没有圆角，内部有圆角，所以单独使用border-radius是不行的。上一部分内容中，我们可以发现，box-shadow是跟随边框有圆角的，而outline则是没有圆角的，所以我们可以使用三者的组合实现边框内圆角。 利用border-radius设置圆角，假设为r，但是不设置border，设置outline为w，这样外边框是没有圆角的， 12345.inner &#123; background: darkgray; border-radius: 5px; outline: 5px solid darkgreen;&#125; 这时候效果是： 背景会由于border-radius的设置出现圆角，然后我们用box-shadow将这部分补上，只设置其扩展半径，颜色与outline的颜色相同 123456.inner &#123; background: darkgray; border-radius: 5px; outline: 5px solid darkgreen; box-shadow: 0 0 0 5px darkgreen;&#125; 扩展半径的取值范围见下图： 复习一下扩展半径的值： 所以这里取值最大值不能超过outline的宽度w，而最小宽度根据勾股定理不能小于$\sqrt{2}r - r$，即$\sqrt{2-1}r$，在我们上面的设置中，扩展半径的取值范围是[2.07, 5) 参考： 边框内圆角@You-need-to-know-css 背景定位background-position 我比较熟悉的背景定位是使用background-position，但是都是只指定了两个属性值： 123.backgroundPosition &#123; background-position: right bottom;&#125; 有三个点要注意： background-position指定的位置是相对于由background-origin定义的位置图层的，默认定位于元素的左上角 background-position在一个方向上，可以指定一个值（例如上面），也可以指定两个值，可以在right后面跟一个数值，表示相对于边缘的位置 如果指定的是百分比，0%代表图片的左（上）边界和容器的左（上）边界重合，100%代表图片的右（下）边界与容器的右（下）边界重合，50%代表图片的中心与容器的中心重合 123456789101112.inner &#123; width: 50%; height: 200px; margin: 0 auto; padding: 20px; background: #fff url('../assets/images/css-tricks.png') no-repeat; background-size: 50px;CSS&#125;.backgroundPosition &#123; background-position: right 20px bottom 20px;&#125; 另外，这个属性是可以融合到background属性中的： 123.backgroundPosition &#123; background: #fff url('../assets/images/css-tricks.png') no-repeat right 20px bottom 20px;&#125; background-origin刚才也提到了，background-position指定的位置是相对于由background-origin定义的位置图层的。background-origin规定了背景图片的属性的原点位置与容器的关系（与background-clip类似） 可以取值有： border-box: 图片边界与border重合 padding-box: 图片边界与padding区域重合 content-box: 图片边界与content区域重合 所以，可以取值content-box，借用padding定位实现。 123456.inner &#123; padding: 20px; border: 10px solid red; background: #fff url('../assets/images/css-tricks.png') no-repeat right bottom; background-origin: content-box;&#125; 参考： 背景定位@You-need-to-know-css background-position@MDN background-origin@MDN 条纹进度条可以使用background的repeating-linear-gradient属性，来生成一个静态的进度条，再结合动画属性，实现动态的进度条样式。 linear-gradient可以实现线形重复渐变效果。 repeating-linear-gradient类似linear-gradient，并且采用相同的参数，但是它会在所有方向上重复渐变以覆盖其整个容器。 它分为两组参数，第一组参数用来描述渐变线的起点位置，to top这样的值会转换为0度，to left会被转换为270度。第二组参数可以包含多个值，用逗号分隔，每个值都是一个色值，后面跟随一个可选的终点位置，终点位置可以是百分比也可以是绝对值 123/* 一个倾斜45度的重复线性渐变, 从蓝色开始渐变到红色 */linear-gradient(45deg, blue, red); 123/* 一个从右下角到左上角的重复线性渐变, 从蓝色开始渐变到红色 */linear-gradient(to left top, blue, red); 1234/* 一个由下至上的重复线性渐变, 从蓝色开始，40%后变绿， 最后渐变到红色 */linear-gradient(0deg, blue, green 40%, red); 要想实现突然变色，而非渐变色，需要为两个颜色制定同一个终点位置，那么这两个颜色会产生一个无线小的过渡区域，从效果上看，颜色会在那个位置突然变化，而不是一个平滑的过程。 1background: linear-gradient(90deg, blue 50%, red 50%); 上面的写法的可维护性不太好，因为每次修改尺寸时都需要修改两处，但是CSS规范规定，如果某个色标的位置值比整个列表在它之前的位置都要小，则改色标的位置会被设置为它前面的额所有色标位置值的最大值 所以上面的代码也可以改为： 1background: linear-gradient(90deg, blue 50%, red 0); 色块的大小是可以通过background-size来控制的： 12background: linear-gradient(90deg, blue 50%, red 0);background-size: 16px; 在就将角度倾斜，通过animation控制background-position，就可以实现动起来的效果了： 12345678910.inner:after &#123; background: linear-gradient(90deg, blue 50%, red 0); background-size: 16px; animation: loading 10s linear infinite;&#125;@keyframes loading &#123; to &#123; background-position: 100% 0 ; &#125;&#125; 这样可以实现水平方向条纹的横向移动 但是如果要是倾斜45度就出现问题了 12345.inner:after &#123; background: linear-gradient(45deg, blue 50%, red 0); background-size: 16px; animation: loading 10s linear infinite;&#125; 这个时候应该改为使用repeating-linear-gradient属性，在所有方向上重复渐变以覆盖其整个容器，使用这个属性时，色标值需要写完整： 1background: repeating-linear-gradient(90deg, blue 0 ,blue 50%, red 50%, red 100%); 所以这样可以实现斜着45度的进度条： 123456.inner:after &#123; background: repeating-linear-gradient(45deg, red 0, red 25%, blue 0, blue 50%, red 0, red 75%, blue 0, blue 100%); background-size: 16px; animation: loading 10s linear infinite;&#125; 参考： 条纹背景@You-need-to-know-css linear-gradient@MDN repeating-linear-gradient@MDN 聊一聊CSS3的渐变——gradient@掘金 不规则卡片想要实现这样的卡片： 上面的不规则椭圆切口使用background的radial-gradient实现。 它的第一个参数定义圆形渐变的中心点，默认为背景的中心，第二个参数定义渐变的形状，可以取值circle（圆形）和ellipse（椭圆），这两个参数可以通过at关键字合并为一个参数，比如circle at 50% -5px 后面的参数和线性填充一样，表示某个确定位置的固定色值，形式为color1 position1, color2 position2，这个位置值是相对虚拟渐变射线的位置值，如果是圆形可以理解为半径 所以这样的一个椭圆缺口可以通过下面实现： 123.top &#123; background: radial-gradient(circle at 50% -5px, transparent 20px, #73d2d3 21px );&#125; 第一个参数定义了在50%, -5px的横纵坐标位置的一个圆形填充，如果不指定位置如下： 后面的色值参数实际上省略了一部分，完整的应该是： 123.top &#123; background: radial-gradient(circle at 50% -5px,transparent 0, transparent 20px, #73d2d3 21px, #73d2d3 100% );&#125; 定义了在20px范围内是透明色，在21px到填充满都是蓝色，之所以大了1px是为了让边缘平滑。这样切口实现。 下面实现上下两个色块的交界处的波浪线，可以利用伪元素加上样式为dotted的border实现： 123456789.top:after &#123; content: ''; display: block; position: absolute; left: 0; bottom: -3px; width: 100%; border-bottom: #f7f7f7 6px dotted;&#125; dotted的边框，显示为一系列圆点。标准中没有定义两点之间的间隔大小，视不同实现而定。圆点半径是border-width计算值的一半。 参考： 不规则卡片@You-need-to-know-css radial-gradient()@MDN border-style@MDN 圆和椭圆一般我们会使用border-radius实现圆角效果，但是实际上使用border-radius可以实现圆、椭圆、半圆等各种圆形的效果。 我们常用的可能就是border-radius: 5px，但是实际上它是一个缩写，它的完整写法是： 1border-radius: 5px 5px 5px 5px / 5px 5px 5px 5px 这八个取值以/进行分割，每一组四个值，分别代表左上、右上、右下、左下四个角的圆角半径，第一组值是水平方向半径，第二组是垂直方向的半径 12border-radius: 上角水平圆角半径大小 右上角水平圆角半径大小 右下角水平圆角半径大小 左下角水平圆角半径大小 / 左上角垂直圆角半径大小 右上角垂直圆角半径大小 右下角垂直圆角半径大小 左下角垂直圆角半径大小 理解了完整的取值，就可以通过设置不同的值来实现不同的圆形。以半圆为例： 首先矩形的宽度应该是高度的2倍，上图的半圆应该设置的是左上和右上的圆角，而且水平半径应该都是矩形宽度的一半，垂直半径应该等于矩形高度，所以： 12345.semicircle &#123; width: 200px; height: 100px; border-radius: 50% 50% 0 0 / 100% 100% 0 0;&#125; border-radius的百分比是相对于offsetWidth和offsetHeight进行设置的，及包括了content、padding以及border的宽度。 更多的实现起来也就不难了，无非是各种组合。 参考 圆与椭圆@You-need-to-know-css 秋月何时了，CSS3 border-radius知多少@鑫空间鑫生活 border-radius@MDN 四边形 实现一个四边形我首先想到的方案是使用矩形+三角形拼接而成，三角形使用border来实现： 12345678910111213141516171819202122232425262728293031323334.parallel1 &#123; position: relative; width: 100px; height: 100px; background: #FFF;&#125;.parallel1:before &#123; content: ''; display: block; position: absolute; left: 0; top: 0; width: 0; height: 0; transform: translateX(-100%); border: 50px solid transparent; border-right-color: #FFF; border-bottom-color: #FFF;&#125;.parallel1:after &#123; content: ''; display: block; position: absolute; right: 0; top: 0; width: 0; height: 0; transform: translateX(100%); border: 50px solid transparent; border-left-color: #FFF; border-top-color: #FFF;&#125; 能够实现，但是代码量是在是不少，而且还占据了两个伪元素。其实有两种更简单的方法，一种是使用transform: skew，skew的意思就是偏离、扭转，它定义了在2D平面上一个对象的歪斜变换，参数可以使一个也可以是两个，当是两个的时候，分别表示沿着横坐标、从坐标扭曲元素的角度。 它的效果可以看下面的三幅图： transform: skewX(30deg) transform: skewY(30deg) transform: skew(30deg) 所以用它来实现四边形就很简单了： 123456.parallel2 &#123; width: 200px; height: 100px; background: #FFF; transform: skewX(-45deg);&#125; 还有一种方法是使用clip-path，它可以用来创建一个只有元素的部分区域显示的剪切区域，区域内的部分显示，区域外的隐藏（这个属性替代了已经弃用的clip属性） 它的可能取值有： clip-source，用一个SVG的URL来表示剪切元素的路径，比如clip-path: url(resources.svg#c1); geometry-box，为基本形状提供相应的参考矿框盒，可以取值有margin-box、border-box、padding-box、content-box、fill-box等 basic-shape，可以用一些预置的形状来进行剪切，比如circle、epplipse、polygon 用这个属性与使用SVG是很类似的，可以实现多种多样的形状，使用clie-path: polygon(A, B, C, D)就可以实现各种四边形。其中A/B/C/D分别是四个点的坐标值，其中横坐标在前，纵坐标在后： 123456.parallel3 &#123; width: 300px; height: 100px; background: #FFF; clip-path: polygon(33% 0, 100% 0, 66% 100%, 0 100%);&#125; 可以实现类似菱形的四边形： 123456.parallel4 &#123; width: 100px; height: 100px; background: #FFF; clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);&#125; 也可以实现一个三角形： 1234567.parallel5 &#123; width: 100px; height: 100px; background: #FFF; clip-path: polygon(0 100%, 100% 100%, 100% 0); transition: clip-path 0.5s;&#125; 简直太强大了。 参考 parallel四边形@You-need-to-know-css skew()@MDN clip-path@MDN css3中-webkit-transform 的 skew 如何使用？@知乎 切角效果想实现下面这两种切角效果 有三种方法，实际上前面都介绍过，先看实现直角切角效果 （1）首先可以使用linear-gradient，首先定义一个方向的直线渐变： 1234.corner1 &#123; background: linear-gradient(45deg, transparent 12px, #FFF 13px) left bottom no-repeat； background-size: 51% 51%;&#125; 要注意的是，这个切角是定义的左下角的位置，首先这个「左下角」是由background-position定义的，只不过简写在background属性中 还要注意的是角度，只需要记住to top是0deg，to right是90deg，计算角度时需要从镜像的起始点出发计算 然后定义了background-size: 51% 51%;相当于只定义了左下角四分之一的背景填充： 之所以不用50%而是51%，是为了防止有些浏览器在渲染时出现缝隙的问题，和border-radius设置为51%是一样的道理。 所以按照同理，将另外三个角补充完整即可： 1234567.corner1 &#123; background: linear-gradient(45deg, transparent 12px, #FFF 13px) left bottom no-repeat, linear-gradient(135deg, transparent 12px, #FFF 13px) left top no-repeat, linear-gradient(-45deg, transparent 12px, #FFF 13px) right bottom no-repeat, linear-gradient(-135deg, transparent 12px, #FFF 13px) right top no-repeat; background-size: 51% 51%;&#125; （2）也可以使用之前一节学习过的clip-path来实现，将这个切过角的形状作为一个多边形，将各个坐标点描绘出来即可（当然也可以使用内联SVG） 在描述各点坐标时，可以使用calc这个属性来计算，小心点一点别把横纵坐标搞错就行： 1234.corner2 &#123; clip-path: polygon(0 12px, 12px 0, calc(100% - 12px) 0, 100% 12px, 100% calc(100% - 12px), calc(100% - 12px) 100%, 12px 100%, 0 calc(100% - 12px)); &#125; （3）圆角切角可以使用radial-gradient实现，原理与使用linear-gradient类似，只是需要额外指定径向渐变的圆心位置： 1234567.corner3 &#123; background: radial-gradient(circle at bottom left, transparent 12px, #FFF 13px) bottom left no-repeat, radial-gradient(circle at top left, transparent 12px, #FFF 13px) top left no-repeat, radial-gradient(circle at bottom right, transparent 12px, #FFF 13px) bottom right no-repeat, radial-gradient(circle at top right, transparent 12px, #FFF 13px) top right no-repeat; background-size: 51% 51%; &#125; 参考 切角效果@You-need-to-know-css linear-gradient()@MDN 使用一个div实现进度条123456789101112.bar &#123; --c: #5b8b7b; --h: 80px; --p: 50%; width: 800px; height: var(--h); border-radius: calc(var(--h) / 2); background-color: lightgray; background-image: linear-gradient(var(--c), var(--c)); background-repeat: no-repeat; background-size: var(--p) 100%;&#125; 效果： 为了使完成部分也出现圆角，可以添加一个radial-gradient，利用它可以实现一个圆球： 1234.circle &#123; background-image: radial-gradient(closest-side circle at 50% 50%, red, red 100%, yellow); background-repeat: no-repeat;&#125; 综合起来： 12345678910111213.bar &#123; --c: #5b8b7b; --h: 80px; --p: 60%; width: 800px; height: var(--h); border-radius: calc(var(--h) / 2); background-color: lightgray; background-image: radial-gradient(closest-side circle at var(--p) center, var(--c), var(--c) 100%, transparent), linear-gradient(var(--c), var(--c)); background-repeat: no-repeat; background-size: 100%, var(--p);&#125; 注意，background-size两个取值之间有一个逗号，意味着是对多个背景的设置，一个背景的设置中如果提供了两个数值时，第一个将作为宽度，第二个作为高度，如果只提供了一个数值，那么它将作为宽度值大小，高度值会被设为auto，所以完整的写法是： 1background-size: 100% auto, var(--p) auto; 实现的效果： 参考 你未必知道的49个CSS知识点@掘金 linear-gradient()@MDN background-size@MDN radial-gradient()@MDN]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03 服务端重构总结]]></title>
    <url>%2F2019%2F06%2F27%2F06%20%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95%2F03%20%E5%B0%8F%E7%B1%B3%2F03%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[花费了差不多1个多月的时间，任天赋、王帅琪和我三人功共同完成了隐私信息管理系统的前后端代码的重构工作。 其中，王帅琪独立完成了前端代码的重构工作，任天赋负责服务端代码中大部分“写”的操作以及与第三方平台对接的代码工作，我负责的是服务端代码中绝大部分与前端对接的“读”的操作以及与隐私合规平台预设规则对接的代码工作。 下面谈一谈我在进行重构过程中的体会和看法。 重构的原因之所以进行重构，是因为之前的系统虽然能够继续开发，但是因为代码结构和业务逻辑的原因，后续维护难度会越来越大，我理解的主要的问题是： 代码结构比较自由，服务端逻辑比较分散，难以维护，可读性不好 有硬编码的现象，前端、后端维护分别维护同一份数据的配置文件，容易出现问题 数据库字段设计不统一，导致增加了大量的处理逻辑 前端负责了很多数据二次处理的工作 重构就是为了解决问题，所以针对上面的问题，这次重构的思路是： 选用Egg框架代替Koa，代码使用一套统一的约定进行开发，让逻辑尽量清晰 数据相关的配置文件由后端维护，变化较大的存入数据库，有必要的以接口的形式返回给前端 优化数据库的字段设计，结合相关的配置文件，减少不要的处理逻辑 服务端完成绝大部分的数据处理工作，以较规范的REST接口形式将数据返回给前端，前端可以直接展示数据 框架选型在重构之前，我针对BFF进行了调研，针对几种Web开发框架进行了对比，比较可行的方案就是Egg和Koa（Express），最后之所以选择用Egg代替了Koa作为框架进行开发，主要基于以下几个原因： Egg是在Koa的基础上进行的封装，完全兼容Koa的中间件，并且文档比较友好 是蚂蚁金服的最佳实践的封装，有众多的插件支持，配套完善 Egg更适合于企业开发，以约定代替配置，可以做到代码规范的统一，提高代码的可维护性 Koa比Egg更加灵活，这就导致了代码无论怎么写，都能够运行，并且很多配套的支持都需要自行搭配，而Egg提供了一整套的解决方案，更适合有严格要求、长久更新维护的企业项目，也更能做到渐进增强的研发体验。当业务开发到一定程度时，完全可以由Egg抽象、封装出属于特定业务、特定模式的中间件、插件甚至框架。 使用了Egg，感觉最大的好处有两个： （1）大量的约定 大量的约定，既限制了开发者，又给开发者自由。 在Egg的约定下，MVC的架构非常清晰，目录结构合理，可以按需选择。 12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app| ├── router.js│ ├── controller│ | └── home.js│ ├── service (可选)│ | └── user.js│ ├── middleware (可选)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (可选)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (可选)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config| ├── plugin.js| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test ├── middleware | └── response_time.test.js └── controller └── home.test.js 根据它的约定进行开发，开发者不再需要关心哪些功能应该放在哪里、哪些服务应该如何被调用。当团队的开发者都遵循统一的约定时，就不必关心这些事情，只关心如何实现具体的业务逻辑，因为其他的事情Egg都帮你做好了 （2）完善的功能 Egg是针对企业级研发的框架，所以它也提供了很多企业级应用开发的核心功能，比如单元测试、本地调试、日志，异常处理等等，封装了cookie和session的操作，我们只需要按照它的文档进行配置，就可以实现绝大部分的需求。 以断点调试为例，其他的框架可能还需要手动去进行浏览器或者IDE的配置，而Egg则实现起来非常简单，就是将启动命令由npm run dev改为npm run debug， 然后用浏览器打开控制台输出的Devtools后面对应的地址即可于凯的进行debugger、打断点的调试了： 非常的容易。 除了框架直接提供的功能之外，也可以使用很多第三方的插件来帮助我们实现功能，比如参数校验和异常处理，使用egg-validate可以大大的简化我们在Controller中的参数校验的逻辑： 12345678910111213141516171819202122232425// 查询网络上传全部详细信息的校验规则const indexRule = &#123; id: &#123; type: 'string', trim: true, format: /^.&#123;24&#125;$/, message: '非法ID' &#125;, // Mongo生成的ID长度为24位 packageName: &#123; type: 'string', trim: true &#125;,&#125;class LogController extends Controller &#123; // 获得某个 App 的网络上传全部详细信息 async index() &#123; const &#123; ctx &#125; = this const &#123; params &#125; = ctx // 参数校验 ctx.validate(indexRule, params) // 参数 const id = params.id const packageName = params.packageName // 响应内容 const data = await ctx.service.network.findPrivacyNetwork(&#123; id, packageName: packageName.trim() &#125;) ctx.response.status = this.config.httpCodeHash.ok.code ctx.response.body = &#123; count: data.length, items: data &#125; &#125;&#125; 当然，Egg作为这么一个功能丰富、大而全的框架，使用中也是有一些问题，后面会提到。 配置处理前面说了，之前可能同一份配置文件，比如加密方法，可能前后端都要维护，如果新增一种加密方法的话，可能前后端都需要更改代码，而且也容易由于维护的不一致性，导致bug。 所以这次重构，将这种配置文件都拿到了服务端，在config目录下，将我们业务所需要的配置文件全部放到custom的目录下，然后通过config.default.js导入 使用时，服务端直接通过this.config就可以获取到对应的配置文件，而前端如果需要对应的配置文件，则直接提供了一个接口提供数据 这样不仅只需要维护一份配置文件，而且如果相关数据更改时，只需要到这里更改一次，不用在所有代码中搜寻进行更改，避免了不优雅的硬编码的现象。 优化数据库的字段这个部分实际上我没有什么发言权，因为我的经验、水平和对业务的熟悉程度都不太够，而且业务是不断变化的，需求不断增加，很有可能导致当初设计的字段，在后期不满足需要。而想要设计出比较完美且扩展性良好的数据结构，不是一件容易的事情。 现实中，当原始的数据结构与需求冲突，后期解决起来会很麻烦，导致很多复杂的处理逻辑。 举个例子，系统中获取到的被检测的包名是是以.分割的，比如com.android.browser，而Mongo数据库的存储对象的键值是不能有.的，原来是将com.android.browser改为了com_android_browser进行存储，这样改过来改过去就需要进行字符串的处理，如果遇到一些特殊的本来就含有_包名还需要特殊处理 这次重构，我和任天赋约定，所有的包名都使用com.android.browser存入数据库，由于大部分情况都是存入到Gzip压缩后的数据，所以没有关系，而必须作为key时，只在他写的时候进行处理替换，而且我们在预设规则的数据表里增加了packageName字段，用来存放com.android.browser，这样实现通过配置关系与com_android_browser对应，能够减少一部分处理的逻辑，而且剩余的处理逻辑比较集中 其他的还有一些细节的优化，比如Log和网络请求的加密信息存储结构改为一致的等等。 我们之所以能够对数据库字段进行更改，很大的原因是因为隐私管理系统的历史数据相对不那么重要，如果我们提供一个缓冲器，之前的数据就可以不再关注。若非如此，想要实现这一点的优化是不太好处理的，因为要考虑大量的兼容性的问题。而且虽然这次重构通过优化可能带来了一些好处，但是也许随着需求的出现，优化后的字段又面临新的问题。所以说这是很考验水平的事情。 为前端提供处理好的数据之前的代码中，前端从接口获取数据后，还是要进行很多的处理才能展示在UI上。而BFF的理念就是，一个前端配药一个小的数据处理后端，减轻前端处理数据的逻辑，让前端的中心关注在交互逻辑和UI呈现上。这次的重构也是相当于BFF的一次事件，只不过大部分数据直接从数据库获取，而不是调用其他后端的接口和服务获取到的而已。 秉承着这个理念，服务端重构的代码基本上把数据按照前端UI界面的格式、按照前端同事的要求，通过接口提供给前端。前端拿到数据后处理的逻辑会很少。 比如前端展示标记后的Log信息和网络请求，之前是前端根据隐私值对信息标记，重构之后由服务端根据隐私项将信息进行标记，标记的方式是通过和前端约定好的标签的形式，返回标记好的信息，前端根据m属性拿到加密方法，直接找到对应的CSS样式，展示即可 12345678910111213141516171819/** * 对隐私信息进行标记，加密/不加密通过m属性判断 * @param &#123; string &#125; target 要标记（替换）的关键词 * @param &#123; string &#125; string 被标记的字符串 * @param &#123; boolean &#125; isEncrypted 要标记的是否为加密数据 * @param &#123; string &#125; method 加密方法 * @return &#123; string &#125; markedString 返回标记后的新字符串 */markPrivacyInfo(target = '', string = '', isEncrypted = false, method = 'unKnow') &#123; if (!target) &#123; return string &#125; // 已经匹配过的带有&lt;em&gt;的不再重复匹配 const reg = new RegExp(`(?&lt;!&lt;em&gt;)($&#123;target&#125;)`, 'g') const encryptedMethod = isEncrypted ? ` m='$&#123;method&#125;'` : '' return string.replace(reg, `&lt;em$&#123;encryptedMethod&#125;&gt;$1&lt;/em&gt;`)&#125;, 此外，作为比较典型的前后端分离的项目，前后端之间唯一的交互就是通过接口。接口设计尽量靠近REST规范，通过不同的HTTP方法来区分请求的种类和目的： 1234// 预设规则router.get('/v1/privacy/settings/', controller.settings.index)router.put('/v1/privacy/settings/', controller.settings.update)router.post('/v1/privacy/settings/', controller.settings.create) 通过规定统一的响应格式和引入egg-errors插件，实现了接口成功时数据格式以及失败时错误响应的统一格式。既实现了简洁明了的响应结构，又便于前端通过HTTP状态码进行异常处理。 现有的很多其他后台开发的服务端的接口并没有做到严格遵守REST的规范，或者说没有向这个方向努力，我们在尽力做到规范和标准。（这里也要向王帅琪同学学习，虽然刚毕业，但是能力很强，提出的建议很中肯，对接口的规范性帮助很大。） 之所以能够做到针对前端提供符合要求的数据格式，除了把项目重构、让项目更好的美好愿景之外，另一个原因就是都是组内的同事，沟通更加顺畅且和平，而且都是前端出身，都知道拿到服务端返回一坨面条样的、直接从数据库取回来的数据时的无奈。 所以这也是BFF除了减轻前端数据处理的负担之外最大的好处，就是减少了前后端的撕逼。一些小的数据改动，不再需要后端，我们自己通过Node中间把层微服务提供的数据处理好，返回给自己负责的前端，这流程实在Peace and Love。 改进的空间虽然是重构了，但是仍然有很大改进和反思的空间 （1）关于Egg 前面提到了Egg的一堆好处，确实，对于开发企业级应用来说，Egg确实是非常易用的。但是也因为此，它变的很厚重，很多功能、很多配置我们并不见得用得上，目前是完全没有问题的。 这就像是我们只要吃一个手抓饼，但是它给我们端上来法式大餐的全套餐具。能吃吗？没问题，但是有可能有一些浪费。更好的方式还是应该针对Egg进行定制，抽象出属于自己的团队和业务的开发框架。 还有一点可能就是它对于类的支持，任天赋开发时采取了面向对象，以类为基础的开发模式，将不同的类型的数据抽象为不同的类，挂到了ctx对象上，这样有助于抽象不同数据对象的行为，代码的可读性更好。 但是在通过context.js挂载时，没有办法获取到Egg的实例，因为只有已函数的形式挂载才能获取到Egg实例，而以导出的类的形式挂载是不行的，结果导致没有办法获取Egg实例上挂载的配置文件。 这一点还是让人很不爽的。Egg支持并鼓励在service中互相调用方法，但是当我们想把拥有相同的行为和方法的一类数据抽象为一个Class时，使用起来却不太方便。 虽然最后通过在config.default.js将配置直接挂到global上解决了这个问题，但是还是让人感到不爽。后面可能还需要研究一下，使我们的使用姿势不太对，还是它本身就不欢迎这种形式。 12345678module.exports = appInfo =&gt; &#123; // 省略 // 将config挂载到全局对象上 global.config = FinalConfig return FinalConfig&#125; （2）关于性能 现在读取数据时，在数据量较大的时候，由于需要解压数据，再加上数据处理的过程，接口响应时间比较长，性能表现不是很好。 后期当性能成为瓶颈时，是否可以考虑引入Redis等缓存来实现查询速度的提高，或者在存储检测结果时进行处理（因为检测时对时间长短不敏感）。 （3）关于开发流程 文档记录在Wiki，Bug通过微信截图反馈，Bug修复情况我们自己记录在Wiki，问题修复后的测试流程也是缺失的。 可能是项目和团队的特殊性吧，但是每当上线代码时，还是觉得忐忑，因为基本没有测试，记录也无处查询。 （4）关于业务 对于这个系统，重构之前的代码逻辑是阻碍新人接受的原因之一，另外一个原因就是比较复杂的业务逻辑。前者通过重构可以解决，后者我认为还是没有很好的解决。 对于重要的项目，如果能有一个比较详尽的业务流程图解+合理的文档+合理的代码注释+合理的代码结构，我想才真的算得上可维护的、健康发展的项目。 重构，对于项目负责人，或者说团队负责人，应该能站在更高的角度，向项目成员介绍（或者以文档的形式）整个业务的逻辑，从大局的角度上把握项目的发展、进行项目的规划。团队成员对整个业务流程和逻辑有了更清晰的了解后，才能更好更快的进行项目开发的流程。 作为项目参与者的我，这方面做的也不太好。因为对比较复杂的业务逻辑不熟悉，服务端开发经验比较少，我的主要关注点在于如何在重构时实现这个功能点、那个功能点，一点点增加对业务的了解，最后止于自己的开发范围，范围之外的业务逻辑还是不太了解。 自己应该更主动的去了解全部的业务，才能更好的理解代码，以后接手也会容易些。 总结我个人觉得，这次服务端的代码重构，在保证原有系统的功能的基础上，实现了代码的重构，简化了代码逻辑，提高了代码的可读性和维护性，并且实现了新的需求，总体来说还是成功的，能够留下一些经验。 经过重构之后，我觉得，项目对于业务团队的发展还是很重要的，代码的质量也和代码的可维护性有关系，还是应该关注这些东西，关注基础和细节的东西，而且在重要项目的初始规划、设计应该更为慎重，后续开发的代码的质量、代码的规范，应该更为关注。 做好平时的积累，让代码能够长久的维护，推迟不得不重构那一天的到来。 重构能够提高经验，但是平时的积累和细节的关注，也是水平不断提高的方向之一。 以上是我的愚见，让各位大神见笑了。]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成02 Travis CI]]></title>
    <url>%2F2019%2F06%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F02%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%9002%20Travis%20CI%2F</url>
    <content type="text"><![CDATA[Travis CI是市场份额最大的持续集成工具，它对于开源项目是免费的，但是对私人项目和公司项目则是收费的。 Travis CI提供的是持续集成服务，它绑定Github上的项目，只要有新的diamante，就会自动抓取，然后提供一个运行环境，执行测试，完成构建，然后部署到服务器。 使用准备Travis CI只支持Github，不支持其他代码托管项目，所以使用Travis CI的前提是: 代码位于Github的仓库 项目中有可运行的代码 项目中包含构建或者测试脚本 满足上述条件之后，需要访问其官网，使用Github账户登陆Travis CI。登陆后Travis CI会列出Github上的所有代码仓库 选择按钮打开，就激活了这个仓库，Travis会监听这个仓库的所有变化。 .traivs.ymlTravis要求项目下面，必须有一个.travis.yml文件，且必须提交到代码仓库。这是一个配置文件，指定了Travis的行为，是必不可少的。 文件是YAML格式： 123456789101112131415# 指定默认运行环境language: node_js ## 指定 node 版本node_js: - "node"# 指定执行的脚本script: test.js# 需要 sudo 权限sudo: required# 安装依赖之前执行before_instasll: sudo pip install foo 运行流程Travis的运行流程包括两个阶段： install阶段（安装依赖）和script阶段（运行脚本） installinstall字段用来指定安装脚本： 1install: npm install 如果有多个脚本，可以写成下面的形式： 123install: - command1 - command2 如果command1失败了，整个构建就会停下来，不再向下进行。 如果不需要安装，则跳过安装阶段，直接设为true： 1install: true scriptscript字段用来指定构建或者测试脚本 1script: npm run test 如果有多个脚本，可以写成下面的形式： 123script: - command1 - command2 script与install不一样，如果command1失败，command2会继续执行，但整个构建阶段的状态是失败的。 如果command2只有在command1成功后才能执行，就需要写成 1script: command1 &amp;&amp; command2 Node项目Node项目的install和script都有默认脚本，可以省略： install默认值npm install script默认值npm test 更多配置见官方文档。 部署script阶段结束后，可以设置通知步骤和部署步骤，它们不是必须的。 部署的脚本可以在script阶段执行，也可以使用Travis为几十种常见服务提供的快捷部署功能。 通知在.travis.yml进行如下配置 1234567notifications: email: recipients: - duola8789@126.com slack: on_success: never on_failure: always 当失败时会发邮件进行通知 钩子方法Travis为上面这些阶段提供了七个钩子： before_install，install阶段之前执行 before_script，script阶段之前执行 after_failure，script阶段失败后执行 after_success，script阶段成功后执行 before_deploy，depoly步骤之前执行 after_depoly，depoly步骤之后执行 after_script，script阶段之后执行 生命周期完整的生命周期： before_install install before_script script aftersuccess/afterfailure before_deploy（可选的） deploy（可选的） after_deploy（可选的） after_script 运行状态Travis每次运行后，可能会返回四种状态 passed，运行成功，所有步骤的退出码都是0 canceled，用户取消执行 errored，before_install、install、before_script有非零退出码，运行会立即停止 failed，script有非零状态码，会继续执行 使用技巧环境变量.travis.yml的env字段可以定义环境变量。 1234env: - DB=postgres - SH=bash - PACKAGE_VERSION="1.0.*" 脚本内部就可以使用这些变量了，使用时前面加$符号有一些环境变量（比如密码）不能同开，可以通过Travis网站，写在每个项目的设置里面，Travis会将其自动加入环境变量，这样脚本内部依然可以使用环境变量，但是只有管理员才能看到变量的值 加密信息如果不放心保密信息明文存在Travis的网站，可以使用Travis提供的加密功能。可以参考阮老师的介绍和官方文档。 部署Github Pages以我的Github Pages博客的部署做例子，根据官网文档，.travis.yml配置如下： 12345678910111213141516171819202122232425262728293031sudo: falselanguage: node_jsnode_js: stablecache: npmbranches: only: - master # build master branch onlyscript: - hexo generate # generate static filesdeploy: provider: pages skip_cleanup: true github_token: $GH_TOKEN keep_history: true local_dir: public on: branch: masternotifications: email: recipients: - duola8789@126.com slack: on_success: never on_failure: always 要说明的是： （1）通过.travis.yml配置后，就不再需要_config.yml中配置deploy相关东西了，但是要注意，使用.travis.yml配置，Travis-CI网站上存放github_token的变量名必须是$GH_TOKEN （2）github_token需要提供Github的个人凭证，生成方式参考Github的文档 这里个人凭证需要勾选public_repo或repo。 生成凭证后，为了防止个人凭证的泄露，不能直接在.travis.yml直接填写个人凭证，需要将凭证一边量的方式添加到Travis CI的对应的项目中的设置里面 （3）需要将skip_cleanup设为true，否则Travis CI会将在构建过程中生成的文件全部删除，可能会导致本来想上传的文件删除 更多的配置项参考文档。 配置完成后来实验一下，新添加一篇文章《持续集成01 入门》。 （2019.10.20更新）根据Hexo的新的文档配置了.travis.yml，很详细却准确，不需要下面的步骤了。 文章结束。本以为会很顺利，结果尝试了多次才按照上面Travis CI的配置推送成功，因为我的博客的源码和页面是放在了两个不同的仓库，源码的仓库是https://github.com/duola8789/blog.git，而页面的仓库是https://github.com/duola8789/duola8789.github.io.git，所以直接推送的时候总是推送失败，是因为它默认将duola8789/blog仓库的本地全部目录推送到duola8789/blog的gh-pages分支，而我现在想要的是将duola8789/blog仓库的public目录推送到duola8789.github.io.git的master分支，所以根据文档的提示，在.travis.yml中增加下面的配置 12345deploy: # 新增 repo: duola8789/duola8789.github.io local_dir: public/ target_branch: master 新增的第一项指明要推送的页面所在的仓库，第二项后者指明要推送的本地目录，第三项修改要推送的分支。同时将_config.yml的Hexo的推送配置注释掉： 1234deploy: type: git # repo: https://$github_token@github.com/duola8789/duola8789.github.io.git branch: master 这样修改完成后就推送成功了： 在网上查找的资料，都没有用Travis CI的辅助配置，而是使用了自定义的配置，也都可以成功，下面这种是比较简单的一种，也推荐使用（将_config.yml的Hexo的推送配置注释掉）： 12345678910111213141516language: node_jsnode_js: stablecache: directories: - node_modulesbefore_install: - git config --global user.name "zh" - git config --global user.email "duola8789@126.com" - npm install -g hexo-cli - export HEXO_DEPLOYER_REPO=https://$github_token@github.com/duola8789/duola8789.github.io.gitscript: - npm run deploy 果然不亲自尝试，都是没有说服力的。 如果遇到403无权限推送的错误，一般是Github Token的问题，是否没有在环境变量中正确的设置，挥着没有在.travis.yml正确引用。 原来管理博客，在文章写完之后需要分两步，首先npm run deploy，本地重新生成、打包文章，将文章发布到https://github.com/duola8789/duola8789.github.io.git，再commit、push当前的源码，提交到https://github.com/duola8789/blog.git。现在配置过后，直接提交源码到仓库即可，其他的Travis CI都会帮助我们完成。 参考 持续集成服务 Travis CI 教程@阮一峰的网络日志 GitHub Pages Deployment@Travis CI Creating a personal access token for the command line@Github 通过travis自动部署hexo博客到github pages@掘金 Configuring Build Notifications@Travis CI]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>持续部署</tag>
        <tag>Travis ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成01 入门]]></title>
    <url>%2F2019%2F06%2F26%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F02%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%9001%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[持续集成入门学习笔记。 持续集成的概念Continuous Intergration（CI），指的是开发代码频繁地合并进主干，式中保持可发布状态的这个过程。 优点： 快速发现错误 防止分支大幅度偏离主干 让产品可以快速迭代，同时还能保持高质量 CI的核心措施：代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成 与持续集成相关的还有两个概念，持续交付和持续部署（CD） 持续交付和持续部署持续交付是持续集成的下一步，指的是频繁地将软件的新版本交付给智联团队或者用户，以供评审。 持续部署是持续交付的下一步，指的是代码通过评审后，自动部署到生产环境。它的前提是能自动化完成测试、构建、部署都步骤。 持续集成的流程（1）提交：开发者向代码仓库提交代码（commit）。 （2）第一轮测试：代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并主干就会进行自动化测试。测试种类包括单元测试（必须）、集成测试、端对端测试。这一轮测试可以省略，因为在构建完成后会有第二轮测试。 （3）构建：通过测试后，代码合并进主干，进行构建（构建包括安装依赖、配置资源等），常用的构建工具有Jenkins和Travis。 （4）第二轮测试：构建完成后要进行第二轮测试，第二轮测试是前面测试，单元测试和集成测试都要进行，有条件也要做段对端测试，所有测试以自动化测试为主，少数无法自动化测试的用例需要人工进行。新版本的每个更新点要必须要测到。 （5）部署：第二轮测试通过后，将这个版本的所有文件打包存档，发到生产网服务器，生产服务器将打包文件解压为本地目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。 （6）回滚：一旦当前版本发生问题，需要回滚到上一个版本的构建结果。最简单的做法就是修改符号链接，指向上一个版本的目录。 参考 持续集成是什么？@阮一峰的网络日志]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>持续部署</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题33 Nginx]]></title>
    <url>%2F2019%2F06%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9833%20Nginx%2F</url>
    <content type="text"><![CDATA[以前的Nginx的学习笔记，重新总结了一下。 关于NginxNginx是一个强大的轻量级的高性能网页服务器、反向代理服务器和电子邮件代理服务器。作为负载均衡服务器，Nginx可以在内部直接支持Rails和PHP程序对外进行服务，也可以支持作为HTTP代理服务器对外进行服务。 Nginx的正向代理正向代理的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器这个代理服务器呢,他能访问那个我不能访问的网站。 于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录。有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。 结论就是正向代理是一个位于客户端和原始服务器(Origin Server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 Nginx的反向代理 正向代理代理的是客户端，反向代理代理的服务器 什么是反向代理所谓反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 从上图可以看出，反向代理服务器位于网站机房，代理网站web服务器接受Http请求，对请求进行转发。 例用户访问http://ooxx.me/readme，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情。这里所提到的ooxx.me这个域名对应的服务器就设置了反向代理功能。 反向代理对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 反向代理的作用（1）保护网站安全：任何来自Internet的请求都必须先经过代理服务器； （2）通过配置缓存功能加速Web请求：可以缓存真实Web服务器上的某些静态资源，减轻真实Web服务器的负载压力； （3）实现负载均衡：充当负载均衡服务器均衡的分发请求，平衡集群中各个服务器的负载压力； Nginx的一些基本知识在介绍下面的使用Nginx进行跨域之前，需要对Nginx的一些基本知识有所了解。 基本命令使用Nginx的命令需要首先定位到nginx.exe所在的目录（Windows系统） Nginx的一些基本命令： 123456789101112131415161718# 查看版本nginx -v# 启动start nginx# 停止nginx -s stop # 快速停止Nginx，可能并不保存相关信息nginx -s quit # quit完整有序的停止Nginx，并保存相关信息。# 重新启动nginx -s reload # 当配置信息修改，需要重新载入这些配置时使用此命令# 重新打开日志文件nginx -s reope# 查看配置文件路径及是否调用有效nginx -t 配置文件Nginx的功能都是通过nginx.conf配置文件来实现的，一个服务器上可能会有多个配置文件，可以执行nginx -t来查看配置文件的路径以及是否调用有效。 Nginx的配置文件主要分为四部分： main，全局设置，设置的指令将影响其他所有部分的设置 server，主机设置，用于指定虚拟主机域名、IP和端口 upstream，上游服务器设置，主要为反向代理、负载均衡相关配置 location，URL匹配特定设置 他们之间，location继承server，server继承main，upstream既不会继承指令也不会被继承。 关于locationNginx配置文件中的loaction是主机访问的地址，在Nginx服务器做一个代理，转发到location中配置的地址。它有如下的匹配指令： =表示进行普通字符精确匹配，只有请求的URL路径与后面的字符串完全相等时，才会命中 ~表示执行一个正则匹配，区分大小写 ~*表示执行一个正则匹配，不区分大小写 ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @定义一个命名的location，使用在内部定向时，例如error_page, try_files loaction匹配的优先级（与loaction在配置文件中的顺序无关） =精确匹配会第一个被处理。如果发现精确匹配，Nginx停止搜索其他匹配。 普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。 ^~则只匹配该规则，Nginx停止搜索其他匹配，否则Nginx会继续处理其他loaction指令。 最后匹配理带有~和~*的指令，如果找到相应的匹配，则Nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。 123456789101112131415161718192021location = / &#123; # 只匹配"/". [ configuration A ] &#125;location / &#123; # 匹配任何请求，因为所有请求都是以"/"开始 # 但是更长字符匹配或者正则表达式匹配会优先匹配 [ configuration B ] &#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location [ configuration C ] &#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配以 gif, jpg, or jpeg结尾的请求. # 但是所有 /images/ 目录的请求将由 [Configuration C]处理. [ configuration D ] &#125; 关于rewriterewrite只能对URL中的路径部分除去传递的参数外的字符串起作用，不关心域名部分和查询参数，例如： 1http://www.baidu.com/a/bb/ccc.php?id=1&amp;uu=str rewrite只会对/a/bb/ccc.php重写。 语法： 1rewrite regex replacement [flag] 执行顺序是首先执行location匹配，然后执行location中的rewirte指令。 关于proxy_passproxy_pass地址后面加上了/则相当于转发到绝对根路径，Nginx不会对loaction中匹配的路径部分进行转发，例如： 1234location ^~/proxy/html/ &#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 proxy_pass http://www.b.com/&#125; 如果请求的url为：http://localhost/proxy/html/test.json，则转发后的地址是：http://www.b.com/test.json。 如果proxy_pass地址后面不加/，则Nginx会对loaction中匹配的路径部分进行转发，例如: 1234location ^~/proxy/html/&#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 proxy_pass http://www.b.com&#125; 如果请求的url为：http://localhost/proxy/html/test.json，则转发后的地址是：http://www.b.com/proxy/html/test.json。 利用Nginx的反向代理实现跨域利用Nginx反向代理实现跨域，不需要目标服务器配合，但需要搭建中转Nginx服务器，用于转发请求。 实现原理 对于请求者而言，发送的不是跨域的请求，而是对本地资源的请求，Nginx识别出特定的本地资源请求，转发到真实的跨域的资源的地址。 而作为服务端而言，是不存在跨域的（需要添加对应的请求头），所以会把资源返回给Nginx服务，再由Nginx服务将资源返回给真正的请求页面。 基础配置首先找到nginx.conf中的下面这部分内容： 12345678server &#123; listen 80; server_name localhost; location / &#123; root ../Project; index index.html index.htm; &#125;&#125; 其中server代表启动的一个服务，location是一个定位规则，是Nginx用来跨域的入口。 location /的意思是所有以/开头的地址，实际上是所有请求，后面的地址可以是绝对地址，也可以是相对地址；root的意思是去请求相对上一层中的Project文件夹里的文件，index是去指定首页。 在location /{}中添加一下代码： 12345add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;&apos;;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;rewrite regex replacement [flag]proxy_pass http://ip:port/; 其中： （1）第一条指令：授权从other.subdomain.com的请求；是W3C标准里用来检查该跨域请求是否可以被通过； （2）第二条指令：当该标志为true时，响应于该请求可以被暴露； （3）第三条指令：制定请求的方式，可以使GET/POST等； （4）第四条指令：对域名（根路径）后面除去传递的参数外的字符串的url进行重写及重定向； URL是URI的子集。任何东西，只要能够唯一地标识出来，都可以说这个标识是URI。如果这个标识是一个可获取到上述对象的路径，那么同时它也可以是一个URL；但如果这个标识不提供获取到对象的路径，那么它就必然不是URL。 （4）第五条指令：实际要访问的请求地址； 前三条是用来指定自己的服务器是否可以被跨域访问的指令，是可以没有的。 第四条利用Nginx提供的变量，结合正则表示和标志位来实现比较复杂的重定向，简单的情况也是可以没有的。 实现方法1：location + proxy_pass适用于将location直接转发至proxy_pass地址的情况，这种情况一般比较简单。 比如我们要访问的跨域资源位于http://115.29.203.53:10013/students/，前端代码如下： 1234567891011121314151617181920var button = document.getElementById("button");$(button).click(function() &#123; $.get("students", function(data) &#123; alert(data.data[0].id) &#125;, "json"); $.getJSON("students", function(data) &#123; alert(data.data[0].id) &#125;); $.ajax(&#123; url: "students", type: "GET", dataType: "json", success: function(data) &#123; alert(data.data[0].id) &#125; &#125;)&#125;) 上面的三种方法都可以实现跨域，要注意的是使用get方法获取JSON数据时一定要声明第四个参数dataType为JSON，否则总是无法获得正确的对象。 跨域的部分，url地址是一个相对地址students，转化为绝对地址就是http://localhost/Project2/task5/students/。而本地并没有这样的资源，所以需要利用Nginx进行转发处理。 1234567server &#123; listen 80; server_name localhost; location ^~/Project2/task5/students/ &#123; proxy_pass http://115.29.203.53:10013/students/; &#125;&#125; 配置完成后重启Nginx服务，首先定位到nginx.exe所在的目录（Windows系统），然后： 1nginx.exe -s reload 这个是比较蠢的做法，直接将全部的URL替换为最终的真实URL，这样就将地址转发出去了，实现了跨域。 实现方法2：location + proxy_pass + rewrite适用于直接将location转发至proxy_pass不能满足需要，需要对虚拟根路径及后面的路径使用rewrite进行改写的情况。例如： 我们主机的地址是www.a.com/html/index.html，想请求www.b.com/api/msg?method=1&amp;para=2，请求如下： 1234567$.ajax(&#123; type: "get", url: "www.b.com/api/msg?method=1&amp;para=2", success: function(res) &#123; alert("success") &#125;&#125;) 这样必然因为跨域问题发生错误，无法获得b网站的数据。将请求更改为： 12345678$.ajax(&#123; type: "get", url: "proxy/api/msg?method=1&amp;para=2", // 绝对路径是 www.a.com/proxy/html/api/msg?method=1&amp;para=2 success: function(res) &#123; alert("success") &#125;&#125;) 这是的URL请求的就是本地的资源了，但是在本地并不存在相应的数据，所以需要将这个地址通过Nginx转发出去。 在刚才的路径中匹配到这个请求，在location下面再添加一个location： 1234567891011121314server &#123; listen 80; server_name localhost; location / &#123; root ../Project; index index.html index.htm; &#125; # 匹配任何以 /proxy/html/ 开头的地址，匹配符合以后不继续往下搜索 location ^~/proxy/html/ &#123; rewrite ^/proxy/html/(.*)$ /$1 break; proxy_pass http://www.b.com/ &#125;&#125; location ^~/proxy/html/用于拦截请求，是一个匹配规则，匹配任何以proxy/html/开头的地址，这里匹配到的就是proxy/html/api/msg?method=1&amp;para=2 rewrite ^proxy/html/(.*)$ /$1 break用来重写拦截的请求，并且只对域名后面除去传递参数外的字符起作用，即重写上面匹配到的地址的这一部分进行重写：proxy/html/api/msg rewrite后面是一个正则表达式，表示匹配以/proxy/html/开头的任何字符至结尾，并且将proxy/html/后面的任意字符存到第一个捕获组$1之中，break表示匹配一个后停止。 重写的结果是：/api/msg proxy_pass http://www.b.com/用来把请求代理到其他主机，即www.a.com代理到www.b.com，请求路径最终变为http://www.b.com/api/msg? method=1&amp;para=2 配置完成后重启Nginx服务即可。 这样就可以更改上面的情况1中的做法，JS文件不变，Nginx的location的配置如下： 12345678server &#123; listen 80; server_name localhost; location ^~/Project2/task5/students/ &#123; rewrite ^/Project2/task5/(.*)$ /$1 break; proxy_pass http://115.29.203.53:10013/; &#125;&#125; 同样可以实现跨域 又一个例子前端请求： 12345678$.ajax(&#123; type: "get", url: "sohu/api/msg?method=1&amp;para=2", // 真实地址是 www.c.com/proxy/html/api/msg?method=1&amp;para=2 success: function(res) &#123; alert("success") &#125;&#125;) Nginx进行如下配置： 123456789server &#123; listen 80; server_name localhost; location ^~/sohu&#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 rewrite ^.+sohu/?(.*)$ /$1 break; proxy_pass http://www.sohu.com/ &#125;&#125; 所以： location定位到：/sohu/api/msg?method=1&amp;para=2 rewrite的结果：api/msg proxy_pass后的结果：http://www.sohu.com/api/msg?method=1&amp;para=2 最后一个例子 参考 nginx服务器安装及配置文件详解@Sean’s Note nginx反向代理服务器的工作原理@CSDN nginx配置location总结及rewrite规则写法@segmentfault Nginx proxy pass简单用法@51CTO 最简单实现跨域的方法—-使用nginx反向代理@CSDN 一文弄懂Nginx的location匹配@segmentfault]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习07 数字组合总和]]></title>
    <url>%2F2019%2F06%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F02%20%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A007%20%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个不含重复数字的数组arr，指定个数n，给出目标和sum，判断是否含有由n个不同数字相加得到sum的情况 分析题目和LeetCode的39题和40题相似，我这个代码自我验证是对的，也不知道是否有问题。 先把《算法图解》入门看完，再刷LeetCode，刷到的时候回来重新看一下吧。 我现在的思路是，基线条件就是n === 1，这个时候的返回条件就是当前循环中的arr[i]与sum是否相等，如果相等就返回true，如果不相等就继续遍历，直到遍历结束，返回false 递归条件是对arr和n和sum同时修改，每次让n不断减少，缩小规模 代码123456789101112131415161718function getSum(arr, n, sum) &#123; if (arr.length &lt; n) &#123; return false &#125; for (let i = 0; i &lt; arr.length; i++) &#123; if (n === 1) &#123; if (arr[i] === sum) &#123; return true &#125; &#125; else &#123; const result = getSum(arr.slice(i + 1), n - 1, sum - arr[i]); if (result) &#123; return true &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS33 关于居中的总结]]></title>
    <url>%2F2019%2F06%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS33%20%E5%85%B3%E4%BA%8E%E5%B1%85%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于CSS中水平、垂直居中的总结 准备工作HTML结构： 123&lt;div class="container"&gt; &lt;span class="text"&gt;你好&lt;/span&gt;&lt;/div&gt; 公共样式： 12345678.container &#123; width: 300px; height: 300px; background: royalblue;&#125;.text &#123; background: darkgoldenrod;&#125; 水平居中的方法（1）使用text-align: center 对于行内元素，可以直接使用text-align: center来水平居中 123.container &#123; text-align: center;&#125; （2）使用margin: 0 auto 对于宽度确定的块级元素，可以使用margin: 0 auto来水平居中，原理和后面的绝对定位加margin: auto的原理类似，后面单独结合总结。 12345.text &#123; display: block; width: 100px; margin: 0 auto;&#125; （3）flex布局 如果不考虑兼容性，很完美的方案： 1234.container &#123; display: flex; justify-content: center;&#125; （4）grid布局 显然兼容性有着问题的方案： 1234.container &#123; display: grid; justify-content: center;&#125; （5）绝对定位+移动 父元素相对定位，子元素绝对定位，并且使用transfrom移动自身宽度的-50%（如果子元素的高度已知也可以通过margin向左移动自身高度的一半 12345678.container &#123; position: relative;&#125;.text &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; （6）绝对定位和margin: auto 1234567891011.container &#123; position: relative;&#125;.text &#123; position: absolute; left: 0; right: 0; width: 100px; margin: auto;&#125; 一定要指定子元素的宽度，否则子元素就会充满父元素 垂直居中的方法（1）vertical-align: middle 针对行内元素，并且需要有一个兄弟行内元素，撑满父元素： 12345678910.container:after &#123; content: ''; display: inline-block; height: 100%; background: aliceblue; vertical-align: middle;&#125;.text &#123; vertical-align: middle;&#125; （2）line-height === height 让父元素的height和line-height相等，一般适用于文字的居中 123.container &#123; line-height: 300px;&#125; （3）padding 适用于父元素高度不确定，或者说父元素高度是根据子元素高度确定的情况： 1234567/* container 不能指定 height */.container &#123; padding: 20px 0;&#125;.text &#123; background: darkgoldenrod;&#125; （4）绝对定位+移动 父元素相对定位，子元素绝对定位，并且使用transfrom移动自身高度的-50%（如果子元素的高度已知也可以通过margin向上移动自身高度的一半 123456789.container &#123; position: relative;&#125;.text &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; （5）flex布局 如果不考虑兼容性，很完美的方案： 1234.container &#123; display: flex; align-items: center;&#125; （6）grid布局 显然兼容性有着问题的方案： 1234.container &#123; display: grid; align-items: center;&#125; （7）display: table-cell + vertical-align: middle 1234.container &#123; display: table-cell; align-items: middle;&#125; 平时没怎么用，不知道有什么缺点呢~ （8）绝对定位和margin: auto 1234567891011.container &#123; position: relative;&#125;.text &#123; position: absolute; top: 0; bottom: 0; margin: auto; height: 30px;&#125; 一定要指定子元素的高度，否则子元素就会充满父元素。 利用margin: auto居中的原理123456789101112131415.father &#123; position: relative; width: 500px; height: 500px;&#125;.child &#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; width: 100px; height: 50px;&#125; 优点：兼容性好 缺点：子元素需要指定宽高（否则会充满父元素） 原理：以水平方向举例，垂直方向相同。 当绝对定位的元素只定义了一个方向属性时（比如left），并且元素没有利用width指定宽度，宽度是0；当同时指定了相反的两个方向的属性时且相等（left和right都为0），此时如果没有指定width，则宽度会充满父元素，自定宽度会沿着left摆放。 此时指定marign： 如果一侧定值，一侧auto，auto为剩余空间大小 如果两侧均是auto，则平分剩余空间，所以就居中了。 块级元素利用margin: 0 auto水平居中的原理也是这样。 参考 小tip: margin:auto实现绝对定位元素的水平垂直居中]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高20 日期选择器插件]]></title>
    <url>%2F2019%2F06%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F02%20Vue%E6%8F%90%E9%AB%98%2FVue%E6%8F%90%E9%AB%9820%20%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[以前收藏了一篇自己动手实现日期选择器的插件，最近没什么事，就想着仿照ElementUI的DatePicker，自己也写了一个简易的日期选择器，本以为不会很麻烦，实际动手才发现有很多问题需要解决。并且在写完之后，才发现可扩展性很差，距离ElementUI的水平差的很远，下一步就是把ElementUI的源码学习一下，看清楚自己的差距。 以前收藏了一篇自己动手实现日期选择器的插件，最近没什么事，就想着仿照ElementUI的DatePicker，自己也写了一个简易的日期选择器，本以为不会很麻烦，实际动手才发现有很多问题需要解决。并且在写完之后，才发现可扩展性很差，距离ElementUI的水平差的很远，下一步就是把ElementUI的源码学习一下，看清楚自己的差距。 结构我将这个日期选择做成了Vue的插件的形式，有三个文件： 123- index.js- MyDate.js- MyDatePicker.vue index.js很简单，只有一个方法intstall，在install里面注册了全局组件： 1234567import MyDatePicker from './MyDatePicker'export default &#123; install(Vue) &#123; Vue.component('MyDatePicker', MyDatePicker) &#125;&#125; MyDatePicker.vue是UI部分，在这里定义样式和交互事件，我将数据单独放到了MyDate.js中，以Class形式导出 数据部分我的顺序是先完成MyDate.js的数据部分，一个日期选择器基本结构如下： 最后导出一个二维数组，二维数组外层包含6个数组，对应日期选择器中的每一行的数据，内层数组又包含7个对象元素，对应周一到周日，这样相当于总共有42个元素，正好对应面板中的42个日期。 当选择一个日期后，首先通过new Date构造函数获得当前日期所在月的第一天及这一天是星期几 123// 当前选择日期所在月的第一天及这一天是星期几const firstDayOfCurrentMonth = new Date(this.current.year, this.current.month - 1);const firstDayOfWeek = firstDayOfCurrentMonth.getDay(); 要注意的是，new Date().getMonth()的范围是[0, 11]，和我们日常使用的月份是少1的。而我在current里面存的日期是为了显示所用的，已经加过1了，所以需要在上面减1 接下来，通过两层的遍历来生成我们所需要的二维数组，外层遍历是对应的是行数据： 12for (let row = 0; row &lt; 6; row++) &#123;&#125; 关键是内层数据，假设我们选择的就是2019年6月，6月1日是星期六，在二维数组的内部数组里面的七个元素，应该吻别对应[&#39;日&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;]，现在6月1日星期六，它位于数组的第七项，补齐这个数组的结果应该是： 1[5.26, 5.27, 5.28, 5.29, 5.30, 5.31, 6.1] JS的Date构造函数会自动对超出当前月份的日期进行转换，意思就是，当我们构造一个日期new Date(2019, 5, 0)，它会自动往前倒一天，生成的日期就是2019-05-31 所以上面的数组转为对应的以6月为天数就是： 1[-5, -4, -3, -2, -1, 0, 1] 所以当前遍历的范围就是[-5, 1]，起始点与6月1日的星期几存在这样的关系： 12// 内层遍历起始点let weekLoopStart = -firstDayOfWeek + 1; // -5 结束点是7 + weekLoopStart - 1 这样当内层遍历结束一次时，将weekLoopStart加7，就可以生成新的一行数据了： 1[2, 3 4, 5, 6, 7, 8] 所以两层遍历的基本形式就是： 12345678910// 行数据for (let row = 0; row &lt; 6; row++) &#123; const rowDate = []; // 列数据 for (let weekDay = weekLoopStart; weekDay &lt;= 7 + weekLoopStart - 1; weekDay++) &#123; // 生成需要的对象 &#125; weekLoopStart += 7; this.dates.push(rowDate)&#125; 有点绕，而且可扩展性也不是很好，还是太笨了。 在内层遍历生成的对象有这样几个属性： 1234567891011const targetDate = new Date(this.current.year, this.current.month - 1, weekDay);const day = targetDate.getDate();const month = targetDate.getMonth() + 1;rowDate.push(&#123; date: targetDate, value: format(targetDate), label: day, key: weekDay, isCurrentMonth: month === this.current.month, isToday: +targetDate === +this.today&#125;) date是标准的日期对象，value是选择后用于展示的格式化的日期，label是在日历中选择的日期，key是整个遍历过程中它实际的标号，isCurrent用来判断这个日期是否属于当前月份，还是以-5这样的格式转换为前一个月的日期（这样的日期在面板上是有不同的样式），isToday用来标识今天的日期： 这样就生成了一个二维数组放到了this.dates这个实例属性中 当改变选择的月份，面板的日期也会随着变化，对应的实例方法就是changeDate，因为刚才的生成数据的getDateArray方法都是依赖于this.current来进行的，所以只需要改变this.current的值，然后重新执行getDateArray方法就行了 12345678// 改变日期changeDate(date = new Date()) &#123; this.current = &#123; year: date.getFullYear(), month: date.getMonth() + 1 &#125;; this.getDateArray()&#125; 这样基本的数据就完成了。 UI部分UI部分是在.vue的单文件组件完成的，面板使用了&lt;table&gt;标签，在date里面引入MyDate的实例，其余都声明为计算属性，与MaDate的实例相关联，这样形成了这样的变化过程： 1234graph LR用户点击--&gt;改变实例属性改变实例属性--&gt;计算属性改计算属性改--&gt;UI界面改变 有三个事情需要记录一下 （1）设定单元格样式 12345&lt;tr v-for="(row, rowIndex) in tbody" :key="'row-' + rowIndex"&gt; &lt;td v-for="cell in row" :key="cell.key" @mousedown="selectDate(cell)"&gt; &lt;span :class="tableCellClass(cell)"&gt;&#123;&#123;cell.label&#125;&#125;&lt;/span&gt; &lt;/td&gt;&lt;/tr&gt; 因为单元格的原始和遍历的数据cell有关系，如果卸载模板中会有一大堆的代码，不太直观，用计算属性生成一个对象有没有办法传入参数，所以可以用一个method，返回一个对象传给:class 12345678// 设定日期单元格样式tableCellClass(cell) &#123; return &#123; 'not-current-month': !cell.isCurrentMonth, today: cell.isToday, selected: cell.value === this.selectedDate &#125;&#125;, （2）动画效果 ElementUI的动画效果是向上滑出 它是通过Vue的&lt;transition&gt;组件实现的，而&lt;transition&gt;是用JS实现的动画，使用了requestAnimationFrame的API，很流畅，而且便于复用。找个时间还是要好好看一些Vue的源码，学习一下。 我使用了CSS动画来实现，当选择框出现时，添加一个类container-visible，将原本的height由0改为320px，同时将opacity由0改为1，同时添加了will-change和transform: translateZ(0)来提升性能： 12345678910111213141516171819202122.date-container &#123; position: absolute; left: 0; top: 46px; color: #606266; box-shadow: 0 2px 12px 0 rgba(0, 0, 0, .1); background: #fff; border-radius: 4px; line-height: 30px; margin: 5px 0; transition: all 0.5s ease; border: 1px solid #e4e7ed; height: 0; overflow: hidden; will-change: height; opacity: 0; transform: translateZ(0);&#125;.container-visible &#123; height: 320px; opacity: 1;&#125; 实现的效果还可以，但是有两个问题，一是不太好复用，而是需要改为固定的高度，如果面板高度变化，效果就有可能有偏差 （3）第三个问题是日期选择框的出现和隐藏，它具体的逻辑如下： 点击输入框，出现选择框 点击输入框和选择框之外的部分，选择框消失 点击输入框和选择框之内的部分，选择框不消失 点击选择框的快速选择月份（那几个小箭头），选择框发生相应改变，不消失 点击选择框的具体日期，选择框消失，选择成功 我选用的方案是使用&lt;input&gt;的focus和blur事件，发生两个事件时，改变控制选择框是否显示的变量containerVisible focus没有问题，但是blur有着比较大的问题，首先遇到的问题时，当点击选择框的按钮功能和时期时，没有触发对应的功能，选择框就消失了（以前在开发业务的时候遇到过类似的问题），这主要是因为blur事件发生的时机： 1234graph LRmousedown--&gt;blurblur--&gt;mouseupmouseup--&gt;$&#123;click&#125; 在click事件发生之前blur事件就发生了，导致click事件没有发生时，元素就隐藏了，click事件无效。 所以像以前一样，将选择框绑定的click事件改为了mousedown事件，这样做的效果是，点击日期能够选择了，并且选择事件执行了，并且之后选择框失效了，这时候上面的五条逻辑满足了1/2/5，但是3/4又出问题了，点击选择框的小按钮，选择框意外消失了。 之所以这样，是因为mousedown事件之后，blur事件执行，导致选择框小事，我们要做的是在mousedown之后，不触发blur事件，所以应该使用peventDefault方法（注意不是stopImmdeiation，因为不是冒泡导致的），Vue中提供的修饰符是prevent，所以在所有的mousedown事件后面添加上修饰符prevnet： 123&lt;button type="button" class="btn next-month-btn" @mousedown="changeMonth(1)"&gt; &lt;span class="iconfont icon-el-icon-arrow-right"&gt;&lt;/span&gt;&lt;/button&gt; 这样条件4满足了，但是3不行，所以需要在整个选择框的容器上添加一个mousedonw事件，并且使用prevnet修饰符，里面的点击事件只需要使用mousedown就可以了 12&lt;div class="date-container" :class="&#123;'container-visible': containerVisible&#125;" @mousedown.prevent&gt;&lt;/div&gt; 这样基本上就成功了，但是还是有一些小瑕疵，一个问题就是blur事件发生的过于容易，比如我点击浏览器之外的桌面部分，blur事件也会发生，选择框会消失，而ElementUI的并不会消失，还有就是绑定了没有必要的点击事件，不好复用，并且不知道如果同时有多个弹出框的时候还不会有其他的问题。 ElementUI是把这块单独提出了一个方法，位于element/src/utils/clickoutside.js，它对这种情况的点击事件做了统一的处理，主要的思路就是在document绑定了统一的点击事件，通过收集此刻的弹窗元素到一个队列中，隐藏这个队列中的元素，它没有使用blur事件，更可控，也更适合更多的元素。 优化这个日期选择器插件的基本功能能够满足，但是如果作为ElementUI那样的轮子，还差的很多，扩展非常困难（快速选择月、年的面板我就没有做） 下一步的计划就是首先学习clickoutside的实现，然后学习ElementUI的源码，这个计划也好久了，要尽快执行啊~ 最后，代码都在这里。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>日历</tag>
        <tag>blur</tag>
        <tag>focus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 浏览器渲染优化]]></title>
    <url>%2F2019%2F06%2F17%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F04%20%E4%BC%98%E8%BE%BE%E5%AD%A6%E5%9F%8E%2F01%20%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优达学城浏览器渲染优化的学习笔记。 第一课 关键渲染路径Web网页应该尽量避免不稳定性。 多数设备刷新屏幕的频率为每秒60帧，即60fps 渲染流程 生成DOM树，（Parse HTML） 生成CSS树 合并成为渲染树（Recalculate Styles），计算样式 计算布局，生成盒模型（Layour/Reflow） 将页面由矢量转为光栅（Paint） 处理复合层（compositive layer） 注意，复合层上方的元素也会变为单独的图层（隐式复合） 对于样式改变，导致的渲染流程： 对于JavaScript部分，指的是能够引起外观的变化，不仅可以通过JavaScript来改变页面外观，也可以使用CSS动画或者Web Animation API来实现。 改变外观后可能会需要重新计算Style属性（比如媒体查询等），有可能不需要。 改变的CSS属性不同，后续触发流程也不同。 改变宽度、高度、位置等几何结构，会触发后续的Layout、Paint、Composite步骤 改变背景图片、颜色、阴影等不涉及几何几何尺寸的属性，不会再触发Reflow，只会触发后续Paint、Composite步骤 改变transform、opacity等会生成单独的图层的属性，不会再触发Reflow和Repaint，只需触发Composite步骤 CSS属性的改变应该尽可能触发少量的工作，避免Reflow和Repaint，提高性能。 练习（1）第一题 渲染树中只包含了最终显示在屏幕上的元素内容，它与DOM树并不完全相同，比如它不会包含display:none的元素，不会包含&lt;head&gt;标签中的元素。 所以这道题目的答案是A，而其他的属性，虽然不会占据屏幕空间，但是还是属于页面的一部分，仍然会包含在渲染树中。 （2）第二题 无论是改变body还是改变其中内部的div的宽度，浏览器都会做出最坏的打算，就是需要对全部DOM元素的样式进行计算，对整个文档进行Reflow和Repaint。所以答案是C （3）第三题 题目中是一个弹性部局的容器（flex），但改变容器的大小，内部元素的尺寸会随机发生变化。当新的页面渲染时，浏览器会经历那些步骤？ 弹性容器的尺寸发生变化，内部元素的尺寸会发生变化，但是它们的Style并没有发生变化（因为宽度都是弹性确定的，而非固定值，并且不涉及媒体查询短点改变样式的条件），所以不会重新计算Style，但是由于宽度发生了变化，所以后续的Layout、Paint、Composite都会执行。 （4）第四题 会触发Layout+Paint+Composite的属性很多，比如margin、width等 触发Paint+Composite的属性有color、background等 触发Composite的属性变transform、opacity等 可以通过CSS Triggers网站来查找CSS属性分别会触发哪些过程。 第二课 App 生命周期网络应用的生命周期包含了四个主要阶段：RAIL 按照时间先后顺序： Load， 加载阶段，有大概1秒的时间来渲染网页，然后用户的关注级别降低，这个阶段要下载和加载关键资源 Idle，闲置阶段，加载后进入闲置阶段。这时候适合执行不太重要的工作，确保在此之后出现的任何舞动都能及时作出响应，闲置时间在50毫秒左右，以便在用户开始交互时立刻停止闲置阶段 Animations，动画阶段，例如用户滚动屏幕或者出现动画，只有16毫秒的时间来渲染一帧，这样才能保证60fps Responsiveness，响应阶段，人类大脑可以忍受100毫秒的停顿时间，更久的话就会让人觉得卡顿不流畅。这就意味着应用要以某种方式在100毫秒内对用户输入做出响应。 第三课 卡顿杀伤性武器学习使用Chrome的Devtools中的性能分析面板Performance（以前的Timeline） 现在的面板和课程讲解中已经发生了很大声变化，但是大体思路是相同的，录制之后再中间的Main的下拉部分去分析什么导致的卡顿 它是倒火焰图，上方的行为调用了下方的命令，不同的行为有不同的颜色表示，黄色是JavaScript脚本，紫色是重新计算样式，绿色是绘制 可以找到哪个行为事件过长（大于16ms）导致卡顿，然后进行分析、优化 第四课 JavaScriptJavaScript运行时并不是我们编写的样子，而是通过JavaScript解释器提供的即时编译器，编译为更有效率的代码来执行的，所以编写代码时没有必要去做一些while和for谁更快之类的微优化。 JavaScript是渲染管道的开始，后续有重新计算样式、重排、重绘、复合的过程。要想不卡顿需要达到60fps，所以每一帧只有16ms的时间，分配给JavaScript部分的也就只有10-12ms。所以在每一帧渲染开始时，应当尽早执行JavaScript函数，这样才能够有足够的时间完成后续的过程。 在执行JavaScript动画时，应当使用requestAnimationFrame来代替setTimeout/setInterval，因为后者不会关注渲染管道的流程，而前者会自动的在每一帧开始时运行JavaScript函数。 12345function animate() &#123; // do something here requestAnimationFrame(anmiate)&#125;requestAnimationFrame(anmiate) 可以使用上节课提到的Chrome的performance面板分析JavaScript的运行时间和内存占用情况。JavaScript会自动进行内存回收，所以我们不必担心指针、删除对象、局部变量的内存占用问题。可以通过performance分析是否存在内存泄漏等情况。 当有大量耗时的计算任务时，可以考虑使用Web Worker，将耗时的任务移动到Web Worker线程进行计算，而主线程（Main Thread）负责渲染流畅的UI。 Web Worker可以在不同于主窗口的线程下，完全独立的操作系统线程下手运行JavaScript。主线程与Web Worker线程之间通过postMessage和onmessage事件进行通信，各个Worker之间不能通信。 主线程:12345const myWorker = new Worker('./scripts/worker.js');myWorker.postMessage(data)myWoker.onmessage = function(e) &#123; console.log(e.data)&#125; Worker线程 worker.js 1234567// 通过importScipts导入其他脚本importScipts('other.js')this.onmessage = function(e) &#123; console.log(e.data) this.postMessage(data)&#125; 第五课 样式和布局重新计算样式（Recalculate Style）造成的性能代价与元素数量基本上是线性增长的关系。 可以采用BEM规则来为CSS的类命名，更加模块化、可复用、可读性好，且新跟那个好（因为使用class选择器的关系） BEN中的B是Block，指一个UI构成单元，E是Element，是B的后代，M是Modifer，表达状态，比如three、current、active等。 BEM使用连接符连接BEM，但不能使用相同的连接符连接BEM，例如使用__连接BE，使用_连接EM，使用-做连字符，比如header__item-list_active 第二个CSS选择器是速度快的，它只使用了BEM规则的类选择器，不仅性能最好，而且可读性良好。 选择器性能优化有时候不如良好的布局导致的节点数减少带来的性能提升更高。 当在一个循环中，先访问一些尺寸、位置等会导致Layout的属性，然后再改变尺寸，重新计算样式计算，会导致强制布局，当反复如此，会出现布局抖动。 应当尽量避免强制布局，在循环外读取属性，在循环内改变尺寸，不会造成强制布局。 第六课 合成和绘制可以使用Chrome的分析工具来分析页面的绘制过程，但是课程中的Show paint rectangles已经不再原来的位置了 为了分析绘制过程，需要在开发者的工具的More tools里面找到Rendering，在打开的Rendering面板中勾选Paint flasing选项： 勾选之后，它会告诉你绘制流程在页面上的什么地方发生了，何时发生了。当页面有元素被绘制时，对应的元素会显示为绿色： 还可以使用Paint Profiler来确定页面的那些区域被绘制了，何时绘制的。但是新版本的Chomre开启Paint很麻烦。首先勾选Enable advanced paint instruments(slow) 然后点击Record进行录制，录制结束后找到绿色的Paint块并点击： 点击之后再下方出现了Paint Profiler的选项： 可以根据左侧的命令结合上方的新的时间线和右侧的绘制结果，查看每一刻的绘制情况和绘制命令。 绘制之后的流程就是合成，就是将多个图层合并成为一个，当改变一个图层时，不会引起其他图层的绘制。 看下面的练习题，左侧是一个导航栏，那些元素应该放在一个图层上？ 一起移动的元素，应该放在一个图层上。 Chrome的性能分析记录中有两个与图层合成有关，一个是Update Layer Tree。当Chrome的引擎需要知道页面的哪个图层时就会出现该记录，查看元素的样式，弄清楚需要多少图层，另一个是Compositie Layers，浏览器将页面合成到一起发送给屏幕。 图层越多，图层管理和合成花费的时间就越多，所以需要在减少绘制时间和增加图层管理时间二者之间做出权衡。 图层管理大多数情况下是浏览器自动完成的，但是当遇到绘制问题时，可以考虑将某个元素单独放到一个图层中。在创建图层之前，应该看一下看元素是否已经有了自己的图层，在刚才的Rendering的功能面板在宏，勾选上Layers borders选项 勾选之后，页面上除了绿色的框框，还会出现褐色的框框，绿色框框是浏览器对图层的划分，我们没有办法控制，橘色的框框表示元素位于自己的合成图层上。 如何创建属于自己的图层呢？ 一般来说有两种方式： will-change，使用will-change，属性值可以是transform、left、top等外观属性，浏览器会根据这些提示为这些属性进行布局和绘制流程，由于浏览器创建图层也是要耗费性能的，使用will-change最大的好处就是避免浏览器匆忙创建图层带来的性能代价。 使用3D移动transform: translateZ(0)或者transform: translate3D(0, 0, 0) 这两种方式是在为静止的元素（不改变其原始位置）创建单独图层，实际上还有一些其他的方式也会创建单独的图层，比如： transform的对应移动，transalte、rotate、scale等 video/canvas/iframe等元素 opacity改变 position: fixed filter 有合成层后代，并且自身overflow不为visible（隐式合成） Chrome创建层的标准是什么呢？完整的标准： What else gets its own layer? Chrome’s heuristics here have evolved over time and continue to, but currently any of the following trigger layer creation: 3D or perspective transform CSS properties &lt;video&gt; elements using accelerated video decoding &lt;canvas&gt; elements with a 3D (WebGL) context or accelerated 2D context Composited plugins (i.e. Flash) Elements with CSS animation for their opacity or using an animated transform Elements with accelerated CSS filters Element has a descendant that has a compositing layer (in other words if the element has a child element that’s in its own layer) Element has a sibling with a lower z-index which has a compositing layer (in other words the it’s rendered on top of a composited layer) 可以参考这篇文章，讲得不错。 可以使用Layesr工具来查看页面中有多少个图层： 注意要避免隐式提升，下图中的totes promited成为单独图层的原因就是它覆盖在了于具有单独图层的元素的上方 所有元素都提升为单独的图层会消耗大量内存，并花费很多时间，在移动设备上问题更加明显。所以将元素提升到图层上时一定要谨慎，因为有可能会不小心由于存在重叠而创建了大量的其他的图层。 总结如何提升性能： （1）JS 避免多次访问尺寸、更改尺寸，导致布局抖动、强制布局 使用requestAnimation来代替setTimeout/setInterval创建动画 使用Web Worker，将复杂的计算过程放到子线程，避免主线程（渲染线程）的卡顿 （2）CSS 使用will-change提示浏览器将要发生的变化，并且创建单独的图层 使用3D变化来创建单独的图层 使用transform和opacity来创建单独的图层，实现动画 更多的使用类选择器（BEM）来提升选择元素的 避免隐式提升创建太多的图层 分析工具： Performance Rendering Laryouts 参考 浏览器渲染优化@优达学城]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题32 生成PDF]]></title>
    <url>%2F2019%2F06%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9832%20%E7%94%9F%E6%88%90PDF%2F</url>
    <content type="text"><![CDATA[JavaScript生成PDF方案调研，以及PDFKit调研。 生成pdf的方案（1）JSPDF(前端生成 ) 优点：不需要服务端安装无头浏览器，使用CSS方便控制样式，生成的PDF文字可复制 缺点：对中文支持不好 （2）PDFKit( 服务端生成) 优点：服务端直接解决，生成的PDF文字可复制，通过引入字体，可支持中文 缺点：样式控制复杂 （3）node-html-pdf(服务端生成) 优点：服务端通过控制HTML模板生成PDF，支持中文，样式控制方便 缺点：不支持图片，需要安装无头浏览器，性能有隐患 （4）JSPDF + HTMLToCanvas(前端生成) 优点：样式控制方便，支持中文，比较美观 缺点：生成的PDF内容是图片，无法复制 （5） 使用打印(前端生成) 优点：简单，代码量少 缺点：需要引导用户，且不美观 PDFKit简介PDFKit使用来在Node服务端生成PDF文件的JS包（也支持在浏览器使用），它可以轻松生成复杂的、多页的、可打印的PDF文档。 它的API是链式语法，与操作Canvas的API有一些类似 安装： 1npm install pdfkit -S 创建PDFKit文档很容易： 12const PDFDocument = require('pdfkit');const doc = new PDFDocument(); PDFDocument实例是可读的Node流，它不会自动的保存，但是可以使用pipe方法将输出的PDF文档传递给另一个可写的Node流。当PDF文档编写成功后，调用end方法来结束流程。下面的例子来展示如何将生成的文档传递给PDF文件或者HTTP响应： 1234567doc.pipe(fs.createWriteStream('/path/to/file.pdf')); // 写入PDF文件doc.pipe(res); // 传递给HTTP响应// 用后面介绍的API来为PDF添加内容// 结束编辑，关闭流doc.end(); 在浏览器中使用PDFKit的0.6版本后支持在浏览器中使用，有两种方法在浏览器端使用PDFKit，一种是在浏览器端使用browserify加载Node模块，另一种方法是直接使用PDFKit的预编译版本，可以从Github上下载。 在浏览器端使用PDFKit和Node中使用的唯一区别就是输出结果，在浏览器端输出结果必须是浏览器支持的格式，比如Blob。Blob格式可以允许浏览器在一个iframe中直接展示生成的PDF文档，或者将PDF上传到服务器，或者让用户下载它。 将PDFDcument输出为Blob格式，需要将他传递给blob-stream，这个模块可以将Node的流转换为Blob。下面的例子使用了Browserify来加载PDFKit和blob-stram（如果没有使用Browserify可以直接使用&lt;script&gt;标签代替） 1234567891011121314151617181920212223// 引入依赖const PDFDocument = require('pdfkit');const blobStream = require('blob-stream');// 创建文档const doc = new PDFDocument();// 传递给Blobconst stream = doc.pipe(blobStream());// 在这里添加PDF的内容// 结束时得到的是Blobdoc.end();stream.on('finish', function() &#123; // 将blob转换为PDF文档 const blob = stream.toBlob('application/pdf'); // 或者得到Blob URL，直接在浏览器中展示 const url = stream.toBlobURL('application/pdf'); iframe.src = url;&#125;); 添加页面PDFKit文档的第一页是在创建文档时自动添加的，除非使用了autoFirstPage: false选项。后续的页面必须手动添加： 1doc.addPage() 可以使用pageAdded事件，让每个页面创建后都添加上相同的内容： 1doc.on('pageAdded', () =&gt; doc.text("Page Title")); 可以通过为addPage传递参数设置页面的尺寸、方向： layout，页面方向，可取值portrait（默认值）/landscape size，页面尺寸，取值是一个数组[宽, 高]，单位是PDF的点（1/72英寸）。可以传入字符串指定一些预设值，默认值是letter margin，设定页边距，可以设为一个数字，那么各边距都等于它，也可以设为一个对象，分top/left/bottom/right四个属性分别设定各边距 1234567891011121314// Add a 50 point margin on all sidesdoc.addPage(&#123; margin: 50&#125;);// Add different margins on each sidedoc.addPage(&#123; margins: &#123; top: 50, bottom: 50, left: 72, right: 72 &#125;&#125;); 给PDFDocument构造函数传递页面参数对象，可以设置每一页的默认尺寸和布局，它会被每个addPage传递的页面参数覆盖。 bufferPage有的时候需要在后面的页面完成后回到前面的页面，对前面的页面进行修改，可以在PDFDocument构造函数传递一个参数bufferPages: true，来手动控制页面流。 一般这个情况可能不多见，具体可以参考文档这部分内容。 设定文档基础信息基础信息包括标题、作者等，可以通过对doc.info赋值，也可以在创建文档时传递参数实现。可以设定的基础信息包括（需要首字母大写）Title/Author/Subject/Keywords/CreationDate/ModDate 加密和访问权限可以对PDF加密，并且使用密码打开文件。也可以设定PDF文件的访问权限。具体内容参考文档。 矢量图形PDF格式兼容矢量图形，PDFKit提供了类似于HTML5 Canvas的API来创建矢量图形。图形通过一些列的直线和曲线构成，看一个例子： 123456doc.moveTo(0, 20) // 设定起点 .lineTo(100, 160) // 直线 .quadraticCurveTo(130, 200, 150, 120) // 二次曲线 .bezierCurveTo(190, -40, 200, 200, 300, 150) // 贝塞尔曲线 .lineTo(400, 90) // 直线 .stroke(); // 画 SVG路径PDFKit包含了SVG路径解析器，所以可以使用SVG路径画出一个图形，上面的图形使用SVG路径同样可以实现： 12doc.path('M 0,20 L 100,160 Q 130,200 150,120 C 190,-40 200,200 300,150 L 400,90') .stroke() 图形小助手PDFKit提供了一些封装好的方法来画出一些常用的图形，包括： 12345678910// 长方形 rect(x, y, width, height) // 圆角长方形roundedRect(x, y, width, height, cornerRadius) // 椭圆ellipse(centerX, centerY, radiusX, radiusY = radiusX) // 圆形circle(centerX, centerY, radius) // 多边形polygon(points...) 使用ploygon方法通过传输一系列由横纵坐标组成的数组，会创建一系列的直线，并连起来成为多边形： 12doc.polygon([100, 100], [200, 200], [200, 300]) .stroke() 边框和填充样式使用storke是画线，使用fill画出来的是填满空间的实体，使用fillAndStroke同时实现： 1doc.polygon([100, 100], [200, 200], [200, 300]).fillAndStroke('green', 'red') PDFKit可以设定的属性有： lineWidth lineCap lineJoin miterLimit dash fillColor strokeColor opacity fillOpacity strokeOpacity 其中lineCap用来设定直线的端点形状，可取值有butt/round/square，lineJoin用来设定直线交汇处的形状，可取值有miter/round/bevel 虚线使用dash方法画虚线： 123doc.circle(100, 50, 50) .dash(5, &#123; space: 10 &#125;) .stroke(); dash接受的第一个参数是每一段虚线的长度，第二个参数是一个选项对象，其中space属性用来指定每个虚线段的间隔，默认值与虚线段长度相等，phase属性指定虚线段的起点（不知道有什么用） 当使用dash方法后，后续的直线都是虚线的，可以使用undash方法恢复实现： 123456789doc.moveTo(100, 50) .lineTo(100, 150) .dash(5, &#123; space: 10, phase: 10 &#125;) .stroke();doc.moveTo(100, 150) .lineTo(300, 150) .undash() .stroke(); 颜色可以使用一个数组表示RGB或者CMYK颜色，或者字符串的16进制颜色或者CSS颜色的名称 fill和stroke方法的参数可以指定颜色，也可以使用fillColor和strokeColor来指定颜色，第一个参数是颜色，第二个参数是透明度 也可以使用fillOpacity、strokeOpacity或者opacity来单独指定透明度 渐变使用linearGradient和radialGradient实现渐变色，详见文档。 保存恢复图形堆栈图形堆栈是所有创建的样式和移动的快照，每次调用save方法当前的图形堆栈就会被推入一个堆栈中，当调用restore方法后，堆栈中的最后一个状态就会被应用到环境中。 所以，你可以保存状态，改变一些样式，然后恢复到之前的状态。 移动通过移动，可以再不改变图形本身的基础上，改变图形的样式。有三种移动的类型可用：translate/rotate/sacle 详见文档。 剪切途径剪切与填充（fill）和连线（stroke）不同，它是一个蒙版，会隐藏掉图形中不想要的部分。 所有落在剪切路径内部的图形都是可见的，外部的都是不可见的。 123456789101112// Create a clipping pathdoc.circle(100, 100, 100) .clip();// Draw a checkerboard patternfor (let row = 0; row &lt; 10; row++) &#123; for (let col = 0; col &lt; 10; col++) &#123; const color = (col % 2) - (row % 2) ? '#eee' : '#4183C4'; doc.rect(row * 20, col * 20, 20, 20) .fill(color); &#125;&#125; 结果： 想要取消剪切，需要在clip之前调用save方法，完成剪切部分的操作后调用restore方法。 文字使用text方法添加文字 1doc.text('Hello world!') 每次调用text方法都会另起一行，并且自动与之前行的位置对其。可以为text方法传两个参数，指定其位置。 12doc.text('hello1');doc.text('hello2').text('hello3', 0, 0) 可以调用moveDown或moveUp方法来按行移动 文字换行和对其text方法接受一个对象作为参数，用来指定一些配置项。 在不传递任何参数的情况下，text方法生成的文字横向沿着页面的左边距排放，纵向沿着页面上边距摆放，后续文字排在已有文字的下方。 PDFKit会根据文字内容，自动添加下一页，无需手动控制。 PDFKit还提供了文字折行的功能。文字会自动换行，除非指定lineBreak为false。默认情况下文字遇到页面边距会换行，但是指定width属性会让文字按照不同的宽度换行。如果指定了height属性，文字会调整到能放下的最多的行数，多余的行会被剪切 123doc.text(t, &#123; width: 200&#125;) 1234doc.text(t, &#123; width: 200, height 200,&#125;) 当文字在允许换行时，可以通过align属性指定对其方式，可取的值有left/right/center/justify 文字样式text接受一系列的参数来指定文字样式。 ellipsis为true时用来指定当文字太长时用省略号来代替多余的文字，可以传入字符串指定代替的字符 使用columns和columnGap来将文字按列排布 12345678doc.fillColor('red') .text(t, &#123; columns: 3, columnGap: 15, height: 100, width: 300, align: 'justify'&#125;); 文字测量当文档需要精确的布局时，需要知道一段文字的尺寸，可以使用widthOfString(text, options)和heightOfString(text, options)方法 这两个方法不会绘制文字，只会返回测量后的尺寸。 列表使用list方法可以创建无需列表，第一个参数是一个由各项文字组成的数组，后续参数可以指定横纵坐标。 可以通过嵌套数组创建嵌套列表 富文本在text的选项参数里面参数continued为true，可以生成连续的文字 12doc.fillColor('red').text('123', &#123; continued: true &#125;) .fillColor('green').text('456'); 字体PDFKit默认支持14种字体，使用font方法可以直接使用字符串指定这14种字体： ‘Courier’ ‘Courier-Bold’ ‘Courier-Oblique’ ‘Courier-BoldOblique’ ‘Helvetica’ ‘Helvetica-Bold’ ‘Helvetica-Oblique’ ‘Helvetica-BoldOblique’ ‘Symbol’ ‘Times-Roman’ ‘Times-Bold’ ‘Times-Italic’ ‘Times-BoldItalic’ ‘ZapfDingbats’ 除了这14种字体，PEFKit也支持外嵌字体，支持的字体格式有.ttf/.otf/.ttc/.dfont 在默认情况下，PDFKit是不支持中文的，所以需要上传包含中文的字体并指定，下载了开源的思源宋体并上传到文件夹中： 1234doc.font('./fonts/Source-Han.otf');doc.text('你好');doc.text('你也好'); PDFKit也支持注册字体，这样就不必每次使用字体时都输入一大串的路径名了： 12345678// 注册字体doc.registerFont('source font','./fonts/Source-Han.otf');// 使用字体doc.font('source font');doc.text('你好');doc.text('你也好'); 图像通过image方法来创建图像，图像的形式可以是路径、buffer对象、BASE64编码后的data uri。PDFKit支持JPEG和PNG格式 如果没有提供X/Y参数，图像会在当前文字流的位置（在最后一行文字后）渲染。如果提供了坐标，图像会在指定的位置渲染。 image方法可配置的参数有： width/height，指定图像的宽高，当都未指定时会按照图片的实际尺寸渲染，如果指定了某一方向的尺寸，图像会按照指定方向的尺寸按原比例缩放，如果都指定了，图像会拉伸至指定尺寸 sacle，对图像进行缩放 fit，接受一个数组，图像以这个数组提供的宽度和高度中较小的尺寸进行缩放（类似CSS的background-size的contain属性），会留白 cover，接受一个数组，图像以这个数组提供的宽度和高度中较大的尺寸进行缩放（类似CSS的background-size的cover属性），会剪切 注释PDF中的注释是具有可交互特性的文字，比如可点击的链接、注释或者高亮、下划线、删除线等文字样式。支持的注释有： 要注意的是，这些文字样式都不是直接加载文字上，而是以矩形的方式覆盖到文字上。所以使用的时候需要使用widthOfString计算出要添加注释的文字的宽度，使用currentLineHeight计算出当前的行高。 还要注意注释的堆栈顺序，比如添加link，需要保证link是最后一个被添加的，否则会被其他的注释覆盖，导致无法点击。 123456789101112// Add the link textdoc.fontSize(25) .fillColor('blue') .text('This is a link!', 20, 0);// Measure the textconst width = doc.widthOfString('This is a link!');const height = doc.currentLineHeight();// Add the underline and link annotationsdoc.underline(20, 0, width, height, &#123;color: 'blue'&#125;) .link(20, 0, width, height, 'http://google.com/'); 对于比较常用的链接、下划线，可以直接在text方法的选项中添加，更为方便： 1234567doc.fontSize(20) .fillColor('red') .text('Another link!', 20, 0, &#123; link: 'http://apple.com/', underline: true &#125; ); pdfmake后来又发现了PDFMake，它是基于PDFKit的基础上做的封装，可以直接生成表格，神器一个，方便极了（本来想借着做项目的机会，在PDFKit的基础上封装一个做表格的轮子，这下省了）。文档在这里。 它也支持浏览器端的使用，暂时先不管它，来看Node端的使用。 安装1npm i pdfmake -S 使用不想再像pdfKit把文档在过一遍了，官网在这里，Gihutb的仓库里上也给出了一系列的例子和结果展示，还有可在线编辑的例子。官网的文档并不是很详细，具体的API和用法可以再上面的两个例子里找到。 pdfmake基本上把pdfkit链式调用的API改为了面向对象（？）的API，其实就是传入一个大对象作为参数，然后就没有然后了，PDF就生成了。 直接看例子吧，我要生成的DEMO是这样的： 从上到下一点点来吧 主流程它的使用方法和PDFKit类似，都是需要新建一个文档的实例，然后传入一个参数对象： 12345678910111213const fs = require('fs');const PdfPrinter = require('pdfmake');// 创建实例const printer = new PdfPrinter();// 参数对象const docDefinition = &#123;&#125;const pdfDoc = printer.createPdfKitDocument(docDefinition);pdfDoc.pipe(fs.createWriteStream(`document-$&#123;Date.now()&#125;.pdf`));pdfDoc.end(); 按照这个流程就可以生成一个空白的PDF文档，我们要做的就是编辑docDefinition这个对象，添加PDF的内容，docDefinition中可以添加的属性有： 123456const docDefinition = &#123; content: [], defaultStyle, styles, watermark&#125;; content是一个数组，其中的每一个对象元素（或者是字符串）都代表要添加到PDF的一项内容，defaultStyle是文档的默认样式设置，styles是注册样式，定义在这个对象中的样式就可以直接在添加内容时的style属性使用，利用样式的复用，watermark用来给文档添加水印。 这些这是我这个DEMO中用到的内容，可以根据实际情况改变。 接下来要做的就是一些文档的准备工作。 字体pdfMake默认支持的字体和PDFKit是相同的，也就是说也不支持中文字体，需要手动引入包含中文的字体（一般中文字体包都在10M以上，所以这也是这个方案在浏览器端使用的一个很难解决的问题） 手动引入字体的方法是在新建实例的时候参数一个字体定义的对象，每一个属性对应一种字体，每个字体又有bold/normal/italics/bolditalics几种预设的分类，也是根据需要引入。 12345678910111213// 引入字体const fonts = &#123; sourceHan: &#123; normal: './fonts/Source-Han.otf', &#125;, PingFangSC: &#123; normal: './fonts/PingFang-SC-Regular.ttf', bold: './fonts/PingFang-SC-Bold.ttf', &#125;&#125;;// 创建实例const printer = new PdfPrinter(font); 默认样式在default定义默认样式，会应用到全局，可以被单独定义的样式覆盖： 1234567// 全局样式const defaultStyle = &#123; font: 'PingFangSC', fontSize: 10, color: FONT_COLOR, lineHeight: 1.2&#125;; 注册预置样式实际上这个步骤应该是一边添加内容一边完成的，将能复用的样式提出来，放到这里，也便于后期维护： 123456789// 预置样式const styles = &#123; tableTitle: &#123; fontSize: 20, margin: [0, 20, 0, 10], bold: true &#125;, tableHeader: &#123; bold: true, fontSize: 12, color: TABLE_HEAD_COLOR &#125;, dangerLabel: &#123; lineHeight: 1, color: '#F14D58', background: '#F2E6E7' &#125;, dangerText: &#123; lineHeight: 1, color: '#F14D58' &#125;, safeLabel: &#123; lineHeight: 1, color: '#34BA3B', background: '#E1F8E9' &#125;, safeText: &#123; lineHeight: 1, color: '#34BA3B', &#125;&#125;; 使用的时候只需要在style选项中使用属性名即可： 1&#123; text: '检测项', style: 'tableHeader' &#125; 水印可以使用watermark选项添加水印，可以定义的包括颜色、家族、透明度、文本等： 1234567// 水印const watermark = &#123; text: '隐私信息管理平台', color: '#EEE', opacity: 0.1, bold: true,&#125;; 水印的尺寸是不能直接设置的，它会默认从文档左下到右上，在版本更新之前，如果想要调整水印尺寸，那么有一个hack的办法，就是为水印的文本添加空格，用不可见的空格占据空间： 1234567// 水印const watermark = &#123; text: ' 隐私信息管理平台 ', color: '#EEE', opacity: 0.1, bold: true,&#125;; 搞定这些后，来为文档添加具体的内容。 标题首先生成最上方的标题中的文字 1234567// 标题const titleIntro = &#123; text: '小米隐私信息管理平台', fontSize: 28, bold: true, alignment: 'center',&#125;; 选项中设定了字体尺寸并且加粗，如果设定了加粗，但是导入的字体中没有设定加粗对应的字体就会报错，然后通过alignment设定文本居中。 标题前面还有一个小图标，用文本来搞定，引入图片后，默认图片和标题会分行防止，解决方法就是对图片添加absolutePosition选项，相当于CSS的绝对定位，输入坐标值，就可以让图标脱离文档流，随意摆放： 123456// 标题图标const titleImage = &#123; image: './images/mi-logo.png', width: 40, absolutePosition: &#123; x: 98, y: 40 &#125;&#125;; 下方的报告名“隐私检测报告”和前面的标题设定基本一致，居中防止，但是为了设定上下间距需要设定margin选项 12345678// 报告名const titleLineY = 10;const titleText = &#123; text: '隐私检测报告', fontSize: 38, alignment: 'center', margin: [0, titleLineY],&#125;; 分割线标题下方还有一道分割线，需要使用canvas选项来画出这条线： 12345678910// 标题分割线const titleLine = &#123; canvas: [&#123; type: 'line', x1: 0, y1: titleLineY, x2: 500, y2: titleLineY, lineColor: LINE_COLOR &#125;], margin: [0, 0, 0, 20],&#125;; 通过更改type可以画出不同的图形，其余的设置都好理解。 概览信息下面有一堆概览信息，由于原型图没有用列表形式的小点，说以不能直接使用ul选项，直接添加文字即可，将这部分内容放到一个数组中： 123456789101112131415161718// 概览信息const data = &#123; id: '0de3a12b-20190611174750', name: '浏览器', appVersion: '8.9.2', deviceName: 'chiron', miuiVersion: 'MIUI 9 SPT-2019.05.15', developer: '马化腾',&#125;;const id = `编号: $&#123;data.id&#125;`;const name = `软件名称: $&#123;data.name&#125;`;const appVersion = `版本号: $&#123;data.appVersion&#125;`;const deviceName = `测试机型: $&#123;data.deviceName&#125;`;const miuiVersion = `操作系统: $&#123;data.miuiVersion&#125;`;const developer = `开发者: $&#123;data.developer&#125;`;const overview = [id, name, appVersion, deviceName, miuiVersion, developer]; 表格表格的标题没什么特别的： 12345// 隐私信息检测标题const privacyDetailTitle = &#123; text: '隐私信息将策详情', style: 'tableTitle',&#125;; 表格的整体配置如下： 123456789101112// 隐私信息监测表格const privacyDetailTable = &#123; table: &#123; headerRows: 1, widths: ['*', '*', '*', '*', '*'], body: [ privacyDetailTableHeader, ...privacyDetailTableBody ], &#125;, layout: tableLayout&#125;; 如果表格分页时，会自动将在新的页面上再次生成表格，可以通过headerRows定义表格的前多少行作为表头被复制到新的页面，width定义的是表格每一列的宽度，有以下几种取值形式： &#39;*&#39;：会自动扩展占满剩余的宽度，在它其中的内容不会换行 &#39;auto&#39;：会根据内容自动确定宽度，其中的内容会换行，如果想不换行，需要设置noWrap: true 50：根据给定的数值确定宽度，注意是Number类型，不是字符串，否则会报错 我的第一个表格希望这五列占满全部空间，并且平均分配，所以widths（注意有s）是[&#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;] 我将表头单独拿出来定义： 12345678// 隐私信息监测表格-表头const privacyDetailTableHeader = [ &#123; text: '检测项', style: 'tableHeader' &#125;, &#123; text: '是否读取', style: 'tableHeader' &#125;, &#123; text: '是否上传', style: 'tableHeader' &#125;, &#123; text: '是否明文上传', style: 'tableHeader' &#125;, &#123; text: '检测结果', style: 'tableHeader' &#125;]; 表头用style属性指定了使用我在前面注册的tableHeader的样式。 具体表格内容则根据数据动态生成，我的DMO做了一些假数据，和表头一起放到body里面，构成了一个二维数组 最后是layout选项，它用来定义表格单元格和表格的边框，它有几个预设值noBorders/headerLineOnly/lightHorizontalLines，也可以传入一个对象对表格的样式自定义： 123456789101112131415161718// 表格样式const tableLayout = &#123; hLineWidth(i, node) &#123; return 1; &#125;, vLineWidth(i, node) &#123; return 1; &#125;, hLineColor(i, node) &#123; return LINE_COLOR; &#125;, vLineColor(i, node) &#123; return LINE_COLOR; &#125;, paddingLeft(i, node) &#123; return 5 &#125;,&#125;; 传入了一些方法，设定对应的样式，除此之外还可以设置fillColor等，具体的参考官方的例子吧。 这样就可以完成一个表格，另外一个表格知识宽度和内容不同。 最后将所有内容放到生成createPdfKitDocument参数对象中： 12345678910111213141516171819// 参数对象const docDefinition = &#123; content: [ titleImage, titleIntro, titleText, titleLine, overview, privacyDetailTitle, privacyDetailTable, permissionDetailTitle, permissionDetailTable, ], defaultStyle, styles, watermark&#125;;const pdfDoc = printer.createPdfKitDocument(docDefinition); 一份排版还算精美、代码复杂度也可以接受的PDF文档就生成了。 不仅如此，pdfmake还可以包括了生成二维码等功能，确实非常方便。 上面的完整的代码在我的Github仓库中。 总结PDFKit可以在Node环境和浏览器环境使用： 优点：引入字体后支持中文，支持图片，支持缩放、旋转，生成的PDF文字可复制，功能比较强大，API与操作Canvas的API非常类似，有一些使用的方法帮助快速操作，可以生成可点击的链接； 缺点是样式控制需要使用手动控制，不方便且繁琐，如果PDF的布局复杂时（有表格）样式控制也会很复杂。所以比较适合于布局简单的、没有复杂表格、布局以大块内容分割的PDF的生成，或者以现有的API抽象出生成表格等方法，便于复用。 pdfmake是在PDFKit基础上封装的： 优点：提供了直接绘制表格的API，功能比较强大，使用方便，还提供了添加水印、生成二维码等功能，生成较复杂的PDF的代码量可以接受 缺点是调试比较麻烦，每次都需要生成PDF查看样式，样式语法错误一般也不会报错，知识不生效，还有就是如果样式多了维护还是有一点麻烦，可使用类似LESS编写样式的思路。 总的来说，如果需要在Node服务端生成可复制的PDF文件，推荐使用pdfmake。 参考 pdfKit pdfmake bpampuch/pdfmake@Gtihub playground@pdfmake]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>PDFKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础20 换行的处理]]></title>
    <url>%2F2019%2F06%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F01%20Vue%E5%9F%BA%E7%A1%80%2FVue%E5%9F%BA%E7%A1%8020%20%E6%8D%A2%E8%A1%8C%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue中的数据使用双大括号插值插入DOM中，如果数据中含有标签或者换行符\n时，是无法正常被解析为HTML标签的，而是解析为纯文字的 要想正常换行有一下几个解决方法： v-html使用v-html会将数据内容作为HTML标签插入到DOM中，这时候就可以用&lt;br&gt;来代替\n进行换行，这个时候就可以换行成功了 white-space使用v-html要注意防范XSS攻击，我们也可以直接使用CSS属性来实现换行： 将容器的white-sapce属性设置为pre-wrap就可以了，注意，如果设置为pre和使用&lt;pre&gt;标签效果是一样的，它虽然会正常换行了，但是它们式中会保留HTML标签。 如果一定需要动态插入HTML标签，那么还是需要使用v-html innerHTML和innerText设置一个节点的innerHTML和innerText都会保留\n，但是区别是innerHTML会插入HTM标签，innerText则会以字符串的形式显示HTML标签 12345678document.querySelector('test').innerText = '&lt;em&gt;123\n\r45&lt;br /&gt;6&lt;/em&gt;'// &lt;em&gt;123//// 45&lt;br /&gt;6&lt;/em&gt;document.querySelector('test').innerHtml = '&lt;em&gt;123\n\r45&lt;br /&gt;6&lt;/em&gt;'// 123 45// 6 Vue中使用双大括号差值与这两种方式都是不同的，猜测可能是它对\n有特殊的处理 参考 插值@Vue white-space@MDN]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>换行</tag>
        <tag>white-space</tag>
        <tag>innerHTML</tag>
        <tag>innerText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg06 参数校验和异常处理]]></title>
    <url>%2F2019%2F06%2F12%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg06%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Egg中参数校验和异常处理的实践 参数校验手动校验之前的参数都是在Controller的入口处，手动的进行校验： 1234567891011121314151617181920212223async index() &#123; const &#123;ctx &#125; = this const &#123; query &#125; = ctx.request try &#123; const &#123; type &#125; = query // 缺少参数，没法查 if (!type) &#123; const errMsg = '缺少参数' ctx.response.status = this.config.httpCodeHash.badRequest ctx.response.body = ctx.helper.makeErrorResponse(errMsg) this.logger.error(new Error(errMsg)) return &#125; // 响应内容 const data = await ctx.service.settings.findSettings(type) ctx.response.status = this.config.httpCodeHash.ok ctx.response.body = data &#125; catch (err) &#123; ctx.response.body = err.message || '查询规则错误' ctx.response.status = this.config.httpCodeHash.serverError this.logger.error(err) &#125;&#125; 这样很很导致大量的代码冗余，每个Controll都要写这样进行校验，如果失败手动返回错误结果（实际上参数校验失败也应该统一处理，后面的异常处理部分会提到） egg-validate实际上使用egg-validate插件可以大大简化和标准化参数校验的流程。 安装： 1npm i egg-validate --save 需要在plugin.js中开启插件： 12345// config/plugin.jsexports.validate = &#123; enable: true, package: 'egg-validate',&#125;; egg-validate实际上是由parameter这个库封装而来，它可以针对很多类型的参数进行校验，比如string、dateTime、number、enum等，具体的使用方法可以参考它的文档。 使用egg-validate进行参数校验的正确姿势： 123456789101112131415161718192021222324252627282930'use strict'const Controller = require('egg').Controller// 创建规则的校验规则const createRule = &#123; type: &#123; type: 'enum', values: [ 'pre', 'single', 'other' ] &#125;, name: &#123; type: 'string', trim: true &#125;, packageName: &#123; type: 'string', trim: true &#125;, content: &#123; type: 'object' &#125;,&#125;class PrivacyController extends Controller &#123; // 新建预设规则 async create() &#123; const &#123; ctx &#125; = this const &#123; name, packageName, type, content &#125; = ctx.request.body // 参数校验 ctx.validate(createRule, ctx.request.body) // 创建新规则 const data = await ctx.service.settings.createSetting(name.trim(), packageName.trim(), type.trim(), content) // 创建成功 ctx.response.status = this.config.httpCodeHash.created.code ctx.response.body = insertSetting &#125;&#125;module.exports = PrivacyController ctx.validate的第一个参数就是校验的规则，第二个参数是被校验的参数，我们的请求方法是POST，所有的参数都在body中，所以传入的是ctx.request.body 如果参数校验没有通过，将会抛出一个status为422的异常： 这个错误我们没有在Controller中捕获，后面会提到是如何处理的。 要注意的是，在校验规则中，某些类型是可以传入自定义的错误提示信息的，比如对string的校验，如果使用了formate选项，那么传入的message就会有效，其他时刻传入message无效，无法自定义错误提示信息： 1234const indexRule = &#123; id: &#123; type: 'string', trim: true, format: /^.&#123;24&#125;$/, message: '非法ID' &#125;, // Mongo生成的ID长度为24位 packageName: &#123; type: 'string', trim: true &#125;,&#125; 查看它的源码，发现它只有显示或者隐式（type为email等）这种情况下才会提示自定义的提示信息： 123456789101112131415161718192021222324252627282930313233343536373839function checkString(rule, value) &#123; if (typeof value !== 'string') &#123; return this.t('should be a string'); &#125; // if required === false, set allowEmpty to true by default if (!rule.hasOwnProperty('allowEmpty') &amp;&amp; rule.required === false) &#123; rule.allowEmpty = true; &#125; var allowEmpty = rule.hasOwnProperty('allowEmpty') ? rule.allowEmpty : rule.empty; if (!value) &#123; if (allowEmpty) return; return this.t('should not be empty'); &#125; if (rule.hasOwnProperty('max') &amp;&amp; value.length &gt; rule.max) &#123; return this.t('length should smaller than %s', rule.max); &#125; if (rule.hasOwnProperty('min') &amp;&amp; value.length &lt; rule.min) &#123; return this.t('length should bigger than %s', rule.min); &#125; if (rule.format &amp;&amp; !rule.format.test(value)) &#123; return rule.message || this.t('should match %s', rule.format); &#125;&#125;function checkEnum(rule, value) &#123; if (!Array.isArray(rule.values)) &#123; throw new TypeError('check enum need array type values'); &#125; if (rule.values.indexOf(value) === -1) &#123; return this.t('should be one of %s', rule.values.join(', ')); &#125;&#125; 有时间想提一个PR，支持所有的类型校验都支持自定义提示信息，但是现在由于无法完全自定义，所以索性在异常处理的时候不对外暴漏具体的message了，只给出统一的参数校验失败的提示： 1234&#123; "code": -1, "message": "Validation Failed"&#125; 统一异常处理一开始我都是在Controller中使用try...catch来捕获错误，每个Controller都这样做很烦，虽然编写了一个helper中的生成错误响应的方法，但是到处都要调用也很麻烦。 在Controller和Service中都有可能抛出异常，这也是Egg推荐的编码方式。当发现客户端参数传递错误或者调用后端服务异常时，通过抛出异常的方式来进行中断 常见的终端的情形有： Controller中this.ctx.validate进行参数校验，失败抛出异常 Service中调用this.ctx.curl()进行HTTP请求，可能由于网络问题等原因抛出服务端异常 Service中获取到this.ctx.curl()的调用失败的结果，也会抛出异常 其他意料之外的错误，也会抛出异常 Egg提供了默认的异常处理，但是可能与系统中统一的接口约定不一致，因此需要自己实现一个统一错误处理的中间件来对错误处理。 在app/middleware目录下新建errorHanlder.js文件，新建一个中间件： 1234567891011121314151617181920212223242526// app/middleware/error_handler.jsmodule.exports = () =&gt; &#123; return async function errorHandler(ctx, next) &#123; try &#123; await next() &#125; catch (err) &#123; // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志 ctx.app.emit('error', err, ctx) const status = err.status || 500 const message = err.message || 'Internal Server Error' // HTTP Code ctx.status = status // 生产环境 const isProd = ctx.app.config.env === 'prod' // 错误响应对象 ctx.body = &#123; code: -1, message: (status === 500 &amp;&amp; isProd) ? 'Internal Server Error' : message, // detail: status === 422 ? err.errors : undefined, // 参数校验未通过 &#125; &#125; &#125;&#125; 生产环境时500错误的消息错误内容不应该返回给客户端，因为可能包含敏感信息，所以只返回固定的错误信息。 通过这个中间件，可以捕获所有异常，并且按照想要的格式封装了响应，将这个中间件通过配置文件加载进来： 123456789// config/config.default.jsmodule.exports = &#123; // 加载 errorHandler 中间件 middleware: [ 'errorHandler' ], // 只对 /api 前缀的 url 路径生效 errorHandler: &#123; match: '/api', &#125;,&#125;; 中间件的加载单独拿出来这一节，是因为当时踩了一个坑，按照上面的配置之后，发现所有的请求根本没有经过我们的errorHandler中间件。 这是因为Egg支持定义多个环境的配置文件： 12345config|- config.default.js|- config.prod.js|- config.unittest.js`- config.local.js config.default.js是默认的配置文件，所有所有环境都会加载这个配置文件，一般也会作为开发环境的默认配置文件。 当指定env时也会同时加载对应的额配置文件，并且覆盖默认配置文件的同名配置，比如prod环境会加载config.prod.js和config.default.js文件，前者会覆盖后者的同名配置 配置合并使用了extend2模块进行深度拷贝，对数组进行合并时会直接覆盖数组，而不是进行合并 123456789const a = &#123; arr: [ 1, 2 ],&#125;;const b = &#123; arr: [ 3 ],&#125;;extend(true, a, b);// =&gt; &#123; arr: [ 3 ] &#125; 这就是我们的中间件没有生效的原因，我们的目录里面同时配置了config.local.js和config.default.js，在config.default.js虽然配置了中间件，但是在config.local.js中的middleware对应的属性值是一个空数组 根据上面的合并规则，导致最终的middleware是一个空数组，没有加载任何的中间件，所以或者在所有的配置文件的middleware的数组中都加上errorHandler中间件，或者直接在除了config.default.js之外的配置文件中删除middleware属性。 统一的错误对象我们现在有了统一的异常处理机制，在Controller或者Service中有时候我们要主动抛出异常，抛出的异常应该是一个Error对象，这样才会带上堆栈信息。 但是有一些与HTTP状态有关的异常，应该统一进行管理，保持整个系统的统一。所以使用了egg-errors插件，它内置了统一的异常和错误对象。 安装： 1npm i egg-errors --save 这里主要使用的是egg-errors内置的HTTP错误对象，它内置了400到500的错误对象，它提供了对应的status和headers属性： 123const &#123; ForbiddenError &#125; = require('egg-errors');const err = new ForbiddenError('your request is forbidden');console.log(err.status); // 403 也可以使用简写来调用对应的错误： 123const &#123; E403 &#125; = require('egg-errors');const err = new E403('your request is forbidden');console.log(err.status); // 403 我们在config中新建了一个httpCodeHash.js配置文件，在这个配置文件中引入了egg-errors，根据语义化的HTTP返回值进行了配置： 12345678910111213141516171819202122// HTTP 响应代码: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Statusconst errors = require('egg-errors')// TODO: httpCodeHash.codemodule.exports = &#123; continue: &#123; code: 100, message: 'Continue' &#125;, ok: &#123; code: 200, message: 'OK' &#125;, created: &#123; code: 201, message: 'Created' &#125;, noContent: &#123; code: 204, message: 'No Content' &#125;, movedPermanently: &#123; code: 301, message: 'Moved Permanently' &#125;, found: &#123; code: 302, message: 'Found' &#125;, notModified: &#123; code: 304, message: 'Not Modified' &#125;, badRequest: &#123; code: 400, message: 'Bad Request', error: errors.E400 &#125;, unauthorized: &#123; code: 401, message: 'Unauthorized', error: errors.E401 &#125;, forbidden: &#123; code: 403, message: 'Forbidden', error: errors.E403 &#125;, notFound: &#123; code: 404, message: 'Not Found', error: errors.E404 &#125;, conflict: &#123; code: 409, message: 'Conflict', error: errors.E409 &#125;, unprocessable: &#123; code: 422, message: 'Unprocessable Entity', error: errors.E422 &#125;, serverError: &#123; code: 500, message: 'serverError', error: errors.E500 &#125;, otherServerError: &#123; code: 502, message: 'Bad Gateway', error: errors.E502 &#125;, errors,&#125; 使用的时候如果只需要加载对应的信息而不需要抛出错误，那么对应的信息都是统一的： 1234// 响应内容const data = await ctx.service.log.findPrivacyLog(&#123; id, packageName &#125;)ctx.response.status = this.config.httpCodeHash.ok.codectx.response.body = data 如果需要抛出错误的时候，那么就是用对应的error属性，新建一个错误对象，并传入对应的自定义错误提示： 1throw new this.config.httpCodeHash.notFound.error('检测记录不存在') 这样保证了抛出的错误对象的语义化且统一。 参考 开启 validate 插件@Egg eggjs/egg-validate@github node-modules/parameter@github Config 配置@Egg eggjs/egg-errors@github]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>validate</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg05 Session]]></title>
    <url>%2F2019%2F06%2F11%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg05%20Session%2F</url>
    <content type="text"><![CDATA[Session是Web应用在Cookie基础上的封装，主要目的就是进行用户身份识别。 关于Session为什么要有SessionHTTP是无状态的协议，但是在很多情况下服务端需要记录用户的状态，典型的场景比如用户登录、购物车等。所以服务端需要某种机制来识别具体的用户，这种机制就是Session。 当用户购物时，服务端并不知道是那个用户操作的，所以需要为特定的用户创建特定的Session，来标识、跟踪这个用户，才能弄清楚用户购物车内的东西并且不与其他用户的购物车混淆。 Session的保存Session是保存在服务端的，有一个唯一的标识。服务端保存Session的方法很多，内存、数据库、文件都有。大型的网站一般会有专门的Session服务器集群，用来保存用户回话，这个时候Session是保存在内存的。 Session如何是识别用户身份Session是使用Cookie来识别用户身份的。每次HTTP请求时，客户端会发送响应的Cookie到服务器。 第一次创建Session的时候，服务端会在HTTP响应中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求都需要把这个ID发送到服务器，服务端就知道是哪个用户发送的请求了。 这个Session ID是维持Session回话的客户端的唯一标识，是Session实现的核心。 如果浏览器禁用了Cookie，Session ID需要通过url来传递。 与cookie的区别Session是存储在服务端的数据，用来跟踪是被用户的状态，可以保存在集群、数据库、内存、文件中 Cookie是客户端保存信息的一种机制，用来记录用户的一些信息，会随着网络请求发送给服务端，也是实现Session的一种方式 其他的实现方式除了使用Session实现用户身份的识别，也可以使用JWT的机制实现，详情可以参考之前的笔记《JS42 JWT实现单点登录》 Egg中对Session的处理Egg内置了egg-session插件，可以直接使用ctx.session访问或者修改当前用户的Session 1234567891011121314151617class HomeController extends Controller &#123; async fetchPosts() &#123; const ctx = this.ctx; // 获取 Session 上的内容 const userId = ctx.session.userId; const posts = await ctx.service.post.fetch(userId); // 修改 Session 的值 ctx.session.visited = ctx.session.visited ? (ctx.session.visited + 1) : 1; ctx.body = &#123; success: true, posts, &#125;; &#125;&#125; Session可以直接读取或者修改，删除的话直接置为null就可以了： 1ctx.session = null; 需要特别注意的是，设置Session属性时要避免以_开头，并且不能为isNew这个属性，会造成字段丢失。 Session的实现是基于Cookie的，默认配置下，用户Session的内容加密后直接存储在Cookie的一个字段中： 用户每次发送请求时都会带上这个Cookie，在服务端解密后使用。 Session的默认配置如下： 123456exports.session = &#123; key: 'EGG_SESS', maxAge: 24 * 3600 * 1000, // 1 天 httpOnly: true, encrypt: true,&#125;; 这些参数中，key代表存储Session的Cookie的键值对的key是什么，其他的参数都与Cookie的设置参数相同。在默认的配置下，存放Session的Cookie将会加密存储、不能被前端JavaScript访问，这样保证用户的Session是安全的。 扩展存储Session默认放在cookie中，当Session过大时，会带来两个问题： cookie存储空间有限制，可能无法存储过大的Session 每次请求都要发送庞大的Cookie信息 Egg提供了将Session存储到除了Cookie之外的其他存储的扩展方案，只需要设置app.seesionStore就可以将Session存储到指定的位置 123456789101112131415// app.jsmodule.exports = app =&gt; &#123; app.sessionStore = &#123; // support promise / async async get (key) &#123; // return value; &#125;, async set (key, value, maxAge) &#123; // set key to store &#125;, async destroy (key) &#123; // destroy key &#125;, &#125;;&#125;; 可以使用egg-session-redis配合egg-redis，将Session存储到redis中。 注意，一旦选择了将Session存储到外部存储中，就意味着系统强依赖于这个外部存储，当它挂了后，我们就完全无法使用Session的相关功能了。因此Egg推荐大家只将必要的信息存储到Session中，保持Session的精简并使用默认的Cookie存储。用户级别的缓存不要存到Session中。 Session实践修改用户Session失效时间Session的配置中的maxAge只能设置全局Session的有效期，有一些登陆页面的“记住我”的功能会让登陆用户的Session有效期更长，这种针对特定用户的Session有效时间社会可以通过ctx.session.max来实现 1234567891011121314const ms = require('ms');class UserController extends Controller &#123; async login() &#123; const ctx = this.ctx; const &#123; username, password, rememberMe &#125; = ctx.request.body; const user = await ctx.loginAndGetUser(username, password); // 设置 Session ctx.session.user = user; // 如果用户勾选了 `记住我`，设置 30 天的过期时间 if (rememberMe) ctx.session.maxAge = ms('30d'); &#125;&#125; 延长用户Session有效期默认情况下，当用户请求没有导致Session被修改时，框架不会延长Session的有效期。有些时候希望用户长时间都在访问我们的站点，要延长其Session有效期，不让用户退出登录状态。 框架提供了renew配置项来实现上述功能，它会在发现当用户Session的有效期仅剩下最大有效期的一般时，重置Session的有效期。 123456// config/config.default.jsmodule.exports = &#123; session: &#123; renew: true, &#125;,&#125;; 参考 Session@Egg 详解 Cookie 和 Session 关系和区别@Ruby China]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高19 插件]]></title>
    <url>%2F2019%2F06%2F11%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F02%20Vue%E6%8F%90%E9%AB%98%2FVue%E6%8F%90%E9%AB%9819%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue插件学习笔记。 插件和组件的区别（1）组件分为全局注册和局部注册，全局注册使用Vue.component(&#39;componetName&#39;, component)实现，全局注册后可以在Vue系统中任意使用，局部注册的组件每次使用都需要import，然后在组件的componentes中注册，它的目的是复用模板和逻辑，影响的范围大多数是组件自身范围内 （2）插件的范围和能力比组件更大，插件内可以包含多个组件，可以在插件内注册全局组件，并且可以实现其他功能，比如： 添加全局方法或者属性（挂载到Vue的静态方法） 添加Vue实例方法（挂载到Vue.prototype上实现），在组件中通过this调用 通过全局混入来添加组件选项（通过Vue.mixin实现），比如在所有组件created的钩子上完成一些功能 添加自定义指令（通过Vue.directive实现） 使用组件使用组件需要通过全局方法Vue.use()实现，需要在调用new Vue之前完成 1234567891011Vue.use(MyDatePicker);new Vue(&#123; el: '#app', data: &#123; eventBus: new Vue() &#125;, router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 也可以传入一个可选的选项对象： 1Vue.use(MyDatePicker, &#123; someOption: true &#125;); Vue.use会自动阻止多次注册相同插件，即使多次调用也只会注册一次该插件。 开发插件插件应该暴露一个install方法，提供给Vue.use()调用。 install方法第一个参数是Vue构造器，第二个参数是传入的可选的选项对象 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 通过在Vue构造器上添加一些属性、方法，就可以实现添加全局的方法和属性。 在install方法也可以通过Vue.component注册全局组件： 1234567import MyDatePicker from './MyDatePicker'export default &#123; install(Vue, options) &#123; Vue.component('MyDatePicker', MyDatePicker); &#125;&#125; 例子：开发Loading插件首先创建一个MyLoading.vue，接受一个msg参数显示在组件内部，loading的效果通过CSS实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class="container my-loading"&gt; &lt;div class="logo"&gt;&lt;/div&gt; &lt;p class="text"&gt;This is My Loading -- &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'msg' ], name: 'MyLoading' &#125;&lt;/script&gt;&lt;style scoped&gt; .container &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); overflow: hidden; padding-top: 200px; &#125; .logo &#123; margin: 0 auto; width: 100px; height: 100px; border: 10px solid darkcyan; border-right-color: darkgray; border-radius: 50%; animation: myRotate 2s linear infinite &#125; @keyframes myRotate &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; .text &#123; margin-top: 20px; text-align: center; &#125;&lt;/style&gt; 然后创建插件主体文件，创建index.js，这个文件需要导出一个对象，对象中必须有一个install方法，在install方法中来完成主要的逻辑 1234567891011121314151617import MyLoading from './MyLoading'export default &#123; install(Vue, options) &#123; const comp = Vue.extend(MyLoading); Vue.prototype.showMyLoading = (msg) =&gt; &#123; if (document.querySelector('.my-loading')) &#123; return &#125; const tpl = new comp(&#123; propsData: &#123; msg &#125; &#125;).$mount().$el; document.body.appendChild(tpl); setTimeout(function () &#123; document.body.removeChild(tpl); &#125;, 3000) &#125; &#125;&#125; 在上面的代码中，定义了实例的showPicker方法，在这个方法中首先使用Vue.extend来创建一个继承自MyLoading的Vue子类，然后使用new关键字将其实例化。 注意，使用new创建的实例，想要传递给组件props，必须使用propsData参数 12345678910var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'&#125;)var vm = new Comp(&#123; propsData: &#123; msg: 'hello' &#125;&#125;) 然后使用$mount方法创建一个未挂载的实例，这个实例没有关联的DOM元素，它返回实例自身，所以可以链式调用其他实例方法，然后通过$el获取实例自身的根DOM元素，通过appendChild将这个元素手动的挂载到DOM中 使用插件的时候在main.js中： 12import MyLoading from '@/plugin/myLoading/index'Vue.use(MyLoading); 这样在任意Vue中间中就可以调用实例的this.showPicker()方法动态的创建一个Loading元素，3秒后自动消失。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;使用MyLoading插件&lt;/h1&gt; &lt;button @click="showLoading"&gt; Show Loading&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'demo33', props: [], data() &#123; return &#123; title: '' &#125; &#125;, mounted() &#123; &#125;, methods: &#123; showLoading()&#123; this.showMyLoading('你好') &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 这是命令式的创建动态实例，适合Loading、对话框等形式的元素。主要的思路和之前总结的笔记《Vue提高09 动态创建实例》类似。 当然也可以在插件中注册全局组件，类似于ElementUI的用法。 参考 插件@Vue vm.$el@Vue vm.$mount@Vue propsData@Vue Vue插件开发与实战@H2O Vue.js 插件开发详解@掘金]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题31 JS中的日期对象]]></title>
    <url>%2F2019%2F06%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9831%20JS%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[最近做一个重构的业务，使用到了Mongo数据库，在接口中需要返回数据的的更新时间。之前数据库中都使用了时间戳记录时间，返给前端的数据直接使用时间戳进行格式化，并且查询条件也是由时间戳进行比对。 没想到，做数据写入接口的同事，将这个字段由时间戳改为了使用Mongo自带的标准的日期格式：ISODate(&quot;2016-01-01T00:00:00Z&quot;) 突然发现自己一时间对JS中的日期对象、对时间的各种表示方法并没有一个比较清晰的脉络。所以想用一点时间对这块知识做一个梳理、总结。 1 几种时间标准首先要明确，时间标准和时刻的关系。 我理解，时刻对于整个地球来说是唯一的。就在我写下这行文字的这一时刻，无论是美国、老挝还是柬埔寨，大家都经历了同一时刻，对于时间轴的刻度，全球是唯一的。 但是在不同的时区的人，代表这一刻的时间是各不相同的，我所在的北京时间是晚上21:26，但是对于美国、老挝、柬埔寨可能时间各不相同。 时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。 不同给的时区有对应的时间标准，对于中国的开发者来说，常见的时间标准有GMT/UTC/CST （1）GMT GMT，格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义为通过那里的经线。但是格林尼治时间本身有一些缺陷，并不准确，已经被原子钟报时的协调世界时（UTC）替代。 （2）UTC 刚才提到了UTC，协调世界时，是目前最主要的是世界时间标准，以原子时为基础。它的精确度比GTM更高，但是对于大多数用途，UTC时间被认为能够与GMT时间互换。 （3）CST CST，是北京时间，也叫做中国标准时间，比UTC时间快八个小时，与澳门、香港、台北、吉隆坡、新加坡等地的标准时间相同。 （4）小结 也就是说，UTC时间是GMT的时间的升级版，基本可以认为是相同的，有如下的关系： 1GTM ≈ UTC = CST + 8 2 ISO时间ISO时间与前面提到的时间标准属于不同的概念，它并不是一种时间标准，二是一种时间的表示方法。 ISO时间的全称是ISO 8601，是国际标准化组织的日期和时间的表示方法。目前是2004年12月1日发行的第三版标ISO8601:2004 标准中规定了日期和时间的组合表表示法，只使用数字为基本格式，使用冒号间隔开小时、分、秒，小时、分和秒都用2位数表述。日期和时间之间要一个大写字母T。 如果时间与UTC时间相同，那么（不加空格地）在时间最后加一个大写字母Z，比如下午2点30分5秒表示为14:30:05Z，其他时区用实际时间加上时差表示，比如当地的UTC+8时间表示为22:30:05+08:00 所以： 123452004-05-03T17:30:08+08:00// 北京时间2004年5月3日下午5点30分8秒2004-05-03T17:30:08Z// UTC时间2004年5月3日下午5点30分8秒 前面提到的，Mongo里的时间ISODate(&quot;2016-01-01T00:00:00Z&quot;)使用的就是ISO表示法的UTC时间。 3 时间戳时间戳也是常见的表达时间的方式，Unix时间戳指的是格林威治时间1970-01-01 00:00:00（北京时间1970-01-01 08:00:00）其到现在（或某个指定时间）的总秒数。它用来唯一的标识某一刻的时间。 那么，北京时间的时间戳和UTC的时间戳是一样的吗? 当然是一样的，前面提到了，时间戳是用来唯一的标识某一刻的时间，它是独一无二的。虽然北京时间和UTC时间相差了8个小时，但是正如上面提到的，北京时间和UTC时间计算时间戳的起点也相差了8个小时。 所以时间戳是没有时区的区别的。 4 JavaScript中的日期对象ECMAScript中的Date类型使用UTC时间的1970年1月1日午夜（零时）开始经过的毫秒数（注意是毫秒）来保存日期。 创建一个日期对象： 1const now = new Date() 在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒时间戳。 构造函数也可以接受一个字符串返回相应的日期对象，这是因为构造函数在后台调用了Date.parse()方法，将字符串转换为了对应日期的毫秒数。 Date可以接受多种日期格式，常用的有以下几种： 1234567891011// 时间戳new Date(1559569974691)// 月/日/年new Date('6/13/2004')// 年-月-日 时:分:秒new Date('2019-03-18 00:00:00')// ISO 8601 格式日期new Date('2019-03-18T00:00:00.000Z') 在使用Date构造函数创建一个日期对象时，日期和时间都是基于本地时区而非GMT来创建的： 12new Date()// Mon Jun 03 2019 21:56:47 GMT+0800 (中国标准时间) 上面的代码创造的日期对象是基于本地时区，也就是CST时区（为GMT+8)。当然JavaScript也提供了各种方法来进行各种事件标准间的转换： 1234567891011121314151617181920const now = new Date()// Mon Jun 03 2019 22:01:55 GMT+0800 (中国标准时间)now.toString()// "Mon Jun 03 2019 22:01:55 GMT+0800 (中国标准时间)"now.getTime()// 1559570515646now.toLocaleString()// "2019/6/3 下午10:01:55"now.toGMTString()// "Mon, 03 Jun 2019 14:01:55 GMT"now.toUTCString()// "Mon, 03 Jun 2019 14:01:55 GMT"now.toISOString()// "2019-06-03T14:01:55.646Z" Date对象的各种API可以查看MDN的文档，要注意的是日期对象的valueOf方法是取时间戳的值，效果与getTime是相同的。日期对象转换为数字，结果就是其时间戳。 12now.valueOf() === now.getTime()true 日期对象进行比较时，如果是两个对象进行比较，结果永远是不等的，原因和你直接比较两个{}不等是相同的，它们指向的不同的内存地址。但是可以将它们转换为字符串或者数字（时间戳）进行比较，而且在进行大于或者小于的比较时，是不用进行转换可以直接进行比较的（我猜测执行了隐式的转换，先转换为了数字，实际进行比较的是时间戳的值） 123456789101112131415var startDate1 = new Date("02/10/2012");var startDate2 = new Date("02/10/2012");var startDate3 = new Date("01/10/2012");startDate1 === startDate2// falsestartDate1.toISOString() === startDate2.toISOString()// true+startDate1 === +startDate2// truestartDate1 &gt; startDate3// true 对于日期对象，比较简单的转换和使用完全可以使用原生API实现，稍微复杂的一些可以借助Moment.js和date-fns，后者是纯函数，是不变的，而且更容易做到按需引入，所以更加推荐。 参考 时区@维基百科 格林尼治平时@维基百科 协调世界时@维基百科 北京时间@维基百科 ISO 8601@维基百科 时间戳@百度百科 JavaScript高级程序设计（第三版） Date@MDN]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UTC</tag>
        <tag>GMT</tag>
        <tag>IOS</tag>
        <tag>CST</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg04 cookie]]></title>
    <url>%2F2019%2F05%2F30%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg04%20cookie%2F</url>
    <content type="text"><![CDATA[通过ctx.cookie可以很便捷的在Controller中设置、读取Cookie。 开发之前还是应该精读文档啊。 设置Cookie1ctx.cookies.set(key, value, options) 设置Cookie其实是通过在HTTP响应中设置set-cookie头完成的，每个set-cookie都会让浏览器在Cookie中存储一个键值对。 在设置Cookie时还支持很多参数来配置Cookie的传输、存储和权限，具体参考文档。 其中有几个参数需要注意： { Boolean } overwrite，设置key相同时如何处理，如果设置为true，后设置的值会覆盖前面设置的值 { Boolean } singed，设置是否对Cookie进行签名，如果设置为true，则设置键值对是会同时对这个键值对的值进行前面，后面取的时候会进行校验，防止前端对这个值进行篡改。默认为true { Boolean } encrypt，设置是否对Cookie进行加密，如果设置为true，会在发送Cookie前对这个键值对的值进行加密，客户端无法读取Cookie的明文值。默认为false 在默认配置下，Cookie是加签不加密的，浏览器可以看到明文，JS不能访问，不能被客户端手工篡改。 在设置Cookie时需要考虑清楚这个Cookie的作用，需要保存多久，是否可以被JS获取，是否可以被前端修改。 （1）Cookie可以在前端访问并修改： 1234ctx.cookies.set(key, value, &#123; httpOnly: false, signed: false,&#125;); （2）如果想要Cookie在浏览器端不能被修改，不能看到明文： 1234ctx.cookies.set(key, value, &#123; httpOnly: true, // 默认就是 true enctypt: true,&#125;); 由于浏览器对Cookie有长度限制限制，所以尽量不要设置太长的Cookie。一般来说不要超过4093 bytes。当设置的value大于这个值时，框架会打印一条警告日志。 Cookie设置的编码由于浏览器和其他客户端实现的不确定性，为了保证Cookie可以写入成功，应该将value通过Base64或者其他编码方式进行编码后写入。 如果直接写入中文字符会失败： 1ctx.cookies.set('test', '你好') 可以使用encodeURIComponent转义，它会转义除了字母、数字、(、)、.、!、~、*、&#39;、-和_之外的所有字符。 encodeURI自身无法产生能适用于GET或POST请求的URI，例如对于XMLHTTPRequests, 因&amp;, +和=不会被编码，然而在GET和POST请求中它们是特殊字符。然而encodeURIComponent这个方法会对这些字符编码。 1ctx.cookies.set('test', '你好') 这样写入的就是通过编码后的信息： 也可以使用Base64进行加密。 关于Base64的题外话之前面试的时候有面试官问我的项目中为什么要用到base64-js这个库进行Base64加密，为什么不用原生的。我说的是API更简单，其实并不是的，是因为我当时不知道浏览器已经原生支持Base64的加解密了。 在浏览器环境下的window对象有两个方法，window.atob用于解密，window.btoa进行加密： 1234567let str = 'hello'let x = btoa(str)// "aGVsbG8="let y = atob(x)// 'hello' 既然有原生了，那么base64-js在npm上还有8559097的周下载量呢，原因有二： （1）兼容性，window.atob和window.btoa方法不支持IE10以下的浏览器，而base64-js就都解决了： （2）对中文的支持，原生的方法直接对中文编码是会报错的： 1234let str = '你好'btoa(str)// Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range. 解决方法就是对中文字符进行安全转码： 1234567let str = '你好'let x = btoa(encodeURIComponent(str))// "JUU0JUJEJUEwJUU1JUE1JUJE"let y = decodeURIComponent(atob(x))// '你好' base64-js有中文的支持，减少了我们的工作量。 选用一个包，也有这么大的学问，自己还是太不认真。 Node中的Base64加解密说了这么多题外话，回到整体，在Egg中也可以使用Base64加密后再Set-cookie。在Node环境中不能使用刚才提到的atob和btoa方法，我们也不一定需要引用base64-js，Node原生也是支持Base64加解密的，要利用到Buffer对象的toString方法 1234567&gt; let str = '你好'&gt; let x = new Buffer(str).toString('base64')// '5L2g5aW9'&gt; let y = new Buffer(x, 'base64').toString()// '你好' 也可以不新建Buffer实例，而是使用Buffer的静态方法from来实现，原理是一样的 1234567const str = '你好'ctx.cookies.set('base64', Buffer.from(str).toString('base64'))const base64 = ctx.cookies.get('base64')const result = Buffer.from(base64, 'base64').toString()// '你好' 读取Cookie1ctx.cookies.get(key, options) HTTP请求中的Cookie是在Header中穿过来的，而且是字符串中键值对的形式： 1&quot;test=%E4%BD%A0%E5%A5%BD; test.sig=bQpP88NGWWHrDUIuTcFH-D8DqTPU4VmalNWGQDIjnwU; base64=5L2g5aW9; base64.sig=Xbh30SgqJt8y9WY7fdicbtq-YE2E_qUUK5CMthAH4UQ&quot; 框架提供的get方法可以快速的解析Cookie并获取对应的键值对的值。由于在传输时指定了options.signed对Cookie进行签名，所以Cookie中会自动带来base.sig这个签证，用来对Cookie进行校验。 如果设置的时候指定了singed，获取时未指定，则不会再获取时对渠道的值做验签，导致Cookie可能经过客户端篡改而无法发现 如果设置是指定了encrypt，获取时未指定，则无法获取到真实的值，而是加密过后的密文 如果要获取前端或者其他系统设置的cookie，需要指定参数singed为false，避免对它做验签而导致获取不到cookie值 123ctx.cookies.get('frontend-cookie', &#123; signed: false,&#125;); 由于没有好好看文档，在使用Postman发送Cookie时，无论如何都无法成功，就是因为没有设置signed为false，这个时候要想获取成功，只能从浏览器里面将base.sig的值复制到Postman中一起发送。 要注意的是，即便设置了signed为false，在Postman里面直接设置Cookie的键值对的值为中文（这很方便）， 在Egg中也是无法解码的，它不会报错，Postman也给不出原因： 还是应该在Postman中对中文字符进行安全编码，选中中文部分，点击右键，在菜单中选择encodeURIComponet，在接受到之后进行解码就OK了 Cookie密钥在Cookie中需要用到加解密和验签，需要配置一个密钥供加密使用，在config/config.default.js中 123module.exports = &#123; keys: 'key1,key2',&#125;; kyes配置成为一个字符串，使用逗号分割多个key。Cookie在使用这个配置进行加解密时： 加密和加签只会使用第一个密钥。 解密和验签时会遍历keys进行解密 这样做的好处是，如果我们想要更新Cookie的密钥，但是又不希望之前设置到用户浏览器的Cookie失效，可以将新的密钥配置到keys的最前面，过一段事件后再删除不需要的密钥即可。 参考 Cookie 与 Session@egg encodeURIComponent()@MDN encodeURI()@MDN 原来浏览器原生支持JS Base64编码解码@鑫空间鑫生活 How to do Base64 encoding in node.js?@stack overflow Node.js Base64 Encoding和Decoding@Jaxu’s home]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>encodeURIComponent</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序09 小程序中的数据]]></title>
    <url>%2F2019%2F05%2F29%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F10%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F09%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[对小程序中的数据相关知识的学习笔记。 小程序中数据的作用域 逻辑层负责产生、处理程序，小程序的JS脚本运行在同一个JSCore线程中 逻辑层和渲染层是一对多关系，但页面对象（Page）和页面层级（Webview）一一对应。 （1）全局数据 12345678// app.jsApp(&#123; globalData: 'I am global data' // 全局共享数据&#125;)// 其他页面脚本other.jsvar appInstance = getApp()console.log(appInstance.globalData) // 输出: I am global data App实例是单例的，因此在App中定义的数据可以在不同页面共享 （2）页面共享数据 12345678console.log('加载 page.js')var count = 0Page(&#123; onLoad: function() &#123; count += 1 console.log('第 ' + count + ' 次启动这个页面') &#125;&#125;) 在Page构造器外面定义的变量，会一直保存在内存中，不会随着页面销毁而销毁。因此上面的count值会递增 这是因为页面所在的JS文件、app.js以及其他被require的JS文件，在小程序启动时会自动执行且被基础库注册，所以这些文件仅会被执行一次。之后页面都是通过Page构造器来创建Page实例来渲染的。 所以一般require的依赖或者第三方库JS以及getApp()都会放在页面共享数据中，避免重复加载。 （3）Page实例中的数据 12345678910111213Page(&#123; data: &#123; text: "我用来改变界面显示" &#125;, onLoad: function(options) &#123;&#125;, onReady: function() &#123;&#125;, onShow: function() &#123;&#125;, onHide: function() &#123;&#125;, onUnload: function() &#123;&#125;, text: "我不显示在页面上", myData: &#123; a: '我也不显示在页面上', b: true &#125;&#125;) 定义在Page构造函数中的数据，随着每次页面创建、销毁，这些数据也会被创建、销毁，不会被保留在内存当中。这些数据的生命周期与页面的生命周期是相同的。 定义在data中的数据用来渲染页面，就像在Vue中定义在data属性中的数据是一样的，只不过在Vue中是直接通过this.text取值，在小程序中需要通过this.data.text取值 与界面渲染无关的数据不要放在data中，可以提高性能表现。 合理操作数据，提升性能（1）数据通信 视图层在接收到初始数据data时进行初始渲染，在使用setData更新数据时，视图层进行重新渲染。当用户出发事件，视图层会将信息反馈给逻辑层。 这一切都是逻辑层与视图层两个线程通信的结果。数据量小于64kb时总时长可以控制在30ms以内。传输数据过大将导致这一事件增长。因此减少数据传输量是降低数据传输时间的有效方式。 （2）提升性能的准则 调用setData进行重渲染后，视图层会进行一个节点树Diff的过程，合并数据，用新节点数替换旧节点数，用于下次渲染。 setData发送数据不会进行Diff，而是全量发送，生成新的节点树在进行Diff、合并。 所以： 不要过于频繁调用setData，考虑将多次合并为一次 每次setData只改动的最小的单位数据 与界面渲染无关的数据不要设置的data中 事件绑定时需要传输target和currentTarget的dateset，所以不要再节点的data属性中放置过大的数据 精简优化WXML结构，降低JS代码复杂性，必要时使用分包优化 注意： 如果不使用setData而是直接对this.data中的数据赋值，不仅不会改变页面状态，还会导致数据不一致（和React中是一样的，不用多说了）。 不要将data中的属性值设为undefined，会导致一些莫名其妙的bug 组件中的通信（1）业务组件，也业务数据紧密耦合 从全局变量获取参数，通过更改全局变量与外界通信 通过props获取参数，通过triggerEvent与外界通讯 （2）纯组件，与业务数据无关 只能通过props获取参数，通过triggerEvent与外界通讯 缓存数据这里的缓存数据是小程序存储在设备硬盘的数据，类似WebStorage。小程序宿主环境从不同小程序和不同用户两个维度来隔离缓存空间。每个小程序的缓存空间上线为10MB （1）缓存充当全局数据 通过wx.getStorage/wx.getStorageSync读取本地缓存 通过wx.setStorage/wx.setStorageSync写入本地缓存 （2）利用缓存提前渲染截面 在拉取数据（比如商品列表）后缓存在本地，在onLoad发起请求前，先检查本地是否有缓存，如果有缓存的话使用缓存渲染界面。然后等待wx.request请求成功后在success回调中再次重新渲染页面，并且更新缓存。 一般对数据实时性和一致性要求不高的页面可以利用这个方法做提前渲染，可以提供类似PWA的体验。 状态管理Westore很多基于小程序的框架，类似mpVue，主打的是其他技术栈编译转小程序，并且可以编译为在H5等其他端运行的代码。 但是据统计，开发小程序使用最多的技术栈就是小程序本身的开发工具和语法，因为小程序本身的组件化、调试、发布、回滚、灰度、上报、统计、监控都是很优秀的。 但是小程序现在本身的状态管理可能是一个需要解决的痛点，官方还没有推出类似Redux、Vuex的解决方案。所以组件间叫复杂的数据共享、通讯以及跨页面的组件通讯，还是很容易让小程序难以维护和调试。 Westore是一款腾讯微信小程序解决方案，覆盖状态管理、跨页通讯、插件开发和云数据库开发。其技术方案： 有需要时可以尝试引入。 参考 【223期】 深入理解小程序中的数据@灵感周末 Tencent/westore@github]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>数据</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg03 断点调试]]></title>
    <url>%2F2019%2F05%2F16%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg03%20%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[断点调试Egg应用的方法。 使用Chrome调试需要Node 8.x+版本以上。 首先执行npm run debug（与node app.js --inspect原理相同） 然后有两种方法启动控制台（不是访问接口的控制台，而是直接启动一个新的针对Node的控制台） （1）执行npm run debug之后，在控制台最后会输出DevTools对应的地址，该地址是代理后的worker，无需担心重启问题。直接访问该地址即可进行断点调试。 12345678910111213141516➜ showcase git:(master) ✗ npm run debug&gt; showcase@1.0.0 debug /Users/tz/Workspaces/eggjs/test/showcase&gt; egg-bin debugDebugger listening on ws://127.0.0.1:9229/f8258ca6-d5ac-467d-bbb1-03f59bcce85bFor help see https://nodejs.org/en/docs/inspector2017-09-14 16:01:35,990 INFO 39940 [master] egg version 1.8.0Debugger listening on ws://127.0.0.1:5800/bfe1bf6a-2be5-4568-ac7d-69935e0867faFor help see https://nodejs.org/en/docs/inspector2017-09-14 16:01:36,432 INFO 39940 [master] agent_worker#1:39941 started (434ms)Debugger listening on ws://127.0.0.1:9230/2fcf4208-4571-4968-9da0-0863ab9f98aeFor help see https://nodejs.org/en/docs/inspector9230 openedDebug Proxy online, now you could attach to 9999 without worry about reload.DevTools → chrome-devtools://devtools/bundled/inspector.html?experiments=true&amp;v8only=true&amp;ws=127.0.0.1:9999/__ws_proxy__ （2）第二种方法对于普通的Node应用都适用（前提时使用了--inspect模式），访问chrome://inspect，配置相应的端口（Egg需要将9229和9230端口加入到配置中），然后点击Open dedicated DevTools for Node即可打开调试控制台。 使用Webstorm调试egg-bin会自动读取Webstorm下设置的环境变量$NODE_DEBUG_OPTION。 按照下图进行配置： 使用Webstorm的NPM调试启动即可进行Debug。 果然Webstorm太牛逼。 使用VSCode调试可以通过2个方式： 方式一：开启VSCode配置Debug: Toggle Auto Attach，然后在Terminal执行npm run debug 即可。 方式二：配置VSCode的.vscode/launch.json，然后F5一键启动即可。（注意，需要关闭方式一中的配置） 1234567891011121314151617181920// .vscode/launch.json&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Launch Egg", "type": "node", "request": "launch", "cwd": "$&#123;workspaceRoot&#125;", "runtimeExecutable": "npm", "windows": &#123; "runtimeExecutable": "npm.cmd" &#125;, "runtimeArgs": [ "run", "debug" ], "console": "integratedTerminal", "protocol": "auto", "restart": true, "port": 9229, "autoAttachChildProcesses": true &#125; ]&#125; 也提供了一个vscode-eggjs扩展来自动生成配置 参考 Node 调试工具入门教程@阮一峰的网络日志 使用 DevTools 进行调试@Egg]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS32 FOUC]]></title>
    <url>%2F2019%2F05%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS32%20FOUC%2F</url>
    <content type="text"><![CDATA[FOUC，Flash Of Unstyled Content，中文名称无样式内容闪烁。就是当浏览器在解析一个网页的时候，会出现的内容样式闪烁的现象。 什么是FOUCFOUC，Flash Of Unstyled Content，中文名称无样式内容闪烁。就是当浏览器在解析一个网页的时候，会出现的内容样式闪烁的现象。 具体的过程是，当页面加载渲染时，首先以样式A渲染，当页面加载渲染完成时，页面突然改为由样式B渲染，导致出现页面样式闪烁。 原理为什么会出现FOUC呢？这和浏览器渲染页面的流程机制有关系： （1）浏览器会首先构建DOM树， （2）处理CSS，生成样式树 （3）将DOM树和样式树合并，构建渲染树 （4）生成盒模型 （5）绘制信息 在第二步中，我们的CSS样式是放在&lt;head&gt;标签中的，样式树的构建过程不会阻塞DOM树的构建，但是由于渲染树依赖于样式树，所以只会在DOM树和样式树都解析完成后才会构建渲染树，进行后面的绘制。这样当文档的内容被绘制在屏幕上时，是已经加载了样式的内容。 但是，如果在CSS外部样式表没有放在&lt;head&gt;中，而是放在文档尾部，第二步中的样式树会采用浏览器内置样式（user agent stylesheet）来生成样式树。这样开始绘制内容采用的样式就是浏览器内置样式。当解析到文档尾部的自定义样式表时，会停止之前的渲染，重新加载样式，这就导致了页面样式有一个突变的过程，出现了FOUC的现象。 具体原因一般来说，出现FOUC的原因都是在浏览器开始绘制信息后才加载样式，一般会产生FOUC的操作有： （1）样式表没有放放在&lt;head&gt;中，而是放在页面底部，原因上面说过了。 （2）通过import导入样式表，它会组织并行加载代码， 解决方法将CSS外部样式表通过&lt;link&gt;的方式放在&lt;head&gt;中加载 Create-React-App在使用Create-React-App脚手架创建React的应用时，遇到了FOUC的问题，这是Create-React-App的2.1.4和2.1.5版本的bug 解决方法就是回退到2.1.3版本，或者试一下2.1.5+版本是否解决了这个问题。 参考 前端魔法堂：解秘 FOUC@掘金 什么是FOUC？如何避免FOUC？@咸鱼老弟]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>FOUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS31 网页换肤]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS31%20%E7%BD%91%E9%A1%B5%E6%8D%A2%E8%82%A4%2F</url>
    <content type="text"><![CDATA[实现网页换肤的三种办法。 常规做法1一个全局class来控制样式，切换皮肤时通过更改全局样式来实现换肤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;style&gt; /*默认样式*/ .default &#123; color: #000; background: #ddd; &#125; .default .text &#123; border: 1px solid #000; &#125; /*样式1*/ .green &#123; color: lemonchiffon; background: green; &#125; .green .text &#123; border: 1px solid darkblue; &#125; /*样式2*/ .red &#123; color: navajowhite; background: red; &#125; .red .text &#123; border: 1px solid pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="default"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const skinContainer = document.querySelector('#skin-container'); const inputContainer = document.querySelector('.input-container'); const changeSkin = theme =&gt; &#123; const &#123; classList &#125; = skinContainer; const &#123; value &#125; = classList; classList.replace(value, theme) &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 这种方法的缺点是，加入了一个全局的class控制样式，提高了样式优先级，如果换肤样式多，代码会非常罗嗦（Less可以简化一部分代码，但是维护还是不方便） 常规做法2第二种做法是新建多个对应皮肤样式的CSS文件，通过改变&lt;Link&gt;元素的href属性来切换皮肤 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;link id="skinLink" href="../styles/default.css" rel="stylesheet" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="theme"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const skinLink = document.querySelector('#skinLink'); const inputContainer = document.querySelector('.input-container'); const changeSkin = theme =&gt; &#123; skinLink.href = `../styles/$&#123;theme&#125;.css` &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 几个不同的CSS文件default.css、red.css、green.css中定义不同皮肤的样式 这种方法的缺点是使用JS改变href属性会带来加载延迟，样式切换不流畅（因为新切换的CSS文件原本没有加载，改变了href属性后才会加载，会有延迟） 第三种方法可以借助&lt;link&gt;标签的rel属性的alternate属性值来实现： 123456&lt;link href="reset.css" rel="stylesheet" type="text/css"&gt;&lt;link href="default.css" rel="stylesheet" type="text/css" title="默认"&gt;&lt;link href="red.css" rel="alternate stylesheet" type="text/css" title="红色"&gt;&lt;link href="green.css" rel="alternate stylesheet" type="text/css" title="绿色"&gt; 上面有4个&lt;link&gt;元素，出现了三种不同性质的CSS文件加载： 没有title属性，rel属性值仅仅是stylesheet的&lt;link&gt;元素（第一种），无论如何都会加载，可以利用它来加载reset.css 有title属性，rel属性值仅仅是stylesheet的&lt;link&gt;元素（第二种），作为默认的CSS文件加载并渲染，如default.css 有title属性，rel属性值同时包含alternate stylesheet的&lt;link&gt;元素（第三种和第四种），作为备选的CSS样式文件加载，但不渲染，通过控制其disabled属性来确定是否渲染，用来指定皮肤样式 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;link id="theme-default" title="默认" href="../styles/default.css" rel="stylesheet" type="text/css"&gt; &lt;link id="theme-green" title="绿色" href="../styles/green.css" rel="stylesheet alternate" type="text/css"&gt; &lt;link id="theme-red" title="红色" href="../styles/red.css" rel="stylesheet alternate" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="theme"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const inputContainer = document.querySelector('.input-container'); const links = document.querySelectorAll('link[title]'); const changeSkin = theme =&gt; &#123; [...links].forEach(link =&gt; &#123; link.disabled = true; link.disabled = link.id !==`theme-$&#123;theme&#125;`; &#125;); console.log(links) &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 要注意的是，如果具有alternate的元素有两个及以上的disbaled都为false，那么哪个都不会加载。 这种方法的优点是： 兼容性好 语义非常好 交互体验好，因为CSS文件被提前加载了，切换皮肤时不会有延迟 文档中的代码在这里。 参考 link rel=alternate网站换肤功能最佳实现@鑫空间鑫生活]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router03 按需加载]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router03%20%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[为了提高页面加载性能，加载首屏的加载速度，有的时候我们需要对路由进行懒按需加载，减少首屏需要加载的代码包的体积。 按需加载就是不加载当前路由匹配的组件代码，而不加载其他组件的代码 V3中的实现在V4版本之前，需要利用getComponet这个API来实现按需加载： 12345678const about = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require(&apos;../Component/about&apos;).default) &#125;, &apos;about&apos;)&#125;//配置route&lt;Route path=&quot;helpCenter&quot; getComponent=&#123;about&#125; /&gt; 其中require.ensuire是Webpack的语法： 123456require.ensure( dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String) 给定dependencies参数，将对应的文件拆分到单独的bundle中，此bundle会被异步加载。可以实现动态加载依赖（使用CommonJS的模块语法时这是动态加载依赖的唯一方法），这样能够做到在模块执行时才运行代码，只有在满足某些条件时才加载依赖项。 V4中的实现由于V4版本的动态路由的机制，以及废除了getComponent这个API，实现按需加载的方法比较复杂，首先需要介绍bundle-loader这个Webpack插件，它可以将模块改成异步方式引用，需要单独安装并且在Webpack中进行配置，具体参考Webpack的文档。 准备好bundle-loader之后，正式开始： （1）第一步，创建包装组件模型bundle.js，用来处理经过bundle-loader处理后的组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &apos;react&apos;;class Bundle extends React.Component &#123; constructor(arg)&#123; super(arg) this.state = &#123; mod: null, &#125; &#125; componentWillMount() &#123; this.load(this.props); &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.load !== this.props.load) &#123; this.load(nextProps); &#125; &#125; // load 方法，用于更新 mod 状态 load(props) &#123; // 初始化 this.setState(&#123; mod: null &#125;); /* 调用传入的 load 方法，并传入一个回调函数 这个回调函数接收 在 load 方法内部异步获取到的组件，并将其更新为 mod */ props.load(mod =&gt; &#123; this.setState(&#123; mod: mod.default ? mod.default : mod &#125;); &#125;); &#125; render() &#123; /* 将存在状态中的 mod 组件作为参数传递给当前包装组件的&apos;子&apos; */ return this.state.mod ? this.props.children(this.state.mod) : null; &#125;&#125;export default Bundle ; （2）第二步，创建包装组件的方法 12345678910111213141516171819import React from &apos;react&apos;;import Bundle from &apos;./Bundle&apos;;// 默认加载组件，可以直接返回 nullconst Loading = () =&gt; &lt;div&gt;Loading...&lt;/div&gt;;/* 包装方法，第一次调用后会返回一个组件（函数式组件） 由于要将其作为路由下的组件，所以需要将 props 传入 */const lazyLoad = loadComponent =&gt; props =&gt; ( &lt;Bundle load=&#123;loadComponent&#125;&gt; &#123;Comp =&gt; (Comp ? &lt;Comp &#123;...props&#125; /&gt; : &lt;Loading /&gt;)&#125; &lt;/Bundle&gt;);//实际上lazyLoad就是一个函数,组件调用即可export default lazyLoad; 在上面的代码中回到出一个函数供组件调用，传入的参数loadComponent就是要加载的组件，在路由中调用，而bundle.js作为按需加载的核心，传入的参数load就是要加载的组件，其中的内容是动态的子组件 （3）在路由中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &apos;react&apos;;import &#123; NavLink, Route, Switch, BrowserRouter as Router &#125; from &apos;react-router-dom&apos;;import &apos;./style/style.css&apos;;import &apos;bundle-loader&apos;;// bundle模型用来异步加载组件import Bundle from &apos;../routes/Bundle.js&apos;;import lazyLoad from &apos;../routes/lazyLoad&apos;;import Page1 from &apos;bundle-loader?lazy&amp;name=page1!../components/page1/index&apos;;import Page2 from &apos;bundle-loader?lazy&amp;name=page2!../components/page2/index&apos;;import Page3 from &apos;bundle-loader?lazy&amp;name=page3!../components/page3/index&apos;;class AppPage extends React.Component &#123; constructor(arg) &#123; super(arg); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;Router basename=&quot;/&quot;&gt; &lt;div className=&quot;appWried&quot;&gt; &lt;div className=&quot;appBtn&quot;&gt; &lt;NavLink to=&quot;/page1&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE1 &lt;/NavLink&gt; &lt;NavLink to=&quot;/page2&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE2 &lt;/NavLink&gt; &lt;NavLink to=&quot;/page3&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE3 &lt;/NavLink&gt; &lt;/div&gt; &lt;Switch&gt; &lt;Route path=&quot;/page1&quot; component=&#123;lazyLoad(Page1)&#125; /&gt; &lt;Route path=&quot;/page2&quot; component=&#123;lazyLoad(Page2)&#125; /&gt; &lt;Route path=&quot;/page3&quot; component=&#123;lazyLoad(Page3)&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default AppPage; 在上面的代码中，使用bundle-loader加载模块时语法为 1import Page1 from 'bundle-loader?lazy&amp;name=page1!../components/page1/index'; 其中lazy表示懒加载，name表示要异生成的文件的名字。 （4）最后需要在webpack.config.js文件中进行配置 12345output: &#123; path: path.resolve(__dirname, './output'), filename: '[name].[chunkhash:8].bundle.js', chunkFilename: '[name]-[id].[chunkhash:8].bundle.js',&#125;, 参考 模块方法@weback 前端性能优化之按需加载(React-router+webpack)@xiaobe]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
        <tag>按需加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router02 静态路由和动态路由]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router02%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[React-RouterV3/V4两个版本理念上的区别。 静态路由传统的路由一般都是静态路由，像Express等框架，使用的都是静态路由： 12345678React.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 路由集中配置，UI与路由强绑定。 React-Router V3版本采用的就是静态路由，本质就是path到模块的映射，这种映射关系是静态的。只要程序已启动，映射关系就不能改变了。 从V4版本开始变为了动态路由。这是因为静态路由存在着天生的问题： （1）路就有写法需要满足约定的格式，比如不能将&lt;Route&gt;脱离&lt;Router&gt;使用，这与React倡导的“可以声明式灵活性进行组件组装”的理念。 12// 静态路由不支持const CoolRoute = (props) =&gt; &lt;Route &#123;...props&#125; cool=&#123;true&#125;/&gt; （2）因为&lt;Router&gt;接管了组件，内部实现了createElement、render等方法，同时提供了组件生命周期回调onEnter、onLeave、·onChange`等，而这些生命周期React本身是为组件提供了的。 （3）为了适应代码拆分，引入了getComponent和getChildRoutes 动态路由为了解决以上问题，V4版本中引入了动态路由的概念。 既然React组件渲染时动态发生的，在V4中可以将路由看成普通的React组件，传递props来正常使用，借助它来控制组件的展现。展示的逻辑及权利回归到了组件本身。这样没有了静态配置的路由规则，取而代之的是程序在运行渲染过程中动态控制的展现。 这边是V4中的动态路由的概念。 当&lt;Router&gt;作为普通组件后，React-Router提供的一些特殊的API就不存在了，因为React会为组件提供对应的生命周期函数等API。 通过代码看一下静态路由和动态路由的区别： 123456789101112131415161718192021222324252627// V3import &#123; Router, Route, IndexRoute &#125; from &apos;react-router&apos;const PrimaryLayout = props =&gt; ( &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 3 App &lt;/header&gt; &lt;main&gt; &#123;props.children&#125; &lt;/main&gt; &lt;/div&gt;)const HomePage =() =&gt; &lt;div&gt;Home Page&lt;/div&gt;const UsersPage = () =&gt; &lt;div&gt;Users Page&lt;/div&gt;const App = () =&gt; ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;PrimaryLayout&#125;&gt; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/users&quot; component=&#123;UsersPage&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;)render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)) 在上面的路由中，配置集中在App中，&lt;Route&gt;直接嵌套与&lt;Router&gt;，页面组件作为路由的一分部分与路由机密耦合。这便是整个路由的配置。 V4版本的写法： 123456789101112131415161718192021222324import &#123; BrowserRouter, Route &#125; from &apos;react-router-dom&apos;const PrimaryLayout = () =&gt; ( &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 4 App &lt;/header&gt; &lt;main&gt; &lt;Route path=&quot;/&quot; exact component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/users&quot; component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;)const HomePage =() =&gt; &lt;div&gt;Home Page&lt;/div&gt;const UsersPage = () =&gt; &lt;div&gt;Users Page&lt;/div&gt;const App = () =&gt; ( &lt;BrowserRouter&gt; &lt;PrimaryLayout /&gt; &lt;/BrowserRouter&gt;)render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)) V4中React-Router仓库拆分成了多个包进行发布： react-router，路由基础库 react-router-dom，浏览器中使用的封装 react-router-native，React Native的封装 嵌套路由相比于V3中的集中式的静态路由，V4中似乎看不到路由的影子了，它穿插在了各组件中。尤其是在需要路由嵌套的情况下更加明显，路由嵌套到了组件中，而不再是像V3中那样，&lt;Route&gt;中嵌套&lt;Route&gt;，V4中&lt;Route&gt;中不允许再嵌套&lt;Route&gt; 1234567891011121314151617181920// V3const App = () =&gt; ( &lt;BrowserRouter&gt; &lt;div&gt; &#123;/* 外层路由 */&#125; &lt;Route path=&quot;/tacos&quot; component=&#123;Tacos&#125;/&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;)// 当URL匹配`/tacos`时渲染Tacos组件const Tacos = (&#123; match &#125;) =&gt; ( &lt;div&gt; &#123;/* 嵌套路由，match.url可以更方便的使用相对地址 */&#125; &lt;Route path=&#123;match.url + &apos;/carnitas&apos;&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;) 上面的代码中，&lt;Tacos&gt;组件是否展示，取决于当前路由是否与/tacos匹配，而&lt;Route&gt;可以理解为一个容器，它做的事情很简单，将传入的path与当前的location进行比较，撇皮则渲染component属性传入的组件，否则return null 在看一个嵌套路由的例子，V3中&lt;Route&gt;中嵌套&lt;Route&gt;： 12345678&lt;Router history=&#123;history&#125; createElement=&#123;createElement&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&quot;home&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 最顶层的&lt;Route&gt;对应的是&lt;App&gt;这个组件，这个组件的事情就是渲染&lt;TopMenu&gt;，并且把传入的子组件全部渲染出来： 12345678const App = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;TopMenu /&gt; &lt;div&gt;&#123;children&#125;&lt;/div&gt; &lt;/div&gt; );&#125;; 因为&lt;App&gt;对应的URL是/，所以所有的路由都会鲜明中&lt;App&gt;，然后&lt;App&gt;会渲染子组件，而它的子组件除了&lt;TopMenu&gt;之外就是其他的路由&lt;Route&gt;，于是/home就会命中对应的路由，渲染结果中既包含了&lt;TopMenu&gt;也包含了&lt;Home&gt; 在V4中，&lt;Route&gt;不能再包含&lt;Route&gt;，代码需要改为： 12345678910&lt;Router history=&#123;history&#125;&gt; &lt;div&gt; &lt;TopMenu /&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route exact path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; &lt;Route&gt;变成了普通的React组件，可以认为它是在渲染时动态决定路由对应什么组件的。&lt;Switch&gt;的左右就是只渲染子组件中&lt;Route&gt;第一个匹配的。 动态路由的问题动态路由也有着自己的问题： 不够直观，由于路由分散，无法一下子了解程序中所有的路由 测试难度增加，组件中掺杂了路由逻辑，原本针对组件的单元测试需要考虑路由的逻辑 实际上，React开发者对V4版本的改变也是喜忧参半，React官方也并没有强制开发者升级，因为V2/3版本会持续维护。 参考 心中无路由，处处皆自由/react-router v4 动态路由@github React Router v4 几乎误我一生@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础12 React中的this绑定]]></title>
    <url>%2F2019%2F05%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8012%20React%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[React组件中的this绑定到底是怎么一回事？学习一下。 为什么要bind(this)React的Class组件中常常会用到bind(this)来绑定this，但是究竟为什么要这么做呢？难道Class中的方法拿不到实例的this吗？ 来试验一下： 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125; say() &#123; console.log('my name is ' + this.name); &#125;&#125; 上面代码的Person类中，say方法去获取了this，然后当我们实例化一个对象时，并调用say()方法时，结果是： 123let p1 = new Person('Jay');p1.say();// my name is Jay 结果说明在Class的方法中，是可以直接通过this获得实例对象的。所以实际上在React的Class中直接使用this是没有问题的，例如在生命周期函数或者render中。但是在render函数中的JSX模板中的事件处理函数，这里面的调用的方法的this就不会指向组件实例： 12345678910111213export default class Demo5 extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 上面的handleClick函数作为JSX中的事件处理函数，其中的this不会指向组件实例，而是指向了事件响应的上下文环境（非严格环境下是window，严格环境下是undefined），而类声明和类表达式的主体以严格模式执行（主要包括构造函数、静态方法和原型方法以及getter和setter函数），所以this指向undefined 为什么this不能指向组件实例实际上这与React和JSX语法没有关系，是JavaScript的this绑定机制导致了上述情况的发生。要明确的是，函数内部的this取决于该函数被调用时的上下文环境。 默认绑定12345function display()&#123; console.log(this); // 'this' 将指向全局变量&#125;display(); 在上面的情况下，display方法中的this在非严格模式下指向window，在严格模式下指向undefined 隐式绑定12345678const obj = &#123; name: 'Saurabh', display: function()&#123; console.log(this.name); // 'this' 指向 obj &#125;&#125;;obj.display(); // Saurabh 在上面的情况下，通过obj对象来调用这个函数时，display内部的this指向了obj。 但是如果将这个函数赋值给其他变量，并且通过这个变量去调用该函数时，在display中获得this就不同了： 123var name = 'hello';const outer = obj.display;outer(); // 'hello' 我们调用outer时，并没有指定一个具体的上下文对象，这个时候this值与默认绑定的结果是相同的，在非严格模式下指向window，在严格模式下指向undefined 在将一个方法以回调的形式传递给另外一个函数，或者像setTimeout这样的内置JavaScript函数时，就可以依照上面的过程进行判断 例如我们自定义一个setTimeout方法并调用，预测一下会发生什么： 12345678//setTimeout 的虚拟实现function setTimeout(callback, delay)&#123; //等待 'delay' 数个毫秒 callback();&#125;setTimeout(obj.display, 1000); 在调用setTimeout时，函数内部将obj.display赋值给参数callback: 1callback = obj.display; 在一段时间后调用这个方法时，调用的实际上是callback()，而这种调用会让display方法丢失上下文，其中的this会退回至默认绑定，指向全局变量 1234var name = "uh oh! global";setTimeout( obj.display, 1000 );// uh oh! global 显示绑定为了避免上面的情况，可以使用bind来显式的为方法绑定上下文： 12345var name = "uh oh! global";var outerDisplay = obj.display.bind(obj); outerDisplay();// Saurabh 绑定了this后，在调用对应的方法也能够渠道我们绑定的上下文。同理，粗若将obj.display作为callback参数传递给函数，display中的this也会正确指向obj React编译时的处理明确了隐式绑定时，将方法作为参数传递给另一个函数时会导致该方法的上下文丢失。而在React的类的写法中，JSX的事件处理程序的this会丢失，就是因为这个原因。 在编译JSX的过程中，事件处理程序会作为属性值被放置在一个对象中，调用时会识别为函数调用模式，上下文丢失。 举个例子，下面的Class组件： 123456789101112131415export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; this.handleClick(); return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 编译完是下面这样的： 12345678910111213141516171819const Demo = function (_Component) &#123; _inherits(Deom, _Component); function Demo() &#123; _classCallCheck(this, Demo); return _possibleConstructorReturn(this, _Component.apply(this, arguments)); &#125; Demo.prototype.handleClick = function handleClick() &#123; console.log(this); &#125; Demo.prototype.render = function render() &#123; this.handleClick(); return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( 'div', &#123; onClick: this.handleClick &#125;, 'hello', ) &#125; return Demo;&#125;(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]) 很明显的看到，当编译完成后，JSX中的事件处理程序handleClick是放置在{ onClick: this.handleClick }中，当点击事件触发时实际上调用的是onClick，和隐式调用中的结果一样，上下文丢失了，this指向undefined。 而如果我们在JSX中使用bind绑定this： 1&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;Hello&lt;/div&gt; 那么编译后就变成了{ onClick: this.handleClick.bind(this) }，这就显式的绑定了this。 解决方法（1）React官方首推的一种方法就是使用实验性的语法public class fileds，可以使用class fields正确的绑定回调函数： 12345678910111213export default class Demo extends Component &#123; handleClick = () =&gt; &#123; console.log(this); &#125;; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 上面的写法会会保证handleClick内的this被正确绑定，要注意的是这是一个实验性的语法，但是Create React App默认启用了这个语法。 如果没有使用Create React App的话需要手动开启这个语法，使用Babel的transform-class-properties或者enable stage-2 in Babel这两项功能 （2）第种方式是在JSX的回调函数中使用箭头函数： 12345678910111213export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这种语法的主要问题还是来自于性能的担忧，因为每次渲染组件时都会创建不同的回调函数。大多数情况时没有什么问题，但是如果该回调函数作为prop传入子组件时，这些组件可能会进行额外的重新渲染。 （3）第三种方式是在JSX的回调函数中使用bind进行绑定： 12345678910111213export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这种方法的问题和上一种是类似的，有可能带来性能的问题。 （4）第四种方式是在构造函数constructor中进行显示的绑定： 123456789101112131415161718export default class Demo extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这样就可以避免第二种方法可能带来的性能问题，而且很直观，但问题是增加了代码数量，而且为了绑定this必须声明constructor，在constructor中还不能忘记super，有点麻烦 所以，从性能角度上考虑，如果开启了对应的public class fileds语法（使用了Create React App），那么建议使用第一种方式，否则的话建议使用最后一种方式。 参考 事件处理@React react为什么需要手动绑定方法？@React教程中文网 [译] 为什么需要在 React 类组件中为事件处理程序绑定 this@掘金 React與bind this的一些心得@medium]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础11 React中初始化state的两种方法]]></title>
    <url>%2F2019%2F05%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8011%20React%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96state%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在React的组件中可以在两个位置来初始化state：（1）在组件的constructor中；（2）直接在class中利用属性赋值的方式 在constructor中在constructor中初始化state如下所示： 12345678910111213141516171819class App extends React.Component &#123; constructor(props) &#123; // 必须在这里通过super调用父类的constructor super(props); // 给state赋值，可以使用props this.state = &#123; loggedIn: false, currentState: "not-panic", // 在使用props为state赋值时要格外仔细 someInitialValue: this.props.initialValue &#125; &#125; render() &#123; // whatever you like &#125;&#125; 当一个class组件创建之后，constructor会首先被调用，所以在construcot中可以来初始化所有值，包括state。class实例在内存中已经被创建，所以可以使用this来为state赋值 要注意的是，在constructor中可以不使用this.setState来为state直接赋值，除此之外其他位置都不能这样做： 12// 除了在constructor中，其他位置都不要这样做this.state.a = 123 只有通过setState才能通知React，我们修改了数据，React需要重新渲染组件。 还有要注意的是，在constructor中不要忘记使用super(props)来调用父类的constructor。默认的constructor（当创建一个class时，如果我们没有显式的声明constructor，JS会默认提供一个）会自动调用super，将将所有的参数传入 使用prop来初始化state大多数情况下都不要使用prop来为State的初始化赋值，因为这会让你的数据来源不唯一，这常常会导致Bug。数据源唯一是最佳实践。 当组件的prop发生改变，组件会重渲染，所以没有必要将prop复制为state来保证porp永远是最新的值。 123456789101112131415161718192021222324252627282930313233343536// 不要这样做class BadExample extends Component &#123; state = &#123; data: props.data &#125; componentDidUpdate(oldProps) &#123; // 复制了prop的值给state之后 // 必须保证在props更新时，state的值也随之更新 if(oldProps.data !== this.props.data) &#123; // This triggers an unnecessary re-render this.setState(&#123; data: this.props.data &#125;); &#125; &#125; render() &#123; return ( &lt;div&gt; The data: &#123;this.state.data&#125; &lt;/div&gt; ) &#125;&#125;// 正确的做法：class GoodExample extends Component &#123; render() &#123; return ( &lt;div&gt; The data: &#123;this.props.data&#125; &lt;/div&gt; ) &#125; &#125; constructor是必须的吗？并一定必须显式的定义constructor，因为JS会提供默认的constructor。比如下面这个例子： 12345678910class Parent &#123; constructor(arg) &#123; console.log('constructing Parent with', arg) &#125; &#125;class Child extends Parent &#123;&#125;new Child(5);// constructing Parent with 5 当创建Child的实例时，控制台会打印出constructing Parent with 5，虽然Child类并没有显式的定义constructor，也没有显式的通过super(props)调用父类。当我们没有定义自己的constructor时，JS会自动完成super的步骤。 直接在Class中定义第二种初始化state的方法就是直接在Class的内部，使用Class的属性来定义： 1234567891011class App extends React.Component &#123; state = &#123; loggedIn: false, currentState: "not-panic", someDefaultThing: this.props.whatever &#125; render() &#123; // whatever you like &#125;&#125; 比如使用construcot更加得直接、简介。要注意的是： 没有定义constructor state属性是直接引用的，并不是通过this.state来引用的 state的作用域是在Class内部，并不是一个方法的内部 仍然可以使用this.props和this.context state是class的实例属性，并不是静态属性，不需要添加static关键字（就像为static propTypes {...}） 哪种更好习惯使用哪种，就使用哪种。 class属性的方式看起来更加简单，不再需要额外的模板代码（constructor），也不需要提醒自己调用super(props) 有的时候需要在constructor中处理事件处理函数（为函数绑定this，就像： 12345678910class Thing extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick(event) &#123; // do stuff &#125;&#125; 可以通过Class属性的另外一种形式来替代上面的形式，可以让一个属性等于一个箭头函数，箭头函数获得了class实例的this，所以不再需要在constructor中显式的去绑定： 12345class Thing extends React.Component &#123; handleClick = (event) =&gt; &#123; // do stuff &#125;&#125; 参考 Where to Initialize State in React@Dave Ceddia]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>state</tag>
        <tag>constructor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg02 使用Postman发送Post请求]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg02%20%E4%BD%BF%E7%94%A8Postman%E5%8F%91%E9%80%81Post%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用Postman测试Egg框架实现的API 关闭安全防范默认情况下，Egg在框架中内置了安全插件egg-security，插件中针对post请求做出了一些处理，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的enable属性为false即可。 写例子的话可临时在config/config.default.js中设置 123exports.security = &#123; csrf: false&#125;; 在网页发送请求在AJAX请求中，默认配置下，token会被设置在Cookie中，在AJAX请求时，可以从Cookie中获取到token，放置到query、body或者header中发送给服务端： 使用jQuery： 12345678910111213var csrftoken = Cookies.get('csrfToken');function csrfSafeMethod(method) &#123; // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));&#125;$.ajaxSetup(&#123; beforeSend: function(xhr, settings) &#123; if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) &#123; xhr.setRequestHeader('x-csrf-token', csrftoken); &#125; &#125;,&#125;); 通过header传递CSRF token的字段可以在配置中改变： 12345678// config/config.default.jsmodule.exports = &#123; security: &#123; csrf: &#123; headerName: 'x-csrf-token', // 通过 header 传递 CSRF token 的默认字段为 x-csrf-token &#125;, &#125;,&#125;; 在Postman中发送请求使用Postman来测试API时，直接发送POST请求，会返回403，因为没有传递CSRF token，这个时候可以通过环境配置，来让Postman自动生成CSRF token。 这个功能需要使用独立的Postman APP，Chrome插件是不行的。 在Postman右上角，新建一个环境： 点击Add添加后，将环境切换为新建的环境： 然后在Tests标签下，通过下面的脚本，获取cookie中的csfrtoken，并且写入到postman的全局变量中： 123var csrf_token = postman.getResponseCookie("csrftoken").valuepostman.clearGlobalVariable("csrftoken");postman.setGlobalVariable("csrftoken", csrf_token); 然后发送一个Get请求，来写入Cookie： 在发送Post请求时，在Header中添加字段： 再点击发送Post请求就没问题了。 参考 安全@Egg postman自动设置token(csrf及authorization token)@knktc的杂乱空间]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa01 中间件]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F02%20Koa%2FKoa01%20%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。基本上，Koa 所有的功能都是通过中间件实现的。 概念Koa中间件的最大特色就是中间件（middleware）的设计。 中间件是一个函数，它处在HTTP Request和HTTP Response中间，用来实现某种中间功能，通过app.use()来加载中间件。 1234567891011const Koa = require('koa');const app = new Koa();app.use(async (ctx) =&gt; &#123; ctx.response.body = 'GO'&#125;);app.listen(8080, () =&gt; &#123; console.log('app is listening 8080...');&#125;); 中间件的执行顺序多个中间件会形成栈结构，以先进后出的顺序执行： 最外层的中间件首先执行 代用next函数，把执行权交给下一个中间件 …… 最内层的中间件最后执行 执行结束后，把执行权交回上一层的中间件 …… 最外层的中间件收回执行权后，执行next函数后面的代码 看下面的例子： 12345678910111213141516171819202122app.use(async (ctx, next) =&gt; &#123; console.log(1-1); ctx.response.body = 'GO'; next(); console.log(1-2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(2-1); next(); console.log(2-2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3-1); next(); console.log(3-2);&#125;);app.listen(8080, () =&gt; &#123; console.log('app is listening 8080...');&#125;); 执行结果是： 1234561-12-13-13-22-21-2 这种先进后出的加载模型也可以叫做洋葱圈的模型： 如果中间件内部没有调用next函数，那么执行权就不会传递下去。 异步中间件当中间件中包含异步操作时，中间件应该写成Async函数： 123app.use(async (ctx, next) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 注意，如果调用next，必须等待完成 12345678app.use(async (ctx, next) =&gt; &#123; console.log(1); next();&#125;);app.use((ctx) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 如果是上面的形式，返回的body中将没有任何内容，这是因为Koa在Promise链被机械系了之后就结束了请求，这意味着我们在设置ctx.response.body之前，response就已经被发送了给客户端，正确的做法应该是在第一个中间件的next之前添加await： 12345678app.use(async (ctx, next) =&gt; &#123; console.log(1); await next();&#125;);app.use((ctx) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 当使用纯粹的Promise（不使用Async/Await）应该写成这样： 123456app.use((ctx, next) =&gt; &#123; ctx.status = 200 console.log('Setting status') // need to return here, not using async-await return next()&#125;) 处理中间件中的错误为了方便处理错误，最好使用try...catch将其捕获。但是为每个中间件写try...catch太麻烦，可以让最外层的中间件负责所有中间件的错误处理 123456789101112131415161718192021const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (e) &#123; ctx.response.status = e.statusCode || e.status || 500; ctx.response.body = &#123; message: e.message &#125; &#125;&#125;;app.use(handler);app.use(async (ctx, next) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8'); await next();&#125;);app.use((ctx) =&gt; &#123; ctx.throw(500)&#125;); 运行中，没有被catch的错误都会触发Koa的error时间，监听这个事件，也可以处理错误： 1234567const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', (err, ctx) =&gt; console.error('server error', err);); 但是如果错误被catch捕获，就不会触发error事件，这时候必须调用ctx.app.emit()手动释放error事件，才能使监听函数生效。 1234567891011121314151617// demos/18.js`const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit('error', err, ctx); &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', function(err) &#123; console.log('logging error ', err.message); console.log(err);&#125;); 中间件的开发generator中间件的开发Koa1中的异步流程控制使用的是Generator函数，所以Koa1的中间件都是基于generator的。 Generator中间件返回的是function *(){}函数： 123456789101112131415function log(ctx) &#123; console.log(ctx.method, ctx.header.host + ctx.url);&#125;module.exports = function () &#123; return function* f(next) &#123; // 执行中间件的操作 log(this); if (next) &#123; yield next; &#125; &#125;&#125;; Generator中间件在Koa1中可以直接使用，在Koa2中需要使用koa-convert转换后进行使用 1app.use(convert(loggerGenerator())); Async中间件的开发1234567891011121314function log(ctx) &#123; console.log(2, ctx.method, ctx.header.host + ctx.url);&#125;module.exports = function () &#123; return async function f(ctx, next) &#123; // 执行中间件的操作 log(ctx); if (next) &#123; await next(); &#125; &#125;&#125;; Async中间件在Koa2中可以直接使用： 1app.use(loggerAsync()); 中间件引擎简单实现Koa中的中间件的加载和解析主要是通过Koa的中间件引擎koa-compose模块来实现的，也是Koa实现洋葱模型的核心引擎。 1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa');let app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6); &#125;const middleware2 = async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5); &#125;const middleware3 = async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4); &#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.use(async(ctx, next) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3001)// 启动访问浏览器// 控制台会出现以下结果// 1// 2// 3// 4// 5// 6 上面await next前后的操作，很像数据结构的一种场景——栈，先进后出，并且各个中间件有着统一的上下文，便于管理、操作数据，所以Koa的中间件具有以下特性： 有统一的上下文对象context 执行顺序先进后出 通过next来控制先进后出的机制 有提前结束机制 可以简单的用Promise来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Created By zh on 2019-05-05 */// 所以 Koa 的中间件具有以下特性：// 1 有统一的上下文对象 context// 2 执行顺序先进后出// 3 通过 next 来控制先进后出的机制// 4 有提前结束机制// 可以使用 Promise 来做一个简单的实现let context = &#123; data: []&#125;;class MyKoa &#123; constructor() &#123; this.middlewares = []; this.context = &#123; data: [] &#125; &#125; use(middleware) &#123; this.middlewares.push(middleware) &#125; compose() &#123; let count = -1; const dispatch = () =&gt; &#123; count += 1; return Promise.resolve(this.middlewares[count](this.context, async () =&gt; &#123; if (this.middlewares.length - 1 === count) &#123; return Promise.resolve() &#125; return dispatch() &#125;)) &#125;; return dispatch().then(() =&gt; &#123; console.log('end'); console.log('context = ', this.context); &#125;); &#125;&#125;async function middleware1(ctx, next) &#123; console.log('action 001'); ctx.data.push(1); await next(); console.log('cation 006'); ctx.data.push(6)&#125;async function middleware2(ctx, next) &#123; console.log('action 002'); ctx.data.push(2); await next(); console.log('cation 005'); ctx.data.push(5)&#125;async function middleware3(ctx, next) &#123; console.log('action 003'); ctx.data.push(3); await next(); console.log('cation 004'); ctx.data.push(4)&#125;const app = new MyKoa();app.use(middleware1);app.use(middleware2);app.use(middleware3);app.compose();// action 001// action 002// action 003// cation 004// cation 005// cation 006// end// context = &#123; data: [ 1, 2, 3, 4, 5, 6 ] &#125; 源码解读核心原理就如同上面的compose方法所示，洋葱模型的先进后出顺序，对应Promise.resolve的前后操作，来看一下koa-compose的源码： 12345678910111213141516171819202122232425262728293031323334353637383940const compose = middleware =&gt; &#123; if (!Array.isArray(middleware)) &#123; throw new TypeError('Middleware stack must be an array') &#125; for (const fn of middleware) &#123; if (typeof fn !== 'function') &#123; throw new TypeError('Middleware must be composed of functions') &#125; &#125; return function (context, next) &#123; let index = -1; return dispatch(0); function dispatch(i) &#123; console.log(index, 888); console.log(i, 999); // 理论上 i 会大于 index，因为每次执行一次都会把 i 递增， // 如果相等或者小于，则说明 next() 执行了多次 if (i &lt;= index) &#123; return Promise.reject(new Error('next() called multiple times')); &#125; index = i; // 取到当前的中间件 let fn = middleware[i]; if (i === middleware.length) &#123; fn = next; &#125; if (!fn) &#123; return Promise.resolve(); &#125; try &#123; return Promise.resolve(fn(context, function () &#123; return dispatch(i + 1); &#125;)) &#125; catch (err) &#123; return Promise.reject(err); &#125; &#125; &#125;&#125;; 一个中间件中是不能够调用两次next，这是通过if (i &lt;= index)这条代码来判断的，我想了好一会，才理解这是什么原理。先把它放在这里，把主题逻辑理清楚再回过头说它。 compose返回了一个匿名函数，匿名函数里定义了dispatch函数，并传入0作为初始函数。 在dispatch函数中，i用于标识当前的中间件的下标（中间件通过use方法收集到了middleware这个数组中）。 然后判断next是否在一个中间件中多次调用（暂时略过），然后将当前的i赋值给index，index的唯一的作用也是用来记录当前中间件的下标，判断next方法调用的次数，后面再说。 接下来对fn赋值，获得中间件，在定义中间件时传入了两个参数，第一个就是上下文对象ctx，第二个参数是用来控制流程的next方法，这个next方法中我们通过执行dispatch(i + 1)来递归调用，执行下一个中间件。 这也是为什么我们在自己编写中间件时需要手动执行await next()，只有执行了next函数，才能正确的执行下一个中间件 在多个中间件级联执行时，第一个中间件需要等待第二个中间件返回一个resolved的Promise，也就是在await next()后才能继续执行剩余代码，第二个中间件同样需要等待下一个中间件返回resolved的Promise，这样就实现了洋葱圈模型的执行顺序。 所以如果要写一个Koa2的插件就应该如同上面说的一样： 12345678910async function koaMiddleware(ctx, next)&#123; try&#123; // do something await next() // do something &#125;.catch(err)&#123; // handle err &#125;&#125; 使用时： 1app.use(koaMiddleware) 多次next的判定虽然只有一行代码用来判断如果在一个中间件中执行了多次next方法，却真让我想了好一会才理解，还是我太笨了。 1if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) 正常情况下，index必然会小于i，在执行dispatch(i+1)时，实际上可以认为将当前中间件改变为了下一个中间件，每一个中间件都有着自己的闭包作用域，闭包中的i是固定的，而index是在闭包之外的变量，当执行到下一个中间件时index的值会发生改变。 如果执行了两次next，每个中间件的i是固定的，但是index一直在增大，出现了i &lt;= index的情况，拿下面的情况举例吧： 有两个中间件： 1234567891011async function middleware1(ctx, next) &#123; console.log('action 001'); await next(); console.log('action 004');&#125;async function middleware2(ctx, next) &#123; console.log('action 002'); await next(); console.log('action 003');&#125; 同时我们在dispatch中打印出index和i的值： 12345function dispatch(i) &#123; console.log('index: ', index); console.log('i: ', i); // ...&#125; 在正常情况下打印的结果： 123456789101112index: -1i: 0action 001index: 0i: 1action 002index: 1i: 2action 003action 004 如果在第一个中间件中执行两个next，执行结果： 1234567891011121314151617181920index: -1i: 0action 001index: 0i: 1action 002index: 1i: 2action 003index: 2i: 1something wrong-- Error: next() called multiple times at dispatch (/Users/duola/projects/node-learning/demo4/koa-compose.js:33:31) at /Users/duola/projects/node-learning/demo4/koa-compose.js:46:18 at middleware1 (/Users/duola/projects/node-learning/demo4/koa-compose.js:87:9) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) 执行时，进入“洋葱圈”的过程是不变的，但是在执行完action3之后，在第一个中间件中再次执行了next，而在第一个中间件中，i是一个闭包中固定的值，为0，所以在执行的dispatch是dispatch(1)，在执行完action3之后，index已经变成了2，这时候在判断时，i &lt;= index相当于1 &lt;= 2是成立的，抛出了错误。 参考 Koa 框架教程@阮一峰的网络日志 掌握 Koa 中间件@Joe’s Blog koa中间件开发和使用@Koa2进阶学习笔记 深入理解 Koa2 中间件机制@掘金]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node14 Buffer对象]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode14%20Buffer%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Buffer对象是Node处理二进制数据的一个接口，它是Node原生提供的全局对象，可以直接使用，不需要require 概述Buffer对象是Node处理二进制数据的一个接口，它是Node原生提供的全局对象，可以直接使用，不需要require Buffer对象是一个构造函数，生成的实例代表了V8引擎分配的一段内存，是一个类数组对象，成员是0到255的数值，即一个8位的字节 123let btyes = new Buffer(2)// &lt;Buffer 00 00&gt; 与二进制数组的关系TypedArray构造函数可以接受Buffer实例作为参数，生成一个二进制数组，例如new Unit32Array(new Buffer([1, 2, 3, 5]))会生成一个4个成员的二进制数组 这时二进制数组对应的内存是从Buffer对象拷贝的，而不是共享的，二进制数组的buffer属性，保留指向原Buffer对象的指针。 Buffer构造函数Buffer作为构造函数，可以使用new命令生成一个实例，可以接受多种形式的参数： 123456789101112131415161718// 参数是整数，指定分配多少个字节内存var hello = new Buffer(5);// 参数是数组，数组成员必须是整数值var hello = new Buffer([0x48, 0x65, 0x6c, 0x6c, 0x6f]);hello.toString() // 'Hello'// 参数是字符串（默认为utf8编码）var hello = new Buffer('Hello');hello.length // 5hello.toString() // "Hello"// 参数是字符串（不省略编码）var hello = new Buffer('Hello', 'utf8');// 参数是另一个Buffer实例，等同于拷贝后者var hello1 = new Buffer('Hello');var hello2 = new Buffer(hello1); 类的方法（1）Buffer.isEncoding()，返回布尔值，表示是否为指定编码 12Buffer.isEncoding('utf8')；// true （2）Buffer.isBuffer()，接受一个对象作为参数，返回布尔值，表示该对象是否是Buffer实例： 12Buffer.isBuffer(Date)；// false （3）Buffer.byteLength()，返回字符串实际占据的字节长度，默认编码为utf-8 1Buffer.byteLength('Hello', 'utf8') // 5 （4）Buffer.concat()，用来将一组Buffer对象合并为一个Buffer对象 12345var i1 = new Buffer('Hello');var i2 = new Buffer(' ');var i3 = new Buffer('World');Buffer.concat([i1, i2, i3]).toString()// 'Hello World' 可以接受第二个参数，指定合并后的Buffer对象的总长度 实例属性/方法（1）length，返回Buffer对象所占据的内存涨肚，与Buffer对象内容无关 12345buf = new Buffer(1234);buf.length // 1234buf.write("some string", 0, "ascii");buf.length // 1234 上面length返回值总是Buffer对象的空间长度，内容的长度通过Buffer.byteLength来获取 length属性是可写的，但是会导致意外，不建议使用，如果想修改Buffer对象的长度，建议使用slice方法返回新的Buffer对象 （2）write()，、向指定的Buffer对象写入数据，第一个参数是写入的内容，第二个参数是写入的起始位置（可省略，默认从0开始），第三个参数是编码方式（默认是utf-8，可省略） 12345678let buf = new Buffer(5)buf.write('Hello')console.log(buf)// &lt;Buffer 48 65 6c 6c 6f&gt;console.log(buf.toString())// 'Hello' （3）slice()，返回一个按照指定位置，所原对象切割的Buffer实例，两个参数是切割的起始位置和终止位置（[start, end) （4）toString()，将Buffer实例按照指定编码（默认为utf-8）转换为字符串 （5）toJSON()，将Buffer实例转换为JSON对象 参考 Buffer对象@JavaScript 标准参考教程（alpha）]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题29 OAuth 2.0]]></title>
    <url>%2F2019%2F04%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9829%20OAtuth%202.0%2F</url>
    <content type="text"><![CDATA[OAuth是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 定义OAuth是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 例子举个例子，京东App要求访问我的微信头像和昵称，这里面，我是数据的所有者，而微信就是服务提供商，也就是上面的系统，而京东就是第三方的客户端。 当京东要求获取我的微信数据时，我不会将我的微信账号和密码直接告诉京东，然后让京东自己去登陆我的微信账号去获取对应的数据，因为这样做会有以下的缺点： 京东也许会保存我的密码，这样很不安全 京东通过密码能够获取我在微信的全部数据，我没有办法限制京东能获得哪些数据、不能获得哪些数据 我除了修改密码之外，没有能够取消京东获取我的微信数据的能力 只要有一个京东这样的、知晓我的密码的第三方APP被破解，我的微信密码就会泄露 所以京东需要通过OAuth这种授权机制来获得我的微信数据。思路是这样的： 京东在它的APP里选择以微信账号登陆京东APP； 京东客户端会跳转到微信设置的认证服务器，向我询问是否允许获取我的微信相关资料； 当我同意之后，微信的认证服务器就会向京东APP颁发登陆令牌（token），这个token与用户密码不同，并且在登陆的时候可以指定token的权限范围有效期； 京东APP获得令牌后，就可以向微信的资源服务器来申请获取用户的微信资料，微信的资源服务器根据令牌的权限和有效期向京东APP开放我的微信头像和昵称。 授权模式OAuth的核心就是向第三方应用颁发令牌，OAuth 2.0定义了四种授权方式来让客户端得到用户的授权： 授权码（authorization-code） 隐藏式（implicit） 密码式（password） 客户端凭证（client credentials） 以上这些授权方式，第三方应用在申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端ID（client ID）和客户端密钥（client secret）。 授权码模式授权码（authorization-code）模式，指的是第三方应用先申请授权码，然后用该授权码获取令牌。 这种方式是最常用的，也是安全性最高的，适用于后后端的Web应用。授权码通过前端传送，令牌存储在后端，所有与资源服务器的通信都在后端完成。这样的前后端分离可以避免令牌泄露。 仍旧以京东和微信举例 （1）第一步，当用户点击京东APP以微信登陆的链接后，就会跳转到微信的认证服务器，下面就是一个示意的跳转链接： 12345https://weixin.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read weixin.com/oauth/authorize就是微信认证服务器的URL，response_type参数表示要求返回授权码（code），client_id参数用来表明客户端的ID，redirect_uri是认证服务器接受或拒接请求后的跳转网址，scope参数表示请求的授权范围 （2）第二步，用户跳转到认证服务器的页面后，会要求用户登录，然后询问是否同意给京东APP授权。用户表示同意后，认证服务器就会调回redirect_uri参数指定的网址，在跳转时会以URL中的query参数的形式传回一个授权码（code） 1https://jd.com/callback?code=AUTHORIZATION_CODE 上面的URL中，code参数对应的值就是授权码 （3）第三步，京东拿到授权码后，就可以在后端向微信认证服务器请求令牌（token） 123456https://weixin.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL 上面URL中，client_id和client_secert参数用来让认证服务器确认京东APP的身份（client_secret是保密的，所以只能在后端发送请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uir参数是令牌颁发后的回调地址。 （4）第四步，微信认证服务器收到请求后，核对信息后就会办法令牌，具体的做法是向redirect_uri指定的网址发送一段JSON数据： 1234567891011121314HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; 上面JSON对象中，access_token就是令牌，京东在后端服务器拿到了。整个过程如下图所示： 第二种方式：隐藏式有一些Web应用是纯前端应用，没有后端，这时就不能使用第一种方式了，需要将令牌存储在前端。这种方式成为隐藏式（implicit），允许直接向前端颁发令牌，而没有授权码这个中间步骤。 （1）第一步，A网站提供一个连接，要求用户跳转到B网站，授权用户数据给A网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read 上面的URL中，response_type参数为token，表示要求直接返回令牌 （2）第二步，用户跳转到上面的URL后，登陆，然后同意向A网站授权。这时B网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为URL的Hash参数，传递给A网站。 1https://a.com/callback#token=ACCESS_TOKEN 上面的token参数就是令牌，A网站直接在前端拿到令牌。 注意，令牌在URL中是使用了Hash参数，也就是锚点位置储存，而不是使用查询字符串。这是因为当跳转网址时HTTP协议时，存在“中间人攻击”的风险，而浏览器跳转时Hash参数不会发送到服务器，减少了令牌泄露的风险。 下面于OAuth的安全设置的内容笔记，专门讨论这一部分内容。 这个过程如下所示： 这种方式把令牌直接传给前端，是很不安全的。因此只适用于安全性不搞的场景，且令牌的有效期必须非常短，通常是会话期间有效，浏览器关了令牌就失效。 第三种方式：密码式如果高度信任某个应用，允许用户把用户名和密码直接告诉该应用，该应用使用密码来申请令牌。这种方式称为密码是（password） （1）第一步，A网站要求用户提供B网站的用户名和密码，拿到以后，A就直接向B请求令牌 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID 上面的URL中，grant_type参数是password，代表授权方式是密码式，username和password就是B的用户名和密码。 （2）第二步，B网站验证身份通过后，直接给出令牌，这里给出令牌的方式不再是通过URL的跳转，而是将令牌放在JSON数据中，作为HTTP响应，返回给A网站。 这种方式需要用户给出用户名和密码，风险很大，因此只适用于其他授权方式都无法采用、并且对应用高度信任的情况下。 第四种方式：凭证式凭证式（client credentials）适用于没有前端的命令行应用，即在命令行下请求令牌。 （1）第一步，A应用在命令行向B发出请求 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET 上面的URL中，grant_type参数client_credentials表示采用凭证式的授权方式，client_id和client_sercret用来表示A应用的身份。 （2）第二步，B网站验证通过后，直接返回令牌。 这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，有可能多个用户共享一个令牌。 令牌的使用拿到令牌后，A网站就可以向B网站提供数据资料的API请求数据了。 此时，每个发到API的请求，都必须带有令牌，具体做法是在请求的头信息加上Authoization字段，令牌就在这个字段里。 12curl -H "Authorization: Bearer ACCESS_TOKEN" \"https://api.b.com" 上面的命令中，ACCESS_TOKEN就是拿到的令牌。 curl命令是一个命令行工具，支持多种协议，可以再命令行发出网络请求，然后得到和提取数据，显示在标准输出（stdout）上面。-H参数用来自定义头信息发送给服务器。 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的获取流程，申请新的令牌，体验会很差。OAuth 2.0允许用户自动更新令牌。 具体做法是，B网站颁发令牌的时候，一次性颁发两个令牌，一个用来获取数据，一个用于获取新的令牌。令牌到期前，用户使用refresh token发送请求，更新令牌 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN 上面的URL中，grant_type参数为refresh_token表示要求更新令牌，refresh_token参数与就是用于更新令牌的令牌。 B网站验证通过后，就会颁发新的令牌。 例子按照阮一峰的例子，做一个Demo，通过OAuth，以Github进行第三方登录，获取API数据。代码在这里。 登陆的过程就是OAuth授权，实际上和前面以微信账号登陆京东APP的例子是一样的。这里面我们的网站是A，允许使用Github账号登陆。 流程如下： 用户点击A网站“使用Gihutb登陆”的链接，页面跳转到Github的授权页面； Github要求用户登陆，然后循环是否授权使用当前Github账号登陆A网站 用户同意登陆，Github会重定向回A网站在最开始的链接中指明的地址，同时发回一个授权码。 A网站使用授权码，向Github请求令牌。这个过程必须在后端完成。 Github返回令牌。 A网站使用令牌，向Github请求用户数据。 具体过程： （1）应用要求OAuth授权，必须在对方网站登记，换取clientID和clientSecret，证明自己的身份。Github的登记地址是这个网址。 注意，应用的callback URL必须是Homepage下的子域名。 （2）新建了一个index.html作为项目的首页 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;OAuth 2.0 Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="login"&gt;Login with Github&lt;/a&gt;&lt;/body&gt;&lt;script&gt; const client_id = 'f38d5d8c4b1bb8259159'; const authorize_uri = 'https://github.com/login/oauth/authorize'; const redirect_uri = 'http://localhost:8080/oauth/redirect'; const link = document.querySelector('#login'); link.href = `$&#123;authorize_uri&#125;?client_id=$&#123;client_id&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;`&lt;/script&gt;&lt;/html&gt; 在HTML代码中，跳转链接设置为https://github.com/login/oauth/authorize?client_id=f38d5d8c4b1bb8259159&amp;redirect_uri=http://localhost:8080/oauth/redirect 其中https://github.com/login/oauth/authorize就是Github用来获取授权码的地址，具体参考它的文档。 在index.js中使用koa-static来托管访问静态资源，监听8080端口： 123456789const Koa = require('koa');const app = new Koa();// Koa静态文件服务的目录app.use(staticServer(path.resolve('public')));app.listen(8080, () =&gt; &#123; console.log('Koa is listening in 8080');&#125;); （3）当点击链接，页面会跳转到Github授权的页面 （4）点击授权后，页面跳转到之前指定的Callback URI，也就是http://localhost:8080/oauth/redirect，所以需要在服务端代码对这个路由进行处理： 1234567const KoaRouter = require('koa-router');const router = new KoaRouter();router.get('/oauth/redirect', oauthController);// 加载路由中间件app.use(router.routes()); 当访问/oauth/redirect会执行oauthController的逻辑： 12345678910111213141516171819202122232425262728293031323334const oauthController = async ctx =&gt; &#123; // 获取授权码 const &#123; code &#125; = ctx.request.query; console.log('authorization code: ', code); try &#123; // 使用授权码 + clientID + clientSecret 获取 token const tokenRes = await axios(&#123; method: 'post', url: `https://github.com/login/oauth/access_token?client_id=$&#123;config.clientID&#125;&amp;client_secret=$&#123;config.clientSecret&#125;&amp;code=$&#123;code&#125;`, headers: &#123; accept: 'application/json' &#125; &#125;); const token = tokenRes.data.access_token; console.log('access token: ', token); // 使用令牌获取数据 const res = await axios.get('https://api.github.com/user', &#123; headers: &#123; accept: 'application/json', 'Authorization': `token $&#123;token&#125;` &#125; &#125;); console.log('result: ', res); // 拿到用户名，渲染到页面 const &#123; name &#125; = res.data; ctx.response.redirect(`/welcome.html?name=$&#123;encodeURIComponent(name)&#125;`); &#125; catch (e) &#123; console.log('There is something wrong when getting token: '); &#125;&#125;; 在oauthController中，首先我们从request的查询参数中获取授权码，然后使用授权码 + clientID + clientSecret从Github获取 token，获取token之后再使用相应的API获取用户名，这时需要将上面获得的token作为Authoriztion字段，加到HTTP请求的头信息里面。 拿到用户名，将页面重定向到welcome.html，在这个页面会将URL中的用户名取出来并显示在页面。注意由于用户名可能是中文，需要在redirect中进行安全编码，否则会发生问题。 关于OAuth的安全性问题回调域名在做微信登陆时，到了获取授权码code这一步，如果给微信服务器传的redirect_uri不是申请appid时输入的域名，微信会立刻返回redirect_uri错误的提示。 为什么会这样？因为如果微信不校验redirect_uri，会导致中间人攻击，攻击者伪造受害者的身份，使用受害者的微信账号，登陆目标网站。 假设在申请appid时的域名是a.com，申请的appid是123，假设微信获取code地址是https://wx.om/code，这样获取code的完整URL是： 12345https://wx.com/code? redirect_uri=http://a.com&amp; appid=11111&amp; response_type=code&amp; scope=userinfo 把这个地址发送给任何一个微信联系人，他们都可以通过自己的微信账号获取code，微信会带着code参数回调到http://a.com?code=455，然后a.com再通过code换取access token，用户就可以使用微信账户登录a.com。 但是如果微信不验证redirect_uri是否是a.com，攻击者将redirect_uri换为他的网站（假设为hack.com），受害人访问此链接，确认登录，微信生成code之后通过回调的方式将code传给了攻击者的网站http://hack.com?code=151，拿到code之后，攻击者再将域名切换为http://a.com?code=151，而这时a.com是无法分辨这是微信直接回调还是有人从中动了手脚的地址，无差别的获取code对应的access token，攻击者以受害者身份登陆成功。 对于Implicit方式，更需要校验redirect_uri，因为是一步到位的获取access token。 所以作为OAuth2.0 Server，redirect_uri的域名限制是一定要做的。而作为调用者，到不必这么担心，目前大部分遵循OAuth2.0的服务都不会犯这个错误。 对于调用者开发过程中，微信后台对于redirect_uri域名设置的限制，对于本地地址是无法正常登陆了。解决方法就是更改Host文件，将redirect_uri的域名直接指向内网就行了： 12# /etc/hosts127.0.0.1 a.com code与secret前面提到了，在使用OAuth之前，需要到提供的服务的服务商进行注册，获取appid（clientID）和secert（client Secret），appid的目的是为了告诉身份认证服务器我是a.com，而secret是为了告诉任务服务器，我真的是a.com。这个secert相当于客户端与认证服务器之间的信物，这个信物是不能暴露给用户的，所以它的传递只能通过服务器进行传递。能够被暴露的只有appid。 如果没有secert，当出现DNS污染，本该发往a.com的code被发往了hack.com，这时候攻击者就会直接使用code换取token了。 OAuth 2.0设计时的一个目标是，让不支持HTTPS的网站也能够安全使用。所以code才是必须的。如果没有code，直接获取access token，流程如下： 用户浏览器访问a.com，跳转到微信OAuth服务器获取access token 用户在微信的网页上登陆成功，并确认授权a.com使用微信账号登陆，微信服务器跳转到redirect_uri并且带上access_token参数 用户浏览器访问带access token的连接，完成登陆。 如果a.com不支持HTTPS，那么在最后一步，access token就完全暴露在浏览器和a.com服务器之间的线路中。 如果a.com支持HTTPS，那么理论上来说，可以省略获取code这一步的。 但是如果a.com不支持HTTPS，那么使用了code，code被暴露的后果是好于access token被暴露的。这是因为OAuth 2.0协议对此规定： code只能使用一次 如果攻击者比正常用户先用了code，当用户第二次使用code时，之前通过此code获取的access token将被撤回。 所以当code被泄露时，攻击最多让正常用户有点困扰，可能登陆意外失败，或者明明看起来登陆成功但还是获取不到用户信息的情况（access token已失效），攻击者拿不到数据。 state参数在获取code时，一般服务器会返回一个state参数，一般来说没什么用，也可以为空，但是OAuth2.0文档标注的是Recommended，在什么时候使用呢？ 它在防御CSRF时是非常有用的。进行CSRF攻击，攻击者： 申请一个的专门用于攻击的账号 走正常流程，跳转到微信上登陆此账号 登陆成功后，微信带着code跳转回a.com，这个时候，攻击者拦截自己的请求不再继续进行，而是将code的链接发送给受害者，棋牌受害者点击 受害人点击后，继续攻击者登陆流程，不知不觉登陆了攻击者的账号 而state参数如果利用起来，作为CSRF Token，就能避免此时的发生： 攻击者依旧获取code并打算骗受害者点击 受害者点击链接，但是服务器（a.com）分配给受害者的设备的state值和链接里面的state值不一样，服务器（a.com）直接返回验证state失败 state或者CSRF Token这种与设备绑定的随机字符串，复杂一点，攻击者就无计可施。 设置一个让攻击者猜不到的、跟设备（或者浏览器）绑定的state或者CSRF Token值，就是解决CSRF的关键。 Implicit授权模式Implicit授权模式一步到位，直接返回了access token，它的最重要也是最巧妙的设计是，登陆成功后身份认证服务器跳转回来带的参数都是放在#后面的，而不是查询参数。 这是因为，如果在没有使用HTTPS的线路上通信时，access token很容易被偷走，但是如果access token放在#后面，浏览器发起请求时，#后面的内容不会碎请求发送到服务器。这一样就可以防止中间人共计而只让设备用用access token。 同样，access token是一定不能存放在cookie这种可能被中间人发现的地方（除非使用HTTPS）。为了做到粳稻的安全性，access token最好连local/session storage都别放。这样理解，Implicit也就只适合SPA了，SPA不刷新页面可以让access token一直在内存里，直到关掉页面。 参考 理解OAuth 2.0@阮一峰的网络日志 OAuth 2.0 的一个简单解释@阮一峰的网络日志 OAuth 2.0 的四种方式@阮一峰的网络日志 GitHub OAuth 示例教程@阮一峰的网络日志 关于 OAuth2.0 安全性你应该要知道的一些事@Chrisyue’s Blog]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>OAuth</tag>
        <tag>第三方登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题28 BFF调研2]]></title>
    <url>%2F2019%2F04%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9828%20BFF%E8%B0%83%E7%A0%942%2F</url>
    <content type="text"><![CDATA[BFF调研报告第二部分 为什么说Node作为中间层带来了真正的前后端分离前后端未分离时是怎么做的？典型的MVC框架，使用一门后端语言、框架，这里以Egg.js为例子，定义路由： 1234module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/', controller.home.index);&#125;; 当访问/时，会到Controller层从处理业务逻辑的Service层（或者叫Modal层）拿到数据，渲染一个模板（View）并且将数据嵌入进去 1234567891011class HomeController extends Controller &#123; async index() &#123; const &#123; ctx &#125; = this; // 从Service层获取数据 const &#123; title &#125; = await ctx.service.news.list(); // 渲染模版 await ctx.render('index.tpl', &#123; title &#125;); &#125;&#125;module.exports = HomeController; 模板使用了nunjucks引擎，在index.tpl中 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hi Egg&lt;/h1&gt;&lt;a href="news"&gt;Movie&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这种前后端没有分离的开发方式，主要指的是前后端传递数据的方式是通过后端渲染模板时将数据传递给模板，前端开发的只是模板的样式，被动的从模板拿到数据。也就是说大部分的逻辑、数据获取、处理都是在后端完成的。 前后端开始分离为了脱离前端强依赖后端的关系，将数据层的接口分离出来，以Ajax的形式进行交互，服务端只负责渲染逻辑、提供数据和接口，不负责数据填充。 页面的数据以JSON格式由前端通过Ajax获取，填充到页面中。具体的做法是，在路由中添加一个接口： 1router.get('/getTitle', controller.home.getTitle); 在Controller中添加对应的处理逻辑，返回JSON数据格式 1234567async getTitle() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; title: 'OK', &#125;; ctx.status = 200;&#125; 在模板中通过&lt;script&gt;脚本访问接口，获得数据后填充到DOM中 这个时候前后端的界限是按照浏览器和服务器的划分，但是也有一些问题 环境：本地开发需要起后端环境，影响开发效率（当然可以通过Mock数据解决） 联调：前后端关注点不同，联调时效率低下 接口：接口不好维护，接口变更、新加时需要沟通成本 前后端分离新阶段：SPA为了提高效率和用户体验，前端在前端开始了MVVM的单页面开发，后端不再负责渲染模板，只单纯的提供数据接口，后端的模板成为了前端SPA的容器。 前端也有了自己的路由、Model、View。 在SPA之前，浏览器接受的是服务器渲染好的HTML字符串和少许的JS/CSS脚本，路由由后端控制；到了SPA之后，服务器渲染好的只是一个空壳子，浏览器接受这个空壳子和大量的JS/CSS脚本，由浏览器渲染为HTML字符串，页面跳转由前端路由控制 前端路由一般是通过Hash模式实现，只只要后台服务器配合一个根路由对应基础模板，其他的跳转都是通过前端路由改变#后面的内容实现，#值的改变并不会想浏览器发送请求，所以SPA的url一般是http://demo.com/#index。 Vue-router也提供了History模式，利用了HTML5的history.pushState来实现URL跳转而无需重新加载页面，这样的URL就像正常的URL，例如http://demo.com/index，但是这需要后台配置支持，增加一个覆盖所有情况的候选资源，当URL匹配不到任何资源，应该返回同一个index.html页面，也就是app依赖的页面。这个时候服务端不再返回404，需要通过前端路由对不匹配的资源返回404 前面提到的Mock数据的问题，本地Mock是一种解决方案，但添加、维护、同步都非常麻烦。现在比较成熟的解决方案可以使用easy-mock，它可以很好地支持Swagger，在开发时在前端不再通过后台服务器获取数据，也不在本地Mock，而是添加一个Mock服务器，直接通同步服务端的接口，产出Mock数据。 Swagger是一款API文档工具，官网在这里。 真正的前后端分离：Node.js中间层服务现在的架构下，前后端的职能更加清晰： 后端 前端 提供数据 接收数据 处理业务逻辑 处理渲染逻辑 Server-side MVC Client-side MVVM 代码跑在服务器上 代码跑在浏览器上 但是服务端和客户端的部分职责重叠，很难统一具体要做的事。在SPA应用上也暴露了一些性能的问题 渲染、取值都在客户端执行，有性能的隐患 首屏渲染有白屏、闪烁的问题 无法SEO 对移动设备网速较低时体验较差 为了解决这个问题，可以引入Node作为中间层，从工作职能的角度上重新定义前后端的范畴 引入了之后前后端的职能重新划分为： Node中间层，也就是BFF，常见的业务场景 接口数据二次处理，在中间层做接口转发 页面性能，将首屏渲染交给中间层去做，次屏渲染依然走之前的浏览器渲染 使用Bigpiper技术，合并请求，降低负担，分批输出，提高体验。 淘宝前端基于Node.js的前后端分离的思考与实践PPT在这里。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端就是前端，服务器端就是后端），这种分法已经无法满足前后端分离的需求，从职责上划分更加满足使用场景： 前端：负责 View 和 Controller 层。 后端：只负责 Model 层，业务处理/数据等。 为什么要前后端分离？ 现有开发模式的适用场景:后端为主的MVC，做一些同步展现的业务效率很高，但是遇到同步异步结合的页面，沟通成本高，Ajax为主的SPA型开发模式，比较适合开发APP类型的场景，但是有SEO的问题 分清前后端职责，代码分别为虎 开发效率 前端发挥的局限 前后端分离，需要Web服务实现Controller层的功能，就是Node.js中间层 这样的架构会引出一些问题： （1）SPA中，后端已经提供了所需的数据接口，View前端也可以控制，为什么多加Node.js这一层？ 让前端控制Controller层，Node对于前端来说是很高效率的选择 （2）多加一层性能怎么样？ 分层就涉及每层之间的通讯，肯定有一定的性能损耗，但是合理的分层能让职责清晰，也方便协作，会大大提高开发效率。分层的损失可以在其他方面弥补回来。 另外，如果决定分层，可以通过优化通讯方式、通信协议，把性能损耗降到最低。 例如可以在Node层合并请求，利用Bigpipe优化数据传输。淘宝这方面的实践已经很多。 （3）多加一层，前端的工作量是不是增加了？ 增加是肯定的，但是可以减少联调、沟通的时间，效率会提升 （4）多加一层的风险怎么解决？ 随着Node.js大规模使用，系统/运维/安全部门的同学也一定会加入到基础建设中，共同晚上各个环节出现的问题，保证系统稳定属性 淘宝基于Node.js的前后端分离架构如下所示： 最上端是服务端，提供各种接口，因为有了Node，所以也不局限是什么形式的服务。对于后端来说，只需要关心业务代码的接口实现 服务端下面是Node.js中间层，中间层有一层Model Proxy与服务端进行通讯，这一层主要是抹平对不同接口的调用方式，封装一些View层需要的model。Node层使用的框架有开发者自己决定，输出方式也是完全由场景决定的 浏览器层在架构中没有变化 淘宝前端团队基于前后端分离的模版探索在传统的开发模式中，模板是前、后端中间的模糊地带，最容易与后端开发纠缠不清 浏览器端渲染的好处 摆脱业务逻辑与呈现逻辑在Java模版引擎中的耦合与混乱。 针对多终端应用，更容易以接口化的形式。在浏览器端搭配不同的模版，呈现不同的应用。 脱离对于后端开发、发佈流程的依赖。 方便联调。 浏览器端渲染造成的坏处： 模版分离在不同的库。有的模版放在服务端（JAVA），而有的放在浏览器端（JS）。前后端模版语言不相通。 需要等待所有模版与组件在浏览器端载入完成后才能开始渲染，无法即开即看。 首次进入会有白屏等待渲染的时间，不利于用户体验 开发单页面应用时，前端Route与服务器端Route不匹配，处理起来很麻烦。 重要内容都在前端组装，不利于SEO 引入了Node中间层后，前端可以自由选择模板是在服务端（Node）还是在浏览器端做渲染 淘宝的模板共享实践经验： （1）复杂交互应用（如购物车、下单页面） 状况：全部的HTML都是在前端渲染完成，服务端仅提供接口。 问题：进入页面时，会有短暂白屏。 解答：首次进入页面，在Node层进行全页渲染，并下载相关的模版。后续交互操作，在浏览器端完成局部刷新 （2）SPA页面 状况：使用Client-side MVC框架，在浏览器换页。 问题：渲染与换页都在浏览器端完成，直接输入网址进入或F5刷新时，无法直接呈现同样的内容。 解答：在浏览器端与Node层共享同样的Route设定，浏览器端换页时，在浏览器端进行Route变更与页面内容渲染，直接输入同样的网址时，在Node.js端进行“页面框架 + 页面内容”渲染（如何做？） 各种开发框架的对比Middelway淘宝前端团队推出的Web全栈应用开发框架，文档在这里。 使用了Egg.js作为Web层容器，可以使用Egg.js的插件，它的特点是 使用IoC机制将应用依赖管理起来，最大程度帮助应用在Web开发中提升可维护行和可扩展性（IoC模块可独立使用） 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。更多的看维基百科和这篇文章。 使用TypeScript进行应用开发 兼容Koa社区和Egg.js插件 一些细节也可以通过这篇文章了解。 Egg.js：蚂蚁金服死马：企业级Node.js Web框架研发与落地这是视频，这是PPT。 Chair BFF是基于Egg.js的研发框架，在Egg.js基础上，添加了很多定制话的插件，内部集成了很多蚂蚁内部的服务，即便开源也无法使用 但是包括Egg.js在内，与业务无关的插件，蚂蚁都已经开源了。正确的做法是基于Egg.js进行BFF的引入，充分利用Egg的社区生态、插件，随着业务开发编写定制化的插件和维护。当积累到一定程度后，可以形成适合于自己公司的BFF研发框架（Mi BFF），当上下游研发流程打通后，形成属于自己的解决方案（Mi-TWA） Egg.js有如下的优点： 蚂蚁金服的最佳实践的封装（通过插件的形式，已开源） 文档友好 更适合企业级开发：灵活定制，遵循约定 npm上插件众多，配套完善 可以使用Koa的中间件 有配套的研发平台的支持 社区模式VS企业模式：个人项目使用Koa和Egg区别不大，但是对企业内部，使用Egg的正确姿势是基于Egg封装自己的东西。 蚂蚁金服有了很多年的积累，才形成了Chair BFF和TWA这样的一站式研发平台和配套设施，对于新引入BFF的团队而言，可以做到渐进增强的研发体验： （1）首先实现，使用Node.js实现功能，保证代码质量 （2）在使用Node实现功能之后，很容易被人挑战，那么就需要一步步优化，比如统一编码规范，让团队可以更好的写代码 （3）提升稳定性、可维护性，对接企业内部服务 （4）通过完善的研发流程平台，提供更好的变成体验 （5）让产品工程师可以专注于产品 Egg的缺点：为了保证框架利用的最大化、代码的可维护性，需要学习、遵守框架的大量的约定 egg-vue-webpack-boilerplate 基于Egg + Vue + Webpack多页面和单页面服务端渲染同构工程骨架项目。需要配套使用基于Webpack封装的easywebpack-cli创建项目，可以创建各种项目的模板： 1234567Create Vue Application Create React Application Create Egg + Vue Application Create Egg + React Application Create Weex Application Create HTML Application Create NPM package Application 选择Egg + Vue项目，可以选择多种渲染方式： 123456Create Egg + Element Admin Application Create Egg + Vue Single Page SSR Application Create Egg + Vue Multil Page SSR Application Create Egg + Vue Single And Multil Page SSR Application Create Egg + Vue + TypeScript SSR Application Create Ves Framework - Node Vue TypeScript Isomorphic Framework Application 对于使用Egg+Vue/React实现服务端渲染，可以使用这个解决方案 nodejs-backend-for-frontendIBM的BFF解决方案，配合使用Express，内置了IMB的云开发工具，针对IBM的云服务进行了一些特殊化定制，Github的star数16，提供了对Swagger的支持，自动生成Mock数据 使用Koa或者Express自行搭建中间层使用Koa或者Express，自行搭建一个中间层，实现接口的转发、数据处理等比较基础的功能。 作为BFF引入时，可以将前端工程代码和BFF层代码分为两个仓库管理，也可以在一个仓库管理。 小米笔记本BFF项目部署 这个部分只是BFF项目使用Docker的部署过程，不作为引入方案，只作为部署经验进行介绍。 Node做中间层，做接口的转发服务，功能比较浅，重业务的逻辑也放到了后端。 接口转发、数据处理、Mock服务（Swagger） 好处： 更好的前后端分离 不需要考虑跨域 接口的聚合不再需要服务端的支持（减少沟通成本） 能自主完成一些小的功能开发 缺点 需要独立完成一套功能的实现 增加维护成本 基于Ocean平台使用Docker容器技术进行部署，具体代码参考Wiki。 总结 框架 维护团队 Star 优点 缺点 Egg.js 阿里 12404 1. 蚂蚁金服的最佳实践；2. 文档友好；3. 适合企业级开发；4. 插件众多，配套完善；5. 且可以使用Koa的中间件；6. 有配套的研发平台的支持 1. 需要学习、遵守框架的大量的约定 Middleway 淘宝 713 1. 淘宝的最佳实践；2. 使用IoC机制管理应用依赖；3. 使用TypeScript进行应用开发；4. 兼容Koa社区和Egg.js插件 1. 使用不广泛；2. 有些概念比较复杂，暂无引入必要； egg-vue-webpack-boilerplate easy-team 881 1. 有Vue和React等一系列工程解决方案；2. 可以扩展多页面和单页面服务端渲染 1. 使用不广泛； 2. 可定制性比较差 nodejs-backend-for-frontend IBM 16 1. 支持Swagger，自动生成Mock数据 1. 使用不广泛； 2. 内置了IBM云服务相关的功能 Express Express 43507 1. 应用广泛；2. 社区繁荣；3. 使用灵活； 1. 需要自搭建项目；2. 需要自行选择中间件； 3. 灵活性过高，导致后期可能维护困难 Koa Koa 25884 1. 异步流程控制优于Express；2. 社区繁荣；3. 使用灵活； 1. 需要自搭建项目；2. 需要自行选择中间件； 3. 灵活性过高，导致后期可能维护困难 落地方案总体建议一开始引入Node作为BFF层，在一些小的项目上进行改造，通过HTTP请求从后端服务获取数据，实现一些接口转发、数据处理之类比较简单的功能，将项目中所有接口都改造为接入BFF Server。 通过简单的项目，把代码管理、开发、Review，测试、部署、维护全流程（或大部分流程）走通后，逐渐扩展边界和功能（接口文档和接口的对应、自动生成Mock数据、性能监控等） 待确定的规范和方案主要流程中要确定的一些代码管理规范和方案： 1 代码管理（1）前端后端代码放到一个代码仓库里面统一管理。（可能需要处理依赖混在一起的问题） 前后端代码分离两个目录 以前端代码目录为主，添加服务端代码文件夹 以前端代码目录为主，添加前端代码文件夹 （2）前端后端代码放到两个代码仓库里面分别管理。 2 框架选择 自行搭建（前端项目+Koa/Express/Egg），demo地址在这里。 Egg.js（完全使用） Esay-Team egg-vue-webpack-boilerplate IBM的方案IBM/nodejs-backend-for-frontend 3 本地开发 前端在一个端口，起一个服务，负责渲染页面，Node服务在另外一个端口，其一个服务，负责提供接口和数据；二者处于开发模式热更新都是各自的构建工具实现的 前端、后端在同一个端口开发（使用egg-view-assets或者Esay-Team egg-vue-webpack-boilerplate） 4 构建流程 多页面/单页面服务端渲染 前端渲染 静态页面 前两种方式需要结合Vue-SSR或者React-SSR，最后一种方式只需要配置对应的构建目录，通过静态资源的方式构建 如果当前阶段只是实现接口转发的功能可以涉及不到第一步骤。 5 部署 前端打包后，手动上传到CDN，后端服务打包后为tar，手动上传至服务器，开启服务 前端打包后，手动上传到CDN，后端服务构建一个Docker镜像，推到服务器（或者结合平台）开启服务 参考 蚂蚁金服死马：企业级Node.js Web框架研发与落地-视频@ArchSummit 蚂蚁金服死马：企业级Node.js Web框架研发与落地-PPT@分享幻灯片 浅谈前后端分离与实践（一）@知乎 浅谈前后端分离与实践 之 nodejs 中间层服务（二）@知乎 前后端分离的思考与实践（一）@淘宝前端团队 前后端分离的思考与实践（二）@淘宝前端团队 前后端分离的思考与实践（三）@淘宝前端团队 淘宝前后端分离实践@2014JS中国技术大会 从NodeJS搭建中间层再谈前后端分离@掘金]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>BFF</tag>
        <tag>Egg.js</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题27 BFF调研1]]></title>
    <url>%2F2019%2F04%2F16%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9827%20BFF%E8%B0%83%E7%A0%941%2F</url>
    <content type="text"><![CDATA[BFF调研报告。 前端开发中存在的难问题 多端应用，不同类型客户端对数据、API有个性化的需求 服务聚合，单一后端为多个前端团队提供接口，导致跨团队协作低效，资源协调困难 问题：服务端设计的接口究竟是面向UI，还是面向通用服务？ BFF解决方案： Backends For Frontends， 简称BFF。 BFF最适合的场景，为第三方提供定制API等差异化场景，每个用户体验（客户端）对应一个后端， BFF作为用户体验适配层，对后端接口进行组合、处理，对数据进行：裁剪、格式化、聚合、编排。 BFF理念中，最重要的一点是：服务自治，谁使用谁开发，所以一般由前端维护。 BFF实现不限制具体技术，可以自由选型：Java/Node/PHP/Python，但大部分前端团队都会选择Node.js。 BFF的演化历程BFF和网关（API Gateway）是微服务架构中两个重要概念，可以通过下面的例子讲解BFF的出现过程 服务化架构V1实现单块应用的解构拆分，微服务初步完成，前端用户体验层主要是传统的服务端Web应用，服务化架构如下所示： 服务化架构V2随着无线应用的流行，除了Web应用外，服务还需要为新的无线原生App来提供接口和数据，先采用下面的服务架构： 这样的架构的问题是： 无线App与内部为微服务强耦合 无线App需要知道内部服务的地址等细节 无线App需要对接口数据进行大量的聚合剪裁和适配逻辑 服务化架构V2.1为了解决这个问题，在用户体验层和内部微服务层之间引入了BFF层，将后端的微服务进行适配，想用户体验层暴露有号和统一的API，方便无线设备接入访问后端服务 这种架构解决了上面的问题： 无线App与内部为微服务解耦，两边可以独立变化 无线App只需要知道BFF的地址，并且服务接口统一，不需要关心内部复杂的微服务的地址和细节 无线App需要不再需要聚合剪裁和适配逻辑，这些步骤都在BFF完成 但是随着接入设备的增加，也会有一些问题： BFF只有一个，接入设备增加后导致要考虑匹配问题，团队之间沟通协调成本高 BFF中不仅包括了各个业务线的聚合剪裁、适配和业务逻辑，还需要引入很多跨横切面逻辑，比如安全认证、日志监控、限流熔断等，这些代码混在一起，导致代码复杂度提高 BFF如果出现错误，会导致所有应用都不可用 微服务架构V3为了解决这个问题，引入API Gateway 在这种架构下： BFF按团队和业务线进行解耦拆分，拆分成若干个BFF微服务，每个业务线并行开发和交付各自负责的BFF微服务 网关，一般由独立的团队负责运维，专注跨横切面的功能，包括 路由，将来自无线设备的请求路由到后端的某个微服务BFF集群 认证，对涉及敏感数据的API访问进行集中认证鉴权 监控，对API调用进行性能监控 限流熔断，网关能够进行限流熔断，保护后端服务 安全防爬，收集访问日志，通过后台分析恶意行为，阻断恶意请求 网关在客户端与BFF之间又引入了一层，让两边可以独立变化 微服务架构V4可以对V3架构进行优化，将传统的服务端Web应用模式改为前后分离架构，前端采用H5单页技术提供给用户更好体验。 同时增加了下手是哪个第三方应用开放API的能力 拓展新的接入渠道，形成了一个完成的现代微服务架构，从外到内依次为：端用户体验层-&gt;网关层-&gt;BFF层-&gt;微服务层 具体实现细分力度要求把一个大后端拆分为多个小后端，有三种方式 用户体验级（UI） 端级 团队级 一般建议按照用户体验级来拆分 对接下游服务（微服务）（1）如何对接多个技术栈不同的下游服务 RPC协议调用 （2）如何管理、组合调用 借助RXJava、Finagle等事件机制来简化这些异步流程控制 （3）某个调用失败时，如何保障可用性 在BFF层容错，同时前端保证可接受不完整相应内容 复用问题拆分后，多个BFF间会产生冗余代码，这是不可避免的。 可以添加API网关层，将通用的后端逻辑（授权、认证、限流）放进去 想消除冗余，又不想因为抽离可复用代码而导致BFF间紧耦合，所以就有了一种折衷的态度：容忍BFF间冗余、消除单BFF内冗余。也就是允许一定程度的BFF间冗余 蚂蚁财富的BFF实践2016年时，汤尧对BFF在蚂蚁财富项目中的落地实践进行了介绍。 在引入BFF之前，蚂蚁财富的业务也遇到了上面提到的问题，主要是体验层API经常变化，导致开发效率低下。 于是引入了BFF，主要的目的是对数据进行：裁剪、格式化、聚合、编排。 一个理想的模型如下： 在实际落地过程中，形成了如下的架构： 他们在实战过程中，主要解决了一下几个问题： （1）Node.js与Java通信 数据：跨语言序列化协议hessian 服务：Node弱类型，Java强类型，如何调用 这个调用过程一般是通过RPC协议完成的，而非通过HTTP协议。 由于我对Java没有接触，而且资料只是他当时的PPT，没有详细的讲解，没有办法理解具体是如何实现的。而且恐怕对于大多数前端开发工程师来说，与Java的通信也是BFF落地过程中一个比较严峻的挑战，而且这是在前端开发人员有比较好的Node开发能力的基础上。 （2）多App适配 在API网关层处理多个App的通用的逻辑，比如错误码管理、数据一致性、免登、业务日志等。 （3）聚合 传给客户端需要的数据，简化客户端逻辑，减少网络开销 避免无意义的透传 敏感信息过滤 （4）接口设计准则 基础服务接口：（微服务？） 细粒度 通用的功能，可能会被多个BFF用到 提供含各种状态的mock真实数据，易于同步开发（如何实现？） BFF API设计 合理设计接口数量，太多不易维护 提供含各种状态的mock真实数据，页面不依赖server开发（如何实现？） 多协议发布（如何实现？） 规范数据格式 在落地BFF过程中，从技术角度来看： 前端和BFF由同一人完成 前端需要具备服务端技能 快速的应用发布能力（docker？） TWA的理念与实践在2018年的SEE Conf，蚂蚁金服的不四（知乎ID：死马)对在BFF基础上发展出来的TWA（Techless Web Application）开发体系进行了介绍（视频和PPT）。 传统的分层： BFF负责聚合底层业务数据，给客户端提供接口，秉承谁使用谁维护的理念，一般由前端团队维护。 业务实际上分为三层：前端（HTML/CSS/JS）+ BFF（Node.js接口聚合层）+ 后端服务（Java） BFF on Chari是蚂蚁自研的，基于Egg.js的BFF框架，打通了Node到Java的RPC通信链路 Egg.js已经开源（Egg.js是以Koa作为基础框架），需要基于Egg.js去打造属于自己的BFF框架 RPC的意思是不在一个内存空间的两个应用，借助网络来实现，像调用本地的函数一样去调用远程函数 BFF不是银弹，有着自己的问题： 研发成本上升：前端团队既要开发客户端，又要开发BFF，人手不够 流程繁琐：BFF引入后，要同时走前端、服务端的研发流程，多端发布、互相依赖，导致流程繁琐 运维经验不足：主要是前端工程师运维经验不足（给业务团队带来了很大困扰） 尽管职责划分越来越清晰，但是由于前后端发布系统不一致，前端团队仍需要在基于不同的代码仓库进行研发，走不同的发布流程 理想的开发流程： 蚂蚁金服推出的解决方案TWA（Techless Web Application），是一个全栈的研发框架 TWA是为了提升开发者研发体验而推出的渐进式解决方案，开发者在一个代码仓库下，基于TWA的框架，完成客户端和BFF层的研发，通过Basement研发平台提供的流程支持，不用再关注应用、构建、部署、流程等细节，可以一键将应用部署到各个运行终端，同时在研发平台上完成应用的自主运维和监控 将TWA拆解开来，分为了三个大的方向：框架、研发平台、运行时 框架：提供了前后端合一的框架，通过定制化网关，抹平多个终端和接入形式的差异，让一套代码可以运行在不同的终端下（？) 研发平台：Basement，提供TWA的研发迭代、自主运维和监控，精简规范了H5 APP的研发流程 运行时：通过基础服务和Docker，给客户端代码和服务端代码提供稳定可靠的运行环境 框架是一个渐进式框架，可以选择部分能力使用 客户端、服务端目录、依赖都是相互独立的。 复杂的终端环境，有不同的接入链路（可能通过网关走TCP长连接通信）、不同的鉴权方案。如果每个业务的BFF系统要对接到每个系统完成接入、鉴权是非常复杂的。 解决方案是：TWA网关层 + 客户端RPC Client， TWA网关层统一完成所有终端的接入、鉴权，BFF不需要对接到每个终端，只需要对接到网关，让BFF接口统一 客户端的RPC Clinet是一个请求库，对接到网关，将客户端的鉴权、接入的细节隐藏，并且可以自动选择接入链路 这就可以在client目录下，像调用本地方法一样，调用server中目录下的服务 研发平台 Basement，一站式运维平台，基于Docker，支撑整个应用的研发流程，完成自动化的测试和部署 Node与Java的通信与使用的微服务框架有关，可以采用HTTP的方式，也可以通过RPC调用。 蚂蚁金服的实践 数据：跨语言序列化协议hessian 服务：Node PRC 开源框架： sofa-bolt-node：蚂蚁通讯协议Bolt的Nodejs实现 sofa-rpc-node：一个通用的Nodejs RPC模块 有赞的实践 – HTTP可以采用服务注册中心： 首先，Java应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是ETCD或者Zookeeper，然后，Node应用在启动的时候，会先从服务注册中心拉取服务列表，接着Node会跟Java服务建立一条TCP长链接，除此之外，Node还需要负责Hession协议解析以及负载均衡等。 上面的方式Node职责比较重，对Node开发的要求高，有赞在此基础上做了改进： 在Node和Java之间添加了一层中间代理层Tether，Tether是用Go语言写的一个本地代理，Tether会对外暴露一个HTTP的服务，对Node来说，只需要通过HTTP方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由Tether来处理。这样，Node这一层就非常轻量了，Node是调用Java服务时： 1234567891011121314151617const Service = require('../base/BaseService');class GoodsService extends Service &#123; /** * 根据商品 alias 获取商品详情 * @param &#123;String&#125; alias 商品 alias */ async getGoodsDetailByAlias(alias) &#123; const result = this.invoke( 'com.youzan.ic.service.GoodsService', 'getGoodsDetailByAlias', [alias] ); return result; &#125;&#125;module.exports = GoodsService; 这种方式的优点： 使用简单，对前端开发非常友好，只需要通过HTTP方式调用本地的Tether服务即可； 多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像Node一样，它们都只需要调用本地Tether暴露的HTTP服务即可，没有额外的开发成本了。 后期更方便做协议层的优化，因为这种方式Tether其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化Tether的性能就可以了。 总结关于TWATWA是蚂蚁金服自研的，整合了BFF的一整套渐进式的前端+Node聚合层的开发体系，它不仅包括了BFF的引入，还包括了前后端代码管理、部署、运维等功能框架。 但是很遗憾的是，TWA没有开源，对于想要从0开始引入BFF，想实现TWA的功能，还有一个努力的过程。 实际上我们引入BFF，不是要完整的开发TWA，而是首先实现Chari BFF的功能。 接入BFF的好处对于团队来说： 业务支持变多 沟通协作变少 解决问题变快 对于个人来说： 更合理分工 做BFF可以拓展知识面 接入BFF的坏处： 组织决定了架构的复杂度 前期学习成本高，短期成为资源瓶颈 可能遇到的问题和可能的解决方法 Node与Java通信 – Hessian（数据），RPC（服务）（sofa-rpc-node）/ （grpc-node） 前端代码和BFF段代码管理 – Egg.js（同一个仓库，不同目录，不同依赖，分别打包、分别配置） 前端的应用发布、运维能力 – Docker 服务端的配合 – 服务：微服务（？），人员： （？） 前端能力提高 – 前端能力（JavaScript + HTML + CSS) + Node（服务端技能）+ Java（如何与Java通信）+ 运维能力（Docker） 参考 Pattern: Backends For Frontends@samnewman 为什么互联网公司开始用node.js做web服务的中间件？有什么好处吗？@知乎 Backend For Frontend@黯羽轻扬 蚂蚁财富的BFF实践.pdf@alipayobjects 微服务架构：BFF和网关是如何演化出来的@10条 Developer Experience First —— TWA 的理念与实践@知乎专栏 Techless Web Application 的理念与实践 — 不四@优酷 02_SEEConf_TWA的理念与实践_不四.pdf@语雀 Node 在有赞的实践@掘金 聊聊 Node.js RPC（一）— 协议@语雀 聊聊 Node.js RPC（二）— 服务发现@语雀]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>BFF</tag>
        <tag>TWA</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg01 入门]]></title>
    <url>%2F2019%2F04%2F15%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在调研BFF的过程中，看到蚂蚁金服自研的BFF的开发框架BFF Chair是基于Egg.js开发的。BFF Chair没有开源，但是Egg.js已经开源了，如果需要引入BFF，需要基于Egg.js的基础上开发自己的BFF开发框架。 在调研BFF的过程中，看到蚂蚁金服自研的BFF的开发框架BFF Chair是基于Egg.js开发的。BFF Chair没有开源，但是Egg.js已经开源了，如果需要引入BFF，需要基于Egg.js的基础上开发自己的BFF开发框架。 1 Egg.js是什么Egg是一个为了开发企业级应用的框架，没有集成太多功能，值专注于提供Web开发的核心功能，并且提供了一套灵活可扩展的插件机制，来满足定制需求。 Egg奉行『约定优于配置』，在团队内应当按照一套统一的约定进行应用开发，降低沟通成本和学习成本。但约定不等于扩展性差，可以按照团队的约定制定框架。 2 Egg与其他Web框架的比较2.1 与Express的差异Express应用很广泛，简单且扩展性强，适合做个人项目，但框架本身缺少约定，标准的MVC模型会有各种千奇百怪的写法。而Egg按照约定进行开发，团队协作成本低。 2.2 与Koa的关系Koa和Express的设计风格类似，底层都是公用的同一套HTTP基础库，但是二者有一些区别： （1）异步解决方案 Express的异步编程模型是callback形式的，而Koa使用了async/await的形式 （2）Middleware中间件 Koa的中间件模型是洋葱圈模型 当中间件在执行时： 所有的请求经过一个中间件的时候都会执行两次，可以很方便的话实现后置处理逻辑。 （3）Context Express只有Request和Response两个对象，Koa增加了Context对象，作为当次请求的上下文对象（Koa1中为中间件的this，Koa2中作为中间件的第一个参数传入），可以将以此请求相关的上下文都挂载到这个对象，同时Context也挂在了Request和Response两个对象，这两个对象提供了大量的便捷方法辅助开发，例如： 1234request.queryrequest.hostnameresponse.bodyresponse.status （4）异常处理 通过同步方式编写异步代码带来的另一个非常大的好处就是异常处理非常自然，使用try/catch就可以将按照规范编写的代码中的所有错误捕获到。可以很方便的编写一个自定义的错误处理中间件： 123456789async function onerror(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit('error', err); ctx.body = 'server error'; ctx.status = err.status || 500; &#125;&#125; 只需要将这个中间件放在其他中间件之前，就可以捕获它们所有的同步或者异步代码中抛出的异常了。 2.3 Egg继承于KoaEgg选择了Koa作为基础框架，在它的模型基础上，做了一些增强。 2.3.1 扩展在基于Egg的框架或者应用中，可以通过定义app/extend/{application, context, request, response}.js中来扩展Koa中对应的四个对象的原型。通过这个功能，可以快速的增加更多的辅助方法。 例如，在app/extend/context.js中写入以下代码： 1234567// app/extend/context.jsmodule.exports = &#123; get isIOS() &#123; const iosReg = /iphone|ipad|ipod/i; return iosReg.test(this.get('user-agent')); &#125;,&#125;; 在Controller中，就可以使用刚才定义的便捷属性了： 123456// app/controller/home.jsexports.handler = ctx =&gt; &#123; ctx.body = ctx.isIOS ? 'Your operating system is iOS.' : 'Your operating system is not iOS.';&#125;; 2.3.2 插件Egg和Koa一样，可以通过中间件来提供各种功能，Egg的插件机制更加强大，让独立领域的功能模块可以更加容易编写。 一个插件可以包含： extend：扩展基础对象的上下文，提供各种工具类、属性 middleware：增加一个或多个中间件，提供请求的前置、后置处理逻辑 config：配置各个环境下插件自身的默认配置项 3 快速入门可以直接使用脚手架快速生成项目 123456789npm init egg --type=simple# 等同于 npx egg --type=simplenpm i# 启动项目npm run dev# open localhost:7001 生成项目后，可以编写Controller和对应的Router，可以在config文件夹下添加配置文件，此时目录结构如下： 12345678egg-example├── app│ ├── controller│ │ └── home.js│ └── router.js├── config│ └── config.default.js└── package.json Egg内置了static插件，默认映射/public/* -&gt; app/public/* Egg不强制使用某种模板引擎，只是约定了View插件开发规范，使用某种模板引擎需要在config目录下的plugin.js中开启： 12345// config/plugin.jsexports.nunjucks = &#123; enable: true, package: 'egg-view-nunjucks'&#125;; 在config/config.default.js中设置文件关联： 123456789// config/config.default.jsexports.keys = &lt;此处改为你自己的 Cookie 安全字符串&gt;;// 添加 view 配置exports.view = &#123; defaultViewEngine: 'nunjucks', mapping: &#123; '.tpl': 'nunjucks', &#125;,&#125;; 实际应用中，Controller一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层Service 可以使用中间件，完成一些独立的功能。 Egg提供了强大的配置合并管理功能： 支持按环境变量加载不同的配置文件，如config.local.js，config.prod.js等 应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载 在项目根目录下，以test.js为后缀名，即{app_root}/test/**/*.(test/app/middleware/robot.test.js) 4 渐进式开发在Egg里面的渐进式开发路径是： 插件（path） → 插件（package） → 框架 4.1 Step1 原始代码当我们编写了一段具有通用型逻辑的代码时，可以抽离成为插件，比如context.js中的内容： 12345678example-app├── app│ ├── extend│ │ └── context.js│ └── router.js├── test│ └── index.test.js└── package.json 4.2 Step2 插件（path）但是在一开始的时候，功能还没完善，直接独立成为插件，维护比较麻烦，这是可以把代码写成插件的形式，但不独立出去（即使用path来引用的插件形式的代码） 这个时候新的目录结构为： 123456789101112131415example-app├── app│ └── router.js├── config│ └── plugin.js├── lib│ └── plugin│ └── egg-ua│ ├── app│ │ └── extend│ │ └── context.js│ └── package.json├── test│ └── index.test.js└── package.json 核心代码： （1）app/extend/context.js移动到lib/plugin/egg-us/app/extend/context.js （2）lib/plugin/egg-ua/package.json声明插件 12345&#123; "eggPlugin": &#123; "name": "ua" &#125;&#125; （3）在config/plugin.js中通过path来挂载组件 123456// config/plugin.jsconst path = require('path');exports.ua = &#123; enable: true, path: path.join(__dirname, '../lib/plugin/egg-ua'),&#125;; 4.3 Step3 独立插件（package）经过一段时间开发后，该模块的功能成熟，此时可以抽离出来成为独立的插件 首先抽离出一个egg-ua插件，具体的方法的需要看插件文档学习。 代码在这里，目录结构： 123456789101112egg-ua├── app│ └── extend│ └── context.js├── test│ ├── fixtures│ │ └── test-app│ │ ├── app│ │ │ └── router.js│ │ └── package.json│ └── ua.test.js└── package.json 然后对原有应用改造，代码参见这里。 移除lib/plugin/egg-ua目录 package.json中声明对egg-ua的依赖 config/plugin.js中修改依赖声明为package方式 12345// config/plugin.jsexports.ua = &#123; enable: true, package: 'egg-ua',&#125;; 在插件没发布前，可以通过npm link的方式进行本地测试，具体参见npm-link 4.4 Step4 框架当积累了插件和配置后我们会发现，团队的大部分项目都会用到这些插件。此时就可以考虑抽象出一个适合团队业务场景的框架。 首先抽象出example-framework框架，具体的方法还是得看文档学习 代码在这里，目录结构： 1234567891011121314example-framework├── config│ ├── config.default.js│ └── plugin.js├── lib│ ├── agent.js│ └── application.js├── test│ ├── fixtures│ │ └── test-app│ └── framework.test.js├── README.md├── index.js└── package.json 把原来的egg-ua等插件的依赖从原来的应用中移除，配置到该框架的package.json和config/plugin.js中，然后改造原有的应用，对应的代码参考这里 移除config/plugin.js中对egg-ua的依赖 package.json中移除对egg-ua的依赖 package.json中声明对example-framework的以阿里，并配置egg.framework 1234567891011&#123; "name": "progressive", "version": "1.0.0", "private": true, "egg": &#123; "framework": "example-framework" &#125;, "dependencies": &#123; "example-framework": "*" &#125;&#125; 同样，在插件没发布前，可以通过npm link的方式进行本地测试 4.5 渐进式开发总结总的来说，Egg.js还是和适合一步步的渐进地去进行框架演进，具体流程如下： 当应用中有可能会复用到的通用逻辑，抽离出来放到lib/plugin中 当插件功能稳定后，独立出来作为一个node moudle 如此以往，应用中相对复用性较强的代码都会逐渐独立为单独的插件 当应用逐渐进化到针对某类业务场景的解决方案时，将其抽象为独立的framework进行发布 在新项目中抽象出的插件，下沉集成到框架后，其他项目只需要简单的重新npm install后就可以使用，可以提高团队效率 5 完整目录结构egg-project ├── package.json ├── app.js (可选) ------------------------- # 用于自定义自动时的初始化工作 ├── agent.js (可选) ----------------------- # 用于 Agent 机制的配置 ├── app | ├── router.js ------------------------ # 用于配置 URL 路由规则 │ ├── controller ------------------------ # 用于解析用户的输入 │ | └── home.js │ ├── service (可选) --------------------- # 用于编写业务逻辑层，建议使用 │ | └── user.js │ ├── middleware (可选) ------------------ # 用于编写中间件 │ | └── response_time.js │ ├── schedule (可选) -------------------- # 用于定时任务 │ | └── my_task.js │ ├── public (可选) ---------------------- # 用于放置静态资源 │ | └── reset.css │ ├── view (可选) ------------------------ # 用于放模板文件 │ | └── home.tpl │ ├── Modal (可选) ----------------------- # 用于放置领域模型，可选，由领域类相关插件约定 │ | └── mySQL.db │ └── extend (可选) ---------------------- # 用于框架的扩展 │ ├── helper.js (可选) │ ├── request.js (可选) │ ├── response.js (可选) │ ├── context.js (可选) │ ├── application.js (可选) │ └── agent.js (可选) ├── config | ├── plugin.js -------------------------- # 用于配置需要加载的插件 | ├── config.default.js │ ├── config.prod.js --------------------- # 配置文件，根据不同环境加载 | ├── config.test.js (可选) | ├── config.local.js (可选) | └── config.unittest.js (可选) └── test ----------------------------------- # 用于单元测屙屎 ├── middleware | └── response_time.test.js └── controller └── home.test.js 6 静态资源egg-view-assets提供了通用的静态资源管理和本地开发，文档在这里。 可以配合基于Webpack封装的roadhog、umi，通过自动的方式添加静态资源。 重要的是和构建工具整合，保证本地开发体验及自动部署，所以构建工具和框架有一层约定。 6.1 映射关系构建工具的Entry配置决定了映射关系，基于Webpack封装的roadhog、umi内置了映射关系，如果单独使用Webpack需要根据这层映射来选择使用哪种方式： 文件源码app/assets/index.js，对应的Entry为index.js 本地静态服务接受以此为Entry，如请求http://127.0.0.1:8000/index.js 构建生成的文件需要有这层映射关系，如生成index.{hash}.js并生成Mainfest文件描述关系如： 123&#123; &quot;index.js&quot;: &quot;index.&#123;hash&#125;.js&quot;&#125; roadhog完全满足这个映射关系，所以可以直接使用assets模板引擎，Umi不满足文件映射，所以选用其他模板引擎的方案。 6.2 开发、部署、CDN文档的介绍多是基于roadhog的基础上进行的配置，如果使用Webpack需要自己配置，还是比较繁琐的。 所以考虑使用Easy-Team提供的EGG + Vue工程化解决方案。 参考 Egg文档]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高09 Hooks]]></title>
    <url>%2F2019%2F03%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9809%20Hooks%2F</url>
    <content type="text"><![CDATA[React Hooks学习笔记。 这篇文章真的写了好久，从1月多，Hooks还是实验特性时就开始看，中间断断续续，再加上一开始看英文的文档，拖到了现在。 总结的太磨叽了，又弄了一个精简版，那这个做分享吧。 心里也没底。 文中涉及到的代码在这里。 做了一个分享的PPT，如果有人需要的话可以拿走。 精简版React Hooks是V16.8的新特性，是一个向后兼容的新特性（不会引入破坏性的改变）。 引入的原因实现比现有方案（HOC/Render Props）更优雅的代码复用，为纯组件引入状态，能够将组件划分为更细的粒度。 内置Hooks1 useState Hook（1）用法内置的useState用来为纯组件添加状态变量和更新方法，可以认为是this.state和this.setState的简化版，以数组的形式获取状态变量，第一个变量是一个状态，第二个是更新方法，useState接受的参数是初始值 12import &#123; useState &#125; from 'react';const [count, setCount] = useState(0); （2）函数式更新在使用setState更新时，可以直接传递一个结果，这个结果将直接赋值给state，如果更新的结果与上一个状态有关系，那可以使用函数式更新，setState的参数是一个函数，函数的参数是之前的值，返回的是更新的值 （3）手动合并对象useState不会自动合并更新对象，所以需要手动进行合并，采取函数式赋值的方式：setState(prevState =&gt; ({ ...prevState, a: 100 })) （4）延迟初始化useState的参数initialState是首次渲染期间使用的状态，如果这个状态是一个高开销的计算结果，可以改为提供函数，这个函数仅在初始渲染时执行，可以避免性能浪费： 1const [state, setState] = useState(() =&gt; (&#123; a: initialize(), b: 2 &#125;)); 2 useEffect Hook（1）用法内置的useEffect会在每次渲染（DOM更新）后（包括首次）后执行才作为参数的方法，可以认为是componentDidMount和componentDidUpdate的合集，分为需要销毁的和不需要销毁的两种 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`&#125;); 上面是不需要销毁的useEffect，它会在每次渲染后执行内部的函数。 （2）清理effect如果需要销毁，那么只需要在这个函数内部返回一个另一个函数，在返回的函数中执行销毁操作即可。注意和执行一样，销毁也是在每次渲染后都会执行，可以防止内存泄漏。 123456useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; return () =&gt; &#123; document.title = `ok`; &#125;&#125;); （3）避免重复渲染useEffect默认的表现是在每次渲染后触发，当组件的任何一个状态发生改变时，更新函数都会执行，可以给useEffect传递第二个参数，这时只有当数组中的任一一项的值发生变化，useEffect的更新函数才会执行。 这个数组并不会作为参数传递给更新函数内部，但是从概念将，更新函数中引用的每个值都应该出现在输入数组中，这样才能避免更新函数依赖的某个值发生了变化，而函数没有重新执行。ESLint的插件会自动检测并插入这个数组，推荐使用。 如果参数一个空数组，那么任何变量的变化都不会引起useEffect的执行，这时候与只在componentDidMount和componentWillUnmount执行代码是类似的。 它的最大作用是就是减少因为没有在componentDidUpdate处理更新前的状态而导致的bug。 （4）useEffect的执行时机useEffect中的更新函数会延迟到layout和paint后触发，也就是说在浏览器更新屏幕之后才会触发，但是有一些事件不能推迟，对于这个类型的事件需要在useLayoutEffect中触发，它与useEffect的不同就是在触发时机上的不同。 虽然useEffect延迟到浏览器绘制完成之后执行，但是它保证在任何新渲染之前触发。 （5）useEffect中获取本次渲染更新后的值==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，==即便执行了setState之后仍是这样==。 可以认为每次渲染时通过useState声明的状态是不可变的（Immutable），每次渲染都会对它拍一个快照保存下来，当状态更而重新渲染时就会形成N个状态。不光是state和props通过快照的形式保存，组件的事件处理和useEffect都是同样的形式 如果要在useEffect中使用更新后的state，需要使用useRef 3 useRefuseRef返回一个可变的对象，其current属性被初始化为传递的参数，返回的这个对象就保留在组件的生命周期中。 useRef返回的ref对象在所有Render过程中保持着唯一引用，如果认为state是不可变的数据，那么ref对象就可以认为是可变对象，对ref.current的赋值和取值，拿到的额都是一个状态。 要注意，避免在渲染过重中（return中）设置直接饮用，可能会导致预料之外的结果，相反，应该只在事件处理程序和useEffect中修改、使用引用。 4 useContext用来创建context对象，当使用来传递数据时有用。 5 useReduceruseState的替代方案，当组件使用flux架构组织管理数据时有用。 用它配合useContext可以避免在多层组件中深度传递回调的需要。 6 useCallback主要是用来处理在useEffect之外的定义函数无法管理依赖，也无法成为useEffect的依赖，每次渲染都会生成新的快照的情况，使用之后只有在函数的依赖发生变化时才会生成新的函数，有利于提高性能，依赖也更清晰。 7 useMemo与useCallback类似，返回的是一个不生成快照的对象，而非函数。 useMemo只会在其中一个输入发生更改时重新计算，此优化有助于避免在每个渲染上进行高开销的计算。 8 useLayoutEffect前面介绍过，与useEffect的不同点仅仅在于执行时机不同，useLayoutEffect在绘制前同步触发，useEffect会推迟到绘制后触发 Hooks的使用规定（1）只在最顶层调用Hooks，不要再内部循环、条件语句或嵌套函数中调用Hooks（这是因为React是通过多个Hooks的调用顺序来确定多个useState中状态变量的对应关系），如果想要有条件的运行一个effect，可以将条件判断放在Hook内部 （2）只在React函数中调用Hooks，不在普通的JavaScript函数中调用 可以通过ESLint的eslint-plugin-react-hooks插件来检查、规范Hooks的使用，避免不规范的使用而导致的bug。 编写自定义Hook自定义Hook实际上就是一个函数，将公用的逻辑提取进去，可以调用其他的Hook，必须以use开头。 不同的组件使用同一个自定义的Hook，状态不会共享，只是将逻辑复用，Hook使用时内部状态和effect都是完全隔离的。 啰嗦版1 简介React Hooks是v16.8推出的一个新特性，它提供给开发者一种能力，让开发者不用class的形式就能够使用state和其他的特性 在进一步了解Hooks之前，有几点注意事项： 不是必选项，你可以现在现有的组件中添加代码来试用Hooks，但是如果你不想使用它也是完全可以的 100%向后兼容，Hooks不会引入任何破坏性的改变（breaking changes） 已经提供使用，在16.8版本正式引入 Hooks的引入并不意味着在React中要放弃使用class，后面会介绍渐进式使用Hooks的策略 Hooks也不会取代你已了解的React中的概念，相反，Hooks为props、state、context、refs和生命周期等等你所熟悉的概念提供了一个更加直接的API。Hooks提供了一个更好的方式来复合使用上述概念。 2 为什么要引入HooksHooks解决了React中一系列看似毫不相关的问题，这些问题在我们编写、维护大量组件时非常常见。 2.1 在组件间复用有状态的逻辑是非常困难的React并没有提供一种方式来为组件添加可复用的接口（例如将一个组件连接到store）。React中经常使用一些编程范式来解决这类问题，例如Render Props、高阶组件。但是使用这些范式需要对组件进行重构，这个过程非常的麻烦，并且将导致代码难以维护。当你在React DevTools中查看一个典型的React应用，你会发现充满了“包裹地狱”（wrapper hell），组件嵌套在多层的provider、consumer、高阶组件、Render和其他抽象结构中。虽然我们可以公国开发工具来进行梳理，但是这也表明了一个更底层的问题：React需要一个更好原生方法来实现状态逻辑的复用。 使用Hooks，你可以将状态逻辑从组件中抽离出来，这样就可以对它单独进行测试和复用。Hooks为开发者提供了在不改变组件层次的基础上进行状态逻辑复用的能力。这使得我们能够轻而易举的在组件之间或者社区间共享Hooks。 2.2 复杂的组件变的难以理解我们常常要维护这样的组件：开始很简单，慢慢就充满了大量难以维护的状态逻辑和副作用。每个生命周期方法常常包含了大量的不相关逻辑的组合。例如，组件常常在componentDidMoun和componentDidUpdate来获取数据，而在一个componentDidMount中常包含许多无关的逻辑，比如建立事件监听器，这些事件监听器需要在componentWillUnmount中销毁。这些相互关联、同时更改的代码被分隔开了，但是完全没有关系的却出现在同一个方法中。这将带来大量的bug和不一致性。 在大多数情况下，我们无法将这些组件分割成为更小的组件，因为状态逻辑贯穿了整个组件，我们也很难测试这些组件。这也是许多开发者更倾向于为React配套使用一个单独的状态管理框架的原因。但是这也常常带来太多的抽象，让你在不同的文件之间反复跳转，让组件的复用更加困难。 为了解决这个问题，Hooks可以根据依赖（例如建立订阅器或者获取数据）而非生命周期钩子，将一个组件分割为更小的函数。为了让组件更容易预测，你可以选择通过reducer来管理组件的内部状态。 2.3 Class让开发者和计算机都感到迷惑为了实现代码复用，代码组织难度加大了。我们发现Class成为了学习React的一大障碍。你必须搞清楚在JavaScript中this的工作原理，这与this在其他大多数语言中的原理都不相同。你必须记得为事件处理程序绑定this。在关于class的语法提案没有正式通过前，class的代码显得非常啰嗦。人们能够很好地理解props、state、自顶向下的数据流，但是仍很难理解class。React中函数和class组件自身以及应用场景的区别在充满经验的React开发者间都存在着分歧。 此外，React已经诞生5年了，我们希望在接下来的5年保持连贯性。像Sevlte、Angular、Glimmer等显示的，AOT编译（运行前编译）有着很大的潜力，尤其是不仅用于与模板时。我们最近在实验使用Prepack进行组件折叠（component folding）的尝试，并且初见成效。但是我们也发现class组件带来的某些无目的范式会降低这些优化效果。Cass在当前的工具中也存在着问题，比如Class的压缩效果并不好，热更新编的颗粒化且不可靠。我们希望能够提供新的API让代码得到最大程度的优化。 为了解决这些问题，Hooks提供了绕过class使用React更多的特性的能力。从概念上将，React组件更接近于函数。Hooks对函数更友好，但也不会未被React所提倡的理念。Hooks提供了一个非常迫切的“逃生舱口”，并且不需要您去学习复杂的函数式编程或者响应式编程的知识。 2.4 小结啰里吧嗦翻译了一堆，总结起来，Hooks出现的原因有三： 现有的React的状态组件复用方式（高阶组件、Render Props）有各自的问题， 而Hooks可以优雅的（不改变组件层次）实现代码复用 Hooks可以将组件根据功能，将组件划分为更小的粒度，便于调试、测试和维护 Hooks可以不使用Class来编写组件，提高代码性能，降低React的使用难度 3 渐进式策略 React并不准备移除class 我们都知道，Recat开发者都忙于搬砖而无暇关注新发布的API。Hooks非常新，可能在更多的实例和教程出现之后，再考虑学习或者使用Hooks，可能更加稳妥。 我们也知道，为React添加一个新的原语遇到的阻力会很大。我们为好奇的读者准备了一份详细的请求意见稿，它介绍了Hooks出现的更多细节，提供了额外的视角来审视具体的设计决定和相关技术。 最重要的是，Hooks与现有代码是共存的，所以可以渐进式的应用到代码中。我们分享了试验性的API，目的是得到社区中对亲自参与React未来发展的人们的早期的反馈，我们将不断更新Hooks。 最后，不必急于迁移到Hooks。我们建议避免任何的“大重构”，特别是针对现有的、复杂的class组件。Hooks的思维习惯还需要一定的思维转变。根据我们的经验，最好首先在全新的、不重要的组件中练习使用Hooks，并且确保你的团队中的每个人都欣然接受。 我们为Hooks准备了全部现有的针对class的用例，但是我们将在可预见的未来继续提供对class组件的支持。Facebook中有大量的用class写成的组件，我们绝没有移除它们的计划。相反，我们将会在新的代码中同时使用Hooks和class 4 State HookReact默认提供了两种Hooks，一种用来声明状态变量的State Hook，另外一种是用来执行副作用函数的Effect Hook。另外，用户可以自定义个性化的Hooks，进行灵活的应用。首先来了解State Hook。 4.1 例子下面的例子渲染了一个计数器，当点击按钮式，计算器的值会递加 先看传统的class组件怎么写： 123456789101112131415161718192021222324class Count extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; setCount() &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count + 1 &#125;) &#125;; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setCount()&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 用Hooks的实现： 12345678910111213141516// 引入useState，用来在函数组件中保存局部变量import &#123; useState &#125; from &apos;react&apos;;function Example() &#123; // Declare a new state variable, which we&apos;ll call &quot;count&quot; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 上面，useState就是一个Hook。我们在一个函数组件中调用Hook，来为函数组件添加一些内部状态。React在重复渲染时会保留这些状态。useState返回两个变量：当前状态值和更新此状态的函数。你可以在一个事件处理程序等任意位置调用这个方法。它和class中的this.setState也有点类似，除了Hook返回的函数并不会将新旧状态进行合并（后面会有一个例子来比较useState和this.setState的区别） useState的唯一一个参数是初始状态值。上面的例子中，这个值是0，因为我们的计数器是从0开始计数的。注意，与this.state不同，Hooks中的状态值类型可以不是对象，当时对象类型也是支持的。初始状态参数旨在第一次渲染时用到。 4.2 声明状态变量上面的class是一个有状态的组件，React中又有一种无状态的组件，也叫做函数组件（function component）长的像这样： 1234const Example = (props) =&gt; &#123; // You can use Hooks here! return &lt;div /&gt;;&#125; 如果想要用函数组件来实现计数器这个例子，在以前是行不通的，因为在函数组件中是没有this的，所以没有办法维护this.state这个状态变量。 这时候就是Hooks的用武之地了：当你想为一个函数组件添加一个状态变量（state），以前只能改写成为class的形式，现在就可以在函数组件中使用Hooks来达到你的目的。 在函数组件中可以使用useState： 123456import &#123; useState &#125; from 'react';function Example() &#123; // Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0);&#125; useState到底做了什么？ useState声明了一个“状态变量”（例子中的count），这个变量名是可以随意定义的。这是在函数调用时保存变量值的方法–useState的作用就像class中的this.state一样。一般来说，当函数退出后变量会被清除，但是React会将状态变量保存起来。 useState的参数是什么？ useState只有一个参数，那就是Hook的初始值。与class不同，useState定义的状态变量可以不是object，number或者string都是可以的。在计数器的例子中我们需要一个数值来记录用户点击的次数，所以我们为变量传入了0作为初始值（如果想要在state中保存两个不同的值，需要调用useState()两次） useState的返回值是什么？ 返回两个变量：当前值和这个值的更新方法，上面的代码const [count, setCount] = useState()和class中的this.state.count和this.setState是类似的，不同点是Hook将它们作为一组数据同时返回 当再次渲染时，React会在函数组件中获取count的最新值，如果想要更新count可以调用setCount 4.3 读取状态变量在class中我们通过读取this.state.count来获取最新的count值： 1&lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; 在函数组组件中可以直接使用count值： 1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; 4.4 更新状态变量在class中通过调用this.setState来更新count值 123&lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me&lt;/button&gt; 在函数组件中，我们已经声明了变量setCount和count，所以也就不需要this了 123&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; 4.5 声明多个状态变量在一个组件中可以多次使用状态Hook： 1234567function ExampleWithManyStates() &#123; // 声明了多个状态变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 通过数组的解构赋值，我们可以在调用useState声明多个不同名称的状态变量。变量名并不是useStateAPI的一部分，相反，React假设你会在每次渲染时，以相同的顺序多次调用useState。后面我们会回过头再来解释为什么可以这样做以及应用场景。 4.6 究竟什么是Hook？通过上面的例子，我们可以发现： Hook是一种能够“侵入”React的函数组件的状态和生命周期特性的函数。Hook不能用在class中–Hook让你能够抛弃class来使用React（我们并不建议立刻对现有代码进行重构，但是如果你愿意的话，可以在新代码中开始使用Hooks） React提供了一些内嵌的Hooks，例如useState。你也可以创建自己的Hook，达到在不同的组件间复用有状态的行为。后面会首先讲解内嵌的Hook。 5 Effect Hook我们将React组件中的某些操作称为具有副作用的effect（或者简称为effect），例如获取数据、订阅事件或者手动更改DOM，因为这些行为可能会影响其他的组件，并且无法在渲染期间完成。 useEffect就是一种Effect Hook，它可以为函数组件添加副作用行为。它提供的功能和class中的componentDidMount、 componentDidUpdate、componentWillUnmount是相同的，只是被合并为一个单独的API。 React组件中有两种常见的effect，一种是需要销毁的，另外一种是不需要销毁的。 5.1 不需要销毁的effect有些时候，我们希望在React更新DOM之后运行一些额外的代码。注入网络请求、手动更新DOM以及打印日志都是常见的不需要销毁的effect。这么认为的原因是我们可以运行它们，并且立刻忘记它们。下面看一下，用Class组件和Hook组件分别是如何实现effect的。 5.1.1 用Class组件实现在React的Class组件中，render方法并不会导致effect，因为在render中为时尚早–我们是在React更新DOM后才执行effect。 所以在React的Class组件中，我们将effect放在componentDidMount和componentDidUpdate生命周期函数中。下面的例子中，组件会在React更新DOM之后设置文档的标题。 123456789101112131415161718192021222324252627class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 我们必须在class的两个生命周期函数中编写相同的代码。 这是因为很多情况下，不管组件是刚刚渲染完成还是更新完成，我们想要执行相同的effect。也就是说，我们想要在每次渲染后都执行effect。但是React的Class组件并没有提供这样的生命周期。我们能够提取出一个单独的方法，但是仍需要在两个地方调用它。 而如果使用useEffectHook来完成同样的行为： 5.1.2 用Hook组件实现如果改成使用useEffect的形式： 1234567891011121314151617181920import &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 你可能会有这样的疑问： （1）useEffect究竟做了什么？ 通过使用这个Hook，你告诉React这个组件需要在每次渲染后执行一些操作。React会保存你传入的函数（这个函数就是上面提到的effect）并且在每次DOM更新后进行调用。在上面的Effect中，我们更改了文档的标题，当然也可以执行获取数据等其他必要的操作。 （2）为什么在组件中调用useEffect？ 将useEffect放在组件中让我们有能力从effect中获取count状态变量（以及任何prop）我们不需要特殊的API来读取它–因为它已经在函数的作用域中了。Hooks鼓励JavaScript闭包，并且尽量避免在JavaScript已经提供解决方案的情况下引入额外的React特有的API （3）useEffect在每次渲染后都会运行吗？ 是的。useEffect默认在首次渲染以及每次更新后都会运行（当然后办法修改这种行为）。这使得你函数无所谓是在mount还是update后被调用，因为他们会在每次渲染后都被统一调用。Reasct会保证在DOM更新完成后才会调用effect。 5.1.3 细节讲解123456function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); 我们声明了count状态变量，随后需要使用effect来完成某些行为。我们给useEffectHook传递了一个函数，这个函数就是effect，在其中我们设置文档的标题。我们在effect可以读取罪行的count因为它位于函数作用域内。当React渲染组件时会保存我们的effect，并且在每次更新DOM后运行–包括首次渲染。 有经验的卡开发者或者会注意到，传递给useEffect的函数在每次渲染后都是不同的。这是有意而为之。实际上，这让我们在effect中读取count的值而不必担心它的值没有刷新。每次渲染，我们都会使用新的effect代替之前的。折让effect看起来更像render的结果–每个effect都“属于”一次特定的render。这是很有用的，后面会提到。 与componentDidMount和componentDidUpdate，useEffect的effect不会阻塞浏览器更新显示信息。这会让你的app更加响应式。大部分的effect不需要同步完成，在少数情况下需要（例如测量布局），可以使用useLayoutEffectAPI。 5.2 需要销毁的effect有一些effect需要销毁，例如我们可能会针对默写外部数据源建立监听器。这种情况下就必须销毁effect，以避免内存泄漏。同样使用Class组件和Hook组件都可以时间。 5.2.1 使用Class组件在React的Class组件中，需要在componentDidMount生命周期中建立监听器，在componentWillUnmount销毁，例如，我们通过ChatAPI来订阅好友的上线状态，在React的Class组件中的实现如下： 12345678910111213141516171819202122232425262728293031323334class FriendStatus extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; render() &#123; if (this.state.isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return this.state.isOnline ? &apos;Online&apos; : &apos;Offline&apos;; &#125;&#125; 在componentDidMount和componentWillUnmount生命周期中需要执行相反的操作。生命周期方法让我们不得不将逻辑上相关联的操作分割开来。 5.2.2 使用Hooks组件你或许认为我们需要一个独立的effect来执行销毁。但是由于添加和移除订阅的关系如此紧密，所以useEffect在设计时就将而二者联系在了一起。在effect中返回一个函数，React就会在销毁时执行这个函数。 12345678910111213141516171819202122mport &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125; 在上面的例子中，React会在组件销毁时通过ChatAPI执行取消订阅，就如同在随后的渲染中再次运行Effect Hook一样（如果需要，当传递给ChatAPI的props.friend.id没有变化时，可以让React不再重复订阅） （1）为什么在effect中返回了一个函数？ 这是effect的可选的销毁机制。每一个effect都可以返回一个函数来进行销毁。这让我们能够统一维护保持添加和移除的逻辑。它们都是同一个effect的组成部分。 返回的函数可以使命名函数也可以是匿名函数、箭头函数。 （2）React究竟是何时销毁一个effect？ React在组件unmount时销毁effect。但是正如我们上面介绍过的，effect在每次渲染都会运行，而不只运行一次。所以React也会在上一次渲染结束后、运行下一次的effect之前来执行清理。后面会介绍为什么这有利于减少bug以及为了减少可能带来的性能问题如何退出这种机制。 5.3 为什么在每次更新后effect都会运行为什么effect的销毁在每次重新渲染后都会执行，而不是只在unmount时执行一次。下面的例子会展示这样设计的好处–编写bug更少的组件。 前面的订阅好友上线状态的组件会展示好友是否上线，组件从this.props中读取friend.id，在组件mount后订阅好友状态，在unmount后取消订阅 12345678910111213componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 但是，如果prop中的firend变化了，而组件仍然显示在界面上，这时会发生什么？我们的组件会继续展示之前的朋友（与当前不同）的上线状态。这就是一个bug。而且当我们在取消订阅时用了错误的好友ID是，会造成内存的泄露甚至崩溃。 在Class组件中，我们需要在componentDidUpdate中处理这种情况： 12345678910111213componentDidUpdate(prevProps) &#123; // Unsubscribe from the previous friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // Subscribe to the next friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 忘记正确的处理componentDidUpdate中的逻辑是React产生bug最多的原因之一。 如果使用Hooks的组件： 12345678function FriendStatus(props) &#123; // ... useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); 这种情况就能避免上面的bug。 没有代码专门处理更新的情况因为useEffect默认会自动处理。它会在应用下一个effect之前清理上一个effect。下面的订阅和取消订阅的顺序可以证明这一点： 12345678910111213// Mount with &#123; friend: &#123; id: 100 &#125; &#125; propsChatAPI.subscribeToFriendStatus(100, handleStatusChange); // Run first effect// Update with &#123; friend: &#123; id: 200 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(200, handleStatusChange); // Run next effect// Update with &#123; friend: &#123; id: 300 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(300, handleStatusChange); // Run next effect// UnmountChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect 这种行为默认保证了一致性，避免了Class组件中因为忽略更新逻辑而导致的bug 5.4 使用effect的注意事项5.4.1 使用多个effect来分离关注点在我们讨论为什么要引入Hooks的时候提到了一个问题，Class组件的生命周期方法常常包含无关的逻辑，而相关逻辑却常常被分散在不同的方法中。下面的组件包含了前面例子中的计数器和好友上线提示的逻辑： 1234567891011121314151617181920212223242526272829303132class FriendStatusWithCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; // ... 上面的代码中，设置文档标题的逻辑分散在componentDidMount和componentDidUpdate中，订阅逻辑分散在componentDidMount和componentWillUnmount中，而componentDidMount中包含了所有的逻辑代码。 使用Hooks如何解决这个问题？就像可以多次使用状态Hook一样，也可以使用多个effect。这让我们可以分离无关逻辑到不动的effect中。 12345678910111213141516171819function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; // ...&#125; ==Hooks让我们能够基于代码的行为来分割代码==，而不是基于生命周期。React会按照effect声明的顺序，运行组件中的每一个effect 5.4.2 跳过effect以改善性能某些情况下，每次渲染都销毁或者应用effect会造成性能问题。在Class组件中，我们可以通过在componentDidUpdate中对比prevProps和prevState来解决这个问题 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这种需求很常见，所以它被内置到了useEffectHook的API中。如果在重复渲染时某些特定值未发生改变，你可以让React不再运行effect。具体做法是将一个数组作为可选的第二个参数传递给useEffect 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // Only re-run the effect if count changes 上面的例子中，将[count]作为第二个参数传给了useEffect。当count值未发生变化时，React会跳过effect。如果数组中有多个值，React会在任何一个发生改变时再次执行effect。 注意，如果进行这种优化，确保数组中包含了被effect使用的、会随时间变化的外部变量。否则你的代码从上次渲染中获取的参考值不会改变。 如果想只执行、销毁effet一次（mount和unmount时），可以传递一个空数组作为第二个参数。这告诉了React你的effect不依赖任何从props和state中任何变量，所以不需要重复执行。这种情况与只在componentDidMount和componentWillUnmount执行代码是类似的，我们建议谨慎使用，因为容易导致bug 6 Hooks的使用规定Hooks是函数，在使用时需要注意两条规定，可以引入ESLint的一个插件来确保遵守 6.1 只在最顶层调用Hooks==不要在内部循环、条件语句或者嵌套函数中调用Hooks==。相反，要式中在React函数的最顶层使用Hooks。这样才能确保组件每次渲染时都以同样的顺序调用Hook。这是保证React在多个useState和useEffect中正确保存状态的前提。 6.2 只在React函数中调用Hooks不要在普通的JavaScript函数中调用Hooks。正确的做法是： 在React的函数组件中调用Hooks 在自定义的Hooks中调用Hooks 遵守这条规定，能够确保组件中的所有状态逻辑在源码中都是清晰可见的。 6.3 ESLint插件通过这个ESLint插件可以检测在使用Hooks时是否遵守了上面两条规定。安装： 1npm install eslint-plugin-react-hooks ESLint的配置文件： 12345678910&#123; "plugins": [ // ... "react-hooks" ], "rules": &#123; // ... "react-hooks/rules-of-hooks": "error" &#125;&#125; 将来这个插件会默认集成在Create React App和类似工具中。 6.4 为什么看这样一个例子： 12345678910111213141516171819function Form() &#123; // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() &#123; localStorage.setItem('formData', name); &#125;); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() &#123; document.title = name + ' ' + surname; &#125;); // ...&#125; React是通过Hooks的调用顺序来确定多个useState中状态变量的对应关系。上面的例子之所以能够正常运行是因为每次渲染时Hooks的执行顺序是相同的。 123456789101112131415// ------------// First render// ------------useState('Mary') // 1. 初始化状态变量name为'Mary'useEffect(persistForm) // 2. 添加effect来保存表单数据useState('Poppins') // 3. 初始化状态变量surname为Poppins'useEffect(updateTitle) // 4. 添加effect来更新标题// -------------// Second render// -------------useState('Mary') // 1. 读取状态变量name (忽略了参数)useEffect(persistForm) // 2. 更新effectuseState('Poppins') // 3. 读取状态变量surname(忽略了参数)useEffect(updateTitle) // 4. 更新effect 只要Hook的调用顺序不变，React就能正确辨别多个变量的关系。但是如果我们将一个Hook放到一个条件语句中呢？ 123456// 🔴 违反了第一条规定，在条件语句中使用了Hookif (name !== '') &#123; useEffect(function persistForm() &#123; localStorage.setItem('formData', name); &#125;);&#125; 条件语句第在第一次渲染时条件判断为true，Hooks的调用情况与上面相同。但是当第二次渲染时判断条件如果变为了false，这个Hook会被跳过，这是Hook的调用顺序发生了变化： 1234useState(&apos;Mary&apos;) // 1. 读取状态变量name (忽略了参数)// useEffect(persistForm) // 🔴 这个Hook被跳过了useState(&apos;Poppins&apos;) // 🔴 2 (原来是第3步). 无法读取状态变量surnameuseEffect(updateTitle) // 🔴 3 (原来是第4步). 无法更新effect React不会知道第二个useState返回值是什么，React认为这个组件的第二个Hook是persistForm这个effect，就如同上次渲染相同，但是实际情况并不是这样。从这之后的Hooks调用都会错位，导致了bug。 ==这就是必须在组件中的顶层中调用Hook的原因==。如果想要有条件的运行一个effect，可以将条件判断放在Hook内部： 123456useEffect(function persistForm() &#123; // 👍 We're not breaking the first rule anymore if (name !== '') &#123; localStorage.setItem('formData', name); &#125;&#125;); 编写个性化Hook例子编写个性化Hook可以将组件的逻辑提取为可复用的函数。 上面例子中一个订阅好友状态的组件我们命名为FriendStatus，现在假设我们的聊天程序有一个通讯录的功能，我们想要将在线好友的名字渲染为绿色。我们可以粘贴复制相同逻辑的代码到FriendListItem组件中，但是这很不优雅： 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendListItem(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 更优雅的做法是在FriendStatus和FriendListItem组件中共用相同的逻辑。 在以前，React中想要在组件中复用状态逻辑有两种方法：render props和HOC。使用这两种方法都需要添加一些包裹组件，现在使用Hooks可以不向组件树中添加新的组件来解决这个问题。 提取自定义Hook如果我们想在两个JavaScript函数中复用逻辑，可以将这部分提取到单独的函数中。React组件和Hooks都是函数，所以也可以使用这种方法。 自定义的Hook是这样的一种函数：函数名以use开头，可以调用其他的Hooks。在下面我们编写一个自定义的Hook：useFeinedStatus 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 在useFeinedStatus中没有新的代码，逻辑都是从旧的组件中复制而来。和组件中调用一样，在我们自己编写的Hooks中，仍然需要遵守在顶层调用、不能在条件语句中调用的原则。 与React的组件不同，自定义的Hook不需要特殊标记。我们可以决定它的参数和返回值，就如果普通的函数一样。它的名字应该以use开头，这样就能一眼分辨出它遵守的Hook的规定。 我们的useFeinedStatusHook的目的是订阅好友的状态，所以参数是friendID，返回值是好友是否在线的状态值 1234567function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... return isOnline;&#125; 使用自定义Hook在一开始，我们的既定目标是从FriendStatus和FriendListItem组件中移除重复的逻辑代码。二者中都包含了好友上线通知的逻辑。 现在我们已经将这部分逻辑提取到了useFriendStatus这个Hook中，我们可以这样使用： 12345678function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 123456789function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 优化后的代码与原来的代码相同吗？ 是的。优化后的代码实现了一样的功能。但是我们将复用的部分提取到了单独的函数中。自定义的Hook的设计思路与Hooks相同，与React的特性不同。 自定义的Hook的名字一定要要以use开头吗？ 是的，这个习惯很重要。如果不这样做，我们就无法自动的侦测违反Hooks使用规定的行为，因为我们无法分别一个函数中是否调用了Hooks。 使用同一个Hook的两个组件的会共享状态码？ 并不是，自定义Hooks是一种复用状态逻辑的方式（就像建立一个监听器并且保存当前值），但是每次使用一个自定义Hook，所有其内部的状态和effect都是完全隔离的。 自定义Hook是如何隔离状态的？ Hook的每次调用都会隔离状态，因为对于React而言，我们直接调用useFriendStatus，与调用useState和useEffect是一样的。前面介绍过，同一个组件中useState和useEffect的多次调用完全是相互独立的。 提示：在Hooks之间传递参数既然Hooks是函数，那么我们就可以在它们中间传递参数。 为了说明这一点，我们为上面的聊天APP的例子再添加一个组件，它是一个聊天信息接受选择器，用来显示当前选择的好友是否在线。 1234567891011121314151617181920212223242526const friendList = [ &#123; id: 1, name: &apos;Phoebe&apos; &#125;, &#123; id: 2, name: &apos;Rachel&apos; &#125;, &#123; id: 3, name: &apos;Ross&apos; &#125;,];function ChatRecipientPicker() &#123; const [recipientID, setRecipientID] = useState(1); const isRecipientOnline = useFriendStatus(recipientID); return ( &lt;div&gt; &lt;Circle color=&#123;isRecipientOnline ? &apos;green&apos; : &apos;red&apos;&#125; /&gt; &lt;select value=&#123;recipientID&#125; onChange=&#123;e =&gt; setRecipientID(Number(e.target.value))&#125; &gt; &#123;friendList.map(friend =&gt; ( &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt; &#123;friend.name&#125; &lt;/option&gt; ))&#125; &lt;/select&gt; &lt;div/&gt; );&#125; 我们将当前选择的好友ID保存在变量recipientID中，如果用户在&lt;select&gt;中选择了另外的好友我们会更新这个变量 因为useStateHook调用时会提供recipientID的最新之，我们将它作为参数传给useFriendStatus这个Hook 12const [recipientID, setRecipientID] = useState(1);const isRecipientOnline = useFriendStatus(recipientID); 这就实现了通知我们当前选择的好友是否上线的目的。当我们选择了另外一个好友并且更新了recipientID后，我们自定义的HookuseFriendStatus就会取消对上一个朋友的订阅，订阅选择后的新朋友的状态 另一个例子：useYourImagination() 这部分的内容，由于我没有接触过Redux，所以不能很好的理解代码的功能。下一个任务就是学习Redux，需要回过头来再重新学习这部分 自定义Hook提供了React组件之前不具备的共享逻辑的灵活性。自定义Hook可以实现很多的功能，比如表单处理、动画、事件订阅、计时器等等。此外，Hooks使用起来就想使用React内置的特性一样轻松。 不要过早开始抽象逻辑。现在函数式组件功能更强大，你代码库中的函数式组件的平均长度会因此增长不少。这很正常，你没有必要立刻将它们分割为Hooks。但我们还是鼓励在有需要隐藏简单接口后的辅助逻辑时、或者分解复杂组件时开始使用自定义Hook 举个例子，下面是一个通过Hooks方式管理的复杂的组件，包含了许多局部变量。useState并没有将更新逻辑集中变得更容易，所以也许你更倾向于使用Redux的reducer的形式来实现： 123456789101112function todosReducer(state, action) &#123; switch (action.type) &#123; case 'add': return [...state, &#123; text: action.text, completed: false &#125;]; // ... other actions ... default: return state; &#125;&#125; reducer非常易于独立测试以及表达复杂的更新逻辑，如果需要还可以被分解为粒度更小的reducer。你也许习惯了使用React局部变量带来的优势，并不愿意再引入另外的库。 但如果编写一个useReducer的Hook帮助我们管理组件中的reducer中的局部变量呢？简单的实现如下： 12345678910function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; 可以在组件中使用这个Hook，使用reducer进行它的状态管理： 123456789function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: 'add', text &#125;); &#125; // ...&#125; 在复杂组件中利用reducer管理局部变量是非常常见的需求，所以React提供了的内置的useReducerHook。 Hooks APIReact提供了一系列内置Hooks，这里简单介绍一下吧，详细的参考文档。 分为两大类，基础Hook和附加Hook 基础Hook包括： useState useEffect useContext 附加Hook包括： useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useState1const [state, setState] = useState(initialState); 返回一个状态变量和更新函数。 要注意的是，在每次渲染期间，useState返回的第一个值将始终是应用更新后的最新的状态。 函数式更新在使用setState更新时，可以直接传递一个结果，这个结果将直接赋值给state，如果更新的结果与上一个状态有关系，那可以使用函数式更新，setState的参数是一个函数，函数的参数是之前的值，返回的是更新的值 1setState((prevState =&gt; prevState + 1) 手动合并对象注意，与class组件中的setState方法不同，useState不会自动合并更新对象： 比如，在class组件中： 123456789101112class Test extends React.Component &#123; state = &#123; a: 1, b: 2, &#125;; render() &#123; console.log(this.state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; a: 100 &#125;)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 点击按钮，setState会自动将对象合并，打印结果是： 1&#123;a: 100, b: 2&#125; 而在使用Hooks的组件中中： 123456789function Test() &#123; const [state, setState] = useState(&#123; a: 1, b: 2 &#125;); console.log(state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setState(&#123; a: 100 &#125;)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125; useState在更新时不会将对象合并，所以打印的结果是： 1&#123;a: 100&#125; 所以需要手动进行合并，采取函数式赋值的方式： 1setState(prevState =&gt; (&#123; ...prevState, a: 100 &#125;)) 这样才能保证更新后的对象是我们想要的对象。 延迟初始化useState的参数initialState是首次渲染期间使用的状态，在后续的更新渲染过程中，它会被忽略，因为state会采用上一次更新后最新的值，但是如果这个初始状态仍然会被计算一次： 1234567891011121314function initialize() &#123; console.log(&apos;initialize&apos;); return 1;&#125;function Test() &#123; const [state, setState] = useState(&#123; a: initialize(), b: 2 &#125;); console.log(state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setState(prevState =&gt; (&#123; ...prevState, a: 100 &#125;))&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125; 在首次渲染时initialize会被调用，当点击按钮组件更新时，initialize仍然会被调用，但是结果却被遗弃了。如果这个状态是一个高开销的计算结果，可以改为提供函数，这个函数仅在初始渲染时执行，可以避免性能浪费： 1const [state, setState] = useState(() =&gt; (&#123; a: initialize(), b: 2 &#125;)); 将useState的参数改为函数，在后续渲染时，初始状态计算就会被跳过了。 useEffect1useEffect(didUpdate); 接受一个函数，默认在每次渲染后执行。 清理effect如果在effect中创建的一些事件需要在组件卸载时清理，比如定时器或者事件订阅等，可以为effect的更新函数返回一个新的函数，这个函数可以作为清理函数，在每次渲染时组件删除前执行，防止内存泄漏。 1234567useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // Clean up the subscription subscription.unsubscribe(); &#125;;&#125;); 如果组件渲染多次，在执行下一个effect之前都会先执行清理函数。 useEffect的执行时机useEffect中的更新函数会延迟到layout和paint后触发，也就是说在浏览器更新屏幕之后才会触发，因为它所针对的事件是订阅等事件处理程序不应该组织UI界面的更新。 但是有一些事件不能推迟，比如用户可见的DOM改变必须在下一次绘制之前同步触发，避免用户感觉到操作与视觉的不一致性。对于这个类型的事件需要在useLayoutEffect中触发，它与useEffect的不同就是在触发时机上的不同。 虽然useEffect延迟到浏览器绘制完成之后执行，但是它保证在任何新渲染之前触发。 避免重复渲染useEffect默认的表现是在每次渲染后触发，当组件的任何一个状态发生改变时，更新函数都会执行： 12345678910111213141516export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); useEffect(() =&gt; &#123; console.log(count2); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count1&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count1 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 每更新count1的值时，useEffect都会执行，如果我们只希望打印count2的useEffect只在count2更新时执行，可以给useEffect传递第二个参数，它是更新时所依赖的值组成的数组 123useEffect(() =&gt; &#123; console.log(count2);&#125;, [count2]); 这样，这个更新函数只有在count2发生改变时才会执行。 如果传入一个空数组[]那就意味着告诉React这个更新函数不依赖于组件中的任何值，仅仅在首次渲染时执行，在组件销毁时执行清理，从不在更新时运行。 这个数组并不会作为参数传递给更新函数内部，但是从概念将，更新函数中引用的每个值都应该出现在输入数组中，这样才能避免更新函数依赖的某个值发生了变化，而函数没有重新执行。ESLint的插件会自动检测并插入这个数组，推荐使用。 useEffect中获取本次渲染更新后的值==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，牢记这一点很重要，例如： 12345678910111213141516171819202122export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); // useEffect1 useEffect(() =&gt; &#123; setCount1(100); console.log(count1, &apos;useEffect1&apos;); &#125;, [count1, count2]); // useEffect2 useEffect(() =&gt; &#123; console.log(count1, &apos;useEffect2&apos;); &#125;); return ( &lt;div&gt; &lt;p&gt;&#123;count1&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount2(count1 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 分析一下这个组件的执行结果： （1）首次渲染，useEffect1执行，setCount1(100)，这个时候打印的结果是多少？ （2）继续向下，useEffect2执行，打印的结果是多少？ （3）此时屏幕上显示的多少？ （4）是否会继续执行？ 再重复一遍，在==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，==即便执行了setState之后仍是这样==，所以： （1）首次渲染，useEffect1执行，setCount1(100)，这时count1的值仍然是初始值0，所以这个时候打印的结果是0 &quot;useEffect1&quot; （2）继续向下，useEffect2执行，同样获取的count1的值仍然是当次渲染的初始值，所以打印的结果是0 &quot;useEffect2&quot; （3）此时屏幕上显示的结果，在return时获取的count1的值才是经过了useEffect中更新后的值，所以屏幕上显示0 （4）由于在这轮渲染中，count1的值由0变为了100，而useEffect1依赖了count1的值，useEffect2默认每次更新后执行，所以会仍然执行。所以在下一轮次的渲染时会打印出100 &quot;useEffect1&quot;和100 &quot;useEffect2&quot;，屏幕上显示100。 所以完整的打印结果是： 12340 "useEffect1"0 "useEffect2"100 "useEffect1"100 "useEffect2" 实际上可以认为每次渲染时通过useState声明的状态是不可变的（Immutable），每次渲染都会对它拍一个快照保存下来，当状态更而重新渲染时就会形成N个状态。不光是state和props通过快照的形式保存，组件的事件处理和useEffect都是同样的形式，例如： 123456789101112131415161718192021export default function () &#123; const [count, setCount] = useState(1); const log = () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(count); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; log(); setCount(100); &#125;&#125;&gt; Set future count &lt;/button&gt; &lt;/div&gt; );&#125; 最终代码打印的结果是1，而不是100，屏幕上显示的100，这是因为在首次渲染时，log方法被执行，执行延时函数，这时候的count快照值是1，继续执行setCount(100)导致重新渲染，这一次渲染时count变为了100，显示在屏幕，3s后打印的count是首次渲染时保存的快照，所以结果是1 我犯过的一个错误就是，在useEffect1中通过setState更新了count1的值，而在useEffect2中要使用更新后的count1的值，这就会导致错误，因为在任何一个useEffect中拿到的count1的值是当次更新的count1的初始值，而不会是在useEffect1中更新后的值。 如何解决这个问题呢？我觉得有两个方法，一个是更好的组织useEffect，一个useEffect中不要完成过多的功能呢，更不要成为一个中间过程，为最终渲染的结果提供中间数据，而是让每个useEffect都提供渲染需要的最终数据。 如果确实有这种需要，那么就需要使用React提供了另外一种内置Hook了，useRef。 注意，在渲染结果中拿到的都是更新后的最新的props和state，如果在渲染结果中出现了旧的props和state，那么很可能是遗漏了一些依赖，导致对应的useEffect没有按照预期执行。还是推荐使用前面提到的ESLint的插件来帮助我们发现和解决问题。 useRef1const refContainer = useRef(initialValue); useRef返回一个可变的对象，其current属性被初始化为传递的参数，返回的这个对象就保留在组件的生命周期中。 useRef返回的ref对象在所有Render过程中保持着唯一引用，如果认为state是不可变的数据，那么ref对象就可以认为是可变对象，对ref.current的赋值和取值，拿到的额都是一个状态： 1234567891011121314151617181920export default function () &#123; const count = useRef(1); // useEffect1 useEffect(() =&gt; &#123; // 赋值 count.current = 100; console.log(count, &apos;useEffect1&apos;); &#125;); // useEffect2 useEffect(() =&gt; &#123; // 赋值 count.current = 200; console.log(count, &apos;useEffect2&apos;); &#125;); return ( &lt;div /&gt; );&#125; 使用useRef就可以再当次渲染获取到改变后的值，所以打印结果是： 12&#123;current: 100&#125; "useEffect1"&#123;current: 200&#125; "useEffect2" 要注意，避免在渲染过重中（return中）设置直接饮用，可能会导致预料之外的结果，相反，应该只在事件处理程序和useEffect中修改、使用引用。 其他内置的Hook目前还没用到，简单看下： useContext1const context = useContext(Context); 用来创建context对象，当使用Context API来传递数据时有用。 useReducer1const [state, dispatch] = useReducer(reducer, initialState，initialAction); useState的替代方案，接受类型为(state, action) =&gt; newState的Reducer，返回与dispatch方法匹配的当前状态。initialAction是可选的，提供初始的action 12345678910111213141516171819202122232425262728293031323334import React, &#123; useReducer &#125; from &apos;react&apos;;const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; const &#123; type &#125; = action; switch (type) &#123; case &apos;reset&apos;: &#123; return initialState; &#125; case &apos;increment&apos;: &#123; return &#123; count: state.count + 1 &#125;; &#125; case &apos;decrement&apos;: &#123; return &#123; count: state.count - 1 &#125;; &#125; default: &#123; return state; &#125; &#125;&#125;export default function () &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; &lt;p&gt;&#123;state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;reset&apos; &#125;)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;increment&apos; &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;decrement&apos; &#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125; 这个时候的state有reducer得来，更新方法dispatch是匹配reducer的dispatch({type: &#39;type&#39;})更新方法。 用它配合useContext可以避免在多层组件中深度传递回调的需要。 useCallback123456const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 主要的目的是，如果一个函数依赖了组件的state，并且由于复用的原因，不能放在useEffect中，就将这个函数用useCallback包装，返回的变量可以作为对应的useEffect的依赖，当其依赖发生变化时，返回新的函数引用，同时触发对应的useEffect重新执行。 我理解使用的原因主要出于性能优化和便于维护，例如： 1234567891011121314151617181920export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(100); function fetch() &#123; console.log(&apos;fetch&apos;); return count1 + 1000; &#125; useEffect(() =&gt; &#123; console.log(fetch()); &#125;); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 其中的useEffect无法添加fetch作为依赖，因为它是一个普通的函数，而且每次渲染fetch都会生成一个快照，如果使用了useCallback： 1234567891011121314151617181920export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(100); const fetch = useCallback(() =&gt; &#123; console.log(&apos;fetch&apos;); return count1 + 1000; &#125;, [count1]); useEffect(() =&gt; &#123; console.log(fetch()); &#125;, [fetch, count1, count2]); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 使用了useCallback之后，依赖更清晰，并且在count1未发生变化时不会生成新的快照，有助于性能的提高。 useMemo1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 与useCallback类似，返回的是一个不生成快照的对象，而非函数。 useMemo只会在其中一个输入发生更改时重新计算，此优化有助于避免在每个渲染上进行高开销的计算。 useLayoutEffect前面介绍过，与useEffect的不同点仅仅在于执行时机不同，useLayoutEffect在绘制前同步触发，useEffect会推迟到绘制后触发 参考 Hooks API Reference@React Hooks API 参考@React中文文档 精读《useEffect 完全指南》@掘进 useEffect 完整指南@overreacted https://reactjs.org/docs/hooks-overview.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git03 Git分支管理策略]]></title>
    <url>%2F2019%2F03%2F21%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F12%20Git%2FGit03%20Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[Git分支管理策略学习笔记。 1 创建与合并分支在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 123456$ git checkout -b dev# 创建dev分支，然后切换到dev分支# git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：# $ git branch dev# $ git checkout dev 用git branch命令查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。 123$ git branch* dev master 从现在开始，对工作区的修改和提交就是针对dev分支了，对readme.txt做个修改，新提交一次后，dev指针往前移动一步，而master指针不变： 123456$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： 12$ git checkout masterSwitched to branch 'master' 切换回master分支后，再查看readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： 123456$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward。 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支 12$ git branch -d devDeleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： 12$ git branch* master 2 解决冲突对master分支和feature1分支下面的README.md同时进行修改后add并且commit，返回master分支。 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 12345$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 对冲突的文件进行手动修改后，再次提交 123$ git add readme.txt $ git commit -m "conflict fixed"[master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test 最后删除feature1分支 12$ git branch -d feature1Deleted branch feature1 (was 75a857c). 3 git merge的--no-ff方式通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的git merge： 创建分支dev并进行修改add、commit后，准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 12345$ git merge --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed 在实际开发中，应当注意，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 4 git stashGit还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 123456$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits.$ git checkout -b issue-101Switched to a new branch 'issue-101' 现在修复bug，然后提交： 12345$ git add readme.txt $ git commit -m "fix bug 101"[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 12345678910$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 2 commits.$ git merge --no-ff -m "merged bug fix 101" issue-101Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 现在，是时候接着回到dev分支干活了！ 123456$ git checkout devSwitched to branch 'dev'$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 用git stash pop，恢复的同时把stash内容也删了： 123456789101112131415$ git stash popOn branch devChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: hello.pyChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtDropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用·git stash list·查看，就看不到任何stash内容了： 1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; 5 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 6 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 当从远程库clone时，默认情况下，只能看到本地的master分支。不信可以用git branch命令看看：、 12$ git branchmaster 现在要在dev分支上开发，就必须创建远程origin的dev分支到本地，用这个命令创建本地dev分支，本地和远程分支的名称最好一致： 1git checkout -b dev origin/dev 现在他就可以在dev上继续修改，然后，时不时地把dev分支push到远程 1git push origin branch-name 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并 1$ git pull 如果git pull提示“no tracking information”，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 1$ git branch --set-upstream branch-name origin/branch-name 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 7 分支管理7.1 主分支Master首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。 Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。 7.2 开发分支Develop主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。 Git创建Develop分支的命令 1git checkout -b develop master 将Develop分支发布到Master分支的命令 12git checkout mastergit merge --no-ff develop 上一条命令的--no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。 7.3 临时性分支前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： 功能（feature）分支 预发布（release）分支 修补bug（fixbug）分支 这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 7.4 功能分支接下来，一个个来看这三种”临时性分支”。 第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支： 1git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支： 12git checkout developgit merge --no-ff feature-x 删除feature分支： 1git branch -d feature-x 7.5 预发布分支预发布分支是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支： 1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支： 12345git checkout mastergit merge --no-ff release-1.2# 对合并生成的新节点，做一个标签git tag -a 1.2 开发完成后，合并到develop分支： 12git checkout developgit merge --no-ff release-1.2 删除预发布分支： 1git branch -d release-1.2 7.6 修补bug分支最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支： 1git checkout -b fixbug-0.1 master 修补结束后，合并到master分支： 123git checkout mastergit merge --no-ff fixbug-0.1git tag -a 0.1.1 再合并到develop分支： 12git checkout developgit merge --no-ff fixbug-0.1 最后，删除”修补bug分支”： 1git branch -d fixbug-0.1 参考 Git分支管理策略@阮一峰的网络日志 创建与合并分支@廖雪峰的官方网站 解决冲突@廖雪峰的官方网站 分支管理策略@廖雪峰的官方网站]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux03 React-Redux]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux03%20React-Redux%2F</url>
    <content type="text"><![CDATA[Redux一个为JavaScript应用而生的可预测的状态容器，可以有很多方式使用它，而React应用只是其中一种，所以它的API是高度抽象的，并非只针对React的。 为了使用方便，Redux的作者封装了一个React的专用的库React-Redux，这个库时可选的，是否选用应该权衡一下，因为React-Redux虽然提供了便利，但是需要掌握额外的API，并且要遵守它的组件拆分规范。 同步和异步流程先来复习一下Redux的基本流程： 12345671. 用户发出Action2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 在第1、2步之间有一个问题，之前考虑的情况都是在Action发出之后，Reducer立刻计算出State，这是一个同步的过程。如果在Action发出之后，过一段时间再执行Reducer，这是异步过程： 1234567891. 用户发出Action1.5 异步操作（等待一段时间）2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 现在我们希望的是在异步操作结束后，自动执行Reducer，这就要用到中间件（middleware） 中间件的概念什么是中间件？中间件（middleware）是一种很常见、也很强大的模式，被广泛应用在Express、Koa、Redux等类库和框架当中。 简单来说，中间件就是在调用目标函数之前，可以随意插入其他函数预先对数据进行处理、过滤，在这个过程里面你可以打印数据、或者停止往下执行中间件等。数据就像水流一样经过中间件的层层的处理、过滤，最终到达目标函数。 1234// 中间件可以把 A 发送数据到 B 的形式从// A -----&gt; B// 变成:// A ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; middleware 3 --&gt; ... ---&gt; B 具体到Redux来看，如果要实现中间件，最合适环节就是在发送Action的环节，即使用中间件包裹store.dispatch来添加功能，比如要增加打印功能，将Action和State打印出来，我们就可以编写这样一个中间件： 1234567const next = store.dispatch;store.dispatch = function (action) &#123; console.log('action: ', action); next(action); console.log('next state: ', store.getState())&#125;; 中间件对store.dispatch进行了改造，在发出Action和执行Reducer之间添加了其他功能。但是实际上中间件的写法不是这样的。 在Redux中，中间件是纯函数，有明确的使用方法，并且要严格的遵循以下格式： 1234567var anyMiddleware = function (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; // 你的中间件业务相关代码 &#125; &#125;&#125; 中间件由三个嵌套的函数构成（会依次调用）： （1）第一层向其余两层提供分发函数dispatch和getState函数 （2）第二层提供next函数，它允许你显示的将处理过的输入传递给下一个中间件或Redux（这样Redux才能调用所有reducer）。实际上next作为参数，就是通过componse传入的下一个要执行的函数，通过next(action)就将action传递给了下一中间件 （3）第三层提供从上一个中间件或者从dispatch传递过来的Action，这个Action可以调用下一个中间件（让Action继续流动）或者以想要的方式处理action 所以一个Log的中间件应该这样写： 12345678function logMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('logMiddleware action received:', action) return next(action) &#125; &#125;&#125; next(action)就是继续传递Action，如果不进行这一步，所有的Action都会被丢弃。 中间件的用法常用的中间件都有现成的，不用我们自行编写，只需要直接引用别人写好的模块即可，比如上面的打印日志的中间件，就可以使用现成的redux-logger模块： 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 使用的时候首先通过redux-logger提供的生成方法createLogger创建一个中间件实例logger，然后将它放在Redux提供的applyMiddleware方法中，放到createStore方法中（由于createStore方法可以接受应用的初始状态作为第二个参数，这个时候applyMiddleware方法就是第三个参数了） 有的中间件有次序要求，必须放在何时的位置才能正确输出，使用之前要查看文档。 applyMiddleware()applyMiddleware()是Redux的原生方法，会将所有中间件组成一个数组，依次执行，下面是它的源码： 12345678910111213141516export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; applyMiddleware可以接受多个中间件作为参数，全部放进了数组chain中，每个中间件接受Store的dispatch和getState函数作为命名参数，返回一个函数。该函数会被传入称为next的下一个中间件的dispatch方法，并返回一个接受Action的新函数，这个函数可以直接调用next(action)。这个过程是通过compose方法完成的。 多个中间件形成了一个调用链，调用链中的最后一个中间件会接受真实Store的dispatch作为next参数，并借此结束调用链。 12// 中间件函数的函数签名(&#123; getState, dispatch &#125;) =&gt; next =&gt; action compose()compose(...functions)的功能是从右到左来组合多个函数，这是函数式编程的方法，其中每个函数的返回值作为参数提供给左边的函数： 123compose(funcA, funcB, funcC); // 同等于funcA(funcB(funcC())) 关于compose方法，以前做过一道练习题《前端练习17 函数式编程的compose函数》，手写简易的compose方法。 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 异步操作的基本思路处理异步操作需要使用中间件。 同步操作只要发出一种Action即可，异步操作的差别是要发出三种Action 123- 操作发起时的Action- 操作成功时的Action- 操作失败时的Action 以向服务器取出数据为例，三种Action有两种不同的写法： 123456789// 写法一，名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', respose: &#123;&#125; &#125;// 写法二， 名称不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', respose: &#123;&#125; &#125; 除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态，例如： 123456const state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125; State中的属性isFetching表示是否正在抓取数据，didInvalidate表示是否正过期，lastUpdated表示上一次更新事件。 现在整个异步操作的思路就很清晰了： 121. 操作开始，发出一个Action，触发State更新为“正在操作”状态，View重新渲染2. 操作结束，再次发出一个Action，触发State更新为“操作结束”状态，View再次重新渲染 redux-thunk中间件异步操作至少要发出两个Action，用户操作触发第一个Action，这个和同步操作一样，标识着异步操作的开始，现在要做的是在异步操作结束时，自动发送第二个Action 奥妙就在Action Creator中，需要对其进行改造。我们有一个组件，点击按钮后会发出一个Ajax请求，将返回的结果填充在视图中，按钮的点击事件如下： 123456789101112131415161718192021sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = (answer) =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer &#125;); // Action Creator3 const actionCreator = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); return Request.demo2.getAnswer(&#123; question &#125;) .then(res =&gt; dispatch(receivePost(res))) &#125;; store.dispatch(actionCreator())&#125; 其中最关键的就是actionCreator，它的返回值是一个函数，这个函数执行时，会先发出一个ActionrequestPost（由Action Creator生成）并进行其他同步操作，然后进行异步操作Request.demo2.getAnswer({ question })，在异步操作的回调函数中发出第二个ActionactionCreator（由Action Creator2生成）。 上面的代码中，有几点要注意： （1）完成异步操作的Action CreatoractionCreator返回的是一个函数，普通的Action Creator返回的是Action对象 （2）返回的这个函数参数是dispatch和getState这两个Redux方法，普通的Action Creator参数是Action的内容。 （3）在返回的函数中，先发出的Actiondispatch(requestPost(question))表示操作开始 （4）异步操作结束后，在发出的Actiondispatch(receivePost(res))表示操作结束 第二点中，返回函数的两个Redux方法是执行时由函数的执行者传进去的，函数的执行者是谁呢？就是中间件redux-thunk 为什么要使用redux-thunk？因为Action是由store.dispatch发出的，这个方法接受的参数是一个对象，而我们的Action Creator返回的是一个函数，使用redux-thunk对store.dispatch进行改造，改造后在执行Action Creator返回的函数时就传入了dispatch和getState两个参数 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用thunk中间件，使dispatch可以接受函数作为参数（默认只能接受Action对象作为参数）import thunk from 'redux-thunk';// 创建Storeconst store = createStore(reducer, applyMiddleware(thunk));export default store; 因此，异步操作的第一种解决方案就是，==编写一个返回函数的Action Creator，然后使用redux-thunk中间件改造store.dispatch== redux-promise中间件在上面的Action Creator返回了一个函数，也可以返回其他值，另一种异步操作的解决方案，就是让Action Creator返回一个Promise对象 这需要使用redux-promise中间件 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用redux-promise中间件，使dispatch可以接受Promise作为参数import promiseMiddleware from 'redux-promise'// 创建Storeconst store = createStore(reducer, applyMiddleware(promiseMiddleware));export default store; 来看一下它的源码： 12345678910111213141516171819202122import isPromise from 'is-promise';import &#123; isFSA &#125; from 'flux-standard-action';export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 如果Action本身是一个Promise，它resolve后的值是一个Action对象，会被dispatch方法送出，reject后不会有任何动作，如果Action本身不是一个Promise对象，而Action对象的payload属性是一个Promise对象，那么无论其resolve或reject，dispatch都会发出Action 所以有两种写法，一种是让Action本身返回一个Promise对象： 12345678910111213141516171819202122sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = async () =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer: await Request.demo2.getAnswer(&#123; question &#125;) &#125;); store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); store.dispatch(receivePost());&#125; 更常见的是第二种写法，一般会配合redux-action中间件使用。 redux-action中createAction的用法： 12345678const a = createAction('test1', () =&gt; 10);a(); // &#123;type: "test1", payload: 10&#125;const b = createAction('test2');b(100); // &#123;type: "test2", payload: 100&#125; 使用redux-action将上面的写法改为： 1234567891011121314151617181920212223// 使用redux-promise中间件解决异步操作第二种写法sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123;type: 'SEND_QUESTION', status: 'sending...', question&#125;); // 发出同步Action store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); // 发出异步Action store.dispatch( createAction('RECEIVE_ANSWER')( // Promise的then函数返回值才是createAction的第二个参数 Request.demo2.getAnswer(&#123;question&#125;).then(v =&gt; (&#123; status: '', answer: v &#125;) ) ) );&#125; 注意，createAction的第二个参数实际上就是向要发送的Action的payload属性值，这里必须是一个Promise对象。（在reducer里面也必须从action.payload属性中获取对应的值） 明显，使用redux-promise的代码量更小一些，但是也因此失去了一定的灵活度，它的同步Action是脱离在异步操作之外单独存在的（即无法在一个Action Creator完成多个dispatch动作） 其他的比较热门的解决方案还有redux-promise-middleware（感觉像是前两者的一个集合）、redux-action-tools、redux-saga，可以学习这篇文章的讲解。 总结学习Redux的异步操作和中间件之后，最大的体会就是太繁琐了，各种解决方案太多了。如果是复杂的项目中，有着复杂的业务逻辑，使用Redux会是一个很麻烦的事情。 以前在做一个React项目时，项目组选型使用的Mobx，当时没觉得有好用（当然也有用的比较浅的原因），但是仅仅是学习Redux，就发现Mobx或者是Vuex真的比Redux好上手太多了，Redux的函数式编程的思想带来的难度不仅是阅读、学习的难度，更是过多的范式代码带来的苦恼。 我认为会经久流传的解决方案一定会在可阅读性、可维护性以及入手难度上取得一个比较好的平衡，除非它是为了解决一些别人无法解决的问题而提出的，是一个时间段内近乎唯一的解决方案，但我感觉Redux好像并不是这样。 参考 Redux 入门教程（二）：中间件与异步操作 compose@Redux中文文档 applyMiddleware@Redux中文文档 redux-tutorial-cn@github Redux异步方案选型@segmentfault]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习05 生成树形结构的方法]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F02%20%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A005%20%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由数组生成树形结构的方法。 问题接受了一个简单小任务，从后端获取一系列数据，以数组的形式存在，每一项都有着id和parentId，根据这两个属性，将这写数组重新组织成为一个树状菜单结构，传递给UI组件 这个问题有一点难度的事，后端传递的数据不是组织好的，是没有顺序的，就是说，有可能子项先出现，而父项后出现 1234567891011121314151617181920212223242526272829let originId = [ id: 2, name: 'b', parentId: 0&#125;, &#123; id: 4, name: 'a-2', parent_id: 1&#125;, &#123; id: 5, name: 'b-1', parentId: 2&#125;, &#123; id: 6, name: 'b-2', parentId: 2&#125;, &#123; id: 3, name: 'a-1', parentId: 1&#125;, &#123; id: 1, name: 'a', parentId: 0&#125;, &#123; id: 7, name: 'a-1-1', parentId: 3&#125;, ]; 所以在处理的时候，需要递归处理 递归实际上，直接用递归是可以实现的，但是我也是在网找了一阵子才发现这种方法，因为一来自己的算法实在是弱，也是因为着急的时候反而脑子更加不好用 1234567891011121314151617//递归方法 生成 json tree 数据const getJsonTree = function(data, parentIds) &#123; var itemArr = []; for (var i = 0; i &lt; data.length; i++) &#123; var node = data[i]; if (parentIds.includes(node.parentId)) &#123; var newNode = &#123;&#125;; newNode.id = node.id; newNode.name = node.name; newNode.children = getJsonTree(data, [node.id]); itemArr.push(newNode); &#125; &#125; return itemArr;&#125;;console.log(getJsonTree(originData, ['0', 'non'])) 这种方法能够实现，但是没有任何优化，对originData反复遍历查找，如果数据量很大的时候，恐怕性能上会出问题 利用JavaScript的引用类型这个纯属是学习了，首先对所有数据进行分组，也就是简历索引，将同一个parentId的数据都放到一个对象的同一个属性名对应的属性值中，也就是说生成这样的结构： 12345678const groupData = &#123; // parentId为'0'的数据都在这里 // 换句话说，id为'0'的所有子数据都在这里 '0': &#123; [1], [2] &#125;&#125; 这个还是比较好实现的，一个reduce搞定: 1234const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; return total;&#125;, &#123;&#125;); 现在，通过groupedData这个对象可以找到某个id对应的所有子数据，那么我就可以认为，对原始数据originData进行遍历，给数据增加一个chilren属性，把对应的groupedData的索引复制到这个children属性 我的脑子还是不太够用，说白了就是蠢，感觉绕在里面出不来，想了好一阵子才理清楚： 123456789101112131415161718const getJsonTree2 = function (data, id) &#123; // 按照parentId对所有数据分组 const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; return total; &#125;, &#123;&#125;); // 遍历原始数据， data.forEach(v =&gt; &#123; // 如果当前项的id存在于groupedData中，说明当前项就是groupedData对应的属性中所有元素的父元素 // 如果当前项的id不存在于groupedData中，说明当前项不是任何元素的父元素，就是个纯纯的子元素 // ID是不会重复的 if (groupedData[v.id]) &#123; v.children = groupedData[v.id] &#125; &#125;); return groupedData[id]&#125;; 最后取出的数据是从groupedData取出顶级元素，传入顶级元素的ID即可，因为这个需求比较特殊，顶级元素有两种ID，&#39;0&#39;或者&#39;non&#39;，所以需要额外处理一下： 123456return ids.reduce((total, current) =&gt; &#123; if (groupedData[current]) &#123; total = total.concat(groupedData[current]); &#125; return total;&#125;, []); 因为这个利用了JS的引用类型，所以不能采用下面的这种形式来改变最终的元素包含的属性： 123current = &#123; id: node.id&#125; 因为这会导致引用关系的丢失，所以如果需要改变最终树状元素的包含的属性有两种方法，一种是在分组获取groupedData时，采用下面这种形式直接修改元素属性： 123456789101112131415161718const dealObj = obj =&gt; &#123; obj.label = obj.chinese; delete obj.name; delete obj.chinese; delete obj.creator; delete obj.parentId; delete obj.status; delete obj.createTime; delete obj.updateTime;&#125;;// 按照parentId对所有数据分组const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; // 处理元素包含的属性 dealObj(current); return total;&#125;, &#123;&#125;); 也可以在生成最终数据后统一处理，但是这样会增加时间复杂度： 1234567891011// 处理最终的数据const dealRes = res =&gt; &#123; res.forEach(v =&gt; &#123; dealObj(v); if(v.children &amp;&amp; v.children.length) &#123; dealRes(v.children) &#125; &#125;)&#125;;dealRes(result); 参考 JavaScript递归方法 生成 json tree 树形结构数据@腾讯云 更优更简洁的生成树和操作树算法@知乎 怎样效率高的生成树形结构的数据？@segmentfault]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习06 从数组中取出n个元素的所有组合]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F02%20%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A006%20%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E5%87%BAn%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[用递归实现从数组中取出n个元素的所有组合。 题目给定一个数组arr，从中选出n个元素，要求给出所有组合的情况（结果在一个数组中） 例子： 123456const arr = ['1', '2', '3'];const n = 2;const result = getCombine(arr, b);console.log(result);// ['12', '13', '23' ] 分析实际上就是一个求排列组合的问题。对上面的例子进行分析 （1）首先arr是[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],n是2，先取出数组中第一项1，然后需要从剩下的两个元素中取一个 （2）此时可以将arr看做[ &#39;2&#39;, &#39;3&#39;],n是1，在从中任取一项就行了 （3）此时结果为[&#39;12&#39;, &#39;13&#39;] （4）返回第一步，取出数组中第一项1改为取第二项2，然后从剩下的元素中取 （5）重复进行上面的步骤 很明显，分析后发现这是一个递归的过程，不过要注意的是需要控制取出第一个元素的序列，防止12和21作为两种情况出现。控制方法有两种，或者传入一个start作为开始的索引值，或者用slice来剪切数组，将数组已经取过的元素剪切掉 代码忽略了n大于数组长度的情况的处理。 123456789101112131415161718192021222324/** * 从数组中取出n个元素的所有排列组合 * @param arr 待处理数组 * @param n 要取出的元素个数 * @param result 返回的结果 * @param current 当前已经取出的元素 * @returns &#123;Array&#125; 返回数组，数组元素是各种排列组合的情况 */const getCombine = (arr, n, result = [], current = '') =&gt; &#123; // 如果只要取出一个元素，那么只需要将数组元素与已取出的元素一一组合即可 if (n === 1) &#123; result.push(...arr.map(v =&gt; `$&#123;current&#125;$&#123;v&#125;`)) ; return result; &#125; // 对当前数组进行遍历，剩余元素个数i等于要取出的元素个数时停止遍历 for (let i = 0; i &lt; arr.length - n + 1; i++) &#123; // 取出当前的元素与已取出的元素组合 const temp = `$&#123;current&#125;$&#123;arr[i]&#125;`; // 递归调用，数组剪切（相当于开始的索引前进），取出的个数减一 getCombine(arr.slice(i + 1), n - 1, result, temp); &#125; return result;&#125;; 参考 从数组中取出n个元素的所有组合（递归实现）@NULL]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高18 更换打包文件路径]]></title>
    <url>%2F2019%2F03%2F17%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F02%20Vue%E6%8F%90%E9%AB%98%2FVue%E6%8F%90%E9%AB%9818%20%E6%9B%B4%E6%8D%A2%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一个由更改Vue打包后路径引发的一系列问题。 引入字体文件在Vue中，想要引入字体文件，需要，使用@font-face来引入本地的字体 12345h1 &#123; background: url('./assets/images/logo.png');&#125; 然后再App.vue中引入并使用 1234567891011&lt;style&gt; @font-face &#123; font-family: 'hello'; src: url('./assets/font/d.ttf'); font-weight: bold; font-style: italic; &#125; .hello-inner h1 &#123; font-family: hello; &#125;&lt;/style&gt; 这样就可以使用引入的字体了。 也可以单独建立一个CSS文件来统一管理引入的字体，然后通过import引入 123456&lt;style&gt; @import 'font.css'; .hello-inner h1 &#123; font-family: hello; &#125;&lt;/style&gt; url-loaderWebpack中的loader的目的是用来处理各种非JS之外的文件，可以使你在import或”加载”模块时预处理文件。 执行的顺序是从右至左，在Vue-cli2中，在webpack.base.conf.js中定义了一些基本的loader： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module: &#123; rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.pug$/, loader: 'pug', &#125;, &#123; test: /\.less$/, loader: "style-loader!css-loader!less-loader", &#125;, ]&#125;, 比较重要的是url-loader这个插件。我们在处理引入的各种资源文件时，Webpack最终会将各个模块打包成一个文件，因此我们样式中的URL路径是相对入口HTML页面的，而不是相对于原始CSS文件所在的路径的。这就会导致图片引入失败。这个问题可以使用file-loader解决。 url-loader中封装了file-loader，它不依赖于file-loader，它除了可以完成file-loader的作用，还可以将符合要求的图片进行编码生成DataURL，减少HTTP请求数目。url-loader选项中提供了limit参数，小于这个参数的文件才会转换为DataURL 路径明确一下关于路径的表示， 123./ 表示当前目录，相对地址../ 表示上层目录，绝对地址/ 表示根目录，绝对地址 __dirname表示当前文件在系统中的绝对路径，比如我在D:\projects\vue-cli-learning文件夹下新建了一个test.js文件： 1console.log(__dirname) 在Node环境下运行这个文件输出结果就是： 1D:\projects\vue-cli-learning path.resolve的目的是用来将相对路径转为绝对路径，接受多册参数，一次表示要进入的路径，直到最后一个参数为止。除了根目录，该方法的返回值都不带尾部的斜杠 12// 实例path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') 上面代码的实例，执行效果类似下面的命令。 12345$ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd 比如，在刚才的test.js中打印： 123const path = require('path');console.log(path.resolve(__dirname, 'a'));console.log(path.resolve(__dirname, '../a')); 输出的结果就是两个路径： 12D:\projects\vue-cli-learning\aD:\projects\a 打包路径的配置在处理字体文件的url-loader的配置选项中： 1name: utils.assetsPath('fonts/[name].[hash:7].[ext]') 规定了Webpack打包后生成的资源名称和路径，其中，utils.assetsPath规定了跨系统平台输出文件路径，并且和环境变量相关： 1234567exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125; 在生产环境下的config.build.assetsSubDirectory配置实在/config/index.js中： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ... 其他&#125; 其中， index是生成的index.html在本机的地址，现在的配置下，生成的index文件会位于D:\projects\vue-cli-learning\dist\中（由path.resolve转换而来） assetsRoot指明了构建后的资源的路径，Webpack会将所有打包后的资源（包括index.html在内都放到这个文件夹下 assetsSubDirectory是打包后的资源目录，除了index.html之外的所有模块都会放到这个文件夹中，当前配置后，所有的资源文件都会打包在D:\projects\vue-cli-learning\dist\static中 assetsPublicPath是static资源文件夹相对于HTTP服务器运行时的路径，比如我利用http模块构建了一个简单的静态服务器： 1npx http-server -a 127.0.0.1 -p 7070 这个时候服务器运行的URL是localhost:7070/ 当前目录的情况是这样： 如果我在App.vue中引入的字体文件路径是./assets/font/d.ttf)，在打包之后首先由对应的url-loader处理，生成的字体文件将位于/dist/static/fonts中，打包后静态服务器请求的字体地址是：http://127.0.0.1:7070/static/fonts/d.d30126a.ttf 明白这些选项都是干什么的后，就可以更改了 （1）更改打包后的文件路径，更改index选项assetsRoot选项，比如更改为： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/test/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/test/'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ... 其他&#125; 这时候打包后文件将是这样的结构： （2）更改打包后静态资源所在目录（同时对资源的请求也会更改，因为打包后内联的URL地址也由url-loader一并改变了 更改为： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static/hello/', assetsPublicPath: '/', // ... 其他&#125; 此时打包生成的目录： 发出的获取字体的网络请求的URL为http://127.0.0.1:7070/static/hello/fonts/d.d30126a.ttf （3） 更改HTTP服务器获取静态资源的路径 这个一直把我搞混了，在默认的配置情况下是去网站的根目录下去寻找assetsSubDirectory中规定的资源目录，比如http://127.0.0.1:7070/static/fonts/d.d30126a.ttf 但是如果资源不是在根目录下呢，比如需要通过http://127.0.0.1:7070/ok/static/fonts/d.d30126a.ttf来请求字体时，就需要改动assetsPublicPath了，此时的配置： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static/', assetsPublicPath: '/ok/', // ... 其他&#125; 这个时候打包后的目录没有变化，但是请求字体的URL就变成了http://127.0.0.1:7070/ok/static/fonts/d.d30126a.ttf 如果要将assetsPublicPath改为./会发生什么呢？请求字体的URL发生了变化 这是因为./是相对地址，相对发出请求的文件所在的木而言的，这个请求是谁发出的呢？是打包后的CSS文件发出的 转换为绝对路径就是/static/css/，然后再这个目录下再去寻找资源目录，所以请求的URL是http://127.0.0.1:7070/static/css/static/fonts/d.d30126a.ttf，这肯定不是我们想要的 所以在更改assetsPublicPath时，尽量采用绝对地址，从服务器的根节点域名触发，定位资源文件，不容易发生错误。 总结回到初衷，本意只是简单的更改打包后的文件路径，想要打包在/dist/project中，只需要简单的更改index选项和assertsRoot即可 1234build: &#123; index: path.resolve(__dirname, '../dist/project/index.html'), assetsRoot: path.resolve(__dirname, '../dist/project/'),&#125; 这两项只会影响打包后在本地的路径，而assetsSubDirectory会影响请求和本地打包后路径，assetsPublicPath只会影响上线后发送请求的路径。 简单的一点改动，引出了一堆东西要学习。 参考 webpack学习笔记-2-file-loader和url-loader@CSDN Path模块@JavaScript标准参考教程 webpack再入门，说一下那些不入流的知识点@segmentfault webpack的3个路径配置项@博客园]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux02 异步操作和中间件]]></title>
    <url>%2F2019%2F03%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux02%20%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习Redux中间件的概念，以及使用Redux中间件完成异步操作的方法。 同步和异步流程先来复习一下Redux的基本流程： 12345671. 用户发出Action2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 在第1、2步之间有一个问题，之前考虑的情况都是在Action发出之后，Reducer立刻计算出State，这是一个同步的过程。如果在Action发出之后，过一段时间再执行Reducer，这是异步过程： 1234567891. 用户发出Action1.5 异步操作（等待一段时间）2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 现在我们希望的是在异步操作结束后，自动执行Reducer，这就要用到中间件（middleware） 中间件的概念什么是中间件？中间件（middleware）是一种很常见、也很强大的模式，被广泛应用在Express、Koa、Redux等类库和框架当中。 简单来说，中间件就是在调用目标函数之前，可以随意插入其他函数预先对数据进行处理、过滤，在这个过程里面你可以打印数据、或者停止往下执行中间件等。数据就像水流一样经过中间件的层层的处理、过滤，最终到达目标函数。 1234// 中间件可以把 A 发送数据到 B 的形式从// A -----&gt; B// 变成:// A ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; middleware 3 --&gt; ... ---&gt; B 具体到Redux来看，如果要实现中间件，最合适环节就是在发送Action的环节，即使用中间件包裹store.dispatch来添加功能，比如要增加打印功能，将Action和State打印出来，我们就可以编写这样一个中间件： 1234567const next = store.dispatch;store.dispatch = function (action) &#123; console.log('action: ', action); next(action); console.log('next state: ', store.getState())&#125;; 中间件对store.dispatch进行了改造，在发出Action和执行Reducer之间添加了其他功能。但是实际上中间件的写法不是这样的。 在Redux中，中间件是纯函数，有明确的使用方法，并且要严格的遵循以下格式： 1234567var anyMiddleware = function (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; // 你的中间件业务相关代码 &#125; &#125;&#125; 中间件由三个嵌套的函数构成（会依次调用）： （1）第一层向其余两层提供分发函数dispatch和getState函数 （2）第二层提供next函数，它允许你显示的将处理过的输入传递给下一个中间件或Redux（这样Redux才能调用所有reducer）。实际上next作为参数，就是通过componse传入的下一个要执行的函数，通过next(action)就将action传递给了下一中间件 （3）第三层提供从上一个中间件或者从dispatch传递过来的Action，这个Action可以调用下一个中间件（让Action继续流动）或者以想要的方式处理action 所以一个Log的中间件应该这样写： 12345678function logMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('logMiddleware action received:', action) return next(action) &#125; &#125;&#125; next(action)就是继续传递Action，如果不进行这一步，所有的Action都会被丢弃。 中间件的用法常用的中间件都有现成的，不用我们自行编写，只需要直接引用别人写好的模块即可，比如上面的打印日志的中间件，就可以使用现成的redux-logger模块： 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 使用的时候首先通过redux-logger提供的生成方法createLogger创建一个中间件实例logger，然后将它放在Redux提供的applyMiddleware方法中，放到createStore方法中（由于createStore方法可以接受应用的初始状态作为第二个参数，这个时候applyMiddleware方法就是第三个参数了） 有的中间件有次序要求，必须放在何时的位置才能正确输出，使用之前要查看文档。 applyMiddleware()applyMiddleware()是Redux的原生方法，会将所有中间件组成一个数组，依次执行，下面是它的源码： 12345678910111213141516export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; applyMiddleware可以接受多个中间件作为参数，全部放进了数组chain中，每个中间件接受Store的dispatch和getState函数作为命名参数，返回一个函数。该函数会被传入称为next的下一个中间件的dispatch方法，并返回一个接受Action的新函数，这个函数可以直接调用next(action)。这个过程是通过compose方法完成的。 多个中间件形成了一个调用链，调用链中的最后一个中间件会接受真实Store的dispatch作为next参数，并借此结束调用链。 12// 中间件函数的函数签名(&#123; getState, dispatch &#125;) =&gt; next =&gt; action compose()compose(...functions)的功能是从右到左来组合多个函数，这是函数式编程的方法，其中每个函数的返回值作为参数提供给左边的函数： 123compose(funcA, funcB, funcC); // 同等于funcA(funcB(funcC())) 关于compose方法，以前做过一道练习题《前端练习17 函数式编程的compose函数》，手写简易的compose方法。 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 异步操作的基本思路处理异步操作需要使用中间件。 同步操作只要发出一种Action即可，异步操作的差别是要发出三种Action 123- 操作发起时的Action- 操作成功时的Action- 操作失败时的Action 以向服务器取出数据为例，三种Action有两种不同的写法： 123456789// 写法一，名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', respose: &#123;&#125; &#125;// 写法二， 名称不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', respose: &#123;&#125; &#125; 除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态，例如： 123456const state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125; State中的属性isFetching表示是否正在抓取数据，didInvalidate表示是否正过期，lastUpdated表示上一次更新事件。 现在整个异步操作的思路就很清晰了： 121. 操作开始，发出一个Action，触发State更新为“正在操作”状态，View重新渲染2. 操作结束，再次发出一个Action，触发State更新为“操作结束”状态，View再次重新渲染 redux-thunk中间件异步操作至少要发出两个Action，用户操作触发第一个Action，这个和同步操作一样，标识着异步操作的开始，现在要做的是在异步操作结束时，自动发送第二个Action 奥妙就在Action Creator中，需要对其进行改造。我们有一个组件，点击按钮后会发出一个Ajax请求，将返回的结果填充在视图中，按钮的点击事件如下： 123456789101112131415161718192021sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = (answer) =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer &#125;); // Action Creator3 const actionCreator = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); return Request.demo2.getAnswer(&#123; question &#125;) .then(res =&gt; dispatch(receivePost(res))) &#125;; store.dispatch(actionCreator())&#125; 其中最关键的就是actionCreator，它的返回值是一个函数，这个函数执行时，会先发出一个ActionrequestPost（由Action Creator生成）并进行其他同步操作，然后进行异步操作Request.demo2.getAnswer({ question })，在异步操作的回调函数中发出第二个ActionactionCreator（由Action Creator2生成）。 上面的代码中，有几点要注意： （1）完成异步操作的Action CreatoractionCreator返回的是一个函数，普通的Action Creator返回的是Action对象 （2）返回的这个函数参数是dispatch和getState这两个Redux方法，普通的Action Creator参数是Action的内容。 （3）在返回的函数中，先发出的Actiondispatch(requestPost(question))表示操作开始 （4）异步操作结束后，在发出的Actiondispatch(receivePost(res))表示操作结束 第二点中，返回函数的两个Redux方法是执行时由函数的执行者传进去的，函数的执行者是谁呢？就是中间件redux-thunk 为什么要使用redux-thunk？因为Action是由store.dispatch发出的，这个方法接受的参数是一个对象，而我们的Action Creator返回的是一个函数，使用redux-thunk对store.dispatch进行改造，改造后在执行Action Creator返回的函数时就传入了dispatch和getState两个参数 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用thunk中间件，使dispatch可以接受函数作为参数（默认只能接受Action对象作为参数）import thunk from 'redux-thunk';// 创建Storeconst store = createStore(reducer, applyMiddleware(thunk));export default store; 因此，异步操作的第一种解决方案就是，==编写一个返回函数的Action Creator，然后使用redux-thunk中间件改造store.dispatch== redux-promise中间件在上面的Action Creator返回了一个函数，也可以返回其他值，另一种异步操作的解决方案，就是让Action Creator返回一个Promise对象 这需要使用redux-promise中间件 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用redux-promise中间件，使dispatch可以接受Promise作为参数import promiseMiddleware from 'redux-promise'// 创建Storeconst store = createStore(reducer, applyMiddleware(promiseMiddleware));export default store; 来看一下它的源码： 12345678910111213141516171819202122import isPromise from 'is-promise';import &#123; isFSA &#125; from 'flux-standard-action';export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 如果Action本身是一个Promise，它resolve后的值是一个Action对象，会被dispatch方法送出，reject后不会有任何动作，如果Action本身不是一个Promise对象，而Action对象的payload属性是一个Promise对象，那么无论其resolve或reject，dispatch都会发出Action 所以有两种写法，一种是让Action本身返回一个Promise对象： 12345678910111213141516171819202122sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = async () =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer: await Request.demo2.getAnswer(&#123; question &#125;) &#125;); store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); store.dispatch(receivePost());&#125; 更常见的是第二种写法，一般会配合redux-action中间件使用。 redux-action中createAction的用法： 12345678const a = createAction('test1', () =&gt; 10);a(); // &#123;type: "test1", payload: 10&#125;const b = createAction('test2');b(100); // &#123;type: "test2", payload: 100&#125; 使用redux-action将上面的写法改为： 1234567891011121314151617181920212223// 使用redux-promise中间件解决异步操作第二种写法sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123;type: 'SEND_QUESTION', status: 'sending...', question&#125;); // 发出同步Action store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); // 发出异步Action store.dispatch( createAction('RECEIVE_ANSWER')( // Promise的then函数返回值才是createAction的第二个参数 Request.demo2.getAnswer(&#123;question&#125;).then(v =&gt; (&#123; status: '', answer: v &#125;) ) ) );&#125; 注意，createAction的第二个参数实际上就是向要发送的Action的payload属性值，这里必须是一个Promise对象。（在reducer里面也必须从action.payload属性中获取对应的值） 明显，使用redux-promise的代码量更小一些，但是也因此失去了一定的灵活度，它的同步Action是脱离在异步操作之外单独存在的（即无法在一个Action Creator完成多个dispatch动作） 其他的比较热门的解决方案还有redux-promise-middleware（感觉像是前两者的一个集合）、redux-action-tools、redux-saga，可以学习这篇文章的讲解。 总结学习Redux的异步操作和中间件之后，最大的体会就是太繁琐了，各种解决方案太多了。如果是复杂的项目中，有着复杂的业务逻辑，使用Redux会是一个很麻烦的事情。 以前在做一个React项目时，项目组选型使用的Mobx，当时没觉得有好用（当然也有用的比较浅的原因），但是仅仅是学习Redux，就发现Mobx或者是Vuex真的比Redux好上手太多了，Redux的函数式编程的思想带来的难度不仅是阅读、学习的难度，更是过多的范式代码带来的苦恼。 我认为会经久流传的解决方案一定会在可阅读性、可维护性以及入手难度上取得一个比较好的平衡，除非它是为了解决一些别人无法解决的问题而提出的，是一个时间段内近乎唯一的解决方案，但我感觉Redux好像并不是这样。 参考 Redux 入门教程（二）：中间件与异步操作 compose@Redux中文文档 applyMiddleware@Redux中文文档 redux-tutorial-cn@github Redux异步方案选型@segmentfault]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>异步操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux01 入门]]></title>
    <url>%2F2019%2F03%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redux入门学习。 Redux是一个可预测状态的JavaScript容器 是否需要使用ReduxRedux的出现是为了解决React的两个问题： 121. 代码结构2. 组件之间的通信 是否使用Redux，取决于React应用是否存在上面的问题需要解决，一般来说，如果UI层比较简单，没有很多的交互，那么Redux就不是必须的，但是如果你面临的是下面的某些场景，那么就有必要考虑使用Redux了： 123451. 用户的使用方式复杂2. 不同身份的用户有不同的使用方式（比如普通用户和管理员）3. 多个用户可以写作4. 与服务器大量交互，或者使用了Websocket5. view需要从多个来源获取数据 上面的情况才是Redux的适用场景：多交互、多数据源 从组件角度来看，如果组件有一下需求，可以考虑使用Redux： 12341. 某个组件的状态需要共享2. 某个状态需要在任何地方都能够拿到（全局状态）3. 一个组件需要改变全局状态4. 一个组件需要改变另一个组件的状态 Redux提供了一个统一的位置和机制来管理状态、组织代码结构，是Web架构的一种解决方案 设计思想Redux的设计思想： 121. Web应用是一个状态机，视图与状态是一一对应的2. 所有的状态保存在一个对象里面 这是flux单向数据流图： 1234567891011121314151617 _________ ____________ ___________ | | | | | | | Action |------------▶| Dispatcher |------------▶| callbacks | |_________| |____________| |___________| ▲ | | | | | _________ ____|_____ ____▼____| |◀----| Action | | || Web API | | Creators | | Store ||_________|----▶|__________| |_________| ▲ | | | ____|________ ____________ ____▼____ | User | | React | | Change | | interactions |◀--------| Views |◀-------------| events | |______________| |___________| |_________| 其中的每一个步骤和概念都是下面要介绍的一个部分，其实没有什么太多新的东西，更多是一种编程的范式和思想。 在flux的流程中，flux确保所有Action首先通过一个Dispatcher发送给Store，由Reducer计算后通知所有的监听器 概念首先创建一个React应用，然后安装Redux 1npm install redux --save StoreStore是保存数据的地方，可以把它看成一个容器。==整个应用应该只有一个Stroe==。 12import &#123; createStore &#125; from 'redux';const store = createStore(fn); Redux提供了createStore函数，来生成Stroe，这个函数接受另一个函数作为参数，这个函数就是下面要提到的reducer，返回新生成的Stroe对象。 往createStore传Reducer的过程就是给Redux绑定Action处理函数（也就是Reducer）的过程 StateStore对象包含所有数据，想要得到某一时刻（状态）下的数据，新需要对Store生成快照，生成的快照数据就是State 当前时刻的State，可以通过Store.getState获得： 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux中，一个State对应一个View，只要State相同，View就相同，反之亦然。 ActionState的变化就会导致View的变化，但用户接触不到State，用户通过View发出通知，告诉State要发生变化了，这个通知就是Action。 Action是一个对象，必须包含一个名为type的属性，用来标识Action的名称，其他属性可以自由设置，可以参考这个规范进行设置。 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125; 可以这样理解，Action描述当前发生的事情，它是唯一改变State的方法，将数据从View运送到Store。 Action CreatorView要发送多少种消息，就有多少种Action，如果都手写会很麻烦。可以定义一个函数来生成Action，这个函数就是Action Creator 12345678const ADD_TODO = '添加TODO';funciton addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Dispatch有了Action，还需要一种行为将Action由View传递到Store，这种行为就是dispatch，store.dispatch是View发出Action的唯一方法 123456789import &#123; createStore &#125; from 'redux';const store = createStore(fn);const action = &#123; type: '添加TODO', payload: 'Learn Redux'&#125;store.dispatch(action) store.dispatch接受一个Action对象作为参数，并将它发送给Store，结合上面的Action Creator，可以改写为 1store.dispatch(addTodo('Learn Redux')) ReducerStore收到Action后，需要对Action进行处理，返回一个新的State，这样View才会发生变化，这种State的计算过程就是Reducer Reducer是一个函数，它接受当前State和一个Action作为参数，返回一个新的State： 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; store.dispatch会自动触发Reducer的自动执行（因为在使用CreateStore时将Reducer作为参数传递给了Store） 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); ==Reducer函数最重要的特征是，它是一个纯函数==，也就是说只要是同样的输入，必定得到同样的输出。 纯函数必须遵守以下的约束： 123- 不得改写参数- 不得调用系统I/O的API- 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不同的结果 Reducer函数中不能改变State对象，必须返回一个==全新的对象==，参考下面的写法： 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 使用上面的ES7的对象展开进行拷贝时，只是浅拷贝，如果数据结构更复杂或者是嵌套的，那在处理State更新的时候可能要考虑一些不同的做法，可以考虑使用ImmutableJS，Redux对此是全无预设方式的，记住它只是一个状态的容器。 任何时候，与某个View对应的State总是一个不变的对象 这里有个常见模式：在Reducer里用switch来响应对应的Action ： 12345678910111213const reducer3 = function (state = &#123;&#125;, action) &#123; console.log('reducer_3 was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY_SOMETHING': return &#123; ...state, message: action.value &#125;; default: return state; &#125;&#125;; 用switch的时候， ==永远==不要忘记放个default来返回State，否则，你的Reducer可能会返回undefined（等于你的State就丢了） Subscribe现在，用户在View层，通过dispatch发出了一个Action到Stroe，触发了对应的Reducer返回了一个新的State，但是这个State和View之间还需要关联起来，才能让视图进行封信 通过store.subscribe可以设置监听函数，一旦State发生变化，设置的监听函数就会自动执行 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 所以需要吧View的更新函数（对于React就是组件的render方法或setState方法）放到listener，就可以实现View根据State对象的变化而自动更新渲染。 store.subscribe返回一个函数，调用这个函数可以解除监听 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); Store的实现Store设对象提供了三种基本方法： 123- store.getState()- store.dispatch()- store.subscribe() Store对象是由Redux提供的createStore方法创造的，这个方法除了接受一个Reducer作为第一个参数外，还接受第二个参数，表示State的初始状态，==这个状态会覆盖Reducer函数的默认参数== 下面是createStore的简单实现，利用了闭包的原理（也证明，如果声明两个Store对象，其中保存的State对象是相互独立的） 1234567891011121314151617181920212223242526const createStore = reducer =&gt; &#123; let state = reducer(undefined, &#123;&#125;); let listeners = []; const getState = () =&gt; state; const dispatch = action =&gt; &#123; reducer(state, action); listeners.forEach(fn =&gt; &#123; fn() &#125;) &#125;; const subscribe = listener =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners.filter(fn =&gt; fn !== listener) &#125; &#125;; return &#123; getState, dispatch, subscribe &#125;&#125;; Reducer的拆分Reducer函数负责生成State对象，但是由于整个应用只有一个State对象，包含所有数据，对于大型应用来说，这个State对象会很大 看这个例子： 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 三种Action分别改变State的三个属性： 123- ADD_CHAT：chatLog属性- CHANGE_STATUS：statusMessage属性- CHANGE_USERNAME：userName属性 三个属性之间没有联系，因此可以将Reducer函数拆分，不同的函数负责处理不同的属性（即部分state），然后再合并为一个大的Reducer即可 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 拆分后，每一个小的函数负责修改对应的属性，返回值都是完整的State对象 一开始我的理解有一点问题，以为返回一个对象，对象的内容是方法，根据传入的action.type的值来确定执行哪个方法。并不是这样，返回的对象的每一个内容都是State对象的一个属性，当一个Action发送到Stroe后，对象中的每一个子Reducer函数都会被执行一次，这样才能返回完整的State对象 这个时候，每个属性对应的子Reducer内部还是要根据action.type来判断具体逻辑的，否则会应用在所有属性上 这种拆分与React应用的结构相吻合，一个React根组件由很多子组件构成，子组件与Reducer完全可以对应。 Redux提供了combineReducers方法，用于Reducer的拆分，只要定义各个子Reducer函数，然后调用这个方法，将它们合成一个大的Reducer： 123456789mport &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default chatReducer; combineReducers产生一个整体的Reducer函数，根据State的key，分别执行子Reducer，并将返回的记过合并成为一个大的State对象 combineReducers的简单实现，注意返回的应该是一个函数（与常规的Reducer相同），给每个子Reducer传递的第一个参数不应该是整个State对象，而是对应的子对象State[key] 123456const combineReducer = reducers =&gt; (state = &#123;&#125;, action) =&gt; &#123; Object.keys(reducers).reduce((newState, key) =&gt; &#123; newState[key] = reducers[key](state[key], action); return newState &#125;, &#123;&#125;)&#125; 可以把所有子Reducer放在一个文件里面，然后统一引入 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 工作流程之前接触过Vuex，感觉里面一些概念是非常类似的，首先来看一下Redux的工作流程 1234567891011121314// 1. 用户发出Actionstore.dispatch(action)// 2. Store自动调用Reducer，并传入两个参数，当前State和收到的Action，返回一个新的Statelet newState = reducer(previousState, atcion)// 3. 如果返回的新的State发生了变化，Store就会调用监听函数store.subscribe(listener)// 4. 监听函数listener中可以通过getState获取最新的State，在这里可以触发重新渲染Viewfunction listener () &#123; const newState = store.getState(); component.setState(newState)&#125; 实例：计数器我将阮一峰老师的例子稍微改写了一下，只是形式上采用了Class组件的形式 首先在demo1.js组件中，引入Redux 1const store = createStore(reducer); reducer是从./reducers/index导出的一个经由combineReducers合成的Reducer（reducer2没什么用，只是为了练习而引入的） 123456789101112131415161718192021222324252627282930313233import &#123; combineReducers &#125; from 'redux'const reducer1 = (state = 0, action) =&gt; &#123; console.log('reducer1 was called with state', state, 'and action', action); switch (action.type) &#123; case 'INCREMENT': &#123; return +state + 1 &#125; case 'DECREMENT': &#123; return +state - 1 &#125; case 'CHANGE': &#123; return +action.payload &#125; default: &#123; return +state &#125; &#125;&#125;;const reducer2 = (state = &#123; test: 'go' &#125;, action) =&gt; &#123; if (action.type === 'INCREMENT') &#123; console.log('reducer2 was called with state', state, 'and action', action); &#125; return state&#125;;const reducer = combineReducers(&#123; val1: reducer1, val2: reducer2&#125;);export default reducer 在&lt;Demo1&gt;中，&lt;Count&gt;是一个函数式组件，只负责表现，具体的逻辑在&lt;Demo1&gt;中，通过store.getState来为this.state中的变量赋值，当用户点击按钮而使用dispatch(action)发出了Action，State变化，会触发监听函数变化，监听函数中再来调用setState来触发视图的更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Count = (&#123; value, onIncrement, onDecrement, onChange &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;button onClick=&#123; onIncrement &#125;&gt;+&lt;/button&gt; &lt;span&gt;Now, the count is &#123; value &#125;&lt;/span&gt; &lt;button onClick=&#123; onDecrement &#125;&gt;-&lt;/button&gt; &lt;input type=&quot;number&quot; onInput=&#123; onChange &#125; /&gt; &lt;/div&gt; )&#125;;export default class Demo1 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; val1: store.getState().val1, val2: store.getState().val2 &#125; &#125; render() &#123; const value = this.state.val1; const value2 = this.state.val2; const ACTIONS = &#123; INCREMENT: &apos;INCREMENT&apos;, DECREMENT: &apos;DECREMENT&apos;, CHANGE: &apos;CHANGE&apos; &#125;; store.subscribe(() =&gt; &#123; this.setState(&#123; val1: store.getState().val1 &#125;) &#125;); return ( &lt;Count value=&#123; value &#125; value2=&#123; value2 &#125; onIncrement=&#123; () =&gt; store.dispatch(&#123; type: ACTIONS.INCREMENT &#125;) &#125; onDecrement=&#123; () =&gt; store.dispatch(&#123; type: ACTIONS.DECREMENT &#125;) &#125; onChange=&#123; (e) =&gt; store.dispatch(&#123; type: ACTIONS.CHANGE, payload: e.target.value &#125;) &#125; /&gt; ) &#125;&#125;; 参考 Redux 入门教程（一）：基本用法@阮一峰的网络日志 redux-tutorial-cn@github]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>flux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高08 Create React App]]></title>
    <url>%2F2019%2F03%2F01%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9808%20Create%20React%20App%2F</url>
    <content type="text"><![CDATA[一个由Facebook官方出品的React脚手架工具，无需额外配置，迅速搭建React应用脚手架。 这里只对它进行简单的尝试和入门，如果需要进一步的学习，官网在这里，文档在这里，也可以参考这篇文章进行更高阶更深入的配置和学习。 使用Create React App开发React应用不必再安装Webpack或者Babel，它们已经被内置在脚手架中了 它提供的功能： 开箱即用的React支持 开发模式和生产模式的编译 开发模式的热更新 提供了单元测试测试的接口支持 其他配置工具的默认配置（亦可以个性化配置） 快速开始123npx create-react-app my-appcd my-appnpm start React应用会运行在http://localhost:3000/，开发完成后使用npm run build打包 安装安装需要Node的版本在8.10.0以上 12345678# 使用npxnpx create-react-app my-app# npm在5.1版本下不能使用npx# 需要使用npm，首先进行全局安装npm install -g create-react-app# 创建应用create-react-app my-app 运行1npm start 在http://localhost:3000以开发模式运行React应用，页面提供了热跟新功能，在控制台会显示错误和警告。 单元测试基本使用1npm test 使用Jest运行单元测试，默认情况下会运行从上次提交commit后有改动的文件的单元测试。 需要`react-scripts@0.3.0`及更高版本，老项目开启单元测试看这里。 Jest是基于Node的运行期，速度很快，并且动过jsdom提供了浏览器的全局变量，比如window，但Jest对于DOM的测试是不准确的，它的目的是对逻辑和组件进行单元测试，而非测试DOM 在运行时Jest会自动寻找以test.js/spec.js或者__tests__文件夹下以.js结尾的文件，==这些文件可以位于src目录下任意深度的文件夹内==。 建议将测试文件（或__test__文件夹）和北侧文件放在一起，有两个好处： 便于管理，一眼就能看到文件的单元测试文件 引入组件的时候更简洁, 例如import App from &#39;./App&#39; 命令行接口使用npm test时，Jest会以watch模式运行，每次更改文件都会重新运行测试文件 这个模式下的命令行接口提供了各种能力，可以一直开着这个窗口进行快速的重复测试 版本管理接口使用npm test默认情况下会运行从上次提交commit后有改动的文件的单元测试。可以在watch模式下按a来要求Jest执行全部的测试 如果当前的工程没有使用版本管理，那么Jest会默认运行全部的测试 测试组件关于Jest的使用，以前学习在Vue中使用Jest时总结过，Jest的基本用法是相同的，在测试组件时有所区别，Vue测试组件使用的将组件和Jest进行连接的工具是Vue-test-utils，而React则是Enzyme（更准确些，jest-enzyme更接近于Vue-test-utils，封装了很多方便的API） 内容比较多，这里不展开，文档在这里，慢慢单独学习。 构建生产文件1npm run build 打包出的文件是经过压缩的，文件名带有Hash值 个性化配置因为Create-React-App将Webpack、Babel、ESLit的配置隐藏起来，简化了用户的配置操作，可以快速开始开发。 但是这只适用于一些小型的、没有特殊需求的应用的开发，如果构建大型应用还需要对上面这些工具进行个性化的配置： 1npm run eject 运行后，Create-React-App会将上面工具的配置文件复制到项目中，以后对配置文件进行修改后，项目式中会采用项目中复制修改后的配置文件 要注意，这个操作是不可逆的。 CSS-Loader在新版本的Create React App中增加了对CSS Modules的支持，要求react-scripts版本高级2.0.0。 CSS文件的命名形式为[name].module.css，对应的类名会通过添加后缀的形式来实现局部作用域，类名的格式是[filename]\_[classname]\_\_[hash] 详情参考文档。 如果需要在老版本的Create React App中增加了对CSS Modules的支持，则首先需要先通过eject命令暴露配置文件，参考这篇文章。 ESLint由于Create React App将默认的构建配置封装了起来，而ESLint仅仅开启了最基本的规则，更重要的是默认情况下，ESLint仅仅会在IDE中对违反规则的情况进行提示，并不会在构建时在终端的输出进行终端和提示。 如果这种情况可以满足需要，而只需要开启更多的规则，那么就可以在根目录下新建一个文件.eslintrc.json，然后添加： 123&#123; "extends": "react-app"&#125; 但是如果要起到更强制性的提示作用（中断构建、终端提示），Create React App建议使用Prettier代替ESLint。如果要使用ESLint，那么就需要使用npm run eject，将配置文件吐出，按照AlloyTeam的提示进行配置即可，参考这篇笔记。 Ant Design按需引入安装antd： 1npm install antd -S 然后进行按需引入分为两种情况： （1）未eject出所有配置： 参考antd的文档， 安装react-app-rewired和customize-cra（CRA）。 1npm install react-app-rewired customize-cra -D 然后修改package.json文件的启动命令： 12345"scripts": &#123; "start": "react-app-rewired start", "build": "react-app-rewired build", "test": "react-app-rewired test",&#125; 然后安装babel-plugin-import 1npm install babel-plugin-import -D 然后在根目录下创建config-overrides.js，用来修改默认配置： 123456789const &#123; override, fixBabelImports &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: 'css', // true &#125;),); 然后按按照下面的格式按需引入模块： 1import &#123; Button &#125; from 'antd'; （2）已经eject出所有配置文件： 这个时候直接按照babel-plugin-import文档的说明配置即可。 安装babel-plugin-import： 1npm install babel-plugin-import -D 然后在package.json中找到babel选项，修改为： 1234567891011121314"babel": &#123; "presets": [ "react-app" ], "plugins": [ [ "import", &#123; "libraryName": "antd", "style": "css" &#125; ] ]&#125; 引入方式与上面相同： 1import &#123; Button &#125; from 'antd'; 配置Less首先安装less和less-loader： 1npm install less less-loader -D 然后同样分为是否eject配置两种情况： （1）未eject出所有配置，仍遵循上面的步骤，安装react-app-rewired和customize-cra,修改package.json中的启动脚本。 然后修改config-overrides.js文件： 12345678910111213const &#123; override, fixBabelImports, addLessLoader &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &#125;), addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123; '@primary-color': '#1DA57A' &#125;, &#125;),); 这里利用了less-loader的modifyVars来进行主题配置，变量和其他配置方式可以参考配置主题文档。 （2）已经eject出所有配置的情况，参考这篇文章： 在config目录下的webpack.config.js文件，找到// style files regexes注释位置，添加： 123// 添加 less 解析规则const lessRegex = /\.less$/;const lessModuleRegex = /\.module\.less$/; 然后找到rules属性，在其中添加less解析配置： 12345678910111213141516171819202122232425// Less 解析配置&#123; test: lessRegex, // exclude: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, 'less-loader' ), sideEffects: true,&#125;,&#123; test: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent &#125;, 'less-loader' ),&#125;, 要注意的是，新添加的less-loader必须在file-loader的前面才能生效，因为Webpack在解析Loader是从右至左进行的（从下到上），只有先经过file-loader对文件路径的处理，less文件才能够被正确引入。 配置Alias在Vue中习惯了使用@来代替一连串的..表示的相对地址，这个功能是webpack提供的，需要在webpack中进行配置 现在使用了React，也同样希望能够配置Alias来实现路径的更优雅的表示。如果已经eject处所有配置的情况下，直接在webpackd的配置文件下添加相关的代码即可： 12345678module.exports = &#123; //... resolve: &#123; alias: &#123; '@': path.resolve(__dirname, 'src/'), &#125; &#125;&#125;; 但是如果在未eject的情况下，同样需要借助上面使用的react-app-rewired实现，首先在根目录建立一个alias.js文件，在这个文件中编写Alias的配置代码：react-app-rewired 123456789const path = require('path');module.exports = &#123; resolve: &#123; alias: &#123; '@': path.join(__dirname, 'src'), &#125;, &#125;,&#125;; 然后在config-overrides.js文件中引入并进行配置： 123456const &#123; override, addWebpackAlias &#125; = require('customize-cra');const alias = require('./alias');module.exports = override( addWebpackAlias(alias.resolve.alias),); 重新编译后@就生效了。 这时有两个问题要解决 （1）IDE的点击跳转失效了 Webstorm是可以识别webpack的配置文件，对Alias进行相应的处理，但是这里并没有eject出Webpack的配置文件，但是我们的alias.js文件就是按照Webpack的配置模块的格式来编写的，所以可以将alias.js作为配置文件，传递给Webstorm，这样IDE的文件跳转就正常了 （2）ESLint的导入导出规则报错 这是因为ESLint不能识别我们的Alias，这需要安装eslint-import-resolver-webpack这个插件，让ESLint使用Webpack的解析规则。 首先安装 1yarn add eslint-import-resolver-webpack -D 然后在.eslintrc.js中添加如下的配置： 123456789module.exports = &#123; "settings": &#123; "import/resolver": &#123; "webpack": &#123; "config": "alias.js" &#125; &#125; &#125;,&#125; 同样使用alias.js来代替Webpack的配置文件，配置完之后ESLint也就能正常工作了。 配置webpack-bundle-analyzer首先需要安装： 1234# NPM npm install --save-dev webpack-bundle-analyzer# Yarn yarn add -D webpack-bundle-analyzer 在未eject的情况下，同样可以使用customize-cra来添加webpack-bundle-analyzer的配置，在cvonfig-overrides.js中，引入addBundleVisualizer，进行配置： 123456789const &#123; override, addBundleVisualizer &#125; = require('customize-cra');module.exports = override( // 添加 webpack-bundle-analyzer addBundleVisualizer(&#123; analyzerMode: 'static', reportFilename: 'report.html', &#125;, true),); addBundleVisualizer接受两个参数，第一个对象是webpack-bundle-analyzer的配置项，可以参考文档。第二个选项用来配置自动开启，设置为ture就不需要在每次build时传入--analyze来开启分析了 在已经eject了的情况下，在webpack.config.js做进行配置，将webpack-bundle-analyzer作为插件进行引入 1234567const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 环境变量环境变量在构建期间嵌入。 可以使用process.env.NODE_ENV来读取内置的环境变量，当运行npm start时，它等于development，当运行npm test时，它等于test，当运行npm run build时它等于production。不能手动覆盖NODE_ENV，这可以防止开发人员意外地将开发环境部署到生产环境中 除了process.env.NODE_ENV之外也可以使用自定义的环境变量，自定义的环境变量必须以REACT_APP_开头。 添加环境变量有两种方式： （1）在Shell中添加临时环境变量。 操作系统不同，在Shell中定义环境变量的方法也不相同: 12345# Windows (cmd.exe)set "REACT_APP_SECRET_CODE=abcdef" &amp;&amp; npm start# Linux, macOS (Bash)REACT_APP_SECRET_CODE=abcdef npm start 为了统一在不同的操作系统中的设置方法，可以使用cross-env这个库 安装： 1npm install cross-env --save-dev 使用时只需要在原来的脚本前面加上cross-env就可以了 1cross-env NODE_ENV=development nodemon ./index.js （2）在.env中添加开发环境变量 在项目根目录中创建名为.env的文件，在文件创建以REACT_APP_开头的自定义环境变量。除了NODE_ENV之外的任何其他变量都将被会略 ==实际上，NODE_ENV是不能被覆盖的，也就意味着在.env中定义NODE_ENV也是同样被忽略的，在默认配置条件下，脚手架中的NODE_ENV是无法更改的。== .env文件应该提交到git进行管理（除了.env&amp;.local之外） 除了.env之外，还可以使用特殊的.env文件 .env：默认。 .env.local：本地覆盖。除test之外的所有环境都加载此文件。 .env.development, .env.test, .env.production：设置特定环境。 .env.development.local, .env.test.local,.env.production.local：设置特定环境的本地覆盖。 如果使用一个新的自定义的.env文件，比如使用.env.stage的环境变量文件，需要在运行npm命令时使用env-cmd 安装： 1npm install env-cmd --save-dev 使用时直接将.env.stage的路径引入即可，在Package.json文件中： 12345&#123; "scripts": &#123; "test": "env-cmd ./.env.stage npm run build" &#125;&#125; 在命令行中： 1./node_modules/.bin/env-cmd ./.env.stage npm run build 这种情况下，process.env.NODE_ENV仍然是production，但加载的.env文件已经不再是.env.build，而是变为了env.stage 参考 Docs@Create React App 从React脚手架工具学习React项目的最佳实践（上）：前端基础配置@掘金 在create-react-app中使用@Ant Design ant-design/babel-plugin-import@github 在 Create React App 中启用 Sass 和 Less@掘进 eslint-import-resolver-webpack@npm 关于eslint-plugin-import无法识别webpack alias问题@JERMY’S BLOG aze3ma/react-app-rewire-aliases@github create-react-app 通过 react-app-rewired 添加 webpack 的 alias@OnlyLing Resolve@Webpack env-cmd@npm webpack-contrib/webpack-bundle-analyzer@github]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>脚手架</tag>
        <tag>Create React App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS60 ES10的新特性简介]]></title>
    <url>%2F2019%2F02%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS60%20ES10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[ES10/ES2019还只是一个草案，但是大多数功能在新版本的Chrome中已经实现了。 虽然ES6还没有掌握全，但是还是要紧跟时代，了解一下JavaScript的发展趋势吧 BigIntBigInt是第七种原始类型，用来标识超出JavaScript最大安全整数之外的数字 在之前，JavaScript的数字是使用的是双精度浮点数数据类型，可以表示的最大安全整数是2^53-1，也就是9007199254740991，可以使用Number.MAX_SAFE_INTEGER来表示，如果超出这个范围指挥所未定为Number.MAX_SAFE_INTEGER + 1 现在使用BigInt就可以表示这个范围之外的整数值，有两种方式创建： 123456let a = 10n;let b = BigInt(10n);let c = BigInt(10);typeof a; // "bigint"a === b; // true String.prototype.matchAll()使用这个方法对字符串进行匹配时，不必再为正则表达式添加g，直接进行全局查找，返回一个迭代器对象（可以使用for...of遍历） 但是目前Chrome(70.0.3538.77)的实现好像有一些问题，实现的效果与match是相同的，只是返回的不是一个数组，而是一个迭代器对象 1234567891011let a = 'a1a2';let b = a.matchAll(/a./);for(let match of b) &#123; console.log(match)&#125;// 实际结果// ["a1", index: 0, input: "a1a2", groups: undefined]// 预期结果["a1", index: 0, input: "a1a2", groups: undefined]["a2", index: 2, input: "a1a2", groups: undefined] 动态导入现在的import是静态加载，不能将import放在条件语句中，这就导致无法在运行时家在模块（Node的require是运行时加载模块） 现在的提案中使用import()方法完成动态加载，返回一个Promise对象，是一个异步加载的方法 1234btn.addEventListener('click', async () =&gt; &#123; const module = await import('./api/button-click.js'); module.clickEvent()&#125;) Array.prototype.flat(depth)对数组扁平化，可以传入参数指定递归的深度，默认深度为1 1234567let a = [[1], [2, [3]]]let b = a.flat()// [1, 2, Array(1)]let c = b.flat()// [1, 2, 3] 细节参考MDN Array.prototype.flatMap(callback)对数组每个元素使用映射函数callback进行处理，然后将结果扁平化为一个新数组，扁平化的效果与深度为1的flat方法相同。 1234567891011var arr1 = [1, 2, 3, 4];arr1.map(x =&gt; [x * 2]); // [[2], [4], [6], [8]]arr1.flatMap(x =&gt; [x * 2]);// [2, 4, 6, 8]// 只会将 flatMap 中的函数返回的数组 “压平” 一层arr1.flatMap(x =&gt; [[x * 2]]);// [[2], [4], [6], [8]] 细节参考MDN Object.fromEntries(iterable)将键值对列表iterable转换为一个对象，这个iterable列表需要是一个可迭代对象，返回一个新对象 实际上就是Object.entries()的逆向操作： 12345678910let obj = &#123; apple : 10, orange : 20, banana : 30 &#125;;let entries = Object.entries(obj);// [Array(2), Array(2), Array(2)]// 0: (2) ["apple", 10] // 1: (2) ["orange", 20] // 2: (2) ["banana", 30] let fromEntries = Object.fromEntries(entries);// &#123; apple: 10, orange: 20, banana: 30 &#125; 目前最新版本的Chorme浏览器还不支持（只有Firefox支持） 细节参考MDN String.prototype.trimStart()和String.prototype.trimEnd()`别名是String.prototype.trimLeft()和String.prototype.trimRight()`，分别删除开头/结尾的空格 1234567891011let str = ' hello 'str.trimStart()// "hello "str.trimLeft()// "hello "str.trimEnd()// " hello"str.trimRight()// " hello" 细节参考MDN globalThis对象在JavaScript中，不同的宿主环境提供了不同的全局对象，在Web中是window或者self，在Node中是global。 新的提案中规定的globalThis对象可以无视环境，直接获取当前的全局对象 123// 浏览器中globalThis// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window,…&#125; 提案详情在这里。 Symbol.prototype.description一个只读属性，用来返回声明Symbol对象时的描述符 12const symbol = Symbol('hello');// symbol.description; Hashbang语法制定了一个解释器，统一了JavaScript在服务器端的执行方式 1234$ ./index.js# 代替$ node index.js 这块我不太理解，我认为如果标准化之后，是不是以为着在服务器端执行时不再显示的需要Node环境，而是默认可以在系统中执行JS文件了？ 其他还有一些内部实现的优化和改进，比如JSON.stringify对特殊字符的处理、sort方法的稳定性等 还有实现#私有成员的提案，看原文吧。 参考 The Complete Guide to ES10 Features@freecodecamp ES10 特性的完整指南@segmentfault Number.MAX_SAFE_INTEGER@MDN Array.prototype.flat()@MDN Array.prototype.flatMap()@MDN Object.fromEntries()@MDN String.prototype.trimLeft()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES10</tag>
        <tag>ES2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎live10 如何修车养车才更省钱]]></title>
    <url>%2F2019%2F02%2F26%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F02%20%E7%9F%A5%E4%B9%8ELive%2F%E7%9F%A5%E4%B9%8Elive10%20%E5%A6%82%E4%BD%95%E4%BF%AE%E8%BD%A6%E5%85%BB%E8%BD%A6%E6%89%8D%E6%9B%B4%E7%9C%81%E9%92%B1%2F</url>
    <content type="text"><![CDATA[知乎Live的笔记，Live地址戳这里。 题目修车费的组成1修车费 = 材料费 + 工时费 材料费一级一级家家 工时由有工时单价乘以工时数而来 如何挑选一家性价比高的维修店看场面，才成本场面越大，非核心诉求成本越高 应该挑选地段偏僻、装修简单的维修点，成本低，运营成本压力小，水分少 把有钱人当傻子的喷漆厂 看热闹，猜口碑要判断修理厂的能力和口碑，根据运行特征来判断，口碑很好的修理厂肯定门庭若市 （1）维修车辆多不多 （2）维修车辆流转快不快 （3）技师忙不忙 （4）维修区的整洁程度 好的修理师： （1）聪明 （2）不善社交、甚至不善言辞 （3）问不倒 （4）工作习惯非常好，工作服干净 如何省钱 - 物料篇零件的分类（1）原厂件：质量最好，最贵 （2）OEM品牌件：例如博世、采埃孚、法雷欧、马勒等，给主机厂提供配件，但是没有主机厂的授权，这一点导致价格与原厂家有很大的差异。 （3）自主品牌件：一般有六个月质保，质量上、性能上也会有一定保证，但是价格上非常优惠 （4）副厂件（假冒、杂牌、无牌）：质量、性能没有保证，安装都有问题，不是车特老、人特穷不要用 （5）拆车件 （6）下线件 省钱Tips（1）淘宝：不靠谱 （2）奔驰、宝马、路虎等可用自主品牌配件，质量不比原厂差 （3）缸体相关的配件、密封件、内饰件、小部分外观件、电子电器、模块传感器，这些基本上都是只有原厂件的。如果上述的范畴内，某车型能找到OEM件，甚至还有自主品牌件，那就说明这里有通病。有需求才有供给。 （4）油水当中，除了部分变速箱油外，都可以用OEM件 辅料的钱可以省辅料（密封胶、发动机清洗剂、螺栓、卡扣、油水、冷媒）能凑合就凑合，用好东西上不了天。 大品牌三五十的和几百的效果没差别。 如何省钱 - 工时费篇哪些是可以同时做掉的项目？如果在修车的时候，可以打包更换一些东西，同时免去工时费，那么可以一起做 因为有一些东西（比如刹车片）接近更换日期可以同时换。 前提是工时费可以省下来。 可以省钱的诊断法则少走冤枉路：由小到大，由易到难： 先从便宜的零件开始诊断 先从简单、常见的故障点入手 哪些工时费可以砍价？有一些必要的工时费是应该包含在当前操作内的，比如拆油底壳必然会进行四轮定位，所以要求四轮定位工时费有一定优惠 零件毛利率30%，工时费毛利率100%，据此砍价 如何省钱-方案篇保养知识 机油：5000-8000km，一般不推荐超过1万km。（金美孚） 空滤：同机油，用的多的可以2倍于机油。不过关键还是要看脏污程度。（曼牌、马勒） 空调滤：根据经验，每年至少一次。不过关键还是要看脏污程度。 蓄电池：内阻6毫欧，一般2~3年挂掉。 制动液：实际考察的是沸点，但是沸点仪太贵了。我们就用含水量测试笔，一般超过3%就更换。根据经验，也是2~3年左右挂掉。 冷却液：2年左右更换一次，哪怕冰点合适，也不宜太长时间不换，会有水垢生锈。 变速箱油：不存在不需要更换的变速箱油。一般按6-8w公里为标准。我们的自营车标准会更严格一些。 刹车片：普通人6w km一次，牛人是不到6w就换了。 刹车盘：严格按照原厂标准，一般是同刹车片。但我们可以延后，2片换1盘。 火花塞：镍金2-3w，铂金8w左右，铱金10w以上。关键是看点火间隙。 皮带轮系：6-8w km更换一次，会有明显的异响。 燃油滤：3w公里左右，内置是6w公里。 动平衡、四轮定位：2-3万来一次，或者有抖动、跑偏或偏磨时再来。 4S店最爱项目：积碳清洗、喷油嘴清洁……：不出问题就不要做。 常用诊断技巧缺岗：火花塞老化 发动机高频抖动：发动机悬置机构老化，问题不大 发动机怠速抖动：发动机指针上下波动，进气系统出现问题，清洗节气门 哪些故障不用烦 底盘故障不用烦。 漏机油、渗机油不用烦。 空调、抖动、异响，根据自己耐受程度决定。 烧机油，如果不超过1000km/L，也都不用着急。 哪些故障必须修 漏冷却液必须修——高温故障必须立刻修； 机油缺了，必须立刻处理——加一点儿就行； 电路故障看情况，如果和动力相关，需要立刻修； 缺缸建议尽快修，尤其是一些老车：驰鹏的故事； 刹车系统故障，尽快修；]]></content>
      <categories>
        <category>知乎Live</category>
      </categories>
      <tags>
        <tag>笔记总结</tag>
        <tag>汽车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习54 实现strStr()]]></title>
    <url>%2F2019%2F02%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A054%20%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目 题目来自LeetCode 实现strStr()函数。 给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1。 例1: 12输入: haystack = "hello", needle = "ll"输出: 2 示例 2: 12输入: haystack = "aaaaa", needle = "bba"输出: -1 当needle是空字符串时我们应当返回0。这与C语言的strstr()以及Java的indexOf()定义相符。 实现其实就是实现JavaScript中的indexOf函数，对于空字符串indexOf返回的也是0 所以有些答案直接把indexOf方法摆在那里，就是在让人无语了，你来LeetCode的目的是什么呢？刷成绩吗，还是真心想要提高你的算法和逻辑思维的能力呢？ 我一开始想对haystack进行一次遍历，声明一个指针来标识内部的needle的遍历的位置，结果发现没有想象的简单 还是应该老老实实用两次遍历来实现，我一开始额外声明了变量来标识循环是否完成： 12345678910111213141516171819202122232425/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function (haystack, needle) &#123; if (needle === '') &#123; return 0; &#125; let end = true; for (let i = 0; i &lt; haystack.length; i++) &#123; let count = i; end = true; for (let j = 0; j &lt; needle.length; j++) &#123; if (haystack[count++] !== needle[j]) &#123; end = false; break; &#125; &#125; if (end) &#123; return i; &#125; &#125; return -1;&#125;; 执行用时竟然达到了骇人听闻的4912ms。 看了排名在前的答案，进行了优化，优化后执行用时只有100ms： 12345678910111213141516var strStr = function (haystack, needle) &#123; if (needle === '') &#123; return 0; &#125; for (let i = 0; i &lt;= haystack.length - needle.length; i++) &#123; for (let j = 0; j &lt; needle.length; j++) &#123; if (haystack[i + j] !== needle[j]) &#123; break; &#125; if (j === needle.length - 1) &#123; return i; &#125; &#125; &#125; return -1;&#125;; 看一下优化的点： 首先就是额外的两个变量根本没有必要，只需要在内层循环判断循环是否是最后一个字符串了即可，没有必要声明flag，而count的话，直接使用i+j代替就行 其次是外层循环没有必要完全循环，如果剩下的长度已经小于needle的长度，那么就没有必要再循环了，因为已经不能再产生结果了。 所以，还是智商的差距。 努力吧。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础19 Vue2.6更新]]></title>
    <url>%2F2019%2F02%2F21%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F01%20Vue%E5%9F%BA%E7%A1%80%2FVue%E5%9F%BA%E7%A1%8019%20Vue2.6%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[2019.2月，大年三十，Vue在时隔一段时间后发布了新的版本Vue2.6，版本号是Macross（超时空要塞） 真是，不让人过好年啊。学不动了。 吐槽归吐槽，该学还是得学习。相对来说Vue的文档和教程是最平易近人、最易理解的了，而且尤雨溪还亲自发表文章介绍了Vue2.6的更新情况，更没有不跟进的理由了。 Slots：新语法，性能优化，准备接轨3.0语法最重要的更新之一就是对Slots的语法的更新，Slots对于Vue的组件解耦和分发复用有很重要的意义。旧的语法在2.x版本将获得支持，但是在3.0版本后将被废弃。 这次更新引入了v-slot来代替原来的slot和slot-scope语法 有这样一个组件Comp： 1234567891011121314151617181920&lt;template&gt; &lt;div class="slot-inner"&gt; &lt;slot&gt;默认Slot&lt;/slot&gt; &lt;slot name="slot1"&gt;具名Slot&lt;/slot&gt; &lt;slot name="slot2" :innerUser="user"&gt;Hello &#123;&#123;user.firstName&#125;&#125;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; user: &#123; firstName: 'jay', lastName: 'chow' &#125;, &#125; &#125;&#125;&lt;/script&gt; 原来的语法： 1234567891011121314151617181920212223242526&lt;Comp&gt; &lt;!-- 默认插槽 --&gt; &lt;p&gt;向默认Slot插入的内容&lt;/p&gt; &lt;!-- 具名插槽 --&gt; &lt;p slot="slot1"&gt;向具名Slot插入的内容&lt;/p&gt; &lt;!-- 作用域插槽 --&gt; &lt;p slot="slot2" slot-scope="&#123;innerUser&#125;"&gt;Hi, &#123;&#123;innerUser.lastName&#125;&#125;&lt;/p&gt;&lt;/Comp&gt;&lt;!--默认插槽--&gt;&lt;foo&gt; &lt;div slot-scope="&#123; msg &#125;"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/foo&gt;&lt;!--命名插槽--&gt;&lt;foo&gt; &lt;template slot="one" slot-scope="&#123; msg &#125;"&gt; text slot: &#123;&#123; msg &#125;&#125; &lt;/template&gt; &lt;div slot="two" slot-scope="&#123; msg &#125;"&gt; element slot: &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/foo&gt; 更新后的语法： 123456789101112131415161718192021222324252627&lt;Comp&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;!-- 具名插槽 --&gt; &lt;template v-slot:slot1&gt;&lt;p&gt;向具名Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;!-- 作用域插槽 --&gt; &lt;template v-slot:slot2="&#123;innerUser&#125;"&gt;&lt;p&gt;Hi, &#123;&#123;innerUser.lastName&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt;&lt;!--默认插槽--&gt;&lt;foo v-slot="&#123; msg &#125;"&gt; &#123;&#123; msg &#125;&#125;&lt;/foo&gt;&lt;!--命名插槽--&gt;&lt;foo&gt; &lt;template v-slot:one="&#123; msg &#125;"&gt; text slot: &#123;&#123; msg &#125;&#125; &lt;/template&gt; &lt;template v-slot:two="&#123; msg &#125;"&gt; &lt;div&gt; element slot: &#123;&#123; msg &#125;&#125; &lt;/div&gt; &lt;/template&gt;&lt;/foo&gt; 要注意，v-slot只能用在&lt;template&gt;元素上，除了一种情况，那就是独占插槽的情况。 当被提供的内容只有默认插槽时，组件的标签才可以被当做插槽的模板来使用。 123&lt;Comp v-slot:slot1&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 也可用于作用域插槽：123&lt;Comp v-slot="&#123; msg &#125;"&gt; &lt;template&gt;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 注意，独占插槽下不能出现具名插槽，会导致作用域不明确 12345&lt;!-- 无效，会导致警告 --&gt;&lt;Comp v-slot:slot1&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;template v-slot:slot2&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 只要出现多个插槽，应该始终为所有的插槽使用完整的基于&lt;template&gt;语法 为什么使用新指令而不修改旧语法的语义？尤雨溪给出了三点原因： 会导致断裂性的变化，这个特性就不能在2.x版本发布了 即使在3.x版本中修改了slot-scope的语义，但是对于大量的学习者而言会在网络上搜索到大量的基于旧的语义的资料，让人困惑，而引入新的区别于slot-scope的新指令就可以避免这个问题。 在3.x版本后不同类型Slot的概念将会统一，所以也就没有必要去区分普通插槽和作用域插槽。插槽无论是否接受参数都是插槽。在统一插槽的概念后，在用slot和slot-scope代表两种特性就没必要了。 新语法嵌套更清晰原有的语法在多个组件嵌套时会有一个问题，就是不能清晰的判断变量分别是由哪个组件提供的： 123456789&lt;foo&gt; &lt;bar slot-scope="foo"&gt; &lt;baz slot-scope="bar"&gt; &lt;div slot-scope="baz"&gt; &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125; &lt;/div&gt; &lt;/baz&gt; &lt;/bar&gt;&lt;/foo&gt; 而且，有&lt;foor&gt;提供的foo却声明在了&lt;bar&gt;上，而是用了新的语法后： 1234567&lt;foo v-slot="foo"&gt; &lt;bar v-slot="bar"&gt; &lt;baz v-slot="baz"&gt; &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125; &lt;/baz&gt; &lt;/bar&gt;&lt;/foo&gt; 这是，作用域变量的提供者和声明者是同一个组件，新的语法能够清晰的显示多个作用域变量的关系及其提供者。 性能优化普通的slot是在父组件的渲染函数中生成的，因为此当一个普通的slot依赖的数据变化时，会首先触发父组件的更新，然后新的slot内容被传到子组件，触发子组件更新。 而scoped slot在编译时生成的一个函数，这个函数背传入子组件后会在子组件的渲染函数中被低啊用。这意味着scoped slot的依赖会被子组件手机，那么当依赖变动时就只会触发子组件的更新了。 在2.6中还引入了一个优化，如果子组件只是用了scoped slot，那么父组件自身依赖变动时，不会再强制子组件更新。这个优化是的父子组件之间的依赖意识在存在slot的情况下依然完全解耦。 此外，所有使用新的v-slot的语法的slot都会编译为scoped slot，这以为这所有使用新语法的slot代码都会获得上述的性能优化。 所有的非scoped slot现在也被以函数的形式暴露在this.$scopedSlots上。如果是直接用render函数的用户，现在可以完全抛弃this.$slots而全部使用this.$scopedSlots来处理所有的slot了 总结这次更新不仅用新的语法v-slot同一了普通的slot和scoped slot的语法，并且针对新的语法在编译性能上进行了优化提升。 虽然在3.0中才会废弃旧的语法，不再有普通的slot和scoped slot的区分，并且3.0中this.$slots将会直接暴露函数，取代 this.$scopedSlots，但是我认为从2.6起，就应该在项目中使用新的语法代替旧的语法，不仅能更好地迎接3.0的到来，还会获得性能上的提升。 异步错误处理Vue 的内置错误处理机制（组件中的errorCaptured钩子和全局的errorHandler配置项）现在也会处理v-on侦听函数中抛出的错误了。 另外，如果组件的生命周期钩子或者侦听函数中有异步操作现在也可以捕获了，只需要返回一个Promise，来让Vue处理可能存在的异步错误。 例如，在子组件中的button点击事件： 12345click() &#123; return new Promise(resolve =&gt; &#123; throw Error('click') &#125;)&#125; 父组件中的errorCaptured钩子函数和全局的errorHandler配置项中就可以捕获到这个错误： 123456789// 父组件errorCaptured(e, vm, msg) &#123; console.log(msg, 999);&#125;// 全局错误处理Vue.config.errorHandler = function(err, vm ,info) &#123; console.log(info, 'config')&#125;; 如果使用了async/await就更加简单，因为async函数默认返回Promise： 1234567export default &#123; async mounted() &#123; // 这里抛出的异步错误会被 errorCaptured 或是 // Vue.config.errorHandler 钩子捕获到 this.posts = await api.getPosts() &#125;&#125; 动态指令参数指令的参数现在可以接受动态的JavaScript表达式： 1234567891011&lt;div v-bind:[attr]="value"&gt;&lt;/div&gt;&lt;div :[attr]="value"&gt;&lt;/div&gt;&lt;button v-on:[event]="handler"&gt;&lt;/button&gt;&lt;button @[event]="handler"&gt;&lt;/button&gt;&lt;my-component&gt; &lt;template v-slot:[slotName]&gt; Dynamic slot name &lt;/template&gt;&lt;/my-component&gt; 通过这种语法，当表达式的值为null时，绑定/侦听器会被移除： 123456789101112131415161718&lt;button @[event]="click"&gt;click&lt;/button&gt;&lt;script&gt;export default &#123; name: 'demo30', data() &#123; return &#123; event: 'click' &#125; &#125;, methods: &#123; async click() &#123; console.log(123); this.event = null; &#125; &#125;&#125;&lt;/script&gt; 编译警告位置信息2.6开始，所有的编译器都包含了源码的位置信息： https://cn.vuejs.org/v2/guide/components-slots.html https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md 显示地创建响应式对象2.6引入了一个新的全局API，可以用来显示地创建响应式对象： 123const reactiveState = Vue.observable(&#123; count: 0&#125;) Vue内部就是使用这个方法来处理data函数返回的对象 返回的对象可以直接用于==渲染函数==和==计算属性==内，并且在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景： 123456789const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h('button', &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; 用在计算属性内： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="slot-inner"&gt; &lt;button @click="click"&gt;click &#123;&#123;count&#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue';let count = &#123; count: 0 &#125;;const state = Vue.observable(count);export default &#123; methods: &#123; click() &#123; state.count++ &#125; &#125;, computed: &#123; count() &#123; return state.count &#125; &#125;&#125; 在Vue2.x中，被传入的对象会直接被Vue.observable改变，它和被返回的对象是同一个对象。在Vue3.x中，由于用Proxy代替了Object.defineProperty，所以会返回一个可响应的代理，而对原对象直接进行修改仍然是不可响应的。 因此为了向前兼容，推荐式中操作使用Vue.observable返回的对象，而不是传入源对象： 1234567click() &#123; // 推荐的做法 state.count++; // 虽然目前有效，但在Vue3.x中无效，所以不推荐 // count.count++;&#125; 重要的内部改动nextTick重新调整为全部使用Microtask在2.5中引入了一个改动，当一个v-on的DOM时间侦听器触发更新时，会使用Macrotask而不是Microtask类进行移步缓冲（具体的检测降级方案是setImmediate→MessageChannel→setTimeout）。 这原本是为了修正一类浏览器的特殊边际情况导致的bug才引入的（这种bug就是Edge浏览器处理Microtask的优先级比冒泡的优先级更高，会导致使用了Microtask的事件处理程序在冒泡之间就被触发），更多的细节看这里。 但这个改动本身却导致了更多其他的问题。在2.6里面对原本的边际情况找到了更简单的fix。 其他的改动（1）this.$scopedSlots函数统一返回数组，只影响render函数用户 （2）SSR数据预抓取，新增serverPrefetch钩子使得任意组件都可以在服务端渲染时请求异步的数据（不再限制于路由组件） （3）可直接在浏览器中引入的ES Modules构建文件，2.6包含了一个可以直接在浏览器导入的版本： 1234567&lt;script type="module"&gt;import Vue from 'https://unpkg.com/vue/dist/vue.esm.browser.js' new Vue(&#123; // ...&#125;)&lt;/script&gt; 参考 Vue 2.6 发布了@知乎 reverting-to-microtast@github 插槽@Vue]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>slot</tag>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习52 字符串中的第一个唯一字符]]></title>
    <url>%2F2019%2F02%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A052%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目 题目来自LeetCode 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1。 12345s = "leetcode"// 返回 0.s = "loveleetcode",// 返回 2. 注意事项：您可以假定该字符串只包含小写字母。 实现1首先想到的是用空间来换取时间，第一个循环用一个临时的数组来将所有的字符串都寸到对象中，并随时更改出现的次数，第二个循环在判断每一个字符串在对象中的值，如果只出现一次，返回当前的循环下标： 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function (s) &#123; let temp = &#123;&#125;; for (let i = 0; i &lt; s.length; i++) &#123; if (!temp[s[i]]) &#123; temp[s[i]] = 1; &#125; else &#123; temp[s[i]]++; &#125; &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (temp[s[i]] === 1) &#123; return i &#125; &#125; return -1&#125;; 这种方法的时间复杂度是O(2n)，执行结果不太理想，执行用时184mm 实现2想到可以同时从正反查找字符串出现的位置，如果是同一个位置，那么就返回改下标： 12345678910var firstUniqChar = function (s) &#123; const length = s.length; for (let i = 0; i &lt; length; i++) &#123; const str = s[i]; if (s.lastIndexOf(str) === s.indexOf(str)) &#123; return i &#125; &#125; return -1&#125;; 如果将indexOf和lastIndexOf的时间复杂度都认为是n，那么这种方法的时间复杂度是O(n^3)，但是执行用时反而会缩短一些，为144ms，可能是浏览器对indexOf和lastIndexOf有优化吧 实现3看了一下大神们100ms以内的实现方法，果然牛逼。 12345678910111213var firstUniqChar = function (s) &#123; const alpha = 'abcdefghijklmnopqrstuvwxyz'; let first = s.length; for (let i = 0; i &lt; alpha.length; ++i) &#123; let index = s.indexOf(alpha[i]); if (index !== -1 &amp;&amp; index === s.lastIndexOf(alpha[i])) &#123; if (index &lt; first) &#123; first = index; &#125; &#125; &#125; return first === s.length ? -1 : first;&#125;; 本来是遍历原先的字符串，结果变为遍历一个常量字符串。之所以这样可以行，是因为题目的备注中说明了“可以假定该字符串只包含小写字母” 所以这样的时间复杂度是O(n^2)，下降了一个数量级，实际执行用时为96ms 这道题的启发是什么呢。 那就是，智商真的很重要。 我只能勤能补一点点拙了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webstorm10 快速插入当前时间]]></title>
    <url>%2F2019%2F02%2F01%2F04%20IDE%E9%85%8D%E7%BD%AE%2FWebstorm10%20%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Webstorm快速插入当前时间的小技巧 在Webstorm中通过自定义Live Template可以快速插入当前时间 首先在设置中，Editor → Live Template，点击添加模板 填写如下信息： Abbreviation，在编辑器中输入的可以出发插入模板的缩写字符，这里填写datetime Description，对这个模板的介绍，可以不填写 Template，模版的样式，格式为$datetime，其中的datetime就是上面定义的模板字符，需要用$包裹 Expand with，出发插入模板的操作，默认点击Tab插入 No applicable context yet，定义这个模板应用的文件类型，这里选择全部 填写完成后： 然后点击EDIT VARIABLES，编写模板内容，选择datetime那一项，在Expression中输入date(&quot;yyyy-MM-dd HH:mm:ss&quot;) 现在在编辑器界面就可以快速插入当前时间了。 输入da时，编辑器就会提示，按下Tab补全，插入成功。]]></content>
      <categories>
        <category>IDEp配置</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高11 组件的自动化全局注册]]></title>
    <url>%2F2019%2F01%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F02%20Vue%E6%8F%90%E9%AB%98%2FVue%E6%8F%90%E9%AB%9811%20%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[如果使用了Webpack进行了文件的组织、编译，就可以使用require.context令组件实现自动化注册。 这个过程需要在创建Vue实例之前（new Vue({})）之前完成，例如src/main.js require.contextWebpack解析带有表达式的require语句时，会创建一个上下文(context)，因为在编译时(compile time)并不清楚具体是哪一个模块被导入。 上下文模块还包含一些运行时(runtime)逻辑来访问这个map对象。 这意味着Webpack能够支持动态require，但会导致所有可能用到的模块都包含在bundle中。 还可以使用require.context()方法来创建自己的（模块）上下文。 你可以给这个方法传3个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。 语法如下： 1require.context(directory, useSubdirectories = false, regExp = /^\.\//); 实例： 12345require.context('./test', false, /\.test\.js$/);// （创建了）一个包含了 test 文件夹（不包含子目录）下面的、所有文件名以 `.test.js` 结尾的、能被 require 请求到的文件的上下文。require.context('../', true, /\.stories\.js$/);// （创建了）一个包含了父级文件夹（包含子目录）下面，所有文件名以 `.stories.js` 结尾的文件的上下文。 传递给 require.context 的参数必须是字面量(literal)！ 导出的上下文有是三个属性： resolve是一个函数，它返回请求被解析后得到的模块id。 keys也是一个函数，它返回一个数组，由所有可能被上下文模块处理的请求组成 id是上下文模块里面所包含的模块id ==用自己创建出的上下文，去引入要引入的文件，这是关键==： 12const context = require.context('.', false, /.*\.(jpg|png)$/);const images = context.keys().map(v =&gt; context(v)); 利用require.context注册组件在main.js中 12345678910111213141516171819202122232425262728293031const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\w+\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 剥去文件名开头的 `./` 和结尾的扩展名 fileName.replace(/^\.\/(.*)\.\w+$/, '$1') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) 动态注册路由实现组件的自动注册后就可以实现路由的自动注册，在router/index.js中 1234567891011121314151617181920212223242526272829303132import Vue from 'vue';import Router from 'vue-router';const requireComponent = require.context('../components/demos', true, /demo[1-9][0-9]?\.vue$/);const routes = requireComponent.keys().map(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName); // 剥去文件名开头的 `./` 和结尾的扩展名 const componentName = fileName.replace(/^\.\/(demo[1-9][0-9]?).*\.\w+$/, '$1'); // 全局注册组件 const component = Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig ); return &#123; path: `/$&#123;componentName&#125;` , name: componentName, component, &#125;&#125;);Vue.use(Router);export default new Router(&#123; routes,&#125;) 动态导出/引入文件脱离Vue，在使用Webpack的一般情况下也可以通过require来导出和引入组件。 1234567891011121314// 导出const context = require.context('./', false, /Demo\d+\.js$/);const Demos = context.keys().reduce((total, current) =&gt; &#123; const name = current.replace(/^\.\/(Demo\d+).*\.\w+$/, '$1'); total[name] = context(current).default; return total&#125;, &#123;&#125;);export default Demos;// 引入import DEMOS from './demos/'const &#123; Demo01, Demo02 &#125; = DEMOS; 注意，由于Demo是通过default导出的，所以需要使用.default来获取模块 其他应用还可以使用require.context实现一些其他目录的操作，例如读取目录下的图片： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;img v-for="img in images" :src="img" :key="img" class="insert"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const context = require.context('.', false, /.*\.(jpg|png)$/); const images = context.keys().map(v =&gt; context(v)); export default &#123; data() &#123; return &#123; images, &#125; &#125; &#125;&lt;/script&gt; 参考 Webpack Vue - 基础组件的自动化全局注册 掘金 - require.context]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习51 旋转数组]]></title>
    <url>%2F2019%2F01%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A051%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一个旋转问题的练习题。 题目 题目来自LeetCode 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 设计一个算法来计算你所能获取的最大利润。你可以==尽可能地完成更多的交易==（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 实现一开始觉得这是一个动态规划的问题，要拆成另两个部分，买的位置和卖的位置，想了半天，发现没有必要这么复杂 这里的关键是，==尽可能多的完成交易==，比如[1, 3, 2, 3, 4, 5]，肯定是两次交易3-1和5-2的利润比一次交易5-1的利润要高 其实计算的是差价，只要当前的利润小于已有利润，就卖出，已有利润计入当前利润中，并重置相关的数据 1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let buyIndex = 0; let currentProfit = 0; let totalProfit = 0; for (let i = 0; i &lt; prices.length; i++) &#123; let tempProfit = prices[i + 1] - prices[buyIndex]; if (tempProfit &gt; currentProfit) &#123; currentProfit = tempProfit &#125; else &#123; totalProfit += currentProfit; currentProfit = 0; buyIndex = i + 1 &#125; &#125; return totalProfit + currentProfit;&#125;; 再查看他人的答案，有更简单的，不像上面积攒到每次交易才算最后的利润值，还需要重置，可以直接每两次的股票差价进行比较，只要利润大于零就计入总利润，否则就抛弃 12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let totalProfit = 0; let tempProfit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; tempProfit = prices[i] - prices[i - 1]; if (prices[i] - prices[i - 1] &gt; 0) &#123; totalProfit += tempProfit &#125; &#125; return totalProfit;&#125;; 简单多了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高07 Context]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9807%20Context%2F</url>
    <content type="text"><![CDATA[跨组件数据传递和兄弟组件数据传递，一直是一个比较让人头痛的问题，Redux和Mobx都是很好的解决方法。 如果不使用第三方的框架，React提供了Context API来实现组件树传递数据。 简介React Context API提供了一种通过组件树传递数据的方法，而不必在每个级别通过props属性一层一层传递。 Context提供了一个在组件树内可被视为“全局”的数据，当一些数据需要在不同的嵌套级别上被许多组件访问时，可以考虑使用Context。 请谨慎使用Context，它使组件重用更加困难。 旧的API之前的使用方法是： 在上层组件（提供者）添加一个方法getChildContext，返回要传递的context对象 1234567891011121314class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: &quot;purple&quot;&#125;; &#125; render() &#123; return ( &lt;Button&gt;&lt;/Button&gt; ) &#125;&#125;// 还要提前声明传递的数据的类型：MessageList.childContextTypes = &#123; color: PropTypes.string&#125;; 在下层组件（使用者）中直接使用this.context获取属性 1234567891011121314class Button extends React.Component &#123; render() &#123; return ( &lt;button&gt; &#123;this.context.color&#125; &lt;/button&gt; ); &#125;&#125;// 同样要提前声明传递的数据的类型Button.contextTypes = &#123; color: PropTypes.string&#125;; 它的问题是，这样的写法不符合React的声明式的写法，并且在Context值更新后，顶层组件组件向目标组件props透传的过程中，如果中间某个组件的shouldComponentUpdate返回了false，因为无法在继续出发底层组件的render，新的Context将无法达到目标组件。 因此React提出了新的Context API 新的API新的API采用了声明式的写法，也解决了穿透shouldComponentUpdate的问题 看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;// 初始化一个Contextconst ThemeContext = React.createContext();// 父组件class FatherComponent extends React.Component &#123; state = &#123; color: &apos;blur&apos; &#125;; changeColor = color =&gt; &#123; this.setState(&#123; color &#125;) &#125;; render() &#123; return ( // XXXContext.Provider作为顶层组件接受名为value的Prop &lt;ThemeContext.Provider value=&#123;&#123; color: this.state.color, changeColor: this.changeColor &#125;&#125; &gt; ) &#125;&#125;// 后辈组件（目标组件）class App extends React.Component &#123; render() &#123; &lt;FatherComponent&gt; &lt;ThemeContext.Consumer&gt; // XXXContext.Consumer作为目标组件接受参数，必须是一个函数 &#123;context =&gt; ( &lt;ChildComponent color=&#123;context.color&#125; changeColor=&#123;context.changeColor&#125; &gt; )&#125; &lt;/ThemeContext.Consumer&gt; &lt;/FatherComponent&gt; &#125;&#125; 新的Context API由三个部分组成： （1）React.createContext用于初始化一个Context （2）xxxContext.Provider作为顶层组件，接受一个value的prop，可以接受任意需要被放入context中的数据和函数（注意，这个Prop的名字必须是value，这是React要求的，并且内部应该以对象的形式传入数据） （3）xxxContext.Consumer作为目标组件，可以出现在xxxContext.Provider之后的组件树的任意位置，接受Child组件，这里的Child组件必须是一个函数，参数就是context，用来接受从顶层组件传来的Context，返回值是后辈组件。 例子有这样三层组件： 父组件： 12345678910111213class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1&#125;)&#125;&gt; + &lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1&#125;)&#125;&gt; - &lt;/button&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125; 儿子组件： 12345678910class Child extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson /&gt; &lt;/div&gt; ) &#125;&#125; 孙子组件 12345const Grandson = () =&gt; ( &lt;div&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;/div&gt;); 现在，我们想让父组件的count属性能够被孙子组件获取到，按照原来的做法，需要一层一层传递进去： 1234567891011121314151617181920212223242526272829303132const Grandson = (&#123; count &#125;) =&gt; ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot;&#125;&#125;&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;p&gt;老子给的数：&#123;count&#125;&lt;/p&gt; &lt;/div&gt;);class Child extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot;&#125;&#125;&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson count=&#123;this.props.count&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;&#125;&#125;&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; +&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1 &#125;)&#125;&gt; -&lt;/button&gt; &lt;Child count=&#123;this.state.count&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 如果改为使用Context来实现呢？那么就需要在父组件增加一个Provider的架子，将后续的组件都装进去，在孙子组件使用Consumer的架子（是一个函数，返回值是原本的结构，但是通过函数的参数来获取要传递的跨级的数据） 123456789101112131415161718192021222324252627282930313233343536373839404142// 初始化一个Contextconst Context = React.createContext();const Grandson = () =&gt; ( &lt;Context.Consumer&gt; &#123;context =&gt; ( &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot; &#125;&#125;&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;p&gt;老子给的数：&#123;context.count&#125;&lt;/p&gt; &lt;/div&gt; )&#125; &lt;/Context.Consumer&gt;);class Child extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot; &#125;&#125;&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson /&gt; &lt;/div&gt; ) &#125;&#125;export default class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;Context.Provider value=&#123;&#123;count: this.state.count&#125;&#125;&gt; &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot; &#125;&#125;&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; +&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1 &#125;)&#125;&gt; -&lt;/button&gt; &lt;Child /&gt; &lt;/div&gt; &lt;/Context.Provider&gt; ) &#125;&#125; Demo地址在这里。 参考 上下文(Context)@React中文文档 如何解读 react 16.3 引入的新 context api？@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高06 Render Props]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9806%20Render%20Props%2F</url>
    <content type="text"><![CDATA[上一篇笔记学习了通过高阶组件实现React的代码复用，它也有着一些缺点。 除了HOC之外，还有没有别的方法呢？来，学习一下Render Props。 HOCHOC的出现是为了实现代码的复用，是一种React中的编程范式，基本的形式是： 1234567function HOCFactory(WrappedComponent, ...args) &#123; return class HOC extends React.Component &#123; render()&#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 代码通过一个类似装饰器技术（可以参考《16 ES6标准入门(Decorator)》这篇笔记）共享，接受一个基础组件作为参数，返回了一个新的组件 1const ResultComponent = HOC(BaseComponent) 一个HOC的例子Demo的Github地址在这里。 一个响应鼠标事件的HOC的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const withMouseHOC = Component =&gt; &#123; return class extends React.Component &#123; state = &#123; x: 0, y: 0 &#125; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; render() &#123; return ( &lt;div onMouseMove=&#123;this.handleMouseMove.bind(this)&#125; &lt;Component &#123;...this.props&#125; mouse=&#123;this.state&#125; /&gt; &lt;/div&gt; ) &#125; &#125;&#125;class App extends React.Component &#123; render() &#123; const &#123;x, y&#125; = this.props.mouse; return ( &lt;div&gt; &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;)&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;// 也可以写成纯函数式组件const App = props =&gt; &#123; const &#123; x, y &#125; = props.mouse; return ( &lt;div&gt; &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;) &lt;/h1&gt; &lt;/div&gt; )&#125;const AppWithMouse = withMouseHOC(App);ReactDOM.render(&lt;AppWithMouse /&gt;, document.getElementById(&apos;root&apos;) HOC的问题HOC存在着几个问题： （1）存在着多个HOC时，不知道props从何而来 （2）名字冲突，如果多个HOC使用了同名的prop，它们将发生冲突并彼此覆盖，React不会发出警告 （3）HOC使用的是静态组合而不是动态组合（结果组件被创建时发生的组合），不能再Render中调用HOC，不能使用React的生命周期 Render Props于是出现了另一门技术来实现代码复用，可以规避上面出现的问题 那什么是Render Prop呢？一个Render Prop是一个类型为函数的prop，将可复用组件的state作为参数传递给这个函数prop，返回对应的HTML模板（我理解，这也是“Render Prop”的意思吧，一个可以作为render函数返回HTML模板的prop） 将上面的例子改写成Render Prop的形式 123456789101112131415161718192021222324252627282930313233// 用一个普通组件来共享代码class Mouse extends React.Component &#123; state = &#123; x: 0, y: 0 &#125; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; // 在render函数中，利用prop.render来进行渲染 render() &#123; return ( &lt;div onMouseMove=&#123;this.handleMouseMove.bind(this)&#125; &#123;this.prop.render(this.state)&#125; &lt;/div&gt; ) &#125;&#125;const AppWithMouse = () =&gt; &#123; // 给组件的render的prop传入了一个函数 return ( &lt;div&gt; &lt;Mouse render=&#123;(&#123;x, y&#125;) =&gt; ( &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;) &lt;/h1&gt; )&#125; &lt;/div&gt; )&#125;ReactDOM.render(&lt;AppWithMouse /&gt;, document.getElementById(&apos;root&apos;) 使用的窍门：将一个返回HTML函数作为名为render的prop，传给复用组件，复用组件中调用this.props.render(this.state)，渲染个性组件，最终返回最终组件。 有了Render Prop，我们可以使用一个prop去进行渲染，它解决了HOC的问题 （1）足够直接，可以通过Render Prop传入的函数的参数列表，有哪些state和prop可以使用 （2）不会有变量名的冲突，因为不会有任何的自动的属性合并 （3）组合模型是动态的，每次组合都是在render内部，可以利用React生命周期 此外，由于Render Prop仅仅是一个函数，所以不会带来过多的复杂的编程范式，更加简洁 用Render Prop代替HOC？技术实现上，可以使用Render Prop代替HOC，例如可以用一个一般的、具有Render Prop的&lt;Mouse&gt;组件实现的witchMouse的HOC： 1234567891011const withMouse = Component =&gt; &#123; return class extends React.Component &#123; render() &#123; return ( &lt;Mouse render=&#123;mouse =&gt; ( &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt; )&#125; /&gt; ) &#125; &#125;&#125; 但是我现在也没有具体的实践经验，是否在各种复杂的场下，Render Prop代替HOC都是更优的，还是需要实践慢慢总结证明。 与HOC的实现方式的区别假设包含能够复用的逻辑的公共组件是A，需要继承的个性组件是B，HOC的实现是将用一个函数的形式，B为参数，作为render的内容组合至A中，返回包含B的A，也就是最终的组件： 123456789const HOCFactory = B =&gt; &#123; return &lt;A /&gt;&#125;// B组合至A中返回class A extends from React.Component &#123; render() &#123; return &lt;B /&gt; &#125;&#125; 而Render Props方式的实现是，在A中渲染的是this.props.render函数的返回值，最终的组件形成是在使用A时，为A传入一个render参数，它的返回值就是B的内容（通过Prop传进A的内部进行渲染） 12345678910111213141516171819// A class A extends from React.Component &#123; render() &#123; return ( &lt;A&gt; &#123;this.props.render(this.state)&#125; &lt;/A&gt; ) &#125;&#125;// 最终组件class App extends from React.Component &#123; render() &#123; return ( &lt;A render=&#123;(state) =&gt; (&lt;B&gt;)&#125; /&gt; ) &#125;&#125; 参考 [译]使用Render props吧！@掘金 React中的Render Props@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高05 高阶组件]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9805%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[如何更好的实现代码复用，又能够保证一定的灵活性、可维护性和可读性，需要程序员自身的技巧和能力，也需要框架更好和合理的设计实现和编程范式。 高阶组件就是React实现代码复用的一种方法。 什么是高阶组件高阶组件（简称HOC）的目的就是实现代码的复用，它不是React的API，而是根据React的特性形成的一种开发范式。它接受一个组件作为参数并返回一个新的组件 1234567function HOCFactory(WrappedComponent, ...args) &#123; return class HOC extends React.Component &#123; render()&#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; HOC中并没有修改输入的组件，也没有通过继承来扩展组件，而是通过==组合的方式==来达到扩展的目的 即：传入HOCFactory中的WrappedComponent是一个有个性的组件，而HOC中返回的class是有公共特性的组件，通过传入args一些配置参数，返回的就是这个特性组件和公共组件的组合组件 HOC可以做什么 代码复用，代码模块化 增删改props 渲染劫持 （1）代码复用，代码模块化 看这样的一个例子： 加载数据、刷新数据的行为很常见，现在把这种逻辑抽离到高阶组件当中去。完成高阶组件loadAndRefresh，它具有以下功能： 123456789101112class Post extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.props.refresh()&#125;&gt;刷新&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Post = loadAndRefresh(&apos;/post&apos;)(Post) 高阶组件loadAndRefresh接受一个url作为参数，然后返回一个接受组件作为参数的函数，这个新函数返回一个新的组件。新的组件渲染的时候会给传入的组件设置content和refresh作为props。 getData(url)的返回Promise，它返回一个字符串的文本，你需要通过content的props把它传给被包裹的组件。组件在第一次加载还有refresh的时候会去服务器取数据。 另外，组件在加载数据的时候，content显示数据加载中...。而且，所有传给loadAndRefresh返回的组件的props要原封不动传给被包裹的组件。 最后一句话，loadAndRefresh返回的组件就是返回的新组件Post，被包裹的就是传入的原来的Post，原封不动就是指需要将this.props完全传递，利用了对象解构的语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const getData = url =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, 2000, Date.now())&#125;);class Post extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.props.refresh()&#125;&gt;刷新&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const loadAndRefresh = url =&gt; (Wrapper) =&gt; &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; content: &apos;&apos; &#125; &#125;; componentDidMount () &#123; this.refresh() &#125;; async refresh() &#123; this.setState(&#123; content: &apos;数据加载中...&apos;, &#125;); const content = await getData(url); this.setState(&#123; content, &#125;); &#125;; render () &#123; return ( &lt;Wrapper content=&#123;this.state.content&#125; refresh=&#123;this.refresh.bind(this)&#125; &#123;...this.props&#125;/&gt; ) &#125; &#125;&#125;;Post = loadAndRefresh(&apos;/post&apos;)(Post);export default class PCHeader extends Component &#123; render () &#123; return ( &lt;Post /&gt; ) &#125;&#125; 上面的高阶组件中，接受了Post作为个性组件，而HOC中的公共组件部分实现的就是抽离出来的获取、刷新数据的逻辑（它也是一个组件）。 props的传递是通过在组件上，利用对象的扩展，将所有prop传入 （2）增删改props HOC组件可以对传入的props进行修改或者添加 HOC组件会在原始组件的基础上增加一些扩展功能使用的props，这些props不应该传入到原始组件，一般会这样处理： 1234567891011function control(wrappedComponent) &#123; return class Control extends React.Component &#123; render()&#123; let props = &#123; ...this.props, message: &quot;You are under control&quot; &#125;; return &lt;wrappedComponent &#123;...props&#125; /&gt; &#125; &#125;&#125; （3）渲染劫持 可以在HOC中控制是否渲染（这里控制的组件整体是否被渲染，而非组建内部的细节），无法在HOC中控制渲染细节 比如，组件在data没有加载完的时候加载LOADING，可以在HOC中这样实现： 12345678910function loading(wrappedComponent) &#123; return class Loading extends React.Component &#123; render()&#123; if(!this.props.data) &#123; return &lt;div&gt;LOADING...&lt;/div&gt; &#125; return &lt;wrappedComponent &#123;...props&#125; /&gt; &#125; &#125;&#125; 注意事项不要在render方法里面调用HOC方法在render里面每次调用HOC都会返回一个新的class，重新渲染会让性能损耗加大。 拷贝静态方法有的时候在组件的class包装的静态方法，通过HOC返回的包装后的组件就没有这些静态方法。 为了保持组件使用的一致性，一般会把这些静态方法拷贝到包装后的组件上 123456function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 例子logger和debugger官网的例子，可以用来监控父级组件传入的props的改变： 123456789101112function logProps(WrappedComponent) &#123; return class extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; console.log(`WrappedComponent: $&#123;WrappedComponent.displayName&#125;, Current props: `, this.props); console.log(`WrappedComponent: $&#123;WrappedComponent.displayName&#125;, Next props: `, nextProps); &#125; render() &#123; // Wraps the input component in a container, without mutating it. Good! return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 页面权限管理可以使用HOC对组件进行包裹，当组件加载的时候，首先检验用户是否有对应的权限，如果有的话就渲染页面，如果没有就跳走 参考 Higher-Order Components@React 深入React高阶组件(HOC)@掘金 React HOC高阶组件详解@掘金]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>HOC</tag>
        <tag>高阶组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高04 对虚拟DOM和加载过程的理解]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9804%20%E5%AF%B9%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[也是面试时比较常遇到的React的问题之一。了解了之后还是能够加深对React的理解。 React虚拟DOM的理解（1）用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 （2）当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 （3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 虚拟DOM本质上就是在JS和DOM之间做了一个缓存。可以类比CPU和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然DOM这么慢，我们就在JS和DOM之间加个缓存。CPU（JS）只操作内存（虚拟DOM），最后的时候再把变更写入硬盘（DOM）。 虚拟DOM是用JS的对象结构模拟出HTML中DOM的结构，批量的增删改查，由于直接操作的是JS对象，所以速度要比操作真实DOM要快，最后更新到真正的DOM中 虚拟DOM构建的对象，除了DOM相关属性，还包括了React自身需要的属性，比如ref，key等，大概如下结构： 123456789101112131415161718192021&#123; type: 'div', props: &#123; className: 'xxx', children: [&#123; type: 'span', props: &#123; children: ['CLICK ME'] &#125;, ref: key: &#125;, &#123; type: Form, props: &#123; children: [] &#125;, ref: key: &#125;] | Element &#125; ref: 'xxx', key: 'xxx'&#125; React何时将虚拟DOM渲染为真实DOMrender这个步骤就是React组件挂载的步骤 React组件挂载：将组件渲染，并构建DOM元素然后插入页面的过程 render的步骤是创建虚拟DOM，挂载组件， 在render之后，将这个虚拟DOM树真正渲染成一个DOM树，插入了页面，可以认为是在componentDidMount这个步骤完成的，该方法被调用时，已经渲染出真实的DOM 在组件存在期，componentDidUpdate与componentDidMount类似，在组件被重新渲染后，此方法被调用，真实DOM已经渲染完成 React不能setState的步骤shouldComponentUpdate和componentWillUpdate就会造成循环调用，使得浏览器内存占满后崩溃 对于setState的理解setState是一个异步方法，一个生命周期内的所有setState方法会合并操作。 在各个生命周期中执行setState： （1）在componentWillMount执行setState是无意义的，应该将这里为state的赋值放到constructor中直接作为state的初始值。 这是因为，组件直挂再一次，在componentWillMount里面setState会但是仅仅会更新state一次，而且会和constructor中的初始化state合并执行。所以这是无意义的setState （2）在componentDidMount中执行setState会导致组件在初始化的时候就触发了更新，渲染了两遍，应该尽量避免。 有一些场景，比如在组件DOM渲染完成后获得DOM元素位置或者宽高等等设置为state，会不得在componentDidMount之后setState，但是除了这些必要的时候，都应该尽量避免在componentDidMount里setState。 （3）在componentWillUnmount中执行setState不会更新state，是不生效而且无意义的。 （4）禁止在shouldComponentUpdate和componentWillUpdate中调用 setState，这会造成循环调用，直至耗光浏览器内存后崩溃。 在shouldComponentUpdate和componentWillUpdate调用setState会再次触发这两个函数，然后在两个函数又触发了setState，然后再次触发这两个函数，这样就进入了一个不停setState然后不停触发组件更新的死循环里，会导致浏览器内存耗光然后崩溃。 （5）在componentDidUpdate中执行`setState同样会导致组件刚刚完成更新又要再更新，进入死循环。 但是在某些特殊情况下，比如说state或者props变化触发了DOM变化，需要重新获取DOM元素宽高时然后更新某个state的时候，就不得不在这个函数里使用setState了。此时一定要给setState设置一个前提条件，以避免出现循环渲染的问题。 1234567componentWillUpdate(nextProps, nextState, nextContext) &#123; if (this.state.count !== 3333) &#123; this.setState(&#123; count: 3333 &#125;); &#125;&#125; 因此，如非必须，应该尽量避免在本函数里setState。 （5）在componentWillReceiveProps中可以setState，不会造成二次渲染。由于只有props的变化才会触发componentWillReceiveProps事件，因为在这个事件里setState不会造成不停触发组件更新的死循环，可以放心在这个函数里setState。 为什么虚拟DOM比原生DOM性能更高React的基本思维模式是每次有变动就整个重新渲染整个应用，相当于设置 innerHTML，只不过它设置的是内存里面 Virtual-DOM，而不是真实的 DOM。 React厉害的地方并不是说它比DOM快(这句话本来就是错的)，而是说不管你数据怎么变化，我都可以以最小的代价来更新DOM。方法就是在内存里面用新的数据刷新一个虚拟的DOM数，然以后新旧DOM树进行比较，找出差异，再将差异更新到真正的DOM 树上。 原生DOM性能低，因为DOM的规范迫使浏览器在实现的时候为每一个DOM元素添加了非常多的属性，然而这其中很多我们都用不到 而React对虚拟DOM的属性进行了精简，非常轻量化，并且使用了diff的算法，比较前后差异，最后只把变化的部分一次性应用到真实的DOM树 React的变动检查由于是DOM结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。 更正确的说法应该是：虚拟DOM不一定比原生DOM性能高，但是让开发者更省心的更新数据。 首先, 虚拟DOM并没有比直接原生操作更快, 所谓”快”是有条件的比如点赞, 数字+1, 直接操作DOM会更快。 如果你能自己捋请规则, 每回手动操作DOM的时候, 都只改动应该改变的, 那DOM操作永远比虚拟DOM快。 但如果你的改动勾连的地方很多，而且要保持状态，那虚拟DOM的自动diff无疑会让你省更多心。 比如一个列表, 列表项有点赞等状态, 回复数量等信息, 有动态新增, 有动态加载, 这时候你要直接操作DOM会很繁琐。 虚拟DOM的核心在于diff，它自动帮你计算那些应该调整，然后只修改该修改的区域, 省下的不是运行速度这种小速度，而是开发速度/维护速度/逻辑简练程度等”总体速度” diff算法比较两棵DOM树的差异是Virtual DOM算法最核心的部分，这也是所谓的Virtual DOM 的diff算法。两个树的完全的diff算法是一个时间复杂度为O(n^3)的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以Virtual DOM只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到O(n)。 参考 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ - 尤雨溪的回答@知乎 react里面的virtual DOM的效率为什么比直接操作DOM更快呢@segmentfault 如何理解虚拟DOM? - 戴嘉华的回答@知乎 React组件生命周期函数里setState调用分析@Simona&amp;Peter]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高03 编写一个组件]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9803%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[以前总结的，简单的编写一个组件的过程 还是太简略了，以后慢慢丰富吧。 详解过程编写一个组件首先引入相关模块 React prop-types 然后声明一个继承自React.Component的类： 123export default class MyComponent extends from Reac.Component&#123; &#125; 然后对传入的Prop进行限定和验证： 123456static PropTypes = &#123; checkedText: PropTypes.string, uncheckedText: PropTypes.string, hideText: PropTypes.bool, onClickFunc: PropTypes.func&#125; 可以对Prop的默认值进行预定义： 12345static defaultProp = &#123; checkedText: &apos;开&apos;, uncheckedText: &apos;关&apos;, hideText: false&#125; 然后定义组件的constructor， 在其中可以定义state中的初始值 123456constructor(props) &#123; super(props); this.state = &#123; checked: false &#125;&#125;; 将数组传回父组件，是通过调用父组件的方法，父组件的方法是通过Prop传入子组件中进行调用的 123456789101112// 父组件中引用子组件&lt;MyInput onClickFunc=&#123;this.handleClick.bind(this)&#125;/&gt;// 子组件中引用父组件的方法并传值handleClick() &#123; const &#123;checked&#125; = this.state; const &#123;onClickFunc&#125; = this.props; this.setState(&#123; checked: !checked &#125;, () = &gt; &#123; onClickFunc(this.state.checked) &#125;); 注意，调用父组件的方法放在了setState方法的回调函数中 一个组件的例子定义子组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Created by zh on 2018/1/24. */import React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import ReactDOM from &apos;react-dom&apos;;import styles from &apos;./myInput.css&apos;;import classnames from &apos;classnames&apos;export default class MyInput extends React.Component &#123; static propTypes = &#123; checkedText: PropTypes.string, uncheckedText: PropTypes.string, hideText: PropTypes.bool, onClickFunc: PropTypes.func &#125;; static defaultProps = &#123; checkedText: &apos;开&apos;, uncheckedText: &apos;关&apos;, hideText: false &#125;; constructor(props) &#123; super(props); this.state = &#123; checked: false &#125; &#125;; handleClick() &#123; const &#123;checked&#125; = this.state; const &#123;onClickFunc&#125; = this.props; this.setState(&#123; checked: !checked &#125;, () =&gt;&#123; onClickFunc(this.state.checked) &#125;); &#125; render() &#123; const &#123;checkedText, uncheckedText, hideText&#125; = this.props; const &#123;checked&#125; = this.state; let checkStyle = checked ? styles[&apos;circleChecked&apos;] : styles[&apos;circleUnchecked&apos;]; let textEle = !hideText ? ( &lt;span className=&#123; checked ? styles.checkedText : styles.unCheckedText&#125;&gt; &#123;checked ? checkedText : uncheckedText&#125; &lt;/span&gt; ) : null; return ( &lt;div className=&#123;styles.container&#125; onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;div className=&#123;classnames(styles[&apos;circle&apos;], checkStyle)&#125;/&gt; &#123;textEle&#125; &lt;/div&gt; ) &#125;&#125; 引用子组件 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by zhouhao on 2017/5/8. */import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;observable, computed, action&#125; from &apos;mobx&apos;;import &#123;observer&#125; from &apos;mobx-react&apos;import Store from &apos;./components/Store&apos;;import style from &apos;../css/root.css&apos;;import MyInput from &apos;./components/MyInput&apos;;@observerexport default class Root extends React.Component &#123; constructor() &#123; super(); this.state = &#123; childState: &apos;关&apos; &#125; &#125; handleClick(inputChecked)&#123; let state = inputChecked ? &apos;开&apos; : &apos;关&apos;; this.setState(&#123; childState: state &#125;); &#125;; render() &#123; let &#123;childState&#125; = this.state; return ( &lt;div&gt; &lt;MyInput onClickFunc=&#123;this.handleClick.bind(this)&#125;/&gt; &lt;p&gt;子组件状态:&#123;childState&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高02 React性能优化]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9802%20React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以前面试的时候，遇到过如何进行React性能优化的问题。总结了一下。 但是在实际工作中，确实没有遇到过React性能的问题，还是业务场景不复杂。希望以后能有机会实践。 PureRenderMixin因为react的diff是在某一个根节点发生变化的时候，调用所有节点进行render，再对生成的虚拟DOM进行对比，如果不变则不对真实DOM进行更新。这就导致了性能的浪费。 所以优化针对两方面： 拆分组件，有利于组件复用和优化 避免不必要的render 避免不要的render，主要基于componentShouldUpdate(nextProps, nextState)生命周期函数，该函数默认返回true，所以一旦prop或state有任何变化都会引起重新render React的官方解决方案是 PureRenderMixin ES5的写法： 12345678var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;);React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); pure-render-decoratorES7装饰器的写法： 12345678910111213141516171819import pureRender from &quot;pure-render-decorator&quot;...@pureRenderclass Person extends Component &#123; render() &#123; console.log(&quot;我re-render了&quot;); const &#123;name,age&#125; = this.props; return ( &lt;div&gt; &lt;span&gt;姓名:&lt;/span&gt; &lt;span&gt;&#123;name&#125;&lt;/span&gt; &lt;span&gt; age:&lt;/span&gt; &lt;span&gt;&#123;age&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; pureRender很简单，就是把传进来的component的shouldComponentUpdate给重写掉了，原来的shouldComponentUpdate，无论怎样都是return ture，现在不了，我要用shallowCompare比一比，shallowCompare代码及其简单 123function shallowCompare(instance, nextProps, nextState) &#123; return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);&#125; PureComponentReact在15.3.0里面加入了了React.PureComponent - 一个可继承的新的基础类, 用来替换react-addons-pure-render-mixin。用法： 12345678910111213141516class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; 要注意的是，这种比较只是浅比较，在多层嵌套的对象中比较会失败 immutable.jsImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。 Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画： Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的： 1234567891011121314151617181920212223import &#123; is &#125; from &apos;immutable&apos;;shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123; const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false;&#125; 无状态组件react官方还在0.14版本中加入了无状态组件 这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义： 123// es6const HelloMessage = (props) =&gt; &lt;div&gt; Hello &#123;props.name&#125;&lt;/div&gt;;render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode); 参考 https://segmentfault.com/a/1190000007811296 https://segmentfault.com/a/1190000010438089]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习50 买卖股票的最佳时机 II]]></title>
    <url>%2F2019%2F01%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A050%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[贪心算法的练习题。 题目 题目来自LeetCode 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 设计一个算法来计算你所能获取的最大利润。你可以==尽可能地完成更多的交易==（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 实现一开始觉得这是一个动态规划的问题，要拆成另两个部分，买的位置和卖的位置，想了半天，发现没有必要这么复杂 这里的关键是，==尽可能多的完成交易==，比如[1, 3, 2, 3, 4, 5]，肯定是两次交易3-1和5-2的利润比一次交易5-1的利润要高 其实计算的是差价，只要当前的利润小于已有利润，就卖出，已有利润计入当前利润中，并重置相关的数据 1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let buyIndex = 0; let currentProfit = 0; let totalProfit = 0; for (let i = 0; i &lt; prices.length; i++) &#123; let tempProfit = prices[i + 1] - prices[buyIndex]; if (tempProfit &gt; currentProfit) &#123; currentProfit = tempProfit &#125; else &#123; totalProfit += currentProfit; currentProfit = 0; buyIndex = i + 1 &#125; &#125; return totalProfit + currentProfit;&#125;; 再查看他人的答案，有更简单的，不像上面积攒到每次交易才算最后的利润值，还需要重置，可以直接每两次的股票差价进行比较，只要利润大于零就计入总利润，否则就抛弃 12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let totalProfit = 0; let tempProfit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; tempProfit = prices[i] - prices[i - 1]; if (prices[i] - prices[i - 1] &gt; 0) &#123; totalProfit += tempProfit &#125; &#125; return totalProfit;&#125;; 简单多了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础13 遇到的坑]]></title>
    <url>%2F2019%2F01%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8013%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[总结整理了一下一年前使用React开发测评平台时的经验。 总共使用React开发了一个项目，用了1个多月，学到的东西比这一年都多，值得好好总结。 定时任务中的setState如果定时任务触发时，组件已经被销毁，会给出警告 1setState(...): Can only update a mounted or mounting component. 虽然只是一个warning，但是还是证明写的代码不规范，不一定什么时候就埋坑了。 这个问题实质是：setState在异步的callback里执行，而这个时候由于返回上一页，组件已经被销毁了。 用isMounted方法做判断是官方不推荐的方法，而且我也不知道怎么实现。 真正的解决方法应该是在componentWillUnmount中将事件清除或者变量设置为null。 对于setInterval来说需要在componentWillUnmount中clear bind在addEventListener中的使用在组件中添加了scroll事件： 1window.addEventListener('scroll', this.windowScroll.bind(this)); 在componentWillUnmount中想要清除绑定的事件： 1window.removeEventListener('scroll', this.windowScroll.bind(this)); 这样做是不会生效的。 因为bind(this)方法总会返回一个新的函数，所以在removeEventListener时，移除的是一个不存在的、新的函数。 解决方法是在constructor里面对windowScroll一次性绑定this。（这样this.windowScroll变量指向的就是同一个bind之后的方法了。 1234567891011121314151617181920export default class Overview extends React.Component &#123; constructor(props) &#123; super(props); this.windowScroll = this.windowScroll.bind(this) &#125; windowScroll(e) &#123; // do something &#125; componentDidMount() &#123; window.addEventListener('scroll', this.windowScroll); &#125; componentWillUnmount() &#123; window.removeEventListener('scroll', this.windowScroll); &#125; // ... &#125; globalStore中的方法在组件中不能直接调用12345const &#123; globalStore &#125; = this.props;const &#123; setBtnStatus &#125; = globalStore;globalStore.setBtnStatus(); // OKsetBtnStatus(); // 报错 这是因为this指向调用者，前者的this指向globalStore，后者指向window checkbox值不能正确重置在不同题目之间跳转时checkbox值不会清除，原因是在跳转时即使input所在的组件被重新render，但是如果input本身的key没有变化，React就认为这个组件整体没有变化，不会重新渲染，只会对input局部渲染，所以input的value的值就不会重置。 ==只有key值变化，React才会认为组件整体变化，整体渲染== 解决方法是给input加上key的属性，根据页面变化，强制重新渲染，然后在componentWillReceiveProps里面对选中的答案状态进行重置 并且，不能在componentWillUpdate和componentShouldUpdate里面对state的值进行控制，会造成死循环 （2017.07.14更新） 当时查资料的时候对这里理解的不全面，原文的意思是如果key值太简单，例如只有数字序号作为key，当项目发生变化，key值可能不变，React可能会认为是同一个组件而不进行渲染。所以上面提到的： 只有key值变化，React才会认为组件整体变化，整体渲染 不够准确，应该==将key值独一无二化，例如用ID来标识key值==，这样key值不重复，就不会发生不渲染的情况。 （2019.01.22更新） 有两个问题： （1）React中的key并不要求全局唯一，因为key的作用域是==当前列表内==，同一个列表内唯一即可，不同列表、不同组件间都不需要考虑这个问题。 （2）第二个是，key值是加可以在包含input的组件的（由于当时的组件划分的不合理所以只能加在input上）。 当组件上没有key时，传入的Prop发生变化，React会寻求复用，保存组件状态，不会触发Mount系列事件，只会触发Update系列事件; 而如果增加了key，当传入的Prop发生变化也会导致组件重新渲染，所有状态重置 因此就有两个处理方法：一个就是不为组件增加key，而是在更新周期的componentWillReceiveProps中寻求状态重置，另一种就是为组件增加key，有React自动完成重置 前者在逻辑不复杂的情况下是可以使用的，但是如果逻辑比较复杂就会导致大量的逻辑和函数在componentWillReceiveProps中，而后者就一劳永逸了，直接销毁了组件并重建，在componentDidMount中处理重置好，可以参考这篇文章。 其实在Vue中也是相同的原理。 Prop的类型验证和默认值1234567891011export default class Question extends React.Component &#123; // 类型验证 static propTypes = &#123; finishBtnDisabled: PropTypes.bool &#125;; // Prop默认值 static defaultProps = &#123; finishBtnDisabled : false, &#125;;&#125; 对Mobx的Store中的变量赋值12let &#123; spendMinute &#125; = timeStore;spendMinute = 100; 这样是不行的，这是声明了新的变量，有了两种方法: （1）直接引用Store中的变量，这种方法在Mobx的严格模式下第一种方法是不允许的 1timeStore.spendMinute = 100 （2）引用Store中的方法，对变量赋值（推荐） 12345678910111213141516// Store中export default class Mark &#123; @observable spendMinute = 0; @action changeSpendMinute(minute) &#123; this.spendMinute = minute &#125;&#125;// 组件中@observerexport default class Overview extends React.Component &#123; changeMinute() &#123; const &#123; globalStore &#125; = this.props; globalStore.changeSpendMinute(100); &#125;&#125; &lt;div&gt;的blur事件会遇到这样的需求：当标签失去焦点时，将菜单隐藏并触发一些操作，直觉就想到使用focus和blur事件。 但是这两个事件只对form表单控件有效，但是对于&lt;span&gt;、&lt;div&gt;等普通元素并不生效 解决方法就是设置这些元素的tabindex属性，就可以触发焦点事件了。 12345&lt;div onBlur=&#123;this.blurHandler.bind(this)&#125; onFocus=&#123;this.focusHandler.bind(this)&#125; tabIndex="1"&gt; blur&lt;/div&gt; 此外，如果希望点击出现的菜单本身不会在点击自己时，因为blur事件消失，需要将菜单放入被点击事项的子元素中。 DOM事件传参DOM事件传参，事件对象作为最后一个参数并传入到事件处理程序中 1&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 与Vue中是不同的。 Vue中的点击事件传参时，需要手动将$event传入，否则事件处理程序无法访问事件对象。不传参时，事件处理程序默认的参数就是事件对象。 React中的thisReact组件中的this都指向了组件本身，但是为了接受客户端的响应而添加的回调函数，直接添加到了window对象上，再这个函数里面用到的this就指向了window而非React组件。 1234567891011121314151617export default class PCIndex extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; updateCounter: 0, &#125; &#125;; async markPhoto(index) &#123; // ... window.teacherMark = async function(result) &#123; // ... this.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;; &#125; 上面的setState会报错（可怕的是当时使用了Mobx，直接对组件内的属性赋值this.updateCounter++，没有报错而是直接无效） 解决方法有两个，一个是将组件的this缓存下来： 12345678910async markPhoto(index) &#123; const self = this; // ... window.teacherMark = async function(result) &#123; // ... self.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;;&#125; 第二种方法就是改用箭头函数：12345678910async markPhoto(index) &#123; const self = this; // ... window.teacherMark = result =&gt; &#123; // ... self.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;;&#125; 对于this的指向，一定要谨慎！ 循环的问题其实这个问题和React关系不大，还是自己太菜。 有这样的一段代码，要求根据数组成员的某些属性筛选数后，创建一个新的数组，当时的做法啊是：12345678910111213141516171819const questions = [ &#123; hasMarked: true&#125;, &#123; hasMarked: false&#125;, &#123; hasMarked: true&#125;];let markParamAnswer = [];questions.map((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer[index] = &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;; &#125;&#125;);console.log(markParamAnswer[1]); // undefinedconsole.log(markParamAnswer); // [&#123;...&#125;, empty, &#123;...&#125;] 但由于间隔着遍历导致数组，导致结果会形成带有空位的数组，在后面处理的时候出现了bug 当时的改进方案是： 1234567891011121314151617181920const questions = [ &#123; hasMarked: true&#125;, &#123; hasMarked: false&#125;, &#123; hasMarked: true&#125;];let markParamAnswer = [];let i = 0;questions.map((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer[index] = &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;; i++ &#125;&#125;);console.log(markParamAnswer); // [&#123;...&#125;, &#123;...&#125;] 但是现在来看，当时还是太菜，这就是没有code review的缘故，没人指出你的代码有多烂，只能靠自己回过头再看看，发现自己菜的一比。 可以直接用push就行了（2018-11-22）： 12345678910questions.forEach((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer.push(&#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;); &#125;&#125;); 如果数据量不大（因为会遍历两次）的时候可以写成函数式的，更清晰（2019-01-22）： 12345678let markParamAnswer = questions.filter(question =&gt; question.hasMarked).map(v =&gt; &#123; return &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;&#125;); 参考 React setState can only update a mounted or mounting component@stackoverflow react native Warning: setState(…): Can only update a mounted or mounting component.@QCSDN React Checkbox Stays Checked Even After Component is Unmounted@stackoverflow React 实践心得：key 属性的原理和用法]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS56 Generator 函数的异步应用]]></title>
    <url>%2F2019%2F01%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS56%20Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Generator函数实现异步编程，利用的是协程的思想。Generator函数可以将异步流程表示的很简洁，但是流程管理不方便，有两种方式进行Generator函数的自动流程化管理，一种是利用Thunk函数，另外一种是使用Promise对象，二者结合起来就是co模块。 传统方法所谓异步，简单说就是一个任务不是连续完成的，被分成了两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 在JavaScript中，ES6之前，实现的异步编程的方法有四种： 回调函数 事件监听 发布/订阅 Promise 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到回过头重新执行这个任务的时候，就直接调用这个函数。 第二段所需要信息和错误对象，都必须通过参数的形式传递给回调函数，这是因为程序分为两段执行，当第一段执行后，==任务所在的上下文环境就已经结束了==。在这之后的任务信息和抛出的错误，原来的上下文环境已经无法捕获，所以只能当做参数传入。 Promise回调函数本身没有问题，但是当多个回调函数存在的时候，会出现“回调地狱”，形成强耦合，只要有一个操作需要修改，它的上下层函数都要跟着修改 12345fs.readFile(fileA, 'utf-8', function (err, data) &#123; fs.readFile(fileB, 'utf-8', function (err, data) &#123; // ... &#125;);&#125;); Promise对象就是为了解决这个问题而提出的，它不是新的语法功能，而是一种新的写法，将回调函数的嵌套改为链式调用： 123456789101112var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).catch(function (err) &#123; console.log(err);&#125;); Promise的问题是代码冗余，很多的then导致语义不清楚 Generator函数协程的 Generator 函数实现Generator函数实现异步编程，利用的是协程的思想： 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 一段时间后，协程B交换执行权 协程A恢复恢复执行 协程A就是异步任务，分为了多段执行 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面的asyncJob就是一个协程，关键就在于yield命令，当程序执行到此处，asyncJob将执行权交给其他协程 整个Generator函数就是一个异步任务的容器，程序需要暂停的地方都需要使用yidld表达式 Generator之所以能够成为异步编程的旺盛解决方法，除了可以暂停执行和恢复执行之外，还因为Generator函数体内外的==数据交换和错误处理机制==。 上一篇笔记详细学习过Generator的基础知识了，看这里。 异步任务的封装看一个例子： 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); // fetch返回的是Promise对象 console.log(result.bio);&#125; 执行折断代码的方法： 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); Generator函数将异步流程表示的很简洁，但是流程管理不方便，即何时执行第一段、何时执行第二段 Thunk参数的求值策略求值策略关注的是函数的参数到底应该何时求值 有两种求值策略，一种是传值调用，即在进入函数体之前就进行计算，另一种是传名调用，即只将表达式传入函数体，旨在用到的时候求值。 传值调用有可能造成性能的浪费。 Thunk函数的含义编译器的传名调用，是将参数放到一个临时函数中，再将这个函数传入函数体，这个临时函数叫做Thunk函数 1234567var thunk = function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; Thunk函数是传名调用的一种实现，用来替换某个表达式 JavaScript中的Thunk的函数JavaScript中的Thunk函数替换的不是表达式，而是多参数函数，将多参数函数替换为只接受一个回调函数作为参数的==单参数函数==。 123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）const Thunk = fileName =&gt; &#123; return function(callback) &#123; fs.readFile(fileName, callback); &#125;&#125;const readFileThunk = Thunk(fileName);readFileThunk(callback) 任何函数，只要参数有回调函数，就能写成Thunk函数的形式，简单的Thunk函数转换器： 1234567const Thunk = function (fn) &#123; return function(...args) &#123; return fucntion(callback) &#123; return fn.call(this, ...args, callback) &#125; &#125;&#125; 使用： 12const readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback) Generator函数的流程管理Thunk函数可以用于Generator函数的自动流程管理，下面的Generator函数中封装了两个异步操作： 12345678910var fs = require('fs');var thunkify = require('thunkify');var readFileThunk = thunkify(fs.readFile);var gen = function* ()&#123; var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString());&#125;; 在使用Thunk函数管理之前，看一下如何手动执行上面这个函数： 123456789101112131415const g = gen();const r1 = g.next();r1.value(funciton(err, data) &#123; if (err) &#123; throw err; &#125; const r2 = g.next(data); r2.value(function(err, data) &#123; if (err) &#123; throw err; &#125; g.next(data) &#125;)&#125;) 为什么能够在r1.value里面传入一个函数呢？r1.value是第一个yield的结果，也就是readFileThunk(&#39;/etc/fstab&#39;)的结果，它是一个Thunk化的函数，返回值仍是一个函数，参数是回调函数： 123456// 相当于const thunk1 = r1.value;thunk1(function(err, data)&#123; // ...&#125;)) 通过上面的代码可以发现，Generator函数的执行过程，就是将同一个回调函数返回传入next方法返回值的value属性。 这使得我们可以通过递归来自动完成这个过程 Thunk函数的自动流程化管理Thunk函数的真正的威力，就在于可以==自动执行==Generator函数。下面是一个基于Thunk函数的Generator执行器 1234567891011function run(fn) &#123; const gen = fn(); function next(err, data) &#123; const result = gen.next(data); if (result.done) &#123; return; &#125; result.value(next) &#125;&#125; 有了这个执行器执行Generator函数的时候，不管内部有多少个异步操作，直接将Generator函数传入run函数即可（但是前提==每一个异步操作都要是Thunk函数==） 12345678var g = function* ()&#123; var f1 = yield readFileThunk('fileA'); var f2 = yield readFileThunk('fileB'); // ... var fn = yield readFileThunk('fileN');&#125;;run(g); Thunk函数并不是Generator函数自动执行的唯一方案，因为自动执行的关键是，必须==有一种机制，自动控制Generator函数的流程，接受和交换程序的执行权==。 Promise对象也可以代替回调函数做到这一点。 co模块co模块让你不用编写Generator函数的执行器： 12345678910const co = require('co');var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;co(gen).then(() =&gt; &#123;console.log('执行完成')&#125;) co函数返回一个Promise对象，当Generator函数执行完，可以用then方法添加回调函数。 co模块的原理co模块将两种自动执行器（Thunk函数和Promise对象）包装成一个模块，使用co模块的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或者Promise对象（或者数组或对象的成员全都是Promise对象） 基于Promise对象的自动执行同样的例子，将fs模块的readFile方法包装成为一个Promise对象： 12345678910111213141516171819const fs = require('fs');const readFile = function (fileName) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(fileName, (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(data) &#125;) &#125;)&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/filaA'); const f2 = yield readFile('/etc/filaB'); console.log(f1.toString()); console.log(f2.toString());&#125; 然后手动执行上面的函数： 1234567var g = gen();g.next().value.then(function(data)&#123; g.next(data).value.then(function(data)&#123; g.next(data); &#125;);&#125;); 实际上手动执行就是用then方法，层层添加回调函数（原理和前面的基于Thunk函数的自动执行器类似）： 123456789101112131415function run(gen)&#123; var g = gen(); function next(data)&#123; var result = g.next(data); if (result.done) return result.value; result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;run(gen); co模块的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function co(gen) &#123; var ctx = this; // 接受Generator函数作为参数，返回一个Promise对象 return new Promise(function(resolve, reject) &#123; // 检查参数gen是否为Generator函数。 // 如果是，就执行该函数，得到一个内部指针对象 // 如果不是就返回，并将Promise对象的状态改为resolved。 if (typeof gen === 'function') &#123; gen = gen.call(ctx); &#125; if (!gen || typeof gen.next !== 'function') &#123; return resolve(gen); &#125; // 将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。 // 这主要是为了能够捕捉抛出的错误。 onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; // next函数，它会反复调用自身 function next(ret) &#123; // 检查是否为Generator函数最后一步，是的话就返回最终结果 if (ret.done) &#123; return resolve(ret.value); &#125; // 将返回结果转换为Promise对象 var value = toPromise.call(ctx, ret.value); // 确保每一步的返回值，是 Promise 对象。 if (value &amp;&amp; isPromise(value)) &#123; // 使用then方法，为返回值加上回调函数 // 然后通过onFulfilled函数再次调用next函数 return value.then(onFulfilled, onRejected); &#125; // 在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象） // 将Promise对象的状态改为rejected，从而终止执行。 return onRejected( new TypeError( 'You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"' ) ); &#125; &#125;);&#125; 参考 Generator函数的异步应用@ECMAScript6 入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS55 Generator函数]]></title>
    <url>%2F2019%2F01%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS55%20Generator%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Generator函数的基本知识。 简介Generator函数有两个特征： function关键字后面有一个* 函数体内部使用yield表达式 123456function* helloWorldGenerator() &#123; yield 'hello'; yield 'word'; return 'ending'&#125;const hw = helloWorldGenerator() 调用函数后，函数并不执行，返回的也不是函数运行结果，而是指向内部状态的指针对象（即==遍历器对象==） 然后必须调用遍历器对象的next方法，让指针移向下一个状态，直到遇到yidld（或者return）为止。也就是说，yiled是暂停执行的标记，而next方法可以恢复执行： 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 每次调用nexd方法就会返回一个对象，对象有着value和done两个属性，value是yield后面的值，done是一个布尔值，表示便利是否结束。 yiled表达式yield是函数内部的暂停标志，执行逻辑： （1）遇到yiled暂停执行，将其后面的值作为next返回对象的value属性值 （2）下一次调用next方法，继续执行，直到遇到下一个yield （3）如果没有新的yield则运行到return或者函数运行结束 （4）将return的值作为返回对象的value属性值，如果没有return，返回对象的value属性值为undeinfed yield提供了==惰性求值==的功能。 ==yield表达式只能用在Generator函数里面，用在其他地方都会报错==。 与Iterator接口的关系可以将Generator函数赋值给对象的Symbol.iterator属性，从而使得对象具有Iterator接口 12345678910let obj = &#123;&#125;;[...obj]; // Uncaught TypeError: obj is not iterableobj[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...obj] // [1, 2, 3] next方法==yield表达式本身没有返回值==或者说总是返回undefined（这个指的是它在内部对于本身的传递，而非传递给next返回对象的value的属性值） 123456789101112function* f() &#123; let a = yield 100; console.log(a, 'a');&#125;let gen = f();gen.next();// &#123; value: 100, done: false &#125;gen.next();// undefined "a"// &#123; value: undefined, done: true &#125; a的值是undefined next方法可以带一个参数，这个参数会被当做==上一个==yield的表达式的返回值。 123456789101112function* f() &#123; let a = yield 100; console.log(a, 'a');&#125;let gen = f();gen.next();// &#123; value: 100, done: false &#125;gen.next('hello');// hello "a"// &#123; value: undefined, done: true &#125; 这个功能，可以在Generator函数开始运行后，==从外部向函数体内部注入值==，从而调整函数行为。 注意，==next注入的参数改变的是yield表达式的返回值==： 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // &#123; value:6, done:false &#125;a.next() // &#123; value:NaN, done:false &#125;a.next() // &#123; value:NaN, done:true &#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 当执行b.next(12)时，不是给y赋值12，而是yield (x + 1)为12，所以value是8 上面提到了，next的参数是赋值给==上一个==yield表达式返回值，所以在首次调用next传参是==无效==的。 ==第一次执行next方法，等同于启动执行Generator函数的内部代码== for...of循环for...of循环可以自动遍历Generator生成的Iterator对象，不需要再逐步调用next方法 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 要注意的是，==当nextd方法的返回值的done属性为true时，for...of循环就会终止，并且不包括return的值== 除了for...of之外，扩展运算符、解构赋值、Array.from内部都调用的遍历器接口，都可以将Generator函数返回的Iterator对象作为参数。 1234567891011121314151617function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2 Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获 123456789101112131415161718function* f() &#123; try &#123; yield 100; yield 200; &#125; catch(e) &#123; console.log('内部捕获', e) &#125;&#125;const gen = f();try &#123; console.log(gen.next()); // &#123; value: 100, done: false &#125; gen.throw('a'); // '内部捕获, a' console.log(gen.next()); // &#123; value: undefined, done: false &#125; gen.throw('a'); // '外部捕获, b'&#125; catch (e) &#123; console.log('外部捕获', e)&#125; 遍历器对象抛出的错误被Generator函数体内捕获后，Generator函数try语句内的其他语句就==不再继续运行==，并且遍历器对象抛出的其他错误也==不会被Generator函数内捕获==，而是被全局的catch捕获 try语句中抛出错误，try中的其他语句不会在继续执行 ==不要混淆遍历器对象的throw方法和全局的throw命令== 如果函数内部没有部署try...catch代码，遍历器对象抛出的错误会被外部的额try...catch代码捕获 要注意的是，throw抛出的错误要被内部捕获，前提是==必须执行过一次next方法==，因为不执行一次next代码，意味着Generator函数没有启动执行，所以错误会被抛出在函数外部。 遍历器对象的throw方法被捕获后，自动执行了一次next方法，并且只要Generator函数内部部署了try...catch代码，throw方法也不会影响下一次遍历 123456789101112131415function* f() &#123; try &#123; yield 100; yield 200; &#125; catch(e) &#123; console.log('内部捕获', e) &#125; yield 300;&#125;const gen = f();console.log(gen.next()); // &#123; value: 100, done: false &#125;console.log(gen.throw('a')); // '内部捕获, a', &#123;value: 300, done: false&#125; 这种在==函数体内==捕获错误的机制，大大方便了错误的处理，多个yield表达式，可以在函数内部==使用一个try...catch代码块==来捕获错误就可以了。 Generator函数内部的错误，也可以被函数体外的catch捕获，但是==函数内部的代码就不会再继续执行了==，JavaScript认为这个Generator已经==结束运行==了，再调用next方法会返回一个value属性为undefined，done属性为true的对象 Generator.prototype.return()Generator函数返回的遍历器对象有return方法，可以返回给定的值，提前==结束==Generator函数。 12345678910111213141516function* f() &#123; yield 100; yield 200; return 300;&#125;const g = f();g.next()// &#123; value: 100, done: false &#125;g.return(800)// &#123; value: 800, done: true &#125;g.next()// &#123; value: undefined, done: true &#125; return不提供参数，返回值的value属性是undefined。 如果Generator内部有try...finally代码块，且正在执行try代码，return方法会推迟到finally代码块执行完再执行 next、throw、return的共同点三者都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式 next是将yield表达式替换为一个值，throw是将yield表达式替换成throw语句，return是将yield表达式替换为return语句 1234567const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123; value: 3, done: false &#125; next： 123gen.next(1); // Object &#123; value: 1, done: true &#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; throw： 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return： 123gen.return(2); // Object &#123; value: 2, done: true &#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; yield*表达式如果在Generator函数内部调用另外一个Generator函数，默认情况下是无效的 123456789101112131415function* foo() &#123; yield 100; yield 200;&#125;function* bar() &#123; yield 300; foo(); yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 400 ==在Generator函数内部调用另外一个Generator函数需要用到yield*表达式==： 12345678910111213141516171819202122232425function* foo() &#123; yield 100; yield 200;&#125;function* bar() &#123; yield 300; yield* foo(); // 相当于 // yield 100; // yield 200; // 等同于 // for(let v of foo()) &#123; // yield v // &#125; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 100 200 400 yield*后面的Generator函数（没有return语句时）等同于在Generator函数内部部署一个for...of循环 123456789101112131415function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125; 有return语句时，可以通过赋值var value = yield* iterator获取return语句的值，==yield*后面表达式中的return语句作为一个遍历的结果，而不是作为yield*的的返回值== 123456789101112function* foo() &#123; return 1;&#125;function* bar() &#123; const x = yield* foo(); return x;&#125;const gen = bar();gen.next();// &#123; value: 1, done: true &#125; 如果yiled*后面跟着一个数组，会直接遍历这个数组： 123456789101112131415161718192021function* foo() &#123; yield 300; yield [1, 2, 3]; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 [1, 2, 3], 400function* bar() &#123; yield 300; yield* [1, 2, 3]; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 1, 2, 3, 400 实际上，==任何数据结构只要有Iterator接口，就可以被yield*遍历==。 123456const read = (function* () &#123; yield 'hello'; yield* 'hello'&#125;)();read.next().value; // 'hello'read.next().value; // 'h' 作为对象属性的Generator函数可以简写为下面的形式： 12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例： 123456789function* gen()&#123;&#125;gen.prototype.say = function() &#123; console.log('hello')&#125;let obj = gen();obj instanceof gen; // trueobj.say(); // 'hello' 但是==Generator不能作为构造函数使用==，因为它的返回值总是一个遍历器对象，而非this对象（即使显示声明return this也不可以） 1234567function* gen()&#123; this.test = 123;&#125;let obj = gen();gen.test; // undefined Generator函数也不能和new一起使用，会报错。 Generator与协程协程有多个线程（函数），可以并行执行，但是只有一个线程（函数）处在正在运行的状态，其他线程（函数）都处于暂停状态（suspended），线程（函数）之间可以交换控制权。 协程以多占用内存为代价，实现多任务的并行。 Generator函数是ES6对协程的==不完全==实现，成为“半协程”，只有Generator函数的调用者才有权将程序的执行权还给Generator函数（完全协程，任何函数都可以将暂停的协程继续执行） 如果将Generator函数当作协程，可以将多个需要相互协作的任务写作Generator函数，之间==使用yield表达式交换控制权==。 练习 &amp; 应用判断Generator函数输出结果11234567891011121314function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();console.log(genObj.next());console.log(genObj.next('a'))console.log(genObj.next('b')) 思路：next的参数是对上一次的yield表达式返回值赋值，所以拆开来看： 123456function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); // -- genObj.next() &#123;value: undefined, done: false &#125;，此时第二个console.log被暂停了 console.log(`2. $&#123;yield&#125;`); // -- genObj.next('a') &#123;value: undefined, done: false &#125; 第二个console.log执行，传入了a return 'result'; // -- genObj.next('b') &#123;value: 'result', done: true &#125;，最后一个console.log执行，传入了b&#125; 判断Generator函数输出结果2123456789101112131415161718192021222324252627282930313233function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g()); Generator函数内部的错误，如果没有被内部捕获，则会被外部捕获，这时候Generator函数执行完毕，不再继续执行 注意，在内部抛出错误后，next返回值仍为上一次的返回值，并非抛出的结果。 结果： 123456// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 判断Generator函数输出结果3123456789101112131415161718192021222324function* foo() &#123; yield 2; yield 3; return "foo";&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log("v: " + v); yield 4;&#125;var it = bar();console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next()); 要注意的是，被代理的Generator函数的return语句，不再作为next方法的输出结果，而是用来向代理它的Generator函数返回数据 12345678910// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 3, done: false &#125;// v: foo// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125; 判断Generator函数输出结果41234567891011function* genFuncWithReturn() &#123; yield 'a'; yield 'b'; return 'The result';&#125;function* logReturned(genObj) &#123; let result = yield* genObj; console.log(result);&#125;console.log([...logReturned(genFuncWithReturn())]) 需要好好判断顺序，首先genFuncWithReturn()返回了一个迭代器对象，然后传入了logReturned中，按顺序执行，执行了console.log(result)之后，才会执行解构操作，所以顺序是： 12// The result// ["a", "b"] 如果换一种形式输出结果就不同了：123456for (let i of logReturned(genFuncWithReturn())) &#123; console.log(i)&#125;// a// b// The result 关键点就是解构操作符是等到函数执行后再执行的。 让for...of可以遍历原生对象原生的JavaScript对象时候不能使用for...of进行遍历的，因为并没有部署遍历接口。 123456789let obj = &#123; name: 'jay', age: 31&#125;for(let i of obj) &#123; console.log(i)&#125;// Uncaught TypeError: obj is not iterable 使用Generator函数，for...of可以遍历原生对象。 思路：由于原生对象没有部署遍历器接口，所以需要为对象的遍历器接口部署一个Generator函数，返回一个遍历器对象 123456obj[Symbol.iterator] = function* () &#123; let keys = Object.getOwnPropertyNames(this); for(let key of keys) &#123; yield [key, this[key]] &#125;&#125;; 可以编写一个更通用的方法： 12345678function makeIterator (obj) &#123; let keys = Object.getOwnPropertyNames(obj); obj[Symbol.iterator] = function* () &#123; for(let key of keys) &#123; yield [key, obj[key]] &#125; &#125;&#125; 我们之所以能够使用上面的Generator函数，就是因为它的返回结果是一个Iterator对象，这个Iterator对象有next方法，每次遍历时都要调用这个方法，返回的记结果就是包含了value和done两个属性的值 所以，我们不使用Generator函数，自己都构造返回一个具有next方法的对象也是可以的，next方法返回对象也需要包括了value和done连个属性，value属性是for...of的返回值，done用来标识遍历何时结束。 123456789101112function makeIterator (obj) &#123; let keys = Object.getOwnPropertyNames(obj); obj[Symbol.iterator] = function () &#123; let index = 0; return &#123; next() &#123; const key = keys[index] return &#123; value: [key, obj[key]], done: index++ === keys.length &#125; &#125; &#125; &#125;&#125; 第一次调用next方法就能够传值next的参数是赋值给==上一个==yield表达式返回值，所以在首次调用next传参是==无效==的。 构造一个wrapper函数，返回一个Generator函数，实现在第一次调用next方法时就能够输入值。 1234567const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 思路：既然Generator首个next不能传参，那么就在我们的包裹函数中，将首次next调用在包裹函数内执行 1234567const wrapper = function(fn) &#123; return function(...args) &#123; const gnObject = fn(...args); gnObject.next(); return gnObject &#125;&#125; 利用Generator函数和for...of循环，实现斐波那契数列1234567891011121314function* fibonacci() &#123; let [prev, curr] = [0, 1]; for(;;) &#123; yield curr; [prev, curr] = [curr, curr + prev] &#125;&#125;for(let v of fibonacci()) &#123; if(v &gt; 100) &#123; break &#125; console.log(v)&#125; 实现一个clock状态机如果不使用Generator函数： 1234567const clock = (function () &#123; let ticking = true; return function () &#123; console.log(ticking ? 'tick' : 'tock'); ticking = !ticking &#125;&#125;)() 使用Generator函数： 12345678const clock = (function* () &#123; for(;;) &#123; console.log('tick'); yield; console.log('tock'); yield &#125;&#125;)() 输出多维数组中的值123456const numbers = flatten2([1, [[2], 3, 4], 5])numbers.next().value // =&gt; 1numbers.next().value // =&gt; 2numbers.next().value // =&gt; 3numbers.next().value // =&gt; 4numbers.next().value // =&gt; 5 思路就是递归调用Generator函数： 123456789function* flatten(arr) &#123; for(let i of arr) &#123; if (Array.isArray(i) &#123; yield* flatten(i) &#125; else &#123; yield i &#125; &#125;&#125; 要注意的就是，在一个Generator函数里面调用另外一个Generator函数，默认是无效的，所以必须使用yield*表达式来调用 遍历二叉树 对二叉树这里有些迷糊，因为基础不牢固，回头好好不玩了数据结构和算法，再来重新看一下这里（2019.01.17） 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 控制流管理如果一个多步操作非常耗时，采用回调函数，可能会写成下面这样： 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 改写成Promise格式： 123456789Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(value4 =&gt; &#123; // Do something with value4 &#125;, error =&gt; &#123; // catch the error from step1 through step4 &#125;) 改写成Generator格式： 1234567891011function* gen(value1) &#123; try &#123; const value2 = yield step1(value1); const value3 = yield step2(value2); const value4 = yield step3(value3); const value5 = yield step4(value4); // Do something with value4 &#125; catch(e) &#123; // catch the error from step1 through step4 &#125;&#125; 需要一个函数按次序调用： 12345678910scheduler(longRunningTask(initialValue));function scheduler (task) &#123; const taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if(!taskObj.done) &#123; task.value = taskObj.value; scheduler(task) &#125;&#125; 上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。 让Generator函数能够使用newGenerator函数不能和new命令一起用，会报错： 1234567function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 如何让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 12345678910111213141516171819function* gen () &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F ()&#123; // do something here&#125;let f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 实现： 123function F ()&#123; return gen.call(gen.prototype)&#125; 实际上这是一个有欺骗性的做法，实际上new关键字无效的，我们要的只是执行F即可。 1let f = new F(); 而gen.call(gen.prototype)相当于在gen原型上添加了属性，当访问f.a时实际上访问的就是原型链上的属性。 参考 Generator 函数的语法@ECMAScript6入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS54 无法使用Map遍历Array创建的数组的原因]]></title>
    <url>%2F2019%2F01%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS54%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Map%E9%81%8D%E5%8E%86Array%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[介绍了使用Map遍历Array创建的数组失效的原因 原文：Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work作者：shawn.webdev 示例为了便于说明，假设现在需要你生成一个数组，数组由数字 0~99 组成。你会怎么做？下面是一种方案： 1234const arr = [];for (let i = 0; i &lt; 100; i++) &#123; arr[i] = i;&#125; 也许你和我一样，不太喜欢在 JavaScript 中使用传统的 for 循环。实际上，由于像 forEach、map、filter、reduce 等高阶函数的出现，我已经很久没有使用传统的 for 循环了。声明性函数式编程太棒了！ 也许你还没有使用过函数式编程，认为上面的方法已经相当不错了。从技术层面上看没错，但是当你体会到函数式编程的魔力后，你可能就会思考是不是有更好的方法。 我对这个问题的第一反应是，“我可以创建一个长度为 100 的空数组，然后使用 map 遍历数组每个成员的索引！”在 JavaScript 中，我们可以使用 Array 构造函数去创建一个长度为 n 的空数组，就像下面这样： 1const arr = Array(100); 完美，对吧？我们创建了长度为 100 的数组，接下来我只需要 map 遍历每个元素的索引。 12const arr = Array(100).map((_, i) =&gt; i);console.log(arr[0] === undefined); // true 什么情况！数组的第一个元素应该是 0，但实际上是 undefined。 原理为了解释上面的现象，我必须介绍一个重要的技术特性。在 JavaScript 内部，数组就是用数字作为键名的对象。比如： 1['a', 'b', 'c'] 本质上它等于下面的对象： 123456&#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125; 当访问数组中索引 0 的元素时，实际上访问的是对象中键名为 0 的属性的键值。这很重要，因为当你把数组作为对象看待，再结合高阶函数的运行原理，上面的问题就很好理解了。 当你使用 Array 构造函数创建了一个新的数组时，实际上是创建了一个新的数组对象，它的 length 属性等于你传给 Array 的参数，除此以外，这个对象是一个空对象。对象中并没有数组对应的索引键（index key）。 1234&#123; //no index keys! length: 100&#125; 当你试图访问索引值为 0 的数组成员时，访问结果是 undefined，但这不是因为在索引键为 0 的位置存储的值是 undefined，而是因为 JavaScript 规定，当访问一个对象中并不存在的键名对应的键值时，会返回 undefined。 当 map、reduce、filter、forEach 等高阶函数沿着 0 到数组长度的索引键遍历数组对象时，就会发生上面的现象，但是只有当对象的键值存在时，回应的回调函数才会执行。所以，当我们使用 map 对数组遍历时没有执行回调函数–就是因为索引键并不存在。 解决方法正如你所了解的，我们需要的是这样的数组，它内部对应的对象形式包含着从 0 到数组长度的每一个键值。最好的办法就是将数组展开到另一个空数组中。 123const arr = [...Array(100)].map((_, i) =&gt; i);console.log(arr[0]);// 0 将数组展开到一个空数组后会生成一个新数组，它每个成员都是 undefined： 12345678&#123; 0: undefined, 1: undefined, 2: undefined, ... 99: undefined, length: 100&#125; 这是因为，扩展运算符比 map 方法更简单。它对数组（或者任何可遍历对象）进行从 0 到数组长度的简单循环，在当前的索引处，根据展开后的数组返回值，生成一个新的索引键。而 JavaScript 对展开数组的每一项都会返回 undefined （记住，这一些都是默认行为，因为访问的值对应的索引键并不存在），我们就得到了一个新的数组，数组成员都具备了索引键，因此是可以使用 map 进行遍历的了（同样也可以使用 reduce、filter、forEach 进行遍历） 结论我们发现了在 JavaScript 中数组的内部实质上就是对象，学习了创建任意长度、任意填充值的数组的最好的额办法。 同以往一样，在下面留下您的评论、疑问和反馈吧！ 编程愉快！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Array</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重学前端》的学习笔记]]></title>
    <url>%2F2019%2F01%2F18%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F01%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B402%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[极客时间的专栏《重学前端》的学习笔记，持续更新中。 开篇词 | 从今天起，重新理解前端前端开发之痛：散点自学 + 基础不牢，对于前端的知识体系和底层原理没有真正系统地理解 关于前端工程师成长需要两个视角： （1）立足标准，系统性总结和整理前端知识，建立自己的认知和方法论； （2）放眼团队，从业务和工程角度思考前端团队的价值和发展需要。 除此之外，前端工程师还需要了解程序员通用的编程能力和架构能力。 01 | 明确你的前端学习路线与方法两个前端学习方法： （1）建立知识架构 将零散的知识组织起来，也能帮助我们发现知识上的误区 （2）追本溯源 关注某个知识点背后的体系 03 | HTML语义：div和span不是够用了吗？语义类标签的特点是在视觉表现上都差不多，主要区别在于表示了不同的语义。 语义标签的好处：（1）增强网页结构可读性；（2）更适合SEO和读屏软件 语义标签用不好会造成大量的冗余标签，所以“用对”比“不用”好，“不用”比“用错”好 比较重要的语义标签适用场景： （1）作为自然语言延伸的语义类标签，例如&lt;ruby&gt;、&lt;rt&gt;、&lt;rp&gt; （2）作为消除歧义的标签，例如表示重音的&lt;em&gt; （3）作为标题摘要的标签，例如&lt;h1&gt;、&lt;hgroup&gt;、&lt;section&gt; （4）作为整体结构的语义类标签。例如&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;address&gt; 123456789101112131415&lt;body&gt; &lt;header&gt;……&lt;/header&gt; &lt;article&gt; &lt;header&gt;……&lt;/header&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; &lt;article&gt;……&lt;/article&gt; &lt;article&gt;……&lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; 04 | HTML语义：如何运用语义类标签来呈现Wiki网页？用Wiki的一个页面举例，学习了语义化标签的使用。 这一节介绍到的语义化标签有： aside，导航性质的工具内容 article，有明确独立性的主体部分 hgroup/h1/h2，一个标题组中的各级标题 abbr，缩写的词语都应该使用abbr标签 hr，横向分割线，但是表示故事走向或话题的转变，如果是单纯的视觉效果不应该使用这个标签 strong，强调的 blockquote，段逻辑的引述内容 q，行内的引述内容 cite，引述的作品名 time，日期，让机器阅读更方便 figure/figcaption，与著文章先骨干的、有一定自包含性的内容，都可以用figure包裹，可以是图片、表格、代码等，figcaption是这些内容的标题 dfn，包裹被定义的名字，例如：&lt;dfn&gt;程序员&lt;/dfn&gt;就是写程序的人 nav，目录导航 ol/ul，二者的区别是内容是否有顺序关系，不要因为视觉表现夏鸥改变语义 pre，表示其中的内容是预先经过排版的，不需要浏览器干预排版（保留了原来的缩进格式） samp：计算机程序的实例输出 code：代码，和samp一样，一般都是包裹在pre之中 还有一些其他的标签： date，类似于time，给及其阅读的内容 sub/sup，下标/上标，多用于数学、物理、化学领域 menu，ul的变体，用于功能菜单使用 main，整个页面出现一个，表示页面的主要内容，可以理解为特殊的div 语义化标签非常多，并且不像严谨的编程语言一样，有一条非此即彼的线。一些语义的引入会带来争议，所以应该尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签，保证语义不被滥用，不带来更多问题。 05 | JavaScript类型的细节类型JavaScript中定义了7种类型： Undefined Null String Number Boolean Symbol Object Undefined/NullJavaScript中的undefined是一个变量，而非一个关键字。任何变量在赋值之前都是Undefined类型，值为undefined，是一个全局变量，所以有： 12345undefined === undefined; // truelet a;let b;a === b; // true void运算的作用是将一个表达式变为undefined： 12345let a = void 0;a; // undefinedlet b = void &#123;&#125;;b; // undefined 一般不会将变量赋值为undefined，保证所有值为undefined的变量都是从未赋值的自然状态 Null类型也只有一个值null，所以有： 1null === null; // true Null语义是定义了，但是为空，这与Undefined是不同的 StringString的最大长度是2^53-1，这个长度指的不是字符数，而是字符串的编码长度 字符串操作charAt、charCodeAt、length针对的都是UTF16编码 UTF是Unicode的编码方式，一个Unicode码点表示一个字符，通常用U+????来表示，其中????是十六进制的码点值，0-65536（U+0000-U+FFFF的码点被称为基本字符区域 在JavaScript中的表示： 1'\u0031'; // 1 JavaScript字符串把每个UTF16单元当做一个字符串来处理，所以处理超出自己字符区域的字符时需要格外小心。 感觉阮一峰关于字符编码的知识讲的更加详细。 NumberNumber类型符合IEEE754-2008规定的双精度浮点数规则，但是为了表达几个额外的语言场景，规定了几个例外情况 NaN Infinity，无穷大 -Infinity，负无穷大 Infinity和-Infinity是为了不让除以0出错而引入的 JavaScript中有0和-0的区别，加法类运算没有区别，除法场合需要留意区分，区分的方式就是检测用作除数的结果，是Infinity还是-Infinity 121/-0 ===-Infinity; // true1/0 ===Infinity; // true 由于浮点数运算的精度问题，导致非整数得Number不能直接比较： 10.1 + 0.2 === 0.3 // false 正确的比较方法是使用JavaScript提供的最小精度之Number.EPSILION 1Math.abs(0.1 + 0.2 - 0.3) &lt; Number.EPSILION // ture ==检查等式左右两边的差是否小于最小精度==，才是正确的比较浮点数的方法。 SymbolSymbol是一切非字符串的类型key的集合，使用全局的Symbol函数创建Symbol 1var mySymbol = Symbol("my symbol"); 一些特殊的属性可以在全局的Symbol函数的属性中找到，比如可迭代对象的迭代器就定义在了Symbol.iterator属性上 12345678910111213let o = &#123;&#125;;o[Symbol.iterator] = function* () &#123; let index = 0; while(index &lt; 10) &#123; yield index++ &#125;&#125;;for(let i of o) &#123; console.log(i)&#125;// 0 1 2 3 ... 9 更多的内容需要专门学习。 Object提出了一个问题，为什么给对象添加的方法能够用在基本类型上？ 1234Number.prototype.say = function () &#123; console.log(123)&#125;;(123).say(); // 123 ==这是因为.运算符提供了封箱操作，它会根据基本类型构造一个临时对象，使得我们能够在基本类型上调用对应的对象的方法。== 类型转换封箱转换把基本类型转换为对应的对象，装箱独享都有私有的Class属性，可以用Object.prototype.toString来获取。 JavaScript中没有任何办法可以更改私有的class属性，因此Object.prototype.toString是可以准确识别对象对应的基本类型的方法 拆箱转换ToPrimitive函数是对象类型到基本类型的转换，对象到String和Number的转换都遵循“先拆箱再转换”的规则，拆箱转换会调用valueOf和toString类获得拆箱后的基本类型 转换为数字时首先调用valueOf，转换为字符串时首先调用toString ES6中可以通过显示指定Symbol.toPrimitive来覆盖原有行为 06 | JavaScript对象：面向对象还是基于对象JavaScript中的对象与其他语言的对象有一些不同之处，例如： JavaScript在ES6以前没有类的概念 JavaScript对象可以自由添加属性，其他语言不能 到底什么是面向对象？ 面向对象是顺着人类思维模式产生的一种抽象，从人类认知角度，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西 人的智力可以理解的东西 可以指导思考或行动（进行想象或施加动作）的东西 JavaScript没有采用C++、Java等流行的编程语言采用的“类”的方式来描述对象，而是采用了一个更为冷门的方式“原型”来描述对象 但是由于公司正值原因，JavaScript推出时在“原型运行时”的基础上增加了new、this的特性，使之看起来更像Java。 对象的特点对象有如下的特点： （1）对象具有唯一标识性：即使完全相同的两个对象，也并非一个同一个对象 对象的唯一标识性是用内存地址来体现的，对象具有唯一标识的内存地址 123var o1 = &#123; a: 1 &#125;;var o2 = &#123; a: 1 &#125;;console.log(o1 == o2); // false （2）对象有状态：对象具有状态，同一个对象可能处于不同状态之下 （3）对象具有行为：对象的状态，可能因为它的行为产生变迁 第二个和第三个特征“状态”和行为，在JavaScript中统一抽象为“属性”（因为JavaScript中函数也是一个特殊的对象） JavaScript在实现对象基本特征的基础上，JavaScript对象独有的特色是：==对象具有高度的动态性，这是因为JavaScript赋予了使用者在运行时为对象添改状态和行为的能力==。 JavaScript对象的两类属性JavaScript对象的属性并非只是简单的键值对，而是用一组特征来描述属性 第一类是数据属性（descriptor），有四个特征：value/writable/enumerable/configurable 第二类是访问器属性，也有四个特征（setter/getter/enumerable/configruable 访问器属性使得使用者在读和写属性时，可以执行代码得到不同的值，可以视为一种函数的语法糖 通常定义属性的代码会产生数据属性的value特征值，其他的数据属性的特征值默认为true，使用Object.getOwnPropertyDescripter可以查看数据属性特征值，使用Object.defineProperty可以改变数据属性特征值和访问器属性 在创建对象时，可以使用get和set关键字阿里创建访问器属性： 1234567var o = &#123; get a() &#123; return 1 &#125; &#125;;console.log(o.a); // 1 对象是一个属性的索引结构，key是属性名，属性值是一系列描述属性的集合 123456&#123; value: 1, writable: true, enumerable: true, configurable: true&#125; JavaScript提供了完全运行时的对象系统，可以模仿多数面向对象的编程范式，比如基于类和基于原型，但是由于它的对象系统是独特的、具有高度动态性的对象系统，这让它与其他面向对象的语言不通 07 | JavaScript对象：我们真的需要模拟类吗早期JavaScript的模拟面向对象，实际上是模拟基于类的面向对象 而JavaScript的面向对象本质上是基于原型的，而由于历史原因，不得不加入了new、this等语言特性来模拟类 JavaScript的原型复制操作采用了引用的思路：一个对象并不是真的去复制一个原型对象，而是使得新对象持有一个原型的引用 原型系统用两条概括原型系统 对象通过私有字段[[proto]]连接到其原型 读取一个属性，如果对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止 ES6提供了一些列内置函数，可以更方便的访问、操作原型，使用这三个方法，可以完全抛开类的模拟，直接利用原型来实现抽象、继承和复用。这三个方法是： Object.create(a, b)，根据指定的原型（a）创建新对象，原型可以是null，b是新对象的描述属性（数据属性） Object.getPrototypeOf获得一个对象的原型（等同于直接获取对象的__proto__属性） Object.setPrototypeOf设置一个对象的原型（等同于直接设置对象的__proto__属性） 用构造函数模拟类我们现在用来判断类型的最准确的方法Object.prototype.toString获得的结果[object xxxx]，实际上就是早期版本的“类”的概念，它原本是一个私有属性[[class]]，从ES5开始，[[class]]被Symbol.toStringTag定义，而Object.prototype.toString的结果可以使用Symbol.toStringTag定义： 12var o = &#123; [Symbol.toStringTag]: "MyObject" &#125;;console.log(Object.prototype.toString.call(o)); // [object MyObject] 用构造函数模拟类，关键就是使用new运算符，当我们对一个构造函数执行了new操作，实际上发生了一下几件事： 1234567let p = new Person();// 实际上let p = &#123;&#125;;p.__proto__ = Person.prototype;Person.call(p);return p new运算的返回值默认返回this，但显式的返回值时，如果返回值的是==基本类型==，则忽略返回值，仍然返回this，如果返回值是==引用类型==，则直接返回该返回值作为对象的结果 new的行为，视图让函数对象在语法上跟类变得相似，它客观上提供了两种范式，一种是在构造器中的this上添加实例属性，另外一种是在构造器的prototype原型对象上添加原型属性 在早期没有Object.create等方法的早期版本中，new是唯一一个可以指定[[proto]]的方法（直接访问__proto__是不被推荐在生产环境使用的） 下面是Object.create简单的Polpyfill： 12345function create (prototype) &#123; function F() &#123;&#125; F.prototype = prototype; return new F()&#125; ES6中的类classES6中的class用一种看起来更符合主流意义上的类的形式来模拟JS中的类，但本质上还是利用原型系统实现继承和复用，只不过用class代替了new和function的搭配，看起来更协调而已。 推荐使用ES6的语法来定义类，令function回归原本的函数语义。 ES6中引入的class关键字，意味着类的概念从属性升级为语言的基础设施，从此，基于类的编程方式成为了JavaScript的官方编程范式。 在类中通过get/set关键字创建getter/setter，类中定义的方法和属性会被写在原型对象上，数据型成员最好写在构造器里面： 1234567891011121314class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; // Getter get area() &#123; return this.calcArea(); &#125; // Method calcArea() &#123; return this.height * this.width; &#125;&#125; 类的写法实际上也是由原型运行时来承载的（我认为是原型系统的一种语法糖），逻辑上JavaScript认为每个类是有共同原型的一组对象。 类通过extends提供了继承能力： 12345678910111213141516171819202122class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); // call the super class constructor and pass in the name parameter &#125; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;let d = new Dog('Mitzie');d.speak(); // Mitzie barks. 比起早期的继承方式，extends关键字自动设置了constructor，并且会自动调用父类的构造函数，是一种更少坑的设计。 所以当我们使用类的思想来设计代码时，应该尽量使用class来声明类，而不是用旧语法，拿函数类模拟对象 （但是我认为，可以使用新的语法，但是如果不搞清楚本质还是不行的，需要弄清楚JavaScript实现继承和复用的根本原理，搞清楚JavaScript中原型链的原理，这是根本） （这一节的内容实际上信息量很大，讲述的是JavaScript中最基础、最精华的部分，设计能力的提高离不开这部分基础，之前自己总结过相关的笔记《Javascript面向对象编程2–构造函数的继承》，需要反复的思考和复习，打好基础） 08 | JavaScript对象：你知道全部的对象分类吗？ 这两天，offer的事情有了着落，又刚过完年回来，工作又闲的冒泡，自我驱动能力大幅下降，有点控制不住自己了 关于这一章的内容，实际上是比较复杂且深奥的，需要好多储备知识才能大概理解，而前几章我一直有一个不太满意的点，就是感觉作者的思路，或者说是语言组织，有一种故作高深的感觉，把简单的东西搞的很复杂的样子，把不好理解的知识用一些更不好理解的语言讲解，让人理解起来更加费劲，而且思路常常碎片化。 比较之下，更显得阮一峰的难得，举重若轻，平易近人，这才是我学习的榜样。 可以把对象分成几类： （1）==宿主对象==，有JavaScript宿主环境提供的对象，它们的行为完全由宿主环境决定 （2）==内置对象==，有JavaScript语言提供的对象，包括： 固有对象，有标准规定，随着JavaScript运行时创建而自动创建的对象实例 原生对象，可以由用户通过Array，RegExp等内置构造器或者特殊语法创建的对象 普通对象，由{}、Object构造器或者class关键字创建的对象，能够被原型继承 宿主对象JavaScript中常见的宿主对象就是浏览器提供的宿主对象，在这个宿主对象中，全局对象是window，window上有很多属性，比如document 实际上，window对象上的属性一部分来自浏览器环境，另外一部分来自JavaScript语言（JavaScript的标准中规定了全局对象属性） 宿主对象也分为固有的和用户可创建的两种，比如document.createElement就可以创建一些dom对象 宿主也会提供一些构造器，比如可以使用new Image创建&lt;img&gt;元素 内置对象·固有对象固有对象在任何JavaScript代码执行前就已经被创建出来了，它们通常扮演者饿类似基础库角色，ECMA中规定的固有对象有150+个 内置对象·原生对象我们将JavaScript中，能够通过语言本身的构造器创建的对象作为原生对象。JavaScript提供了30多个构造器，可以分成以下几类： 可以使用new运算符调用构造器创建新的对象，这些构造器的能力是原生的（即无法用纯JavaScript代码实现的），也无法用class/extend来继承的 这些构造器创建的对象多数使用了私有字段，例如Error: [[ErrorData]]、Boolean: [[BooleanData]]等，这些字段使得原型继承方法无法正常工作，所以可以认为，这些原生对象都是为了特定能力或性能，而设计出来的“特权对象” 用对象来模拟函数与构造器：函数对象和构造器对象JavaScript为用来模拟函数与构造器的对象预留了私有字段，并据此规定了抽象的函数对象和构造器对象的概念 函数对象的定义是，具有[[call]]私有字段的对象 构造器对象的定义是，具有[[construct]]私有字段的对象 JavaScript用对象模拟函数的设计代替了一般的编程语言中的函数，它们可以像其他语言的函数一样被调用、传参。任何宿主，只要提供了“具有[[call]]私有字段的对象”，就可以被JavaScript的函数调用的语法锁调用 [[call]]私有字段必须是一个引擎中定义的函数，需要接受this值和调用参数，并且会产生域的切换。 任何对象只需要实现[[call]]，它就是函数对象，可以作为函数被调用。如果它能够实现[[construct]]，它就是构造器对象，可以作为构造器被调用。 宿主对象和内置对象的表现对于宿主对象和内置对象来说，他们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器调用）也不总是一致。比如内置对象Date作为构造器调用时产生新的对象，作为函数时则返回字符串 12345typeof Date()// "string"typoeof new Date()// "object" 在浏览器宿主环境中提供的Image构造器，则根本不允许被作为函数调用： 12345new Image()// &lt;img&gt;Image()// Uncaught TypeError: Failed to construct 'Image': Please use the 'new' operator, this DOM object constructor cannot be called as a function. 基本类型（String、Number、Boolean）作为构造器时返回对象，作为函数调用时则产生类型转换的效果。 ==注意的是，ES6的箭头函数创建的仅仅是函数，而不能作为构造器使用。== 使用function创建的函数的行为当使用function关键字或者使用Function创建的函数必定同时是函数和构造器，它们执行同一段代码，但是表现出来的行为效果却不相同。 以前遇到过面试题，题目的中心思想就是如何判断一个函数是作为构造函数调用，还是作为普通函数被调用。两种行为的结果是不同的，进行判断的话就需要搞清楚new调用构造函数时发生了什么： 创建一个新的对象{} 实现原型链的继承 将构造函数的作用域赋给新对象（因此this对象就指向了新对象） 执行构造函数的代码 返回新对象（构造函数调用默认返回this，但显式的返回值时，如果返回值的是基本类型，则忽略返回值，仍然返回this，如果返回值是引用类型，则直接返回该返回值作为对象的结果） 所以要判断我认为只需要在函数内部判断this是否是该函数的实例即可。 对象的特殊行为在固有对象和原生对象中，有一些对象的默写行为与正常对象有很大区别，主要是下标运算（即使用中括号或者.来做属性访问）和设置原型继承 主要有： Array： Array的length属性根据最大的下标自动发生变化 String：String的正整数属性访问会去字符串里查找 arguments：arguments的非负整数型下标跟对其函数父对象的输入的变量联动 Object.prototype：作为所有正常对象的默认原型，不能在设置原型了（这就是语言的规定，Object.prototype.__proto__ === null，没有为什么） 模块的namespace对象：特殊的地方非常多，跟一般对象完全不用了 一个练习不使用new运算符，极可能找到获得对象的方法 1234567891011let o = &#123;&#125;;const o = function()&#123;&#125;;let o = Object.create(Object.prototype);let o = Object.assign(&#123;&#125;)class o &#123;&#125;let o = JSON.parse('&#123;&#125;')]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》的学习笔记]]></title>
    <url>%2F2019%2F01%2F18%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F01%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B401%20%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%2F</url>
    <content type="text"><![CDATA[极客时间的专栏《左耳听风》的学习笔记，持续更新中。 01 + 02 | 程序员如何用技术变现 程序员用手艺、技术养活自己，不依靠公司； 提高工作效率，去研究那些难的，公司内外的核心技术； 注重输出，输出技术、价值观，帮助更多的人，提高影响力。 如何做？ 积少成多，形成正向循环 关注有价值的东西，关注市场市场需求和技术趋势 在学习技术的过程一定要多问自己两个问题：“一，这个技术解决什么问题？为什么别的同类技术做不到？二，为什么是这样解决的？有没有更好的方式？” 找到最能体现价值的地方，技术人员在高速发展的公司价值可以最大化 加强动手能力，了解细节才能提出更好、更靠谱、可以落地的解决方案 关注技术付费点：①帮别人挣钱；②帮别人省钱 提升自己的能力和经历 找到有价值的信息源，提升英文能力，利用好Google 输出观点和价值观，这不容易，需要积累和经历，厚积薄发 真正伟大的公司和价产品都是要输出价值观的 朋友圈很重要 ==最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱不用还在那里，时间不用就浪费掉了。把时间投资在哪些地方，意味着未来会走什么样的路。== 03 - 04 | 从Equifax信息泄露看数据安全攻击的实现： 利用程序框架或者库的漏洞 暴力破解密码，撞库 代码注入，SQL注入，XSS攻击，CSRF攻击 利用程序日志意外泄露的信息 数据管理的问题： 一层防护 弱密码 内部系统暴露在公网 系统不及时打补丁 安全日志被暴露 保存不必保存的敏感信息 密码没有被合理地散列 安全最佳实践 了解使用了哪些框架和库，关注其安全性声明 建立能够快速部署安全补丁的发布流程 依赖的软件都有可能有安全性漏洞，建立安全策略时要考虑 建立多个安全层 建立对异常访问模式的监控机制 技术上的安全做法: 隔离关键数据到高安全级别的地方 敏感数据只进不出，提供对外服务接口操作数据 业务上需要返回的关键数据需要在传输层加密并且隐藏部分信息 用户加密算法需要非对称加密，密钥自动更换 被加密的数据和用于加密的密钥是由不同的人来管理，相互牵制 信息泄露需要做到通知，并限制外部系统的数据访问量 05 | 何为技术领导力何为技术领导力？ 尊重技术，追求核心基础技术 不断追求效率的提高： 工具自动化 组织架构的高效运转 人员的高效工作 开发可复用组件 坚持高于社会主流的技术标准和要求 如何拥有技术领导力？ 能够发现现有方案的问题 能够提供解决问题的思路和方案，并能比较这些方案的优缺点 能够做出正确的技术决定和技术选择，完成一个项目 能够更优雅、更简单、更容易的方式解决问题 能够提高代码的质量（扩展性、复用性、可维护性） 能够用正确的方式管理团队（人尽其用、提高效率） 有创新能力 ==总是在提供解决问题的思路和方案的人才是有技术领导力的人== 努力方向： 扎实的基础技术 非同一般的学习能力 坚持做正确的事 不断提高对自己的要求标准 06 | 如何才能拥有技术领导力（1）吃透基础技术 基础技术可以分为两部分：==编程和系统== 编程部分：C语言，编程范式，算法和数据结构； 系统部分：计算机系统原理，操作系统原理和基础，网络基础，==数据库原理==，分布式技术架构 （结合自身情况和职业，我认为加粗的几个部分可能是作为前端工程师的我来说是优先级更高的基础技术） （2）提高学习能力，能够很快的学习新技术，==又能在关键技术上深入==的能力 学习的信息源（英文搜索更接近最新的知识） 与高手交流 举一反三的思考 不怕困难的态度 开放的心态 （3）坚持做正确的事 提高效率的事 自动化的事 掌握前沿技术的事 知识密集型的事 技术驱动的事 （4）高标准要求自己，不断地反思、总结和审视自己 07 | 推荐阅读：每个程序员都该知道的知识每个程序员都应该要读的书： 《代码大全》，有点过时，但很经典 《程序员修练之道》，指路明灯 《计算机的构造和解释》，经典中的经典 《算法导论》，美国的本科生教材 《设计模式》，指路明灯 《重构》，代码重构最佳时间 《人月神话》，有点过时，但很经典 《代码整洁之道》，细节指出的效率，完美和简单 每个计算机专业的学生应该有的知识：（1）作品集（项目经历、开源软件的贡献、网址）比简历更重要 （2）与人交流的技巧（写演示文档、辩论能力） （3）硬技能（太多了，毫无目的的学习恐怕要耗费数年，必须有的放矢吧？） LinkedIn 高效的代码复查技巧提出做Code Review要求对提前的代码写说明文档，既可以方便做Code Review的人了解代码背景，又可以让写代码的人重新回头梳理代码 并且除了给出修改意见之外，也允许给出正面鼓励的评价 给出的Code Review写出有目的性的注释，比如“消除重复代码”、“增加测试覆盖率”等 不光要Review代码，还要Review对应的测试 还有给出的两篇文章，感觉不是我现在能吸收的，能把前边的书单完成，就是一个大的成就了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点感想]]></title>
    <url>%2F2019%2F01%2F18%2F02%20%E5%81%B6%E5%B0%94%E8%AE%B0%E5%BD%95%2F2019%2F2019.01.18%20%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[突发而来的一点感想。 这一段时间的经历，让我对自己的现状和不足有了一个更清醒的认知，那就是： 学习能力不错，但是由于客观情况导致的前端乃至计算机基础薄弱； 前端知识点的深度有所加深，但还是没有能连成片； 过于依赖的强推动去提高自己，发现问题、发现痛点的主观能动性差 针对这些，我2019年的努力方向就是： 继续自我驱动，不断学习 继续之前定下的“基础扫盲三部曲”的第三步，体系化的学习算法和数据结构 有意识的去记录身边、开发过程中的难点、痛点，想办法解决问题，提高自己发现问题的能力，从解决自己的小问题开始，正确能够从更高层面，解决团队、公司的问题 对新技术保持好奇，对新技术的了解、学习、实践不拖延。 按照计划一步一步来吧，沉着一点，少点焦虑，多点坚定。 加油。]]></content>
      <categories>
        <category>偶尔记录</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习49 判断美元符号格式]]></title>
    <url>%2F2019%2F01%2F15%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A049%20%E5%88%A4%E6%96%AD%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用正则表达式判断美元符号格式的练习题，以及使用正则表达式为数字添加千分符 知识点正则表达式 题目完成一个函数isUSDFormat返回true/false来判断一个字符串是否符合美元格式： 以$开头 如果是小数，保留两位小数；如果不是小数则不显示小数部分 整数部分从小数点上一位开始每隔三位用,分割开来 如果整数部分从数字0开始，则只会显示一位0 例如： 1234567isUSDFormat('$1') // =&gt; trueisUSDFormat('$1.0') // =&gt; falseisUSDFormat('$100,000.00') // =&gt; trueisUSDFormat('$0,000.00') // =&gt; falseisUSDFormat('$0.00') // =&gt; trueisUSDFormat('$11,23,345.33') // =&gt; falseisUSDFormat('$1,123,345.33') // =&gt; true 实现这道题目和之前在面试中遇到过的为数字添加逗号的问题有一点点类似，先来看这道题目。 正则表达式是非常强大的，如果不用正则表达式，需要在函数里面进行拆分判断，所以还是需要多练习正则的使用 这道题，我又没有做出来，还是水平太低，看了讨论区的答案，好好分解一下： 实现，要判断的格式分为三个部分，就是$加上整数部分再加上（肯能存在的）小数部分： 1/^$(整数部分)(小数部分)?$/ 先看比较容易的小数部分，小数部分如果存在时，构成就是小数点加上两位数字，所以： 12// 小数部分/\.\d&#123;2&#125;/ 再来看整数部分，整数部分大体上可分为两种情况，情况1是以0开始，情况2就是不以0开始，那么两种情况可以用|来分割，两种情况都是满足要求的： 12// 整数部分((情况2)|0) 再来看情况2，它有两个要求，首位不能是0，并且从末尾（单词结束或者小数点位置）起每三位用,分割，所以情况2为： 1/[1-9]\d&#123;0,2&#125;(,\d&#123;3&#125;)*/ 上面表达的意思就是第一位是非0的整数，然后接着的数字可能是0，1，2三种，也就是说三面这一半匹配了x/xx/xxx三种形式的数字，后面如果再有数字的话就是后面括号中的内容，必须接着一个逗号和三位数字，当然这部分也可以没有，所以用*来限制数量 所以拼接到一起就是： 1const isUSDFormat = str =&gt; /^\$([1-9]\d&#123;0,2&#125;(,\d&#123;3&#125;)*|0)(\.\d&#123;2&#125;)?$/.test(str) 为数字添加逗号说说拿到面试题，很简单，就是使用正则为一个数字，从右向左每三位添加一个, 这道题目我当时没有用直接用正则做出来，因为我觉得正则是从左至右进行判断，而现在是从右至左添加，所以不知道怎么搞。 我当时的做法就是将字符串反转后进行添加，添加完了再反转回去。 如果不采用这种形式怎么实现呢？ 首先要了解一下在正则中的先行断言 先行断言是是用来判断位置的，比如x(?=y)，代表的是如果x后面跟的是y，那么就匹配x，在xyz中，匹配结果就是x，不包括y，因为y是作为先行断言进行判断位置的。 与先行断言对应的就是后行断言(?!)，比如x(?!y)表示后面不是y才会匹配x，所以xyz中的x就不会被匹配，而xzy中的x会被匹配 然后再来看一下我们要用到的\b和\B，它们是用来匹配位置的（注意是匹配，而不是判断），\b匹配的是单词边界，而\B正好相反，也就是匹配非单词边界的位置 我的理解是，比如123，\b匹配是1之前和3之后的位置，\B匹配的是1和2以及2和3之间的位置 1234 1 2 3 | | | | | | | | \b \B \B \b 那么如果用replace方法对\b和\B的匹配进行替换是什么效果呢？ 123let a = '123'.replace(/\b/g, '!')a // "!123!" 实现了添加的效果，因为被我们替换掉的是一个位置，而非一个字符。这就是我们能够使用replace实现需求的原因。 然后来看具体的正则表达式，以12345举例 我们首先要明确，要匹配的就是一个位置，这个位置将被替换为,，这个位置的特殊性是它后面应该跟着3个数字 到目前位置我们的正则表达式就是： 1/\B(?=(\d&#123;3&#125;))/ 上面，\B匹配非单词边界，匹配的结果将是12/23/34/45各自数字之间的位置 然后后面通过一个先行断言对\B进行了约束，那就是这个位置后面必须跟着3个数字，那现在匹配的结果就是12/23之间的位置了，都可以满足要求 实际上12之间后面跟着3个数字，3个数字后面又跟着一个数字，而我们要的不是这样，它后面需要是单词的结束（或者说是单词的边界），所以需要在后面增加另外的位置判定（$或者\b） 1/\B(?=(\d&#123;3&#125;)\b)/ 这样就能正确12345，而对于12345123456，可能有多个符合条件的先行断言位置要匹配，所以需要增加量词+ 1/\B(?=(\d&#123;3&#125;)+\b)/ 我之前理解错了，以为是有多个\B要匹配，+应该加在最外层的括号外边，其实不是，多个\B要匹配是replace的g完成的 所以最后的结果是： 1const reformat = str =&gt; str.replace(/\B(?=(\d&#123;3&#125;)+\b)/g, ',') 这只是对整数部分的处理，如果有小数部分，我没想到怎么直接用正则一次搞定，还是需要先判断是否有小数，然后将整数部分分割出出来单独处理，然后再把小数部分拼接上。 参考 #87 判断美元符号格式@ScriptOJ 正则表达式-数字每隔3位加入逗号@MDN 正则表达式/\B(?=(\d{3})+(?!\d))/怎样给数字添加千分符的@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习48 字体高亮函数]]></title>
    <url>%2F2019%2F01%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A048%20%E5%AD%97%E4%BD%93%E9%AB%98%E4%BA%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关于标签模板的练习题 知识点标签模板 题目完成highLight函数，可以把模板字符串中的插入内容替换掉，并且插入文档后显示红色，例如： 123const yourName = 'ScriptOJ'const myName = 'Jerry'document.body.innerHTML = highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` CSS样式： 123.red &#123; color: red&#125; 实现上面的关键是函数调用那一行： 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` 以我浅薄的学识，认为是题目出错了，哪有这样进行函数调用的，所以自作主张按照下面的调用方式实现： 1highlight('Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.') 按照这种形式，以前联系过类似的问题，使用new Function可以实现替换模板字符串变量的功能： 12345678910111213const highlight = (str) =&gt; &#123; let reg = /\$\&#123;(.+?)\&#125;/g; let match = reg.exec(str); let result = []; while(match) &#123; result.push(match[1]); match = reg.exec(str); &#125; return str.replace(reg, (match, p1) =&gt; &#123; const string = new Function(...result, `return $&#123;p1&#125;`)(...result.map(v =&gt; eval(v))); return `&lt;span class="red"&gt;$&#123;string&#125;&lt;/span&gt;` &#125;)&#125;; 但是实际上，题目根本没有出错，就是这样的调用形式： 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` 这种调用形式叫做==标签模板==功能。 标签模板功能模板字符串可以紧跟在一个函数后面，函数将被用来处理这个模板字符串，这就是标签模板功能： 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种形式，函数后面紧跟的字符串就是函数的参数。 当字符串中有变量时，会将模板字符串处理为多个参数，再调用函数，比如： 123456const a = 5;const b = 10;alert`hello $&#123;a + b&#125; world $&#123;a * b&#125;`// 等同于alert(['hello ', ' world', ''], 5, 10) alert的返回值就是函数处理模板字符串后的返回值，函数会接收到多个参数： 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; 函数的第一个参数是一个数组，数组的成员是模板字符串中没有变量替换的部分，也就是说，变量替换只发生在各个数组成员之间 函数的其他参数，都是模板字符各个变量被替换后的值 回到题目上来 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;`. 实际上函数调用是： 1function highlight(['hello, ', '. I am ', ''], yourName, myName) &#123;&#125; 所以可以这样： 123const highlight = (strArray, ...rest) =&gt; &#123; return strArray.map((v, key) =&gt; v + `&lt;span class="red"&gt;$&#123;rest[key] || ''&#125;&lt;/span&gt;`).join('')&#125;; 另外，有一个String.raw方法，它可以获取一个模板字符串的原始字面量值的 比如： 123let name = "Bob";String.raw `Hi\n$&#123;name&#125;!`; // "Hi\\nBob!"，内插表达式还可以正常运行 以后用到的时候再看MDN的文档。 参考 #86 字体高亮函数@ScriptOJ 标签模板@ECMAScript6入门 String.raw()@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习47 自动绑定实例方法]]></title>
    <url>%2F2019%2F01%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A047%20%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[利用Proxy自动绑定实例方法 知识点 class内部默认是严格模式 class定义的原型方法的可枚举行 Proxy 题目首先看这样一个引子： 123456789101112const name = 'window';let obj = &#123; name: 'jay', say() &#123; console.log(this.name) &#125;&#125;;obj.say(); let say = obj.say;say(); 两次执行，分别会输出什么？ 显然，第一次会打印出jay，第二次是window(，如果在严格模式下会报错)，是因为this指向调用者，第二次的调用者是window 在构建类的时候，同样有这个问题： 123456789101112class Person &#123; constructor (name) &#123; this.name = name &#125; sayHi () &#123; console.log(`I am $&#123;this.name&#125;.`) &#125;&#125;const jerry = new Person('Jerry')const sayHi = jerry.sayHisayHi() // =&gt; 报错 注意，这里面是直接报错，因为this是指向了undefined而不是window，因为==在类和模块的内部，默认就是严格模式== 所以在类似于React.js的组件的事件监听当中我们总是需要手动地进行bind(this)操作。为了简化这样的操作，请你完成一个方法autoBind，它可以接受一个类作为参数，并且返回一个类。返回的类的实例和原来的类的实例功能上并无差别，只是新的类的实例所有方法都会自动 bind 到实例上。例如： 12345const BoundPerson = autoBind(Person)const lucy = new BoundPerson('Lucy')const sayHi = lucy.sayHisayHi() // =&gt; I am Lucy. 注意，如果autoBind以后给原来的类新增方法，也会自动反映在实例上，例如： 123456Person.prototype.sayGood = function () &#123; console.log(`I am $&#123;this.name&#125;. I am good!`)&#125;const sayGood = lucy.sayGoodsayGood() // =&gt; I am Lucy. I am good! 实现一上来我就想到了可以使用Proxy来拦截new的操作符，后来又试了试用extends方法，都可以实现一半，但是后一半，也就是“自动反映在实例上”这个要求没办法实现 先讲一下我用Proxy的实现，利用handler.construct方法，拦截了new的操作 1234567891011const autoBind = (ToBindClass) =&gt; new Proxy(ToBindClass, &#123; construct(targets, argus, newTarget) &#123; const self = new targets(...argus); Object.getOwnPropertyNames(targets.prototype).forEach(v =&gt; &#123; self[v] = targets.prototype[v].bind(new targets(...argus)) &#125;); return self &#125;&#125;) 在构造函数的方法中，使用了Object.getOwnPropertyNames(targets.prototype)对原型上的方法遍历进行绑定 要注意的是，==class里面定义的原型方法是不可枚举的==，这一点与直接定义在prototype是不同的，直接定义在prototype是可枚举的 所以遍历class的原型方法不能使用Objecet.keys方法，可以使用Object.getOwnPropertyNames 但是，这种方法没办法动对新增的方法进行处理。 看了看评论区，可以使用双层的Proxy实现，外层的Proxy不同，里面不直接返回实例，而是用Proxy再次进行处理的实例，对实例的get方法进行拦截，每次访问的时候再去原型链上找，然后进行绑定。 123456789101112131415const autoBind = (ToBindClass) =&gt; new Proxy(ToBindClass, &#123; construct(targets, argus, newTarget) &#123; const self = new targets(...argus); return new Proxy(self, &#123; get(target, key) &#123; if(typeof target[key] === 'function') &#123; target[key] = target[key].bind(self) &#125; return target[key] &#125; &#125;) &#125;&#125;) 外层的Proxy可以用函数自己去拦截构造器，所以上面也可以改写成： 12345678910111213const autoBind = (ToBindClass) =&gt; &#123; return function(...argus) &#123; const self = new ToBindClass(...argus); return new Proxy(self, &#123; get(target, key) &#123; if(typeof target[key] === 'function') &#123; target[key] = target[key].bind(self) &#125; return target[key] &#125; &#125;) &#125;&#125; 太笨了。 参考 #84 自动绑定实例方法@ScriptOJ Class 的基本语法@ECMAScript6入门 handler.construct()@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转行之路]]></title>
    <url>%2F2019%2F01%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[做出转行的决定，不知道是对是错 将自己的轨迹强行换到另外一条道路，到现在很矛盾，既有成就感，感觉自己掌握了很多东西，而且在学习的时候乐在其中，又很焦虑，因为前端的千变万化，新的框架层出不穷，版本升级绵延不绝。 痛并快乐着。 由于有了几年的工作经历，我知道学习和实际工作之间的差别。所以在自学过程中非常注意从实际项目的角度出发，在网上寻找、通过论坛发问，实际的工作过程是怎样的，将实际的工作能力提高。 转行最难的一是坚持，二是得不到认可。我坚持到了现在，下一步呢就是坚持下去，坚持到得到认可。（2016.12.05） 一年多了，在简单科技这一年我充满感激。能够转行成功有自己的努力，也有运气使然。明天就要去网易入职，不知道大公司会是什么样子，不知道未来是什么样子，可以预见的只有自己还有很多东西要学，很长的路要走。继续坚持下去吧。（2018.03.07） 这一年，尤其是最近几个月，焦虑更加严重了。互联网经济寒冬，公司业务的停滞，几次面试的失败，年龄的增大，让我的焦虑与日俱增。我总是觉得自己的时间宝贵，因为转行让我的前些年的时间全部白费，所以我渴望快速的成长。但是到现在，成长的速度赶不上年龄和外界对你的要求的增长速度。不知道未来会怎样，不知道下一站在哪里。（2019.01.11） 有了一点新的感想，按照计划一步一步来吧，沉着一点，少点焦虑，多点坚定。]]></content>
      <categories>
        <category>偶尔记录</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习09 同字母异序]]></title>
    <url>%2F2018%2F12%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A09%20%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目同字母异序指的是两个字符串字母种类和字母的数量相同，但是顺序可能不同。 完成isAnagram，接受两个字符串作为参数，返回true或者false表示这两个字符串是否同字母异序。例如： 12isAnagram("anagram", "nagaram") // =&gt; return true.isAnagram("rat", "car") // =&gt; return false. 实现1我实现的方案还是比较简单的，排序一下在比较就行了 1const isAnagram = (str1, str2) =&gt; [...str1].sort().join('') === [...str2].sort().join('') 还可以： 1const isAnagram = (str1, str2) =&gt; str1.length === str2.length &amp;&amp; ![...str1].find(v =&gt; !str2.includes(v)) &amp;&amp; ![...str2].find(v =&gt; !str1.includes(v)); 还可以使用for循环： 12345678910111213141516const isAnagram = (str1, str2) =&gt; &#123; if (str1.length !== str2.length) &#123; return false; &#125; let str2Copy = str2; for (let i = 0; i &lt; str1.length; i++) &#123; if (!str2Copy.includes(str1[i])) &#123; return false; &#125; else &#123; const str2CopyArr = [...str2Copy]; str2CopyArr.splice(str2Copy.indexOf(str1[i]), 1); str2Copy = str2CopyArr.join('') &#125; &#125; return str2Copy.length === 0&#125;; 实现2在LeetCode上又遇到了这道题，看了大神的代码，自愧不如。 想要执行用时短，要避免类型转换，所以直接使用了replace方法，这样就可以实现同样字母的替换 12345678var isAnagram = function (s, t) &#123; while (s !== t &amp;&amp; s.length === t.length) &#123; const reg = new RegExp(s[0], 'g'); s = s.replace(reg, ''); t = t.replace(reg, ''); &#125; return s === t&#125;; 执行用时116ms，而原先的方法最少都在150ms以上 实现3因为题目中注明了，可以假设字符串只包含小写字母，那收到另外一个题目的其他，也可以对一个常量字符串进行遍历： 1234567891011121314151617181920212223242526var isAnagram = function (s, t) &#123; if(s.length !== t.length) &#123; return false; &#125; const alpha = 'abcdefghijklmnopqrstuvwxyz'; let reg; for (let i = 0; i &lt; alpha.length; i++) &#123; const letter = alpha[i], sIndex = s.indexOf(letter), tIndex = t.indexOf(letter); if ((sIndex === -1 &amp;&amp; tIndex !== -1) || (sIndex !== -1 &amp;&amp; tIndex === -1)) &#123; return false; &#125; else &#123; reg = new RegExp(letter, 'g'); s = s.replace(reg, ''); t = t.replace(reg, ''); if (s === t) &#123; return true &#125; if(s.length !== t.length) &#123; return false &#125; &#125; &#125; return s === t;&#125;; 执行用时104ms。 参考 ScriptOJ - #44 同字母异序]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习10 连续子串最大和]]></title>
    <url>%2F2018%2F12%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A010%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[求连续子串最大和的练习。 题目输入一组整数，例如：[-23, 17, -7, 11, -2, 1, -34, 2, -21, 9, 12]，求出子序列的最大和 实现1先尝试一种最暴力的方法，求最大子串，那么就将所有的子串计算出来，然后从中选出最大的 123456789101112const getMax = arr =&gt; &#123; let result = []; let temp; for (let i = 0; i &lt; arr.length; i++) &#123; temp = 0; for (let j = i; j &lt; arr.length; j++) &#123; temp += arr[j]; result.push(temp) &#125; &#125; return Math.max(...result)&#125;; 实现2可以对上面的方法进行优化，没有必要将所有的子串都保存起来，在计算过程中就可以实时的比较当前的最大值，最终返回的也是这个最大值 12345678910111213const getMax = arr =&gt; &#123; console.time('getMax'); let max = arr[0]; let temp; for (let i = 0; i &lt; arr.length; i++) &#123; temp = 0; for (let j = i; j &lt; arr.length; j++) &#123; temp += arr[j]; max = Math.max(max, temp) &#125; &#125; return max&#125;; 这种解法的时间复杂度为O(n²) 实现3实际上这是一道动态规划题目，以我对动态规划浅显的理解，就是从已有的状态中，推测下一状态的最优解。 要计算最优解，我们假设计算到的序列是i，这之前的子串和是temp，同时保存一个临时变量result，将temp和result每一步遍历都进行比较，保证result存的永远是当前结果的最大值。 如果temp小于0， 那么就抛弃temp，从i开始重新计算。 这样实际上只保留了计算过程中最近一步的状态 1234567891011121314151617const getMax = arr =&gt; &#123; console.time('getMax'); let temp = 0; let max = arr[0]; for (let i = 0; i &lt; arr.length; i++) &#123; // 如果前面计算的子串和&lt;0，那么就不要了 if (temp &lt; 0) &#123; temp = 0 &#125; temp += arr[i]; // 上面可以简化为 // Math.max(0, tempMax) + arr[i] max = Math.max(max, temp) &#125; return max&#125;; 这种解法的时间复杂度为O(n) 今天重新做，优化了一下，感觉更好理解一点（2019.01.25）： 12345678910111213const getMax = arr =&gt; &#123; let result = 0; let temp = 0; for (let i = 0; i &lt; arr.length; i++) &#123; temp += arr[i]; if (temp &lt; 0) &#123; temp = 0 &#125; // 保证永远是当前结果的最大值 result = Math.max(temp, result); &#125; return result&#125;; 实现4还可以用分治法来解决这个问题，连续最大子序列出现的位置有三种可能： 数组的左半部分MaxL 数组的右半部分MaxR 横跨数组左右两个部分MaxM 我们要做的就是分别求出上面三个值，然后取最大值就可以了，所以有： 1const reuslt = Max.max(MaxL, MaxR, MaxM) 那么现在的关键就是分别取得这三个值了： 12345678910111213141516171819202122232425262728293031const getMax = (arr, start = 0, end = arr.length - 1) =&gt; &#123; if (start &gt; end) &#123; return 0 &#125; else if (start === end) &#123; return arr[start] &#125; // 取中间位置 let middle = Math.floor((start + end) / 2); // 求横跨左右的最大连续子序列中左半部分的最大值 let maxMiddleL = arr[middle]; let tempL = 0; for (let i = middle; i &gt;= start; i--) &#123; tempL += arr[i]; maxMiddleL = Math.max(tempL, maxMiddleL) &#125; // 求横跨左右的最大连续子序列中右半部分的最大值 let maxMiddleR = arr[middle + 1]; let tempR = 0; for (let i = middle + 1; i &lt;= end; i++) &#123; tempR += arr[i]; maxMiddleR = Math.max(tempR, maxMiddleR) &#125; // 获得横跨左右的最大连续子序列和 const maxM = maxMiddleL + maxMiddleR; // 获得位于数组左半部分的最大连续子序列和 const maxL = getMax(arr, start, middle); // 获得位于数组右半部分的最大连续子序列和 const maxR = getMax(arr, middle + 1, end); // 返回三者最大值 return Math.max(maxM, maxL, maxR)&#125;; 这种解法的时间复杂度为O(nlgn) 我现在对于分治法的思想理解起来还是由一些困难，感觉数组排序中的归并排序也是利用了分治法的思想 算法还是要加强啊，唉 实现5：动态规划 2019.08.11更新 学习《算法图解》，学习了动态规划的算法，动态规划算法的关键就是将大的问题分解为子问题，使用子问题的答案来解决大问题。 对于连续子串最大和，可以分解为：1当前子串的值 = 当前值 + 之前子串的值 每个动态规划都会涉及一个表格，关键的点就是找到表格的值的计算方法，表格的行坐标是数组的各项的值j，列坐标是子串的长度i，每个单元格的值cell[i][j]就是长度为i的子串，以当前数字结束时，子串的和。 计算第一行的数据，代表的意思就是，当子串长度为1时，子串的值是-23，其他的单元格同理，这样就可以得到这一行的值。并且这一行最大的值就是17 到了第二行，第一个格子是不存在的，因为-23是不能构成长度为2的子串的。实际上表格中分割线以下的位置都是不存在的。 计算下一个格子的时候，就要利用上面的公式，当前值是17，子串长度为2，这个子串的和就等于17加上之前子串的值，之前子串的值就是cell[i-1][j-1]，所以单元格的值就是17 + -23 = -6。，也就是说，长度为2、以17结束的子串即-23, 17这个子串的和是-6。 这样就可以得到这一行的最大值是10，它比17小，所以单元格的最大值仍是17 同理可以填完整个表格： 填完之后发现，当前子串的最大值就是21，成员是17, -7, 11 用代码来实现： 123456789101112131415// 连续子串最大和const maxSubSum = arr =&gt; &#123; let result = 0; const cell = []; for (let i = 0; i &lt; arr.length; i++) &#123; cell[i] = []; for (let j = i; j &lt; arr.length; j++) &#123; cell[i][j] = arr[j] + ((cell[i-1] &amp;&amp; cell[i-1][j-1]) ? cell[i-1][j-1] : 0); result = Math.max(result, cell[i][j]) &#125; &#125; return result;&#125;; 虽然不一定更简单，但是是有理论依据的思想，有分析问题、建模、代码实现这样一个正确的解决问题的过程。 参考 简书 - 2018年各大互联网前端面试题二（滴滴打车） CSDN - 最大连续子序列和]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>最大子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS53 判断变量类型]]></title>
    <url>%2F2018%2F12%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS53%20%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[总结了几种判断JavaScript中变量类型的方法。 学到了instanceof在iframe中的问题，去美团面试又被拒了吧。（2018.12.13） 知其然不知其所以然，只知道可以用intanceof和constructor，区别又不知道，去头条面试又被拒了吧（2018.12.3） 总结最常用的判断方法是Object.prototype.slice.call()，其他判断的方法都有着各种问题： Array.isArray判断数组，需要ES6的支持 typeof有各种特殊情况 instanceof对于字面量不适用，并且在iframe场景中有问题 constructor是可以手动改写的 Object.prototype.toString也有着风险：Object.prototype.toString的结果可以使用Symbol.toStringTag定义（2019.02.01） 方法1 typeof不太靠谱的方法，对于基本类型是可以的 1234567891011typeof 123// "number"typeof '123'// "string"typeof true// "boolean"typeof undefined// "undefined" 对于引用类型行不通，判断结果都是object 1234567891011121314151617typeof []// "object"typeof new Array()// "object"typeof &#123;&#125;// "object"typeof null// "object"typeof JSON// "object"typeof Math// "object" 方法2：instanceofinstanceof运算符用来验证原型对象与实例对象之间的关系。 ==当a.___proto___ === A.prototype成立时，instanceof返回true== 1234567var a = [], b = '21', c = &#123;&#125;;a instanceof Array; // trueb instanceof Array; // falsec instanceof Array; // false 但是注意： 1 instanceof只对引用类型有效，==对于基本类型字面量是无效的==，因为基本类型不是对象，不存在原型链的继承关系 1234567891011[] instanceof Array;// true123 instanceof Number;// falseNumber(123) instanceof Number// falsenew Number(123) instanceof Number// true 2 instanceof存在继承关系，==对于引用类型都是Object的实例== 12345[] instanceof Array;// true[] instanceof Object;// true 3 instanceof在iframe的场景中有可能出现误判 123456const a = [1, 2, 3];const iframe = document.querySelector('#iframe');console.log(a instanceof Array); // tureconsole.log(a instanceof iframe.contentWindow.Array); // falseconsole.log(iframe.contentWindow.Array === Array); // false 可以认为宿主和iframe是两套JS的执行环境，环境中的Array是不同的，所以判断会出现问题。 方法3：constructor实质上实例是没有constructor属性的，其constructor属性是继承自原型的： 1234567function Person()&#123;&#125;;let p = new Person();p.constructor === p.__proto__.constructor;// turep.constructor === Person.prototype.constructor// true 应用时： 1234567var a = [], b = '21', c = &#123;&#125;;console.log(a.constructor === Array); // trueconsole.log(b.constructor === Array); // falseconsole.log(c.constructor === Array); // false 它的主要问题是：constructor是可以手动更改的，当通过原型继承时，constructor会被改写 12345678910function Person() &#123;&#125;;function Man() &#123;&#125;;Man.prototype.constructor === Man;// trueMan.prototype = new Person();Man.prototype.constructor === Person;// true instacnceof和constructor的区别 instanceof是操作符，而constructor是继承构造函数的原型的一个属性 instanceof对于基本类型的字面量是无效的（返回false），基本类型的字面量的constructro不存在 instancoeof存在继承性，引用类型都是Object的实例，而constructor是可以认为改写的 1234567undefined instanceof Object;null instanceof Object;null.constructorundefined.constructo 方法4 Array.isArray()ES6的Array.isArray()方法可以来判断数组的类型 123456var a = [], b = '21', c = &#123;&#125;;console.log(Array.isArray(a)); // trueconsole.log(Array.isArray(b)); // falseconsole.log(Array.isArray(c)); // false 方法5 toString方法首先要知道，调用Object.prototype.toString返回结果都是[object xxx]的格式，例如： 1234567891011121314151617Object.prototype.toString.call(&#123;&#125;)"[object Object]"Object.prototype.toString.call('')"[object String]"Object.prototype.toString.call([])"[object Array]"Object.prototype.toString.call(function ()&#123;&#125;)"[object Function]"Object.prototype.toString.call(new Date())"[object Date]"Object.prototype.toString.call(true)"[object Boolean]" 构造一个函数，isType，传入要验证的类型，返回值是一个新的函数： 1234567891011function isType(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]` &#125;&#125;const isArray = isType('Array')const isString = isType('String')console.log(isArray[1, 2, [3]]); // trueconsole.log(isString(&#123;&#125;)); // false 这是一个比较稳妥的判断方法。 Object.prototype.toString也有着风险：Object.prototype.toString的结果可以使用Symbol.toStringTag定义： 12var o = &#123; [Symbol.toStringTag]: "MyObject" &#125;;console.log(Object.prototype.toString.call(o)); // [object MyObject] 参考 JavaScript高级程序设计（第3版） 掘金 - 高阶函数，你怎么那么漂亮呢！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter05 实现原理]]></title>
    <url>%2F2018%2F11%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F04%20Vue%20Router%2FVueRouter05%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue router 实现原理学习笔记。 概要在VueRouter中提供了两种模式： Hash模式 History模式 Hash模式的基础是当URL的#后的参数改变时浏览器不会发送请求 History模式的基础是pushState和replaceState修改浏览器的历史栈后浏览器不会立即发送请求 前端路由前端路由是通过改变URL，在不重新刷新整体页面的情况下，更新页面视图。 目前浏览器实现这一功能主要通过两种方式： 利用URL中的hash值 利用H5中的history对象 Hash模式vue-router默认使用的是hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载。 #的含义#代表网页中的位置，其莜面的字符，就是该位置的标志符号 1http://www.example.com/index.html#print 浏览器读取这个URL周，会自动将print位置滚动至可视区域，对应print位置可以通过两种方法实现：使用锚点&lt;a name=&quot;print&quot;&gt;&lt;/a&gt;或者使用id属性&lt;div id=&quot;print&quot;&gt;&lt;/div&gt; #的特性#是用来指导浏览器动作的，对服务器端完全无用，==HTTP请求中不包括#及后面的内容字符== 单单改变#后面的部分，只会可能触发浏览器的滚动，==不会重新加载网页==。 改变了#后面的部分，==都会改变浏览器的访问历史==，使用后退按钮，就可以回到上一个位置,这对于Ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。 使用通过window.location.hash可以读取、写入页面的hash值，读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。 HTML5中增加的onhashchange事件，当#发生变化时，就会触发这个事件 VueRouter中的实现首先构建了HashHistory构造函数，获取页面的hash值 然后定义了HashHistory.push()方法，当页面的hash值发生变化时，会替换window.location.hash，hash的改变会自动添加到浏览器的访问历史记录中，视图的更新是首先通过Vue.mixin()方法，全局注册一个混合，定义了响应式的_route属性，当_route改变时会触发Vue实例的render方法，更新视图 123456graph TB$router.push--&gt;HashHistory.pushHashHistory.push--&gt;History.transitionToHistory.transitionTo--&gt;History.updateRouteHistory.updateRoute--&gt;app._route=routeapp._route=route--&gt;vm.render HashHistory.replace()与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史栈顶，而是替换掉当前的路由 上面的VueRouter.push()和VueRouter.replace()是可以在Vue组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现 详细的源码解读看这篇文章。 HTML History模式History interface是浏览器历史记录栈提供的接口，通过back()，forward()，go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 history.pushState()和history.replaceState()方法，分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate配合使用。 12window.history.pushState(stateObject,title,url)window.history.replaceState(stateObject,title,url) stateObject：当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本 title：所添加记录的标题 url：所添加记录的url(可选的) pushState和replaceState两种方法的共同特点：==当调用修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url==，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。 VueRouter中使用History模式VueRouter也提供了Hsitory模式，利用的是H5中的history对象和事件，只需要在新建VueRouter的实例时传入mode参数： 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 这种模式下页面的URL就像正常的url，例如http://yoursite.com/user/id 这种模式需要后台配置支持，如果后台没有正确的配置，当用户在浏览器直接访问http://oursite.com/user/id就会返回404，所以需要在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，则应该返回同一个index.html页面，这个页面就是app依赖的页面。 注意： 这么做以后，服务器就不再返回404错误页面，因为对于所有路径都会返回index.html文件。为了避免这种情况，应该在Vue应用里面覆盖所有的路由情况，然后在给出一个404页面。 123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;) VueRouter中的实现代码结构以及更新视图的逻辑与hash模式基本类似，只不过将对window.location.hash直接进行赋值或者调用window.location.replace()改为了调用history.pushState()和history.replaceState()方法。 两种模式的比较一般的需求场景中，Hash模式与History模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改Hash主要有以下优势： pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而Hash设置的新值必须与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据记录中，而Hash只可添加短字符串 pushState可额外设置title属性供后续使用 参考 vue-router原理剖析@掘金 History模式@Vue Router URL的井号@阮一峰的网络日志]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node13 文件路径]]></title>
    <url>%2F2018%2F07%2F11%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode13%20%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。文件路径的笔记。 路径表示Node.js中的文件路径主要有以下几种： __dirname __filename proces.cwd() ./ ../ 其中前三个是绝对路径，后两个是相对路径 ，可以通过path.resolve转换为绝对路径 我现在的目录结构是这样的： 1234D:/ -projects/ path-test/ path.js path.js： 12345const path = require('path')console.log('__dirname：', __dirname)console.log('__filename：', __filename)console.log('process.cwd()：', process.cwd())console.log('./：', path.resolve('./')) 在path-test文件夹下用Node执行path.js，输出结果： 1234__dirname： D:\projects\path-test__filename： D:\projects\path-test\path.jsprocess.cwd()： D:\projects\path-test./： D:\projects\path-test 在projectst文件夹下用Node执行path.js： 1234__dirname： D:\projects\path-test__filename： D:\projects\path-test\path.jsprocess.cwd()： D:\projects./： D:\projects 关于他们的区别： process.cwd()是程序的执行路径，./相同 __dirname是被执行的JS文件所在文件夹的绝对路径 __filename是被执行的JS文件的绝对路径，与__dirname一样，都是JS文件本身的属性 path模块path.join()用于连接路径，主要用于针对不同系统（windows/unix）使用当前系统的路径分隔符 12var path = require('path');path.join(mydir, "foo"); 上面代码在Unix系统下，会返回路径mydir/foo。 path.join()用于将相对路径转为绝对路径 它可以接受多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。 12// 实例path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') 上面代码的实例，执行效果类似下面的命令。 12345$ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd 更多例子： 123456789path.resolve('/foo/bar', './baz')// '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/')// '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')// 如果当前目录是/home/myself/node，返回// /home/myself/node/wwwroot/static_files/gif/image.gif 参考 Node.js的dirname，filename，process.cwd()，./的一些坑@github Path模块@JavaScript标准参考教程 process对象@JavaScript标准参考教程]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>process.cwd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node12 AMD、CMD、UMD]]></title>
    <url>%2F2018%2F07%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode12%20AMD%E3%80%81CMD%E3%80%81UMD%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。AMD/CMD/UMD学习笔记。 AMDAMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”，也是由RequireJS定义的模块形式。 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 定义模块12345678// 文件名: foo.jsdefine(['jquery'], function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;); 定义的第一个部分是一个依赖数组，第二部分是回调函数，只有当依赖的组件可用时回调函数才会执行。 加载模块123require(['foo'], function(foo) &#123; console.log(foo)&#125;) CommonJSNode.js的模块和包机制的实现参照了CommonJS的标准，但并未完全遵循。不过两者的区别不大。 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 定义模块在CMD规范中，一个模块就是一个文件。define是一个全局函数，用来定义模块。 define接受factory参数，factory可以是一个函数，也可以是一个对象或字符串。 比如可以定义一个JSON数据模块： 1define(&#123;&quot;foo&quot;: &quot;bar&quot;&#125;); factory是一个函数，有三个参数，function(require, exports, module) require是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id) exports是一个对象，用来向外提供模块接口 module是一个对象，上面存储了与当前模块相关联的一些属性和方法 1234567define(function(require, exports, module) &#123; var a = require('./a'); a.doSomething(); // 依赖就近书写，什么时候用到什么时候引入 var b = require('./b'); b.doSomething();&#125;); NodeJS中12345678// 文件名: foo.js// 依赖var $ = require('jquery');// 方法function myFunc()&#123;&#125;; // 暴露公共方法（一个）module.exports = myFunc; UMD通用模块规范UMD是AMD和CommonJS的糅合。 123456789101112131415((root, factory) =&gt; &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //CommonJS var $ = requie('jquery'); module.exports = factory($); &#125; else &#123; //都不是，浏览器全局定义 root.testModule = factory(root.jQuery); &#125;&#125;)(this, ($) =&gt; &#123; //do something... 这里是真正的函数体&#125;); 更详细的内容看这个教程。 参考 https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E8%AE%A4%E8%AF%86AMD%E3%80%81CMD%E3%80%81UMD%E3%80%81CommonJS.md http://web.jobbole.com/82238/ https://mp.weixin.qq.com/s/WG_n9t4E4q0kBWczkSEdEA https://neveryu.github.io/2017/03/20/amd-cmd/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>UMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node11 process.env对象]]></title>
    <url>%2F2018%2F07%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode11%20process.env%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。process.env对象的学习笔记。 process对象process对象是Node的一个全局独享，提供当前Node进程的信息。他可以在脚本的任意位置使用，不必通过require命令加载 属性process对象提供了一系列的属性，用于返回系统信息 process.argv：返回一个数组，成员是当前进程的所有命令行参数 process.env：返回一个对象，成员为当前Shell的环境变量 process.pid：返回一个数字，表示当前进程的进程号 process.platform：返回一个字符串，表示当前的操作系统，比如Linux process.version：返回一个字符串，表示当前使用的 Node 版本，比如v7.10.0 process.envprocess.env返回一个对象，包含了当前Shell的所有环境变量 通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设定为production，开发阶段设定为development，然后在脚本中读取process.env.NODE_ENV 运行脚本时改变环境变量可以采用下面的写法： 1NODE_ENV=production node app.js ross-env如果按照上面的写法，在windows系统下是会报错的： 1'NODE_ENV' 不是内部或外部命令，也不是可运行的程序或批处理文件。 因为windows下不支持这种设置环境变量的方式，正确的方法是： 1set NODE_ENV=production &amp;&amp; node app.js 但是这样需要维护两个脚本命令，使用cross-env就可以解决这个问题 cross-env提供了一个设置环境变量的脚本，让我们能够以Linux的方式设置环境变量，在Windows下可以兼容运行 安装： 1npm install cross-env --save-dev 使用时只需要在原来的脚本前面加上cross-env就可以了 1cross-env NODE_ENV=development nodemon ./index.js 使用.env文件在Vue-cli3.0和Create-react-app两款脚手架中，都支持使用.env文件来引入环境变量 Vue中Vue-cli3.0在Vue-cli3.0的项目中，可以直接传递--mode参数复写环境变量，例如想要使用.env.staging，可以这样： 1vue-cli-service build --mode staging 这个时候NODE_ENV被改写为staging，同时会加载.env.staging文件 在.env中定义的变量除了NODE_ENV之外，都需要以VUE_APP_开头，同样可以在.env文件制定NODE_ENV，同样可以生效，例如上面的.env.staging文件中可以： 1NODE_ENV=production 这样NODE_ENV又被重新改写为了production Vue-cli2.0在以前的项目中，是不能直接使用.env文件的，一般都是直接使用process.env.NODE_ENV来区分环境。除了内置的development/production/test环境变量外，想要增加新的环境有两个做法 一个是在build的文件夹中，复制为build-staging.js，同时中为process.env.NODE_ENV重新赋值，在运行npm run build:staging命令时，运行build-staging文件 另外一个就是使用上面提到的corss-env，在运行npm命令时赋值 React中如果是使用Create-react-app脚手架的项目，在未eject之前，是不能覆写NODE_ENV的， 也没有提供--mode的选项来指定新的.env文件，可以使用cmd-env来指定.env文件，但是这个时候的NODE_ENV是不变的。 具体的可以参考《React提高08 Create React App》这篇笔记。 参考 process对象@JavaScript标准参考教程 使用cross-env解决跨平台设置NODE_ENV的问题@segmentfault 环境变量和模式@Vue CLI]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画05 Vue中实现文字向上滚动的动画效果]]></title>
    <url>%2F2018%2F06%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2F03%20%E5%8A%A8%E7%94%BB%2F%E5%8A%A8%E7%94%BB05%20Vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E5%90%91%E4%B8%8A%E6%BB%9A%E5%8A%A8%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在Vue中实现文字向上滚动的效果。 在Vue中，想要实现文字向上滚动的效果，分成两种情况： 1 无缝滚动无缝滚动如图： 我说的无缝滚动主要是指两点： 滚动中没有停顿 从头至尾再循环播放时没有停顿 实现这种情况可以使用CSS3的动画实现，主要原理就是让多个文字的容器进行移动： 模板： 123&lt;div class="inner-container"&gt; &lt;p class="text" v-for="(text, index) in arr" :key="index"&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt;&lt;/div&gt; CSS部分： 12345678910111213.inner-container &#123; animation: myMove 5s linear infinite; animation-fill-mode: forwards;&#125; /*文字无缝滚动*/@keyframes myMove &#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(-150px); &#125;&#125; 滚动中没有停顿是通过keyframes实现的，而循环在播放时没有“跳帧”的效果，只要是通过增加一条多余数据： 123456789101112data() &#123; return &#123; arr: [ '1 不是被郭德纲发现的，也不是一开始就收为徒弟。', '2 现在雅阁这个状态像极了新A4L上市那段日子。', '3 低配太寒碜，各种需要加装，中配定价过高，又没啥特色', '4 然后各种机油门、经销商造反什么的幺蛾子。', '5 看五月销量，建议参考A4，打8折吧。', '1 不是被郭德纲发现的，也不是一开始就收为徒弟。', ], &#125;&#125;, 当动画结束时通过： 1animation-fill-mode: forwards; 将动画重置为第一帧，这样就能够实现无缝的播放了 2 停顿滚动实现停顿真的是在第一行文字滚动出现后，停顿一下，在进行滚动移出： 实现这种效果有两个思路，第一个思路是沿用上面的方法，用包裹容器的移动来实现，只不过在keyframes总要精细化，留出停顿的时间： 123456789101112131415161718192021222324252627282930313233343536/*文字停顿滚动*/@keyframes myMove2 &#123; 0% &#123; transform: translateY(0); &#125; 10% &#123; transform: translateY(-30px); &#125; 20% &#123; transform: translateY(-30px); &#125; 30% &#123; transform: translateY(-60px); &#125; 40% &#123; transform: translateY(-60px); &#125; 50% &#123; transform: translateY(-90px); &#125; 60% &#123; transform: translateY(-90px); &#125; 70% &#123; transform: translateY(-120px); &#125; 80% &#123; transform: translateY(-120px); &#125; 90% &#123; transform: translateY(-150px); &#125; 100% &#123; transform: translateY(-150px); &#125;&#125; 不过看起来好麻烦，而且如果文字行数过多的话，岂不是吐血，这时候可以使用LESS或者SASS提供的函数功能帮助你完成keyframes，具体就不在这里展开了 第二种思路就是不用列表容器的移动，而是仅保留一个&lt;p&gt;元素，不断变化其内容，在变化过程中实现移动的效果。 这种思路要借用到Vue提供的transition组件了，它提供了一些类名，比如v-enter、v-enter-active等来对应CSS的类，同时在对应我们这种情况的多个元素的过度时，还需要使用过渡模式out-in，具体可以参考官方文档。 代码如下： 模板:12345&lt;div class="text-container"&gt; &lt;transition class="inner-container2" name="slide" mode="out-in"&gt; &lt;p class="text2" :key="text.id"&gt;&#123;&#123;text.val&#125;&#125;&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 多了一个计算属性 12345678computed: &#123; text() &#123; return &#123; id: this.number, val: this.arr[this.number] &#125; &#125;&#125;, 再建立一个定时器，在定时器中不断改变计算属性对应的值： 12345678910startMove() &#123; let timer = setTimeout(() = &gt; &#123; if (this.number === 5) &#123; this.number = 0; &#125; else &#123; this.number += 1; &#125; this.startMove(); &#125;, totalDuration)&#125;, 同时在CSS部分添加对应的类： 123456789.slide-enter-active, .slide-leave-active &#123; transition: all 0.5s linear;&#125;.slide-leave-to &#123; transform: translateY(-20px);&#125;.slide-enter &#123; transform: translateY(20px);&#125; 这样就OK了，demo在这里。 使用列表过渡实现博客下面，有人评论，可以使用列表过渡加定时器实现，所以就试了一下，思路是利用定时器，不断改变列表元素的位置，将最后一个元素查到列表的开始。可以实现，但是效果不如上面的完美。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div&gt; &lt;h2&gt;列表过渡&lt;/h2&gt; &lt;div class="text-container"&gt; &lt;transition-group tg="div" name="list" class="list-container" mode="out-in"&gt; &lt;p v-for="(text, index) in arr2" :key="text + index" class="list-item"&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const totalDuration = 2000; export default &#123; name: 'demo11', data() &#123; return &#123; arr: ['1 不是被郭德纲发现的，也不是一开始就收为徒弟。', '2 现在雅阁这个状态像极了新A4L上市那段日子。', '3 低配太寒碜，各种需要加装，中配定价过高，又没啥特色', '4 然后各种机油门、经销商造反什么的幺蛾子。', '5 看五月销量，建议参考A4，打8折吧。', '1 不是被郭德纲发现的，也不是一开始就收为徒弟。', ], number2: -1, &#125; &#125;, mounted() &#123; this.startMove2() &#125;, methods: &#123; startMove2() &#123; let timer = setTimeout(() = &gt; &#123; this.number2 += 1; if (this.number2 &gt; 4) &#123; const target = this.arr2.splice(4, 1); this.arr2.unshift(target[0]) &#125; else &#123; this.arr2.unshift(this.arr[this.number2]); &#125; this.startMove2(); &#125;, totalDuration) &#125;, &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;.list-container &#123; position: relative; overflow: hidden;&#125;.list-item &#123; margin: 0; transition: all 1s; overflow: hidden;&#125;.list-enter &#123; transform: translateY(30px);&#125;.list-enter-to, .list-leave &#123; transform: translateY(0);&#125;.list-leave-to &#123; transform: translateY(-30px)&#125;.list-leave-active &#123; position: absolute; width: 0;&#125;&lt;/style&gt; 因为列表过渡，新的元素插入时可以平滑度过，但是元素移除时如果要实现平滑过渡需要在v-leave-active的样式中将定位设定为绝对定位 123.list-leave-active &#123; position: absolute;&#125; 在我当前的需求下，如果设置了绝对定位，元素在移除时会重叠显示多个元素 所以在这个阶段加了一个属性，让宽度为0，不显示过渡期间重叠的元素： 1234.list-leave-active &#123; position: absolute; width: 0;&#125; 这样重叠的问题解决了，但是元素在移除时的效果就很生硬： 可能是我的设置不太对，也许直接将没有过渡期间的列表项的定位就设为绝对定位，通过钩子改变时直接改变绝对定位的top值也许能解决这个问题，如果有人尝试成功还望赐教。 参考 纯css3实现文字间歇滚动效果@小目标 纯css实现的无缝滚动@知乎 列表过渡@Vue]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>动画</tag>
        <tag>文字滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全栈01 Koa2+Vue2+MySQL 全栈的入门尝试]]></title>
    <url>%2F2018%2F06%2F07%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F%E5%85%A8%E6%A0%8801%20Koa2%2BVue2%2BMySQL%20%E5%85%A8%E6%A0%88%E7%9A%84%E5%85%A5%E9%97%A8%E5%B0%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[记录一次全栈的尝试。 0 前言其实并没有想要成为全栈工程师的想法，因为我觉得自己作为一个半路出家、至今全职前端开发经验不到两年的程序猿来说，把前端稍微深入一点的东西搞明白就算不错。 但是心里其实一直有一些疑惑，比如，每次后台提供的接口到底是怎么工作的？数据是怎么存放到数据库中的？数据库是怎么维护的？等等。这些问题总不时的在我全心全意的码代码的过程中冒出来。 幸好，我们前端有了NodeJS这个利器，让我可以在现有的技能树上去简单的探讨这些问题，而不用完全新开一门技能。这让我能够降低难度的去初步了解后台乃至整个网站的开发流程，让我有一些明白在以前的工作中接触过的后台代码“啊，原来是这么回事”。 想着通过尝试实现一个小小的登陆+后台管理系统，了解后台接口的实现、对数据库的操作以及代码部署。这次尝试对于我自己而言还是有意义的，补上了一些短板，解决了一些疑惑，但是这次尝试也仅仅是初步的、浅尝辄止的，很多更深的问题我目前没有经历和能力去深入的研究，所以本文也可能仅仅适用于有一些前端基础、对全栈技能有一些好奇的小伙伴，前端骨干、后端精英、全栈大神们，咱们说好，不要鄙视我好么？ 确定了这个基本的约定后，让我们开始全栈开发的初次尝试吧。 P.S. 这篇文章尝试的主要思路来自于这篇文章，具体代码、实现有所不同，特此致谢。 1 项目简介整个项目的技术栈，前端是Vue+Vue-Router+Element，后端的话主要是Koa2+MySQL。 前端的话不用说了，后端的话主要就是两个方面，一是为前端提供API，二是操作数据库。 2 入口文件首先建立项目的入口文件index.js， 12345678require('babel-polyfill');require('babel-register');if (process.env.NODE_ENV === 'development') &#123; require('./server/dev');&#125; else &#123; require('./server/app');&#125; 这个入口文件作用有两个，一个是区分开发模式和生产模式，两个模式下面主要的区别就是监听给的端口不同并且生产模式下会将webpack打包好的项目目录作为Koa静态文件服务。 另一个作用是引入babel-register和babel-polyfill babel-register的目的主要是为了在文件中兼容ES6的import和export，但是注意：在入口文件（即本项目中的index.js）中仍然不能使用。 babel-polyfill的目的就是为ES6的一些API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）提供转码。这个我考虑在后面进行优化，减小webpack打包体积，后面再说。 3 Koa中间件首先看一下后端服务的真正的启动文件，以app.js为例吧，使用的框架是Koa2，在此基础上引用了很多的Koa2的中间件 3.1 koa-router对路由进行处理控制的中间件，使用的时候我们现在server文件夹下面新建一个router文件夹，用存放所有子路由的文件 现在我们建立了两个文件，api.js用来管理所有的api，auth.js用来专门处理权限相关的路由： 看auth.js，很简单，引用koa-router，然后声明相关的路由并且对应处理方法，最后将路由模块导出 1234567891011import * as userController from '../controller/userController'import KoaRouter from 'koa-router';const router = new KoaRouter();router.get('/user/:id', userController.getUserInfo);router.post('/user', userController.postUserAuth);export &#123; router&#125;; 里面引入的userController就是所有MVC中的C，controller层，我的理解就是对路由进行处理，对api请求进行处理，getUserInfo和postUserAuth都是在其中定义好的方法，具体一会再看。 auth.js作为子路由导出之后，在app.js中引入并且使用： 1234567891011import KoaRouter from 'koa-router';import * as auth from './router/auth';const router = new KoaRouter();const authRouter = auth.router;// 挂载auth子路由router.use('/auth', authRouter.routes());// 挂载所有路由app.use(router.routes()); 这样层层传递下来，当我们使用get请求访问/auth/user时，就会触发预定义的userController.getUserInfo方法 其他api请求也是同样的处理。 3.2 koa-bodyparserkoa-bodyparser用来解析body的中间件，比方说你通过post来传递表单，json数据，或者上传文件，在koa中是不容易获取的，通过koa-bodyparser解析之后，在koa中this.body就能直接获取到数据。 3.3 koa-loggerkoa-logger是koa的日志模块，在安装、挂载之后 12import KoaLogger from 'koa-logger';app.use(KoaLogger()); 命令程序就会在控制台自动打印日志 3.4 koa-json用来美观的输出JSON response，有两种使用方式： 一种是总是返回美化了的json数据，本文就采用的这种 12import KoaJson from 'koa-json';app.use(KoaJson()); 另一种是默认不进行美化，但是当地址栏传入pretty参数的时候，则返回的结果是进行了美化的。 1app.use(json(&#123; pretty: false, param: 'pretty' &#125;)); 3.5 kcors用来处理跨域的中间件，简化了我们处理CORS跨院的设置步骤，为我们在请求头上加上CORS，客户端即可跨域发送请求 123456789import Kcors from 'kcors';// 跨域设置const corsOptions = &#123; 'origin': '', 'credentials': true, 'maxAge': 3600&#125;;app.use(Kcors(corsOptions)); 3.6 koa-jwt用来实现JSON-WEB-TOKEN的中间件，具体的后面关于登录的章节进行展开 123import jwt from 'koa-jwt';router.use('/api', jwt(&#123; secret: db.jwtSecret &#125;), apiRouter.routes()); // 所有走/api/打头的请求都需要经过jwt验证。 3.7 koa-compress用来为服务端的静态文件开启压缩 12345import Compress from 'koa-compress';app.use(Compress(&#123; threshold: 2048 // 要压缩的最小响应字节&#125;)); 3.8 koa-static用来实现访问静态资源，当我们使用webpack进行生产模式的打包之后，都放到了dist目录下，这个目录就作为Koa静态文件服务的目录： 1234import staticServer from 'koa-static';// 将webpack打包好的项目目录作为Koa静态文件服务的目录app.use(staticServer(path.resolve('dist'))); 4 后端服务对数据库的设计这里就不讲了，因为我也不会，只是简单的设计了两个表，一个是user，用来存放用户名和密码： 字段 类型 说明 id int(自增) 用户的id username varchar(50) 用户名 password char(128) 进行bcrypt加密后的密码 另一张表是example，用来显示一些主要的数据 字段 类型 说明 id int(自增) 数据id title varchar(50) 标题 image varchar(50) 插入时间 有了数据库的基本结构后，我们需要使用NodeJS来操作数据库，对数据库进行增删改查，对于Mongodb以前公司的同时使用的是Mongoose，对于MySQL我使用了Sequelize，关于Sequelize的基本使用可以参考我的另一篇总结 在使用Sequelize之前我们需要把数据库的表结构导出来，当然我们可以手动的导出，但是如果表很多的情况下，手动导出的效率太低了，可以使用sequelize-auto导出 这之前我们需要全局安装sequelize-auto： 1npm install sequelize-auto -g 然后安装MySQL在NodeJS下的驱动mysql： 1npm install mysql --save-dev 安装完成之后，进入server目录，执行下面的语句： 1sequelize-auto -o &quot;./schema&quot; -d zhou -h 127.0.0.1 -u root -p 3306 -x XXXXX -e mysql -o 参数后面的是输出的文件夹目录 -d 参数后面的是数据库名 -h 参数后面是数据库地址 -u 参数后面是数据库用户名 -p 参数后面是端口号 -x 参数后面是数据库密码， -e 参数后面指定数据库为mysql 完成之后再schema下面就会生成对应各个表的JS文件 user.js123456789101112131415161718192021export default function (sequelize, DataTypes) &#123; return sequelize.define('user', &#123; id: &#123; type: DataTypes.INTEGER(10), allowNull: false, primaryKey: true &#125;, username: &#123; type: DataTypes.STRING(50), allowNull: true, defaultValue: '' &#125;, password: &#123; type: DataTypes.CHAR(128), allowNull: true, defaultValue: '' &#125; &#125;, &#123; tableName: 'user' &#125;);&#125;; example.js 1234567891011121314151617181920export default function(sequelize, DataTypes) &#123; return sequelize.define('example', &#123; id: &#123; type: DataTypes.INTEGER(10), allowNull: false, primaryKey: true, autoIncrement: true &#125;, title: &#123; type: DataTypes.STRING(50), allowNull: true &#125;, image: &#123; type: DataTypes.STRING(100), allowNull: true &#125; &#125;, &#123; tableName: 'example' &#125;);&#125;; 然后我们在server下建立config文件夹，在其中创建db.js文件，用来存放数据库地址、用户名、密码等信息，在这个文件中我通过对环境的判断，让代码操纵不同的数据库，在开发环境下想测试库写入信息，生产环境下操作的则是线上库 然后再在server下面创建common文件夹，创建mysql.js文件，用来连接我们上面定义好的数据库： 12345678910import Sequelize from 'sequelize';import config from '../config/db';const mysql = new Sequelize(config.mysql.default, &#123; define: &#123; timestamps: false, &#125;, operatorsAliases: false&#125;);export default mysql; 在连接好数据库并且导出mysql这个对象后，我们对数据库的增删改查都是基于这个对象上完成的。 创建model文件夹，用来存放对数据库处理的Model层的代码文件，创建userModel.js，对user表进行处理： 1234567891011121314151617181920import Mysql from '../common/mysql'; // 引入MySQL数据库const userSchema = '../schema/user'; // 引入user的表结构const User = Mysql.import(userSchema);// 将Sequelize与表结构对应export async function getUserById(id) &#123; return await User.findOne(&#123; where: &#123; id &#125; &#125;)&#125;export async function getUserByName(username) &#123; return await User.findOne(&#123; where: &#123; username &#125; &#125;)&#125; 上面的代码中，首先将数据库和user表进行了对应，使用的是sequelize的import方法，然后定义了两个方法，分别是通过id和用户名查找数据 然后在我们上面提到的controller文件夹下的userController.js中，编写api的逻辑。 同样我们定义了两个方法，第一个方法是获取用户信息getUserInfo，对应的就是/auth/user/:id的get请求 1234567891011121314151617export async function getUserInfo(ctx) &#123; const id = ctx.params.id; // 获取url里传过来的参数里的id const user = await userModal.getUserById(id); if (user) &#123; ctx.body = &#123; success: true, retDsc: '查询成功', ret: user &#125; &#125; else &#123; ctx.body = &#123; success: false, retDsc: '用户不存在', ret: null &#125;; &#125;&#125; 需要注意的是，ctx是koa的上下文，可以理解为上(request)下(response)沟通的环境，其实就是将NodeJS的request/response对象封装进一个单独对象，ctx.req=ctx.request，ctx.res=ctx.response，ctx.body是http协议中的响应体，ctx.header是响应头 url里面传过来的参数/user/:id是通过ctx.params.id获取的 另外一个方法postUserAuth是用来为密码验证通过的用户下发token，保证在访问过程中用户权限的有效性，具体会在登录的章节展开，在这里我们只需要了解这个方法的主要逻辑即可 1234567891011121314151617181920212223242526272829303132333435export async function postUserAuth(ctx) &#123; const data = ctx.request.body; // post过来的数据存在request.body里 const userInfo = await userModal.getUserByName(data.username); // 数据库返回的数据 if (!userInfo) &#123; ctx.body = &#123; success: false, retDsc: '用户不存在', ret: null &#125;; return &#125; if (!bcrypt.compareSync(data.password, userInfo.password)) &#123; ctx.body = &#123; success: false, retDsc: '密码错误', ret: null &#125;; return &#125; const userToken = &#123; iss: config.userToken.iss, name: userInfo.username, id: userInfo.id, &#125;; const secret = serverConfig.jwtSecret; // 指定密钥，这是之后用来判断token合法性的标志 const token = JWT.sign(userToken, secret); // 签发token ctx.body = &#123; success: true, retDsc: '登陆成功', ret: &#123; token, &#125; &#125;&#125; 首先调用model里面定义的getUserByName，通过用户名查找用户，找不到就返回“用户不存在”，找到用户对密码校验，如果校验不通过返回“密码错误”，通过之后下发token 对于另外的exmaplModel.js→exampleController.js→api.js流程类似，不再展开，需要指出的几点是 想表中插入数据的方法是create，更新的就是找到对应的对象，然后对要更新的属性直接赋值并保存(save)，删除数据的方法是destroy 操作数据库的操作都是异步函数，这里面使用了async和await语法 最好将返回值的retCode和retDsc有统一的定义并统一维护 接口最好定义为使用restful风格的接口 最终在后端服务的实际启动文件app.js中，除了在第三章提到的加载各个中间件的服务，实现对应的功能，加上对错误和日至的处理： 1234567891011// logapp.use(async (ctx, next) =&gt; &#123; const start = new Date(); await next(); let ms = new Date() - start; console.log('%s %s - %s', ctx.method, ctx.url, ms); // 显示执行的时间&#125;);app.on('error', (err, ctx) =&gt; &#123; console.log('server error: ', err);&#125;); 然后通过listen方法监听指定的端口： 123app.listen(config.appServer.port, () =&gt; &#123; console.log(`Koa is listening in $&#123;config.appServer.port&#125;`);&#125;); 在完成这些之后我们就可以开启后端服务了，在控制台输入： 1node ./index.js 这样我们就要可以开启dev.js对应的端口，提示“koa is listening in 80” 这时候我们如果改动后端代码，都需要手动将node进行停止，然后再次执行上述命令开启服务，代码更改才能生效，好在我们有nodemon， nodemon将监视启动目录中的文件，如果有任何文件更改，nodemon将自动重新启动node应用程序。 如果没有全局安装nodemon的话是无法在命令行直接执行下面的命令来启动nodemon服务的： 1nodemon ./index.js 我们将这条命令写到package.json中的scripts命令中， 123"scripts": &#123; "server": nodemon ./index.js ", &#125;, 当我们执行npm run server时就会启动nodemon服务，但是我们没有办法指定NODE_ENV环境变量，也就无法切换环境，所以需要在命令中增加NODE_ENV=development，再次执行时会报错，原因是“windows不支持NODE_ENV=development的设置方式”，解决方式就是使用cross-env，安装之后再NODE_ENV=development前面增加cross-env就可以了。 1234"scripts": &#123; "server": "cross-env NODE_ENV=development nodemon ./index.js ", "start": "cross-env NODE_ENV=production nodemon ./index.js "&#125;, 这样执行npm run server就可以监听开发端口8099了：”Koa is listening in 8099 for development” P.S. 开发过程中对API的自测可以使用Postman webstorm是支持NodeJS的断点调试的，具体可以参考这篇文章。 5 前端页面前端页面不细说了，就是Vue+Vue Router+element，首先进入的是login页面，进行登录，登录之后是一个列表页，点击单挑数据进入详情页，详情页有三个button，分别是插入、编辑和删除，没什么好讲的。 要注意的是现在由/login到/admin的跳转是单页面应用内的跳转，没有向后端发送任何请求，是从前端实现的。所以实际上在应用了后面的登陆系统后，跳转之前是需要想后端进行判断验证的，根据情况不同再决定是否跳转 6 登录系统6.1 JSON-WEB-TOKEN使用JSON-WEB-TOKEN可以实现无状态的登陆，可以参考这篇文章和这篇文章帮助理解 主要的登陆流程如下： 客户端通过Post请求将用户名和密码发送到服务器接口（这一过程一般都是明文传输的，建议通过SSL加密的https协议进行传输，避免被监听和中间人攻击。 服务器核定用用户名和密码 验证通过之后发送经过加密的Token返回给客户端 客户端收到Token后应该存储到cookie或者storage，每次访问指定资源都应该携带含有Token的cookie或者storage 后端受到请求信息，都需要验证TOKEN是否有效 6.2 token的请求与发放具体到我们的代码中，我们已经安装了JSON-WEB-TOEKN的koa2中间件koa-jwt，然后在安装bcryptjs来为密码加解密，bcryptjs是一个第三方密码加密库 正规的流程应该是当我们向数据库添加一个用户的时候，密码通过bcryptjs加密后存储到数据库的password字段，而登陆时传输的是未经加密的密码数据（所以https是必须的）。我这里为了省事没有做注册的功能，所以数据库中的密码是通过手动加密然后存储的。 当服务器收到登陆验证的Post请求（/auth/user)，会调用对应的postUserAuth方法 1router.post('/user', userController.postUserAuth); 定义在userController.js中的postUserAuth方法会应用bcrypt的compareSync方法对密码进行验证。 12345678if (!bcrypt.compareSync(data.password, userInfo.password)) &#123; ctx.body = &#123; success: false, retDsc: '密码错误', ret: null &#125;; return&#125; 要注意，compareSync的第一个参数应该是未加密的数据，第二个参数是加密的数据，否则是无法验证通过的。 验证通过之后，向客户端下发Token，Token由两个部分组成： 12345678const userToken = &#123; iss: config.userToken.iss, name: userInfo.username, id: userInfo.id,&#125;;const secret = dbConfig.jwtSecret; // 指定密钥，这是之后用来判断token合法性的标志const token = JWT.sign(userToken, secret); // 签发token 里面的userToken是包含了认证用户的一些信息，secret是我们定义的用来加密的密钥，是之后用来判断token合法性的标志，secret不应该在前端被暴露出来，后端将签发后的token返回给客户端： 12345ctx.body = &#123; success: true, retDsc: '登陆成功', ret: &#123; token&#125;&#125; 浏览器收到token之后，将token保存到了sessionStorage中，然后进行页面跳转： 12sessionStorage.setItem('userToken', data.ret.token);this.$router.push('/admin') 6.3 token的验证访问哪些资源需要token的验证呢？这也需要我们在定义koa-router时指定，在app.js中 12router.use('/auth', authRouter.routes());router.use('/api', jwt(&#123; secret: dbConfig.jwtSecret &#125;), apiRouter.routes()); // 所有走/api/打头的请求都需要经过jwt验证。 我们定义，所有走/api/的路由都需要经过token的验证，验证的密钥就是之前定义的secret，具体的验证工作都是有koa-jwt帮我们完成的。 所以前端在发起API请求时，都应该在请求头中携带上token，否则请求会被拒绝。为了简化代码，我们在Vue router的定义文件中使用了全局的导航守卫router.beforeEach，在每次跳转之前都判断是否存在token（并且token是我们所下发的token，这是通过token解析后包含我们预定义一些信息来进行判断的），如果存在就在请求头添加token： 1234567891011import JsonWebToken from 'jsonwebtoken';router.beforeEach((to, from, next) =&gt; &#123; const token = sessionStorage.getItem('userToken'); const isTokenRight = !!(token &amp;&amp; JsonWebToken.decode(token) &amp;&amp; (JsonWebToken.decode(token).iss === config.userToken.iss)); // 全局设定发送请求header的token验证 if (isTokenRight) &#123; Vue.prototype.$http.defaults.headers.common['Authorization'] = 'Bearer ' + token &#125;&#125;); 这样做其实不太对，请求头增加token其实在第一次登陆成功后就增加了，以后每次的网络请求的请求头都会携带token，就算token失效也不会改变 更加合理的做法应该是在每个网络请求前都判断一下token是否存在，如果存在就携带，如果不存在就不添加token 我的http请求使用了axois这个库，并且在src/components/helper下增加了一个httpHelper.js文件，用来对网络请求进行个性化定制，主要的定制内容有： 针对开发环境还是线上环境的URL前缀进行改变等： 1234const sever = process.env.NODE_ENV === "development" ? config.devServer : config.appServer;axios.defaults.baseURL = sever.protocol + sever.host + ':' + sever.port;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';axios.defaults.withCredentials = true; 此外添加了请求拦截器和响应拦截器，刚才提到的对token的判断可以放到请求拦截器中。 12345678910111213141516171819202122232425262728// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 发送时展示loading loading = uiHelper.showLoading(); return config;&#125;, function (error) &#123; // 请求错误时取消loading loading.close(); // 给出提示 uiHelper.showMessage(errorText, 'error'); return Promise.reject(error);&#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 收到相应数据后取消loading if (loading) &#123; loading.close(); &#125; return response;&#125;, function (error, text) &#123; // 响应错误时取消loading if (loading) &#123; loading.close(); &#125; uiHelper.showMessage(errorText, 'error'); return Promise.reject(error);&#125;); 6.4 跳转拦截现在我们每一步路由的变化都会验证token了，但是如果我们直接手动将地址栏的地址更改，还是能够跳转到登陆后的页面的，所以我们需要跳转拦截，做法就是在导航守卫的钩子函数中进行拦截： 1234567891011121314151617181920212223router.beforeEach((to, from, next) =&gt; &#123; const token = sessionStorage.getItem('userToken'); const isTokenRight = !!(token &amp;&amp; JsonWebToken.decode(token) &amp;&amp; (JsonWebToken.decode(token).iss === config.userToken.iss)); // 全局设定发送请求header的token验证 if (isTokenRight) &#123; Vue.prototype.$http.defaults.headers.common['Authorization'] = 'Bearer ' + token &#125; if (to.path === '/login') &#123; // 如果是跳转到登陆页的 if (isTokenRight) &#123; // 如果有token就转向admin页不返回登录页 next('/admin') &#125; else &#123; // 否则呆在登陆页 next() &#125; &#125; else &#123; if (isTokenRight) &#123; // 如果有token就正常转向 next() &#125; else &#123; next('/login') // 否则跳转回登录页 &#125; &#125;&#125;); 注意：一定要确保要调用next()方法，否则钩子就不会被resolved。如果纯粹调用next(path)这样的方法最终还是会回到beforeEach()这个钩子里面来，如果没有写对条件就有可能出现死循环，栈溢出的情况。 至此，前后端的服务就算是都搭建起来了。 7 部署对于一个没有任何部署惊人的人来说，部署这个小demo也是花费了很多精力。下面就是我的部署过程 首先，你需要有一个服务器，我选的是腾讯云的云服务器，最低配置那种，一个月40多，如果是学生的话可以申请免费的（云虚拟主机是不可以的，云虚拟主机只能配置静态网页，无法自行配置node环境、部署koa的服务等） 然后，你还需要申请一个MySQL的服务，同样我选购的是最低配置的，一个月30多 7.1 配置环境都申请好了之后，要在虚拟服务器上配置环境。 7.1.1NodeJS首先就是要安装NodeJS，要存放下载资源的目录，我放在了usr/local/src目录下，然后执行安装命令： 1wget http://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-x64.tar.gz 上述命令是下8.10.0的64位NodeJS版本，如果你想下载其他版本，可以将命令中的两处v8.10.0替换成其他版本号；如果你的系统是 32 位(一般是64位)，也可以将x64改成x32 下载完成后，执行解压命令： 1tar -zxvf node-v8.10.0-linux-x64.tar.gz 解压完成，可以看到当前目录解压后的文件夹node-v8.10.0-linux-x64，将这个文件夹重命名： 1mv node-v8.10.0-linux-x64 node 现在，重命名后的node文件夹就是程序目录，然后需要添加环境变量，首先在root目录下找到.bash_profile，编辑： 1vim ~/.bash_profile 找到PATH=$PATH:$HOME/bin，在后面添加路径为： 1PATH=$PATH:$HOME/bin:/usr/local/src/node/bin 保存修改，然后重载一下 1source ~/.bash_profile 现在node和npm就可以全局使用了 7.1.2 MySQ客户端利用CentOS自带的包管理软件Yum去腾讯云的镜像源下载安装MySQL客户端。 1yum install mysql 输入：1mysql -h 172.21.0.15 -P 3306 -u root -p xxxx 其中172.21.0.15是你申请的MySQL的内网地址，3306是端口号，xxxx是密码 7.1.3 其他其他的软件都可以通过npm来安装了 7.1.4 保存镜像安装之后，在云主机的列表页，操作的选项卡中的更多，选择制作镜像，输入镜像名称和竞相描述，将镜像保存，如果有新的云主机或者需要重装系统的时候，就可以选择自己制作的镜像来快捷的安装依赖了。 7.2 静态资源托管前面提到过了，先用webpack打包出项目文件到dist目录中，然后使用koa-static来实现静态资源的托管 7.3 部署运行一般会使用pm2来管理Node应用进程，而不是直接用Node来执行，原因是pm2这类进程工具可以更方便的监控一些信息，包括cpu，内存，日志，异常，其他信息等 安装之后的启动命令 1pm2 start index.js 7.4 二级域名解析网站目前可以登录了，地址栏输入http://139.199.112.184/#/admin，就可以看到登录页面了 但是现在我们目前只能用IP登录，因为我没有单独购买域名，但是我以前在百度云购买国一个域名，oldzhou.cn，并且已经备案过，所以我想将这个demo作为二级域名解析到demo.oldzhou.cn 登录百度云控制台，进入域名服务→域名管理，点击添加解析，在主机记录输入demo，记录值输入腾讯云服务器的公网IP，其他选择默认值即可。 等待一会就可以通过demo.oldzhou.cn来访问了。 8 webpack打包优化8.1 开启Gzip在webpack.prod.conf.js中，引入了compression-webpack-plugin，用来生成一个被gzip压缩过的JS文件 1234567891011121314151617if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125; 可以看出来，压缩过的vendor.js文件由1.07M减小到了306kb 然后我们配合我们在前面提到的koa-compress中间件，来使用压缩后的JS文件，这时候来看我们的网络请求情况： 可以看到，size栏目上面的数字是传输的大小，是经过gzip压缩的，下面是文件实际的大小。 8.2 定位原因虽然小了很多，但是这样一个简单的demo压缩之后还有300kb，也是让人无法忍受的，我们就要找出打包后的文件到底大在哪里 我们可以使用webpack-bundle-analyzer插件，它可以帮助我们发现模块有哪些组成，体积多大。 安装： 1npm install --save-dev webpack-bundle-analyzer 安装完成之后，在webpack.config.js中进行配置，将webpack-bundle-analyzer作为插件导入进去： 1234567891011121314151617const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin(&#123; analyzerMode: 'server', analyzerHost: '127.0.0.1', analyzerPort: 8888, reportFilename: 'report.html', defaultSizes: 'parsed', openAnalyzer: true, generateStatsFile: false, statsFilename: 'stats.json', statsOptions: null, logLevel: 'info' &#125;), ] 然后需要在进行分析的时候设置环境变量为production，为了统一在不同的操作系统中的设置方法，可以使用cross-env这个库 安装： 1npm install cross-env --save-dev 使用时只需要在原来的脚本前面加上cross-env就可以了 准备工作做好之后，在项目的package.json文件中注入如下命令，以方便运行（npm run analyze），默认会打开http://127.0.0.1:8888作为展示。 12345&#123; "scripts": &#123; "analyz": "cross-env NODE_ENV=production npm_config_report=true npm run build" &#125;,&#125; 运行之后页面内容： 我们发现，两个大胖子是element-ui和vue，那就有针对性的对他们进行处理 8.2.1 element的按需加载element提供了按需加载的方法，可以有效地减小项目体积。 按需加载需要安装babel-plugin-component 1npm install babel-plugin-component -save-dev 然后在.babelrc中添加下面的内容： 123456789"plugins": [ [ "component", &#123; "libraryName": "element-ui", "styleLibraryName": "theme-chalk" &#125; ]] 然后就可以按需引入组件了，在scr/heper/elementHelper.js中，引入Vue和element的css文件，然后按需引入我们使用的表格、按钮等组件 12345678910111213141516import Vue from 'vue'import 'element-ui/lib/theme-chalk/index.css';import &#123; Table, TableColumn, Row, Col, Input, Button&#125; from 'element-ui'[ Table, TableColumn, Row, Col, Input, Button].forEach(Compo =&gt; Vue.use(Compo));export default Vue 引入之后需要使用Vue.use或者Vue.component(Button.name, Button)来注册组件，注册完成后导出Vue 在前端入口文件main.js中引用的Vue更改为由elementHelper.js导出的Vue，然后我们就可以再组件中使用element的组件了，比如ElButton、ElTable等 1&lt;ElButton type="primary" class="login-button" @click="login"&gt;登陆&lt;/ElButton&gt; 将element改为按需加载之后，再执行分析看一下体积 压缩前的打包体积由1.07M缩小到了614kb，压缩后的打包体积由299kb缩小到了203kb 8.2.2 外部引入模块针对打包后的Vue比较大的问题，我们采取通过绕过webpack打包，外部引入模块的方式解决，这样既可以减小打包后的体积，加快打包速度，同时CDN的下载速度肯定要比我目前申请的服务器的宽带速度要快。 既然要处理，我们将前端用的相关的包都通过外部引入 外部引入模块需要在webpack.prod.conf.js中配置externals， 123456externals: &#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'element-ui': 'ElementUI', 'axios': 'axios'&#125;, webpack可以不处理应用的某些依赖库，使用externals配置后，依旧可以在代码中通过CMD、AMD或者window/global全局的方式访问。关于externals更多的信息可以查看官网上的介绍 注意，这里面对应的属性名称比如Vue、VueRouter就是源码中看导出的模块的名称 然后在index.html中通过标签的形式引入 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;background-demo&lt;/title&gt; &lt;link type="text/css" href="static/base.css" rel="stylesheet"&gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.4.0/theme-chalk/index.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.2/vue.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.4.0/index.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/axios/0.18.0/axios.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这样做之后再来看一下打包后的体积： 压缩前的体积已经减小到了491kb，压缩后的体积缩小到了160kb 更多的还可以参考这篇文章进行分析和优化。 9 写在最后到这里基本上这个小的尝试就结束了，正如题目所说的，只是一个入门的尝试，并且还有很多可以改进的地方，但是他解决了我很多的疑惑，让我亲身接触到了前端之外的开发领域 学海无涯，大家加油。 参考 https://molunerfinn.com/Vue+Koa/#%E7%AE%80%E4%BB%8B https://chenshenhai.github.io/koa2-note/note/route/koa-router.html https://segmentfault.com/q/1010000005024412 https://cnodejs.org/topic/56936889c2289f51658f0926 https://www.npmjs.com/package/kcors https://div.io/topic/1937 https://itbilu.com/nodejs/npm/VkYIaRPz-.html https://segmentfault.com/q/1010000008379638 https://www.jianshu.com/p/fc7664e9025c https://segmentfault.com/a/1190000005811347 https://segmentfault.com/a/1190000008479977 https://www.zcfy.cc/article/two-quick-ways-to-reduce-react-app-s-size-in-production-1930.html https://segmentfault.com/q/1010000000672656 https://www.zcfy.cc/article/two-quick-ways-to-reduce-react-app-s-size-in-production-1930.html https://jeffjade.com/2017/08/06/124-webpack-packge-optimization-for-volume/ http://element-cn.eleme.io/#/zh-CN/component/quickstart https://www.cnblogs.com/wangrongxiang/p/8202912.html https://www.jb51.net/article/129670.htm https://blog.csdn.net/qq_25186543/article/details/79279874]]></content>
      <categories>
        <category>全栈开发</category>
      </categories>
      <tags>
        <tag>Koa2</tag>
        <tag>Vue</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具03 Webpack模块热重载(HMR)]]></title>
    <url>%2F2018%2F04%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F01%20%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B703%20Webpack%E6%A8%A1%E5%9D%97%E7%83%AD%E9%87%8D%E8%BD%BD(HMR)%2F</url>
    <content type="text"><![CDATA[使用webpack-dev-server 实现的Hot Moudle Replacement（HMR）让我们在开发时修改代码并保存后，不必手动刷新浏览器，而是让浏览器通过新的模块替换老的模块。这样可以让我们在保证当前页面状态的前提下，让新的代码生效，就如同在Chrome的控制台修改CSS样式一样。 使用安装webpack-dev-server 1npm install webpack-dev-server --save-dev 在webpack.config.js中进行配置 123456devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), host: 'localhost', compress: true, port: 8080&#125; 其中： contentBase：服务器基本运行路径 host：服务器运行地址 compress：服务器压缩式，一般为true port：服务运行端口 在package.json中定义相关命令： 123"scripts": &#123; "dev": "webpack-dev-server --hot --open",&#125;, 然后执行npm run dev就可以开启webpack的服务，并且实现模块热重载，并且自动打开浏览器。 增加--open属性可以自动打开浏览器。 原理解析原来只是在各种Cli工具中使用了模块热重载，知道是利用了Webpack的HMR特性，但是它是怎么实现的却不了解。今天在清理收藏夹攒的知识时看到了饿了么前端专栏的这篇文章Webpack HMR 原理解析，写的非常好，简单易懂，把道理也说的很明白。 上图展示了从修改代码到模块热更新完成的一个周期： 第一步：Webpack在watch模式下打包更改的文件到内存中（对应图中的①②③）Webpack-dev-middleware调用Webpack的API对文件系统watch，监听到文件变化时，根据配置文件对模块重新编译打包，将打包后的代码以JavaScript对象的形式保存在内存中。 12345// webpack-dev-middleware/lib/Shared.jsif (!options.lazy) &#123; var watching = compiler.watch(options.watchOptions, share.handleCompilerCallback); context.watching = watching;&#125; Webpack会将打包的文件保存在内存中，而不是打包到output.path目录下，是因为访问内存中的代码比访问文件系统中的代码更快，也减少了写入文件的开销。这个过程利用了memory-fs这个库，它提供了一个简单的基于内存的文件系统，所有数据都保存在JavaScript对象中。 图中的第③步也是对文件变化的监控，只不过这一步监听的不是代码，而是在配置文件制定的静态文件目录下的静态文件的变化（当配置文件中配置了devServer.watchContentBase为true的时候），当静态文件发生变化时通知浏览器对应用进行刷新（注意是浏览器刷新，而非HRM） 第二步：webpack-dev-Server通知浏览器端文件发生变化（对应④）浏览器端和服务端之间是通过Websocket长连接进行通信的，利用的是sockjs建立的。通过Websocket长连接，webpack-dev-Server将编译打包的各个阶段状态告知浏览器（包括第③步中监听的静态文件的变化）。 同时webpack-dev-Server调用Webpack的API监听complie的done事件，在编译完成后，webpack-dev-Server通过_sendStatus方法将编译打包后的新模块的hash值发送给浏览器，后面的步骤都会利用这个hash值来进行模块热替换。 12345678910111213141516171819202122232425// webpack-dev-server/lib/Server.jscompiler.plugin('done', (stats) =&gt; &#123; // stats.hash 是最新打包文件的 hash 值，发送给浏览器 this._sendStats(this.sockets, stats.toJson(clientStats)); this._stats = stats;&#125;);// ...Server.prototype._sendStats = function (sockets, stats, force) &#123; if (!force &amp;&amp; stats &amp;&amp; (!stats.errors || stats.errors.length === 0) &amp;&amp; stats.assets &amp;&amp; stats.assets.every(asset =&gt; !asset.emitted) ) &#123; return this.sockWrite(sockets, 'still-ok'); &#125; // 调用 sockWrite 方法将 hash 值通过 websocket 发送到浏览器端 this.sockWrite(sockets, 'hash', stats.hash); if (stats.errors.length &gt; 0) &#123; this.sockWrite(sockets, 'errors', stats.errors); &#125; else if (stats.warnings.length &gt; 0) &#123; this.sockWrite(sockets, 'warnings', stats.warnings); &#125; else &#123; this.sockWrite(sockets, 'ok'); &#125;&#125;; 第三步：webpack-dev-server/client接收到服务端消息做出响应（对应⑤⑪）webpack-dev-server/client端并不能够请求更新的代码，也不会执行热更模块操作，而是在接收到通过长连接收到的服务端的消息后，对信息进行处理，而具体的更新操作又交回给了Webpack。 webpack/hot/dev-server的工作就是根据webpack-dev-server/client传给它的信息以及dev-server的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 我们并没有在业务代码里添加Websocket客户端的代码，也没有在webpack.config.js中的entry属性中添加新的入口文件，那么bundle.js中的接受Websocket信息的代码是从哪来的呢？答案是webpack-dev-server会自动修改Webpack配置中的entry属性，在里面添加了webpck-dev-client的代码。 具体来看，webpack-dev-server/client接收到type为hash的消息后会将hash保存起来，接收到type为ok的消息后会执行relooad操作，在reload操作中会根据hot的配置是刷新浏览器还是执行热更新（HMR）: 123456789101112131415161718192021// webpack-dev-server/client/index.jshash: function msgHash(hash) &#123; currentHash = hash;&#125;,ok: function msgOk() &#123; // ... reloadApp();&#125;,// ...function reloadApp() &#123; // ... if (hot) &#123; log.info('[WDS] App hot update...'); const hotEmitter = require('webpack/hot/emitter'); hotEmitter.emit('webpackHotUpdate', currentHash); // ... &#125; else &#123; log.info('[WDS] App updated. Reloading...'); self.location.reload(); &#125;&#125; 在上面的代码中，webpack-dev-server/client首先将接收到的hash值存储到currentHash变量中，当接收到ok消息后调用reloadApp方法，在其内部根据hot配置，决定是调用webpack/hot/emitter将最新的hash值发送给Webpack执行热更新，还是直接调用location.reload刷新页面。 第四步：Webpack接收新的hash值并请求模块代码（对应⑥⑦⑧⑨）首先webpack/hot/dev-server监听上一步webpack-dev-server/client发送的webpackHotUpdate消息，然后调用webpack/lib/HotModuleReplacement.runtime（简称HMR runtime），HMR runtime是客户端HMR的中枢，它首先通过JsonpMainTemplate.runtime调用hotDownloadManifest方法向server端发送JSONP请求，检查是否有更新的文件，如果有的话服务端返回一个JSON响应，包含了所有要更新的模块的hash值。 获取到更新列表后，该模块通过hotDownloadUpdateChunk再次发送JSONP请求，获取到最新的模块代码，并返回给HMR runtime。 上面为了获取最新的Hash值和最新的代码，HMR runtime向服务端发送了两次Ajax请求，为什么不在第三步的Websocket长连接中发送给浏览器呢？可能的原因： （1）包括了功能模块的解耦，webpack-dev-server/client只负责消息的传递而不负责新模块的拉取，HRM runtime来负责获取新代码 （2）可以使用webpack-hot-middleware来代替webpack-dev-server实现HMR，webpack-hot-middleware没有使用Websocket，而是使用EventSource来实现客户端与服务端通信。 第五步：HMR runtime对模块进行热更新（对应⑩）HMR runtime会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 这一切都发生在HMR runtime的hotApply方法中： 12345678910111213141516171819202122232425262728293031323334// webpack/lib/HotModuleReplacement.runtimefunction hotApply() &#123; // ... var idx; var queue = outdatedModules.slice(); while (queue.length &gt; 0) &#123; moduleId = queue.pop(); module = installedModules[moduleId]; // ... // remove module from cache delete installedModules[moduleId]; // when disposing there is no need to call dispose handler delete outdatedDependencies[moduleId]; // remove "parents" references from all children for (j = 0; j &lt; module.children.length; j++) &#123; var child = installedModules[module.children[j]]; if (!child) continue; idx = child.parents.indexOf(moduleId); if (idx &gt;= 0) &#123; child.parents.splice(idx, 1); &#125; &#125; &#125; // ... // insert new code for (moduleId in appliedUpdate) &#123; if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123; modules[moduleId] = appliedUpdate[moduleId]; &#125; &#125; // ...&#125; hotApply方法主要分为了三个阶段： 找出陈旧的模块outdatedModules和依赖outdatedDependencies 从缓存中删除过期的模块和依赖 将新的模块和依赖添加到moudles中，当下次调用_webpack_require方法时就获取到新的代码 如果HMR失败后，回退到live reload操作，也就是进行浏览器刷新来获取最新打包代码，相关的代码在dev-server中： 123456789101112module.hot.check(true).then(function(updatedModules) &#123; if (!updatedModules) &#123; return window.location.reload(); &#125; // ...&#125;).catch (function(err) &#123; var status = module.hot.status(); if (["abort", "fail"].indexOf(status) &gt;= 0) &#123; window.location.reload(); &#125;&#125;); 第六步：业务代码改造当新的模块代替老的模块后，旧的业务代码并不能知道代码发生变化，所以需要在业务代码的入口调用HMR的accept方法，添加模块更新后的处理函数： 123456// index.jsif (module.hot) &#123; module.hot.accept('./hello.js', function() &#123; // 更新后的处理函数 &#125;)&#125; 参考 模块热替换@webpack webpack/webpack-dev-server@github Webpack HMR 原理解析@知乎]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>HMR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 ES6标准入门(Promise对象)]]></title>
    <url>%2F2018%2F04%2F17%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F03%20ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%2F09%20ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8(Promise%E5%AF%B9%E8%B1%A1)%2F</url>
    <content type="text"><![CDATA[学习Promise的笔记。 含义Promise是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。==只有异步操作的结果，可以决定当前是哪一种状态==，任何其他操作都无法改变这个状态。 （2）==一旦状态改变，就不会再变，任何时候都可以得到这个结果==。 Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就==凝固==了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。 Promise也有一些缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法Promise对象是一个构造函数，用来生成Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数 第一个回调函数是Promise对象的状态变为resolved时调用 第二个回调函数是Promise对象的状态变为rejected时调用（第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数）。 一个简单的例子： 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，比如像下面这样 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 1234567891011const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2.then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面的p2的状态在1秒之后改变，resolve方法返回的是p1，所以p2的状态决定于p1，在p1状态确定后p2的then和catch才会被执行 注意，==调用resolve或reject并不会终结Promise的参数函数的执行==。 一般来说，调用resolve或reject以后，Promise的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。 then方法返回的是一个==新的==Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("resolved: ", comments);&#125;, function funcB(err)&#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为 rejected，就调用funcB。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。 另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 如果Promise 状态已经变成resolved，再抛出错误是无效的。 Promise对象的错误具有“冒泡”性质，==会一直向后传递==，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); ==一般来说，不要在then方法里面定义Reject状态的回调函数（即 then 的第二个参数），总是使用catch方法。== 12345678910111213// badpromise.then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise.then(function(data) &#123; //cb // success &#125;).catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是==第二种写法可以捕获前面then方法执行中的错误==，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 1234567891011121314const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123 上面代码中，someAsyncThing函数产生的Promise对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。 这就是说，Promise内部的错误不会影响到Promise外部的代码，通俗的说法就是Promise 会吃掉错误。 一般总是建议，Promise对象后面要跟catch方法，这样可以处理Promise内部发生的错误。catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。 另外，==注意catch和then一样，也会返回一个可链式操作的新的Promise对象== Promise.prototype.finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是ES2018引入标准的。 123promise.then(result =&gt; &#123;···&#125;) .catch(error =&gt; &#123;···&#125;) .finally(() =&gt; &#123;···&#125;); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的Promise状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于Promise的执行结果。 可以手写一个简单的finally方法（美团点评面试）： 12345678Promise.prototype.finally = Promise.prototype.finally || function (callback) &#123; if (Object.prototype.toString.call(this) !== '[object Promise]') &#123; return &#125; return Promise.resolve( this.then(() =&gt; callback()).catch(() =&gt; callback()) )&#125; Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1const p = Promise.all([p1, p2, p3]); Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise实例，如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise 实例。） 数组中的各个Promise实例同时开始 p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值==按顺序==组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意，如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并==不会触发==Promise.all()的catch方法。 1234567891011const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e));// ["hello", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的Promise实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 注意，这样每个promise实例都要有自己的then方法，并且有返回值，才能被 all 方法的then接住 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 同样可以手写一个Promise.all方法（滴滴面试）： 123456789101112131415161718192021Promise.all = Promise.all || function (promiseAll) &#123; let total = promiseAll.length; // 需要提前将结果数组的长度预定好，因为需要按顺序存入Promise结果 let result = new Array(total); let doneCount = 0; return new Promise((resolve, reject) =&gt; &#123; promiseAll.forEach(promise =&gt; &#123; promise.then((value, index) =&gt; &#123; result[index] = value; doneCount++; if(doneCount === total) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。其余的Promise就不再改变了 数组中的各个Promise实例同时开始 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 手写一个Promise.race的实现： 1234567Promise.race2 = Promise.race2 || function (promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(promise =&gt; &#123; promise.then(v =&gt; resolve(v)).catch(err =&gt; reject(err)) &#125;) &#125;)&#125; Promise.resolve()Promise.resolve方法可以将现有对象转为Promise对象 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve等价于下面的写法 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况 （1）参数是一个Promise实例 Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行改对象的then方法。 123456789let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 123456const p = Promise.resolve('Hello'); p.then(function (s)&#123; console.log(s)&#125;);// Hello （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。所以，==如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法== 1234const p = Promise.resolve();p.then(function () &#123; // ...&#125;); Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise的错误处理最好使用catch代替then里面的第二个参数来捕获错误，因为这样就可以==捕获then的第一个参数中发生的错误== 同时，catch会检测的区域是==整个==promise链上之前每个地方的（then和其他异步操作），如果它前面还有另一个catch，则从那个catch后面开始 还有就是，catch也会返回一个可链式操作的新Promise对象，所以如果在一个catch中抛出一个错误，也会被下一个catch捕获 如果多层嵌套时，如果内层的错误在内层有catch捕获，那么就不会被外层的catch捕获到，如果内层没有被捕获，则会“冒泡”到外层的catch 如果Promise的错误没有被处理，那么可以通过unhandledrejection来统一捕获未==处理的Promise错误==（美团面试） 注意，有两个关键词： （1）一个是==未处理==的，如果被catch处理了，则不会被unhandledrejection捕获 （2）另一个是Pormise错误，必须是在Promise链路上发生的错误，否则也不会被捕获 使用： 123window.addEventListener('unhandledrejection', e =&gt;&#123; console.log(e)&#125;) 事件对象e是PromiseRejectionEvent事件，有两个属性: promise：被rejected的Promise reason：被rejected的原因 12345678910111213141516const p1 = new Promise((resolve) = &gt; &#123; a(); setTimeout((a) = &gt; &#123; resolve(a) &#125;, 1000, 'ok1')&#125;);p1.then(v = &gt; &#123; console.log(v)&#125;);window.addEventListener('unhandledrejection', e = &gt; &#123; console.log(e.reason) e.preventDefault()&#125;)// ReferenceError: a is not defined 可以通过e.preventDefault()来将错误拦截到此为止。 还可以监听rejectionhandled事件，当一个Promise发生错误，最初未被处理，稍后被处理的情况 12345678910111213141516171819202122232425262728const p1 = new Promise((resolve) =&gt; &#123; a(); setTimeout((a) =&gt; &#123; resolve(a) &#125;, 1000, 'ok1')&#125;);p1.then(v = &gt; &#123; console.log(v)&#125;);setTimeout(() =&gt; &#123; p1.catch (v =&gt; &#123; console.log(v, 'rejection') &#125;)&#125;, 1000);window.addEventListener('unhandledrejection', e =&gt; &#123; console.log(e.reason, 'unhandledrejection'); e.preventDefault()&#125;);window.addEventListener('rejectionhandled', e =&gt; &#123; console.log(e.reason, 'unhandledrejection')&#125;);// ReferenceError: a is not defined "unhandledrejection"// ReferenceError: a is not defined "rejection" 实例：图片加载一个例子，根据图片加载状态执行异步操作 123456789101112131415const preLoadImage = (path) = &gt; &#123; return new Promise(((resolve, reject) = &gt; &#123; let img = new Image(); img.src = path; img.className = 'image'; img.onload = () = &gt; resolve(img); img.onerror = () = &gt; reject(new Error('出错了')); &#125;))&#125;;preLoadImage('../demo03-上传图片预览/default.png') .then((img) = &gt; &#123; document.querySelector('#div').appendChild(img); &#125;).catch ((err) = &gt; &#123; console.log(err) &#125;) 手动实现Promise看了一些参考文章，还是迷迷糊糊，有机会要重新看（2019-04-11） 首先建立一个构造函数 123456789101112131415161718192021222324252627282930function MyPromise(fn) &#123; // 省略非 new 实例化方式处理 // 省略 fn 非函数异常处理 // promise 状态变量 // 0 - pending // 1 - resolved // 2 - rejected this._state = 0; // promise 执行结果 this._value = null; // then 方法注册的回调函数 this._deferreds = []; // 立即执行 fn 函数，调用私有方法 resolve 和 reject try &#123; fn( value =&gt; &#123; resolve(this, value) &#125;, reason =&gt; &#123; reject(this, reason) &#125; ) &#125; catch (e) &#123; reject(this, e) &#125;&#125; 然后来看resolve函数，它的目的主要是用来将promise实例的状态由pending改为resolved，它接受了两个参数，第一个参数是当前的promise实例，第二个参数是promise的执行结果 resolve函数中要处理的情况还是比较复杂的，主要是根据value的类型，这里只处理了value为promise和普通对象的情况，为thanable对象和函数的情况省略没有处理。 1234567891011121314151617181920212223242526272829303132333435/** * 用来改变 promise 状态。 * @param promise promise实例 * @param value promise的执行结果 * @returns &#123;*&#125; */function resolve(promise, value) &#123; // 非 pending 状态不可改变 if (promise._state !== 0) &#123; return; &#125; // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if (value === promise) &#123; return reject(promise, new TypeError('A Promise cannot be resolved with itself')) &#125; // 如果 value 为 Promise，则使 promise 接受 value 的状态 if (isPromise(value)) &#123; const deferreds = promise._deferreds; if (value._state === 0) &#123; // value 为 pending 状态 // 将 promise._deferreds 传递给 value.deferreds // 这样，当 value 不为 pending 状态后，可以抛弃之前的 promise，以 value 作为当前的 promise 执行 then 注册函数 value._deferreds.push(...deferreds) &#125; else if (deferreds.length &gt; 0) &#123; // value 为非 pending 状态 // 使用 value 作为当前的 promise ，执行 then 注册回调处理 for (let i = 0; i &lt; deferreds.length; i++) &#123; // handleResolved 是实际处理 handleResolved(value, deferreds[i]) &#125; // 清空回调函数队列 value._deferreds = [] &#125; return; &#125; 其中用到一个工具函数isPromise用来判断对象是否是一个Promise对象： 123function isPromise(value) &#123; return value &amp;&amp; Object.prototype.toString.call(value) === '[object Promise]' &amp;&amp; value.then&#125; 最后实际执行调用的是handleResolved函数，它不光在resolve函数中调用，在其他地方也被调用，它的主要目的有两个，一个是实现了当then注册函数为空时的透传功能，另外就是根据promise的状态来判断调用onResolved或onRejected 要注意的是需要保证异步调用，防止调用顺序错乱，使用了asyncFn函数来模拟异步执行。 123456789101112131415161718192021222324252627282930313233343536// 根据 promise 当前状态判断调用 onResolved 或 onRejected// 处理 then 注册回调为空的情形// 维护 then 链式调用function handleResolved(promise, deferred) &#123; asyncFn(function () &#123; const cb = promise._state === 1 ? deferred.onResolved : deferred.onRejected; let res; // 使用 deferred.promise 作为当前 promise 结合 value 调用后续处理函数继续往后执行，实现值穿透空处理函数往后传递。 if (!cb) &#123; if (promise._state === 1) &#123; resolve(deferred.promise, promise._value) &#125; else &#123; reject(deferred.promise, promise._value) &#125; return; &#125; try &#123; // 根据状态调用 then 中注册的 onResolved 或 onRejected 函数 res = cb(promise._value); &#125; catch (e) &#123; reject(deferred.promise, e) &#125; resolve(deferred.promise, res) &#125; )&#125;// 模拟异步执行函数function asyncFn() &#123; if (process &amp;&amp; typeof process === 'object' &amp;&amp; typeof (process.nextTick) === 'function') &#123; return process.nextTick &#125; else if (typeof setImmediate === 'function') &#123; return setImmediate &#125; return setTimeout&#125; 上面的函数中，之所以deferred对象之所以有onResolved和onRejected对应的方法，是因为我们在then函数的处理中进行了封装，下面看一下在原型上定义的then方法： 1234567891011121314151617181920212223242526272829MyPromise.prototype.then = function (onResolved, onRejected) &#123; // 实例化空 promise 对象用来返回（保持then链式调用) const res = new Promise(function () &#123; &#125;); // 使用 onResolved，onRejected 实例化处理对象 Handler const deferred = new Handler(onResolved, onRejected, res); // 当前状态为 pendding，存储延迟处理对象 if (this._state === 0) &#123; this._deferreds.push(deferred); // 返回新 promise 对象，维持链式调用 return res; &#125; // 当前 promise 状态不为 pending // 调用 handleResolved 执行 onResolved 或 onRejected 回调 handleResolved(this, deferred); // 返回新 promise 对象，维持链式调用 return res;&#125;// 封装存储 onResolved、onRejected 函数和新生成 promise 对象function Handler(onResolved, onRejected, promise) &#123; this.onResolved = typeof onResolved === 'function' ? onResolved : null; this.onRejected = typeof onRejected === 'function' ? onRejected : null; this.promise = promise;&#125; 之所以没有直接返回this，而是返回了一个新的Promise对象来实现链式调用，看下面的代码 123var promise2 = promise1.then(function (value) &#123; return Promise.reject(3)&#125;) 假如then函数执行返回this调用对象本身，那么promise2 === promise1，promise2状态也应该等于promise1同为resolved。而onResolved回调中返回状态为rejected对象。考虑到Promise状态一旦resolved或rejected就不能再迁移，所以这里promise2也没办法转为回调函数返回的rejected状态，产生矛盾。 剩下的就是reject函数，简单得多： 12345678910111213141516function reject(promise, reason) &#123; // 非 pending 状态不可变 if (promise._state !== 0) &#123; return &#125; // 改变 promise 内部状态为 rejected promise._state = 2; promise._value = reason; // 判断是否存在 then 注册回调函数，如果存在则依次执行 if (promise._deferreds.length &gt; 0) &#123; for (let i = 0; i &lt; promise._deferreds.length; i++) &#123; handleResolved(promise, promise._deferreds) &#125; promise._deferreds = [] &#125;&#125; 感觉现在大概能够明白这个意思了，但是要是自己实现可能还是要费点劲，考虑不了太多的情况，还是能力差。 有时间还是要来回顾，不断整理自己的笔记。 参考 then or catch@Promise迷你书 PromiseRejectionEvent@MDN unhandledrejection@MDN 解读Promise内部实现原理@掘金]]></content>
      <categories>
        <category>ES6标准入门</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高06 组件间通信]]></title>
    <url>%2F2018%2F04%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F02%20Vue%E6%8F%90%E9%AB%98%2FVue%E6%8F%90%E9%AB%9806%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Vue中组件通信的方法。 父子组件通信父组件向子组件传递数据父组件向子组件传递数据，直接使用prop即可，父组件中在子组件的实例上通过v-bind传入prop: 1&lt;LeftChild :message="myMessage"&gt;&lt;/LeftChild&gt; 在子组件中声明了这个prop之后就可以使用： 123456789&lt;template&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'message' ], &#125;&lt;/script&gt; 子组件向父组件传递数据子组件向父组件可以直接通过$emit组件上的事件来进行通信，例如在父组件中，通过v-on为子组件传入一个事件： 12345678910111213&lt;template&gt; &lt;LeftChild @changeValue="setValue"&gt;&lt;/LeftChild&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; setValue(newValue) &#123; // newValue 就是从子组件传递的数据 &#125; &#125;, &#125;&lt;/script&gt; 子组件中通过#emit来触发传入的自定义事件，以参数的形式将数据传递给父组件： 12345678910111213&lt;template&gt; &lt;div @click="clickHandler"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; clickHandler() &#123; // 第二个参数就是要传递的数据 this.$emit('changeValue', 'hello') &#125; &#125;, &#125;&lt;/script&gt; 非父子组件通信非父子组件的通信有几种解决方案，如果是比较复杂的应用，可以直接使用Vuex来实现通信和数据管理，如果不使用Vuex则可以使用下面几种方法来实现组件通信。 事件总线原理就是通过一个空的Vue实例eventBus，A组件首先在eventBus上通过$on订阅一个事件，然后在组件B中通过$emit发布一个事件，在事件中将数据进行传递。 首先在一个单独的文件中定义名称为eventBus的Vue实例，并导出这个实例 123456// eventBus.jsimport Vue from 'vue';export default new Vue(&#123; name: 'eventBus',&#125;) 在组件A引入eventBus后，在eventBus上订阅一个事件getValue，最好在组件销毁前注销监听的事件： 1234567891011121314// 组件Aimport eventBus from './eventBus';export default &#123; mounted() &#123; eventBus.$on('getValue', value =&gt; &#123; // value 从 getValue 事件传递的数据 &#125;) &#125;, beforeDestroy() &#123; // 组件销毁之前 eventBus.$off('getValue') &#125;,&#125; 然后在组件B中也引入eventBus后，借由eventBus发布getValue事件，并将数据作为第二个参数传递给事件的订阅者： 12345678910// 组件Bimport eventBus from './eventBus';export default &#123; methods: &#123; clickHandler() &#123; eventBus.$emit('getValue', 'hello') &#125; &#125;,&#125; 事件总线的优化上面这种方式，在每个需要通信的组件都需要手动引入eventBus，很麻烦。所以希望能够做到一次注入，到处使用。 改进的方法就是在main.js中定义Vue根实例时，将eventBus添加到根实例的data中，然后再每个组件中都可以通过this.#root.eventBus来访问它： 123456789// main.jsnew Vue(&#123; el: '#app', data: &#123; eventBus: new Vue() // 增加总线实例 &#125;, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 在组件A使用$root.eventBus.$on来订阅事件： 123456789101112// 组件Aexport default &#123; mounted() &#123; this.$root.eventBus.$on('getValue', value =&gt; &#123; // value 从 getValue 事件传递的数据 &#125;) &#125;, beforeDestroy() &#123; // 组件销毁之前 this.$root.eventBus.$off('getValue') &#125;,&#125; 在组件B中使用$root.eventBus.$on来发布事件： 12345678910// 组件Bimport eventBus from './eventBus';export default &#123; methods: &#123; clickHandler() &#123; this.$root.eventBus.$emit('getValue', 'hello') &#125; &#125;,&#125; 通过原型Vue对象本质上就是一个JS对象，想要引入eventBus只需要在Vue的原型prototype上增加一个属性就可以了。本质上所有的Vue组件都是继承全局的Vue，所以只要在初始化Vue对象之前在prototype上定义属性，这样所有的组件都可以访问这个属性了。 所以在main.js中，在实例化Vue之前增加代码 123// main.js// 在实例化Vue实例之前Vue.prototype.$eventBus = Vue.prototype.$eventBus || new Vue(); 组件A中 12// 组件Athis.$eventBus.$on('getValue', value =&gt; &#123;&#125;) 组件B中 12// 组件Bthis.$eventBus.$emit('getValue', 'message') 使用Vue.observaleVue的2.6版本新增了一个Vue.observale，它可以定义一个可响应的对象，实际上Vue内部会用它来处理data函数返回的对象。 这个API返回的对象可以直接用于渲染函数和计算属性内，并且在发生改变时触发相应的更新，可以作为最小化的跨组件状态存储器，用于简单的场景。 我们新建一个simpleStore.js，导出一个使用Vue.observale处理后的对象： 123456// simpleStore.jsimport Vue from 'vue';export default Vue.observable(&#123; count: 0&#125;) 然后再main.js中作为Vue的根实例的data的属性导入（也可以根据组件通信的范围，分别在不同的组件导入，比如作为组件的数据处理层时）： 1234567891011// main.jsimport simpleStore from './simpleStore'new Vue(&#123; el: '#app', data: &#123; simpleStore, &#125;, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 这样在需要通信的组件中就可以直接修改这个变量，在另外一个组件中通过计算属性引入这个变量，就可以实现响应式的更新： 组件A中直接修改这个变量： 12345678// 组件Aexport default &#123; methods: &#123; clickHandler() &#123; this.$root.observable.count += 1; &#125; &#125;,&#125; 组件B中通过计算属性引入这个变量： 12345678// 组件Bexport default &#123; computed: &#123; value() &#123; return this.$root.observable.count; &#125; &#125;&#125; 实际上在simpleStore.js中我们可以继续定义commit、action、mutation、dispatch等事件，来统一管理变量的修改，实际上就是自己实现了一个简易的Vuex 在使用Vue.observable时，有两点需要注意： （1）Vue.observable返回的对象只能用于渲染函数或者计算属性内，才能实现响应式的更新，不能直接用于data函数中赋值 123456789const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h('button', &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; （2）在Vue 2.x中，被传入的对象会直接被Vue.observable改变，它和被返回的对象是同一个对象。但是在Vue 3.x中，则会返回一个可响应的代理，而对源对象直接进行修改仍是不可相应的。因此为了兼容性，应该始终操作Vue.observable返回的对象，而不是传入的源对象。 参考 组件基础@Vue Vue2.0 事件发射与接收@CSDN vue 中央事件总线 Vue.observable(object)@Vue]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex03 Vuex其他]]></title>
    <url>%2F2018%2F02%2F21%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F05%20Vuex%2FVuex03%20Vuex%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[Vuex其他知识点。 插件Vuex的插件就是一个函数，接收store作为唯一参数，通过subscribe对store每次的mutation进行监听： 1234567const myPlugin = store =&gt; &#123; // 当store初始化后调用 store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation 的格式为 &#123; type, payload &#125; &#125;)&#125; 插件需要使用plugins选项引入： 1234const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 插件内同样不允许直接修改state，只能通过只能通过提交mutation来触发变化 严格模式开启严格模式，当不通过mutation而直接修改state时，Vuex都会抛出错误。 不要再发布环境下启用严格模式，严格模式会深度检测状态树来检测不合规的状态变更，造成性能上的损失： 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production'&#125;) 表单处理在开启了严格模式后，把Vuex的state使用到v-model会报错： 1&lt;input v-model="subTitle.message" type="text" /&gt; 上面的代码中的subTitle是属于Vuex的store的对象，用户输入时相当于没有通过mutation直接修改了state，Vuex会抛出错误： 1Error: [vuex] do not mutate vuex store state outside mutation handlers. 解决方法有两个，一种是利用了v-model的语法糖的本质，将obj.message作为value，再input方法中手动触发commit方法，然后在mutation中修改state值 1&lt;input :value="subTitle.message" type="text" @input="inputHandler"/&gt; 12345678910export default &#123; methods: &#123; inputHandler(e) &#123; this.$store.commit('changeSubTitle', &#123; message: e.target.value &#125;) &#125;, &#125;, computed: &#123; ...mapState(['subTitle']), &#125;&#125; 在Store中： 1234567export default new Vuex.Store(&#123; mutations: &#123; changeSubTitle(state, &#123; message &#125;) &#123; state.subTitle.message = message; &#125; &#125;,&#125;) 另一种方法就是使用带有setter的双向绑定计算属性： 1&lt;input v-model="title" type="text" /&gt; 12345678910111213computed: &#123; // 带有 setter 的双向绑定的计算书行 title: &#123; get() &#123; return this.$store.state.title &#125;, set(value) &#123; this.$store.commit('changeTitle', &#123; message: value &#125;) &#125; &#125;,&#125; 测试Mutation和Getter测试时思路相同，将Mutation或者Getter单独导出来，在测试文件中模拟一个state，来进行断言： 12345678910111213const state = &#123; count: 0,&#125;// mutations 作为命名输出对象export const mutations = &#123; increment: state =&gt; state.count++&#125;export default new Vuex.Store(&#123; state, mutations&#125;) 12345678910111213141516// mutations.spec.jsimport &#123; expect &#125; from 'chai'import &#123; mutations &#125; from './store'const &#123; increment &#125; = mutationsdescribe('mutations', () =&gt; &#123; it('INCREMENT', () =&gt; &#123; // 模拟状态 const state = &#123; count: 0 &#125; // 应用 mutation increment(state) // 断言结果 expect(state.count).to.equal(1) &#125;)&#125;) 测试Action比较麻烦，因为它们可能会调用外部的API，需要将外部的API调用进行Mock，可以使用webpack和inject-loader打包测试文件： 123456789// actions.jsimport shop from '../api/shop'export const getAllProducts = (&#123; commit &#125;) =&gt; &#123; commit('REQUEST_PRODUCTS') shop.getProducts(products =&gt; &#123; commit('RECEIVE_PRODUCTS', products) &#125;)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// actions.spec.js// 使用 require 语法处理内联 loaders。// inject-loader 返回一个允许我们注入 mock 依赖的模块工厂import &#123; expect &#125; from 'chai'const actionsInjector = require('inject-loader!./actions')// 使用 mocks 创建模块const actions = actionsInjector(&#123; '../api/shop': &#123; getProducts (cb) &#123; setTimeout(() =&gt; &#123; cb([ /* mocked response */ ]) &#125;, 100) &#125; &#125;&#125;)// 用指定的 mutations 测试 action 的辅助函数const testAction = (action, args, state, expectedMutations, done) =&gt; &#123; let count = 0 // 模拟提交 const commit = (type, payload) =&gt; &#123; const mutation = expectedMutations[count] try &#123; expect(mutation.type).to.equal(type) if (payload) &#123; expect(mutation.payload).to.deep.equal(payload) &#125; &#125; catch (error) &#123; done(error) &#125; count++ if (count &gt;= expectedMutations.length) &#123; done() &#125; &#125; // 用模拟的 store 和参数调用 action action(&#123; commit, state &#125;, ...args) // 检查是否没有 mutation 被 dispatch if (expectedMutations.length === 0) &#123; expect(count).to.equal(0) done() &#125;&#125;describe('actions', () =&gt; &#123; it('getAllProducts', done =&gt; &#123; testAction(actions.getAllProducts, [], &#123;&#125;, [ &#123; type: 'REQUEST_PRODUCTS' &#125;, &#123; type: 'RECEIVE_PRODUCTS', payload: &#123; /* mocked response */ &#125; &#125; ], done) &#125;)&#125;) 还是挺复杂的，实际上actionsInjector模块mock的仅仅是API部分（../api/shop），而actions.getAllProducts执行的还是原来的action，但是commit和state已经都被我们替换了。 如果可以使用Sinon.JS，那么可以使用它来替换上面的辅助函数testAction： 123456789101112131415describe('actions', () =&gt; &#123; it('getAllProducts', () =&gt; &#123; // 一步直接模拟 commit const commit = sinon.spy() const state = &#123;&#125; actions.getAllProducts(&#123; commit, state &#125;) expect(commit.args).to.deep.equal([ ['REQUEST_PRODUCTS'], ['RECEIVE_PRODUCTS', &#123; /* mocked response */ &#125;] ]) &#125;)&#125;) 如果需要给Vuex写单元测试的时候，还是需要到这里对照着例子来实现一下。 执行测试可以在Node环境下，也可以在浏览器环境下，在Node环境下执行的时候需要创建以下webpack配置（需要配置好.babelrc）： 1234567891011121314151617// webpack.config.jsmodule.exports = &#123; entry: './test.js', output: &#123; path: __dirname, filename: 'test-bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125; ] &#125;&#125; 执行的时候： 12$ webpack $ mocha test-bundle.js 在浏览器中测试可以参考文档。 热重载Vue-cli脚手架针对Vuex提供了热刷新的功能，当更改Store的数据，页面会自动刷新，但是相比于Vue组件的热重载功能，体验还是略逊一筹。 Vuex想要实现热重载，也是借助了webpack的Hot Module Replacement API，以前曾经学习过它的实现原理/)（注意，面试的时候的高频题目） 实现热重载的前提就是，必须将代码模块化，所以Store中的Mutation/Module/Action/Getter必须导出为单独的JS文件，才可以实现热重载 12345678910111213141516if (module.hot) &#123; module.hot.accept(['./modules/todo-list'], () =&gt; &#123; // 获取更新后的模块 // 因为 babel 6 的模块编译格式问题，下面需要加上 .default const newTodoList = require('./modules/todo-list').default; console.log(newTodoList); // 加载新模块 store.hotUpdate(&#123; modules: &#123; store_todoList: newTodoList, &#125; &#125;) &#125;)&#125; 注意：热重载的目标只能是Mutation/Module/Action/Getter，手动对state的修改不能触发HMR，可以参考这个issue。所以这就导致了一个问题： 如果配置了热重载，那么如果改动state时就必须手动刷新，热刷新也没有了；如果不配置热重载，修改任何文件都是热刷新。这样的话热重载我感觉意义不大]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex02 Vuex基础]]></title>
    <url>%2F2018%2F01%2F31%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F05%20Vuex%2FVuex02%20Vuex%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vuex快速学习笔记。 如何引入Vuex首先安装Vuex： 1npm install vuex --save 然后在src中新建一个文件夹store，在里面新建一个JS文件index.js，这就是我们的Vuex的主文件（如果项目木块比较多，可以在store中再建立moudles文件夹，利用Vuex提供的模块拆分功能，拆分模块） 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 然后在index.js中，引入Vuex（Vue.use(Vuex)），创建store和对应的state、getter、mutation、action和module： 12345678910111213141516import Vue from 'vue';import Vuex from 'vuex';import cart from './modules/cart.js'import products from './modules/products.js'Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; count: 0, &#125; modules: &#123; cart, products, &#125;&#125;) 最后将创建好的store导入到Vue实例中，在main.js中： 12345678910import Vue from 'vue';import store from './store';new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 使用Vuex的准则：（1）应用层级的状态应该集中到单个store对象中。 （2）提交mutation是更改状态的唯一方法，并且这个过程是同步的。 （3）异步逻辑应该封装到action里面 （4）组件仍然可以保有局部状态，如果某些状态严格属于单个组件，最好还是作为组件的局部状态。 StoreVuex的核心就是store， 包含了应用中大部分的状态（state） 一个简单的store: 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) muaction就是定义在store中，用来改变store中state的方法 通过提交mutation的方式，而非直接改变store.state.count，可以更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。 12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id="app"&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;button @click="add"&gt;+&lt;/button&gt; &lt;button @click="reduce"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; add: state =&gt; state.count++, reduce: state =&gt; state.count-- &#125; &#125;); const vm = new Vue(&#123; el: '#app', computed: &#123; count: store.state.count &#125;, methods: &#123; add()&#123; store.commit('add') &#125;, reduce()&#123; store.commit('reduce') &#125; &#125; &#125;);&lt;/script&gt; StateVuex是单一状态树，用一个对象就包含了全部的应用层级状态，是整个应用的唯一数据源。 首先可以通过根组件使用store选项，将状态库从根组件注册到每一个组件中（需要提前调用Vue.use(Vuex)）: 1234567new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 在Vue组件中，获取状态的方法是在组件的计算属性中返回某个状态。有两种方法，一种是直接使用this.$store.state来获取： 12345678export default &#123; // ... computed: &#123; count() &#123; return this.$store.state.count; &#125; &#125;&#125; 另一种是使用mapState辅助函数： 12345678910111213import &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; count: 'count', // 等同于state =&gt; state.count // 使用普通函数（非箭头函数）获取局部状态 myStr (state) &#123; return state.str + this.msg &#125; &#125;)&#125; 映射的计算属性名与state子节点名称相同，也可以给mapState传一个数组： 1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 利用对象展开运算符，可以让mapState与局部的计算属性混合使用： 12345678910computed: &#123; count() &#123; return this.$store.state.count; &#125;, ...mapState(&#123; myMessage: function(state) &#123; return state.str + this.msg &#125; &#125;)&#125; GetterGetter可以认为是store中的计算属性，它的返回值会根据它的依赖被缓存起来，且只有它的依赖值发生了改变才会被重新计算 Getter的第一个参数事state对象，第二个参数事其他getters 12345678910111213141516const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;, count: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; &#125;&#125;) 获取getter通过store.getters对象，可以直接以属性的方式获取： 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 也可以通过方法的形式获取getters，让getters返回一个函数，实现给getters传参： 123456getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125; 使用时： 1this.$store.getters.getTodoById(2) 和state类似，getters也有辅助函数，它将store中的getter映射到局部计算属性： 12345678910111213141516import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 数组形式 ...mapGetters([ 'doneTodosCount', 'anotherGetter', ])， // 对象形式 ...mapGetters(&#123; doneCount: 'doneTodosCount' &#125;)， &#125;&#125; Mutation更改Vuex中的state的唯一方法就是提交mutation，mutation在store中注册，key值就是事件类型，对应的函数就是回调函数，它接受state作为第一个参数： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state, payload) &#123; // 变更状态 state.coun += payload.amount; &#125; &#125;&#125;) mutation不能直接调用，只能通过store.commit方法来调用，第一个参数就是要出发的mutation的事件名，第二个额外的参数是mutation的载荷，载荷应该是一个对象： 1234567this.$store.commit('increment', &#123; amount: 100 &#125;); // 或者也可以this.$store.commit(&#123; type: 'increment', amount: 100,&#125;); 也可以使用mapMutations辅助函数将store.commit映射为组件的methods： 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; 使用mutation时也需要遵循与Vue一样的规则： state中初始化所有所需属性 不能直接添加新属性，必须使用Vue.set方法或者使用新对象替换老对象 要注意的事，Mutation必须是同步函数，原因是为了使devtool能够捕捉前后状态的快照，异步函数则让状态改变试无法变更的 ActionAction是一个架构上的概念，它提交的是mutation，不直接改变状态，一般用来在action内部执行异步操作： 123456789101112131415161718192021const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; // 或者可以简化为 decrement(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125; &#125;&#125;) 它接受一个store实例具有相同方法和属性的对象作为参数context，所以可以通过context.commit来提交mutation，也可以通过context.state和contet.getters来获取state和getters 可以通过参数解构来简化代码： 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; Actions通过store.dispatch来触发： 1234567this.$store.dispatch('increment', &#123; amount: 100 &#125;); // 或者也可以this.$store.dispatch(&#123; type: 'increment', amount: 100,&#125;); 也可以使用mapActions来将store.dispatch映射为组件的methos： 12345678910111213import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 可以在Action中返回Promise，让store.dispatch.then继续处理异步流程，也可以将Action进行组合： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; Module可以使用modules选项将Store分割成模块，每个模块都有自己的state、getter、mutation、action，还可以嵌套子模块 （1）默认情况，未添加命名空间 要注意的是，state默认是注册在模块下的，而模块内部的action、mutation、getter都是注册在全局命名空间的： 12345678910111213141516171819202122232425262728293031323334353637383940const moduleA = &#123; state: &#123; value: 1 &#125;, getters: &#123; value: 2 &#125;， mutations: &#123; increment() &#123;&#125; &#125;, actions: &#123; foo() &#123;&#125; &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)// statestore.state.a.value // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态// gettersstore.getters.value // -&gt; 2// mutationstore.commit('increment');// actionstore.dispatch('foo'); 在未添加命名空间的模块内部的 getter，根节点状态（rootState）和根节点Getters（rootGetters）会作为第三、四个参数暴露出来，（第一个参数是局部状态对象state，第二个参数是局部getter对象） mutation，第一个参数是模块的局部状态对象 action，参数仍然是context，局部状态通过context.state暴露，根节点状态通过context.rootState暴露 （2）添加命名空间 由于模块中的getter、mutation和action都是定义在全局空间下的，很有可能在不同模块中出现重名的现象，导致意料之外的情况发生。 为了解决这个问题，并且为了实现更高的封装度和复用性，可以添加namespaced: true使其成为带有命名空间的模块，它的所有getter、action，mutation都会自动根据模块注册的路径调整命名： 1234567891011121314151617181920212223242526272829303132// module: userconst state = &#123; name: 'Ronald',&#125;;const getters = &#123; fullName(state) &#123; return 'C ' + state.name &#125;&#125;;const mutations = &#123; changeName(state, payload) &#123; state.name = payload.name &#125;&#125;;const actions = &#123; changeNameDelay(context, payload) &#123; setTimeout(() =&gt; &#123; context.commit('changeName', payload) &#125;, 2000) &#125;&#125;;export default &#123; namespaced: true, state, getters, actions, mutations,&#125; 组件中使用的时候，除了state，getter、action，mutation都会自动根据模块注册的路径调整命名： 1234567891011121314151617181920212223242526272829303132computed: &#123; // state name() &#123; return this.$store.state.user.name &#125;, // getters fullName() &#123; return this.$store.getters['user/fullName'] &#125;, // 或者 ...mapGetters(&#123; fullName: 'user/fullName', &#125;)， // 或者 ..mapGetters('user',['fullName'])，&#125;,methods: &#123; // action ...mapActions(&#123; changeNameDelay: 'user/changeNameDelay' &#125; changeNameHandle() &#123; // mutation this.$store.commit('user/changeName', &#123; name: 'Messi'&#125;); // action this.changeNameDelay(&#123; name: 'Kaka'&#125;) &#125; &#125; 在添加了命名空间的模块内部的 getter，根节点状态（rootState）和根节点Getters（rootGetters）会作为第三、四个参数暴露出来，（第一个参数是局部状态对象state，第二个参数是局部getter对象） mutation，第一个参数是模块的局部状态对象，触发时commit添加root: true就可以在全局命名空间内分发Mutation action，参数仍然是context，局部状态通过context.state暴露，根节点状态通过context.rootState暴露，根节点的Getter会通过context.rootGetters暴漏，触发时dispatch添加root: true就可以在全局命名空间内分发Action 嵌套模块的情况，如果没有添加namespaced: true，则会继承父模块的命名空间。 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) 在使用mapState辅助函数绑定命名空间的模块时，可以将模块的空间名称字符串作为第一个参数传递给函数，这样所有绑定都自动将该模块作为上下文： 12345678910111213141516171819202122computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;), // 优化为 ...mapState('some.nested.module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions([ 'some/nested/module/foo', // -&gt; this['some/nested/module/foo']() 'some/nested/module/bar' // -&gt; this['some/nested/module/bar']() ]), // 优化为 ...mapActions('some/nested/module', [ 'foo', // -&gt; this['some/nested/module/foo']() 'bar', ]),&#125; 可以对上面的辅助函数的使用再进一步优化，通过使用createNamespacedHelpers创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数，就无须再为辅助函数逐个添加命名空间了： 12345678910111213141516171819import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; // 在 `some/nested/module` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) &#125; 当需要创建一个模块的多个实例时，需要使用一个函数来声明模块状态（与Vue组件内的data出于同样的原因和解决方法） 12345678const MyReusableModule = &#123; state () &#123; return &#123; foo: 'bar' &#125; &#125;, // mutation, action 和 getter 等等...&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex01 简单状态管理]]></title>
    <url>%2F2018%2F01%2F31%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F05%20Vuex%2FVuex01%20%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue中的简单状态管理方式（不全，新的API和方法都没有添加） Vue中对原始数据对象的访问，只是简单的代理访问（也就是引用了同一个地址的数据），所以当一份数据被多个实例共享，不必维护多份数据，只需要维护一份即可。 但是这会带来调试上无法辨别何人何时改变过数据的问题，为了解决这个问题，可以引入store模式 123456789101112131415161718var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; if (this.debug)&#123; console.log('setMessageAction triggered with', newValue) &#125; this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug)&#123; console.log('clearMessageAction triggered') &#125; this.state.message = '' &#125;&#125; 注意，改变stroe中state的行为方法，都应放在store中的action进行统一管理。 这时，每个实例、组件都可以同时拥有来自组件的共享状态和来自自身的私有状态 12345678910111213var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 重要的是，注意你不应该在action中替换原始的状态对象 - 组件和store需要引用同一个共享对象，mutation才能够被观察 所以一个重要的约定就是： 组件不允许直接修改属于store实例的state，而应该执行action来分发（dispatch）事件通知store去改变 回想起在Exam项目中，使用MOBX，完全违反了这个规定。什么都不懂，乱七八糟的代码就上线了 参考 状态管理@Vue]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter01 基础]]></title>
    <url>%2F2018%2F01%2F11%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2F04%20Vue%20Router%2FVueRouter01%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vue Router基础学习笔记。 安装1npm install vue-router 加载需要使用Vue.use()明确的安装路由 12345// main.jsimport Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) 基本使用1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;h3&gt;Hello Vue Router&lt;/h3&gt; &lt;template&gt; &lt;router-link to="/foo"&gt;Go to foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to bar&lt;/router-link&gt; &lt;/template&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; 'use strict'; const Foo = &#123;template: '&lt;div&gt; Hello Foo &lt;/div&gt;'&#125;, Bar = &#123;template: '&lt;div&gt; Hello Bar &lt;/div&gt;'&#125;; const routes = [ &#123;path: '/foo', component: Foo&#125;, &#123;path: '/bar', component: Bar&#125; ]; const router = new VueRouter(&#123; routes &#125;); let app = new Vue(&#123; router &#125;).$mount('#app')&lt;/script&gt; （1）用&lt;router-link&gt;实现导航标签，在DOM中会被渲染为&lt;a&gt;标签，to属性指定链接 （2）用&lt;router-view&gt;作为路由出口，路由对应的组件内容会被渲染到其中 （3）定义路由routes，由对象组成的数组，对象至少包含的属性是path和component，其中path和&lt;router-link&gt;中的to属性对应，to属性如果不加/则是以当前地址为基准的相对路径 （4）创建路由实例new VueRouter({routes}) （5）创建Vue实例时可以直接添加router属性挂载路由 动态路由在routes数组的path属性中，以:开始后面的参数就是动态路径参数： 123456const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: '/user/:id', component: User &#125; ]&#125;) 当访问/user/a时，可以在组件中通过$route.params.id获取到动态路径参数a 可以通过$route.query获取URL中的查询参数，通过$route.hash获取路由的hash值 动态路由间的跳转，比如从/user/a到/user/b，原组件实例会被复用，所以Vue实例的mounted等生命周期钩子函数不会执行。如果想要响应参数变化有两种方法： （1）watch组件的$route对象: 1234567const User = &#123; watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; （2）使用beforeRouteUpdate()方法（2.2+） 1234567const User = &#123; template: '...', beforeRouteUpdate (to, from, next) &#123; // 对路由变化作出响应... // 需要调用 next 方法进行跳转 &#125;&#125; 路由匹配有时候，一个路径可以匹配多个多路，此时匹配的优先级就是按照路由的定义顺序，先定义的路由优先级最后，后面定义的路由就不会再匹配 可以使用通配符*来匹配任意路径，由于上面提到的优先级，所以含有通配符的路由应该放在最后，一般用来匹配404路由 12345678const router = new VueRouter(&#123; routes: [ // 会匹配所有路径 &#123; path: '*', component: NotFound &#125;, // 匹配以 `/user-` 开头的任意路径 &#123; path: '/user-'', component: User &#125;, ]&#125;) 使用了通配符后，可以通过$route.params的pathMatch属性获取URL通过通配符被匹配的部分。 除了通配符之外，vue-router支持很多高级的匹配模式，可以看这个例子来学习。 嵌套路由&lt;router-view&gt;是渲染路由内容的组件，最高级路由匹配到的组件会渲染到顶层的&lt;router-view&gt;中。组件可以在内部包含自己的嵌套的&lt;router-view&gt;，将路由选项中的children属性中的组件渲染在其中 12345678910111213141516171819const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: '', component: UserHome &#125;, &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, ] &#125; ]&#125;) 以/开头的嵌套路径也会被当做根路径进行匹配。 嵌套路由如果要设置默认的子路由，子路有的path可以设置为/或者&#39;&#39;，但是父路由不能有的name属性 （想要嵌套路由的&lt;router-link&gt;的active-class起作用，可以为自由路的默认路由设置redicet: 12345routes.find(v =&gt; v.path === '/demo38').children = [ &#123;path: '/', redirect: 'demo38-1'&#125;, &#123;path: 'demo38-1', component: HelloWorld&#125;, &#123;path: 'demo38-2', component: NotFound&#125;,]; 编程式导航除了使用&lt;router-link&gt;来进行路由跳转之外，还可以通过$router的实例方法实现编程式的导航 路由跳转可以使用$router.push方法，它会向History栈添加新的记录，为用户点击后腿按钮提供后退功能 1router.push(location, onComplete?, onAbort?) 第一个参数可以是字符串路径，也可以是一个描述地址的对象： 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 如果提供了path，param虚选项会被忽略： 123456const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user 后两个参数是导航成功或终止后的回调函数，在3.1.0+版本后如果省略这两个参数，将会返回一个Promise 如果跳转时路由相同，只是参数发生变化（比如/user/:id跳转），需要使用beforeRouteUpdate来响应变化 除了router.push，还可以使用router.replace来进行跳转，不同的是router.replace不会为History添加新纪录 还可以使用router.go(n)，在History记录中向前或者后退多少步。 命名路由在创建Router的实例时，在routes数组内部对象增加name属性，为路由设置名称 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;) 这样在&lt;router-link&gt;的to属性中，就可以使用name属性来进行路由的匹配 1&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt; 命名视图在一个组件中，可以为&lt;router-view&gt;添加name属性，同时展示多个视图，没有设置name的&lt;router-view&gt;，默认为default 123&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt; 在路由设置里面，需要使用components在当前路由下渲染多个组件，不同组件对应不同name的router-view 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向和别名重定向时在routes数组的对象中添加rediect属性： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125; ]&#125;) redirect的值可以是字符串，也可以是一个命名路由{ name: &#39;foo&#39; }，也可以是一个函数，返回值是字符串路径或者路径对象 注意导航守卫没有应用在跳转路由上，仅应用在目标上。 别名别名与重定向不同，重定向会将URL进行替换，而设置了别名的路由，URL并不会改变： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) 当用户访问/b时，URL显示为/b，但是加载的组件是A 路由组件传参在组件中使用$route会使组件与对应路由高耦合，可以使用props将组件合路由解耦： 12345678const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;) 使用props解耦，将props设置为true，那么$route.params就会被设置为组件属性 123456789const User = &#123; props: ['id'] template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125; ]&#125;) 针对包含多个命名视图的路由，必须分别为每个命名视图添加props选项： 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 如果props是一个对象，那么会被原样设置为组件的属性，一般用做props为静态的情况： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a/b', component: C, props: &#123; popup: false &#125; &#125; ]&#125;) props是也可以接受一个函数，参数是当前的路由对象route： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) 访问/search?q=123会将{query: 123}作为属性传递给SearchUser组件 应该尽可能保持props函数为无状态的，如果需要状态来定义props，请使用包装组件。 History模式vue-router默认使用hash模式，使用URL的hash值来模拟一个完整的URL，当URL改变时，实际上改变的是#后面的hash值，页面不会被重新加载 vue-router提供了history模式，它利用的是history.pushStateAPI来实现URL跳转而无需重新加载页面 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 这种情况下URL不会有#，但是需要后台配置支持，因为如果后台没有配置，那么用户直接访问URL时，首先会经过后台的真正的路由，但是后台没有匹配的路由会返回404，所以应该在服务端增加一个覆盖所有情况的候选资源，如果URL匹配不到任何静态资源，就返回同一个index.html，这个页面就是单页应用的容器页面 要注意，这个时候的后台无法响应404页面了，必须在前端给出404页面。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础16 携带Cookie跨域]]></title>
    <url>%2F2018%2F01%2F06%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8016%20%E6%90%BA%E5%B8%A6Cookie%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[普通的AJAX请求（非跨域的情况）是默认携带cookie的，但是在跨域时则是不携带cookie的。跨域时携带cookie的方法有三种： Nginx反向代理 JSONP CORS 对Cookie跨域的理解假设服务端的域名是a.com，发送跨域请求的前端的域名是b.com，那么在b.com想a.com发送跨域请求时，是可以携带cookie的，但是这个cookie必须是域名为a.com下的cookie 也就是说，b.com的前端发送的跨域请求携带的cookie，是目标页面所在域的cookie。 所以带cookie跨域的前提是目标页面的cookie在本机存在，跨域要携带的cookie必须是目标页面所在域的cookie 之前的理解有两个误区： b.com向a.com发送跨域请求，可以把b.com域名下的cookie带上。如上面所说的，这是行不通的 b.com通过JS在本机生成一个域名a.com的Cookie，或者a.com的服务端在发送响应时setCookie的domain为b.com。这两种做法都是行不通的，因为设置cookie的domain可以设置为父域名和自身，但是不能设置其他域名和子域名，否则cookie设置不会成功。 domain假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。 服务端是无法跨域设置cookie的（set-cookie），只能设置自身域名或者父域名的Cookie 前端是可以带cookie跨域的，前提是cookie是目标服务器所在域的cookie Nginx反向代理通过Nginx反向代理来解决cookie跨域问题可以携带cookie。 JOSNP使用JSONP跨域可以携带cookie，但是只能是GET请求，需要在请求的选项中添加xhrFiles对象： 12345678910111213141516$.ajax(&#123; url: 'http://b.fdipzone.com/server.php', // 跨域 xhrFields: &#123; withCredentials: true // 发送凭据 &#125;, dataType: 'json', type: 'post', data: &#123; 'name': 'fdipzone' &#125;, success: function(ret) &#123; if (ret['success'] == true) &#123; alert('cookie:' + ret['cookie']); &#125; &#125;&#125;); CORSCORS的全称是“跨域资源共享“（Cross-Origin Resource Sharing） 它允许浏览器向跨源服务器发出XMLHttpRequest请求，解决跨域问题。 CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段： 12header(&quot;Access-Control-Allow-Origin: http://www.xxx.com&quot;); header(&quot;Access-Control-Allow-Credentials: true&quot;); 另一方面，开发者必须在AJAX请求中打开withCredentials属性： 123456789101112131415// 原生var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;xx.com&apos;);xhr.withCredentials = truelxhr.send()// jQuery$.ajax(&#123; type: &apos;GET&apos;, url: &apos;xx.com&apos;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true&#125;) 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 参考 HTTP cookies@MDN Set-Cookie@MDN 解决cookie跨域访问@博客园 跨域资源共享 CORS 详解@阮一峰的网络日志 跨域请求带cookie的解决方案@CSDN]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>HTTP</tag>
        <tag>cookie</tag>
        <tag>set-cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础01 Cookie]]></title>
    <url>%2F2018%2F01%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8001%20Cookie%2F</url>
    <content type="text"><![CDATA[Cookie学习笔记 什么是cookiecookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。==由于服务器指定cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销==（尤其是在移动环境下）。 新的浏览器API已经允许开发者直接将数据存储到本地，如使用Webstorage（本地存储和会话存储）或IndexedDB 。 cookie的分类cookie分为会话期cookie和持久性cookie。 会话期cookie在浏览器关闭后会自动删除，没有指定Expires和Max-age的cookie为会话期cookie 持久性cookie可以指定一个特定的过期时间（Expires）和有效期（Max-age），设定的日期和时间只与客户端相关，而不是服务端。 很多Web浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie也会恢复，就跟从来没有关闭浏览器一样。 cookie创建时包含的字段&lt;cookie-name&gt;=&lt;cookie-value&gt;设置name和value, 是必选字段，其他字段皆为可选 Expires=&lt;date&gt;规定cookie的过期日期，是一个绝对时间的日期值，如果没设置，cookie将在session结束后（即浏览器关闭后）失效（即会话期cookie）。HTTP/1.0的特性。 Max-Age=&lt;seconds&gt;规定了cookie的有效期（经过seconds秒后失效），是一个相对值。它是HTTP/1.1的特性，假如Expires和Max-Age均存在，那么Max-Age优先级更高。 Path=&lt;path-value&gt;指定一个URL路径，控制请求哪些路径下的页面能够读取cookie，/表示根路径下的文件有权限读取该cookie，path 权限有继承性，此目录的下级目录也满足匹配的条件 例如，如果path=/docs，那么/docs、/docs/Web/或者/docs/Web/HTTP都满足匹配的条件 Cookie的路径是在服务器创建Cookie时设置的，它的作用是决定浏览器访问服务器的某个资源时，需要将浏览器端保存的那些Cookie归还给服务器。 Domain=&lt;domain-value&gt;指定cookie生效的域名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。 假如指定了域名，那么相当于各个子域名也包含在内了。例如，.baidu.com的设置表明在baidu.com的所有域名中生效，如果设置为www.baidu.com，则仅仅在www.baidu.com域名中生效 SecureSecure设置为true时，cookie只应通过被HTTPS协议加密过的请求发送给服务器。默认为false 但即便设置了Secure，敏感信息也不应该通过cookie传输，因为Cookie有其固有的不安全性，Secure标记也无法提供确实的安全保障。 HttOnly设置了HttpOnly属性的cookie不能使用JavaScript进行访问，仅仅用于网络请求发送给服务端，目的是为了防范跨站脚本攻击（XSS）。 XSS（Cross-site scripting）：跨站脚本攻击是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。 对Cookie跨域的理解假设服务端的域名是a.com，发送跨域请求的前端的域名是b.com，那么在b.com想a.com发送跨域请求时，是可以携带cookie的，但是这个cookie必须是域名为a.com下的cookie 也就是说，b.com的前端发送的跨域请求携带的cookie，是目标页面所在域的cookie。 所以带cookie跨域的前提是目标页面的cookie在本机存在，跨域要携带的cookie必须是目标页面所在域的cookie 之前的理解有两个误区： b.com向a.com发送跨域请求，可以把b.com域名下的cookie带上。如上面所说的，这是行不通的 b.com通过JS在本机生成一个域名a.com的Cookie，或者a.com的服务端在发送响应时setCookie的domain为b.com。这两种做法都是行不通的，因为设置cookie的domain可以设置为父域名和自身，但是不能设置其他域名和子域名，否则cookie设置不会成功。 domain假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。 也就是说： 服务端是无法跨域设置cookie的（set-cookie），只能设置自身域名或者父域名的Cookie 前端是可以带cookie跨域的，前提是cookie是目标服务器所在域的cookie cookie在网络请求中的传递网络请求过程中cookie的传递有两个部分： Set-Cookie服务器可以通过==响应头==中的Set-Cookie字段，请求浏览器保存==一个==cookie信息 多个字段用;分割 123Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnlySet-Cookie: id=123; Domain=.toutiao.com; expires=Wed, 04-Apr-2018 09:59:25 GMT; Max-Age=7804800; Path=/ 注意，不能将多个cookie放在一个Set-Cookie中，要设置多个cookie，需要添加同样多的set-Cookie字段 Cookie浏览器会在发送HTPP请求时，通过==请求头==中的Cookie字段，携带上当前页面保存的所有cookie 可以在Cookie字段中设置多个cookie: JavaScript操作本地cookieJavaScript可以通过document.cookie创建cookie，也可以访问非HttpOnly标记的cookie 创建cookiedocument.cookie每次只能写入一条cookie，需要写入多条cookie时，需要重复调用 后写入的重名的cookie会覆盖旧的cookie 123document.cookie = "userId=828";document.cookie = "username=ok";document.cookie = "userId=919"; 在Cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格，所以在创建Cookie时需要用encodeURIComponent函数对要存入的值进行安全编码，读取时进行相应的解码 1document.cookie = "userId=" + encodeURIComponent("string"); 读取cookie获取cookie值可以直接取值 12var strCookie = document.cookie; // "name=123; ok=999; ok2=0; ok3=999; ok4=123" 只能够一次获取所有的Cookie值，而不能指定cookie名称来获得指定的值 要获取userId的值，可以这样实现（==要注意的是分号;后面是有一个空格的，需要在分割为数组的时候处理==）： 123456789101112131415var strCookie = document.cookie;//将多cookie切割为多个名/值对 var arrCookie = strCookie.split(";");var userId;//遍历cookie数组，处理每个cookie对 for (var i = 0; i &lt; arrCookie.length; i++) &#123; var arr = arrCookie[i].split("="); //找到名称为userId的cookie，并返回它的值 if ("userId" == arr[0]) &#123; userId = arr[1]; break; &#125;&#125; 删除cookie因为cookie是存储在客户端，所以服务器端是没法删除的，必须通知客户端去删除。==客户端通过设置cookie的max-age或者expires为-1将其删除== 为了考虑兼容性，二者应该同时使用。 封装对cookie的操作比较复杂，所以可以进行封装： 1234567891011121314151617181920const cookieJar = &#123; set(name, value, days = 1) &#123; const seconds = days * 24 * 60 * 60; document.cookie = `$&#123;name&#125;=$&#123;value&#125;; expires=$&#123;new Date(Date.now() + seconds * 1000)&#125;; max-age=$&#123;seconds&#125;` &#125;, get(name) &#123; const &#123;cookie&#125; = document; if (!cookie) &#123; return &#125; const cookieObj = cookie.split('; ').reduce((total, current) =&gt; &#123; const [ key, value ] = current.split('='); return Object.assign(total, &#123; [key]: value&#125; ); &#125;, &#123;&#125;); return cookieObj[name] &#125;, remove(name) &#123; document.cookie = `$&#123;name&#125;=''; expires=-1; max-age=-1` &#125;&#125; cookie的安全性问题cookie的安全性存在着很大的不确定性，所以一个重要的原则是，不能通过cookie存储、传输敏感信息 所以通过cookie维护用户的登陆状态时，应该是通过cookie保存、传输经过加密后的一份登陆状态，而==不是直接保存用户的密码信息==。 常见的窃取cookie的攻击有：跨站脚本攻击（XSS）和跨站伪造请求。 一些可以用来提高安全性的手段： 防止XSS攻击，对用于输入进行过滤 使用HTTPS传输cookie 用于明敏感信息的cookie只能拥有较短的生命周期 cookie加密 cookie里面加入IP信息，判断cookie中的IP信息和发送请求的IP是否相等，不相等采取措施，比如重新登录。 物理机窃取是防止不了的，就是到你电脑上，拷走cookie，是防止不了的。 追踪和隐私欧盟已经在2009/136/EC指令中提了相关要求，该指令已于2011年5月25日生效。虽然指令并不属于法律，但它要求欧盟各成员国通过制定相关的法律来满足该指令所提的要求。当然，各国实际制定法律会有所差别。 该欧盟指令的大意：在征得用户的同意之前，网站不允许通过计算机、手机或其他设备存储、检索任何信息。自从那以后，很多网站都在网站声明中添加了相关说明，告诉用户他们的cookie将用于何处。 参考 HTTP cookies@MDN Set-Cookie@MDN JavaScript Cookies@W3school 如何防止cookie被盗用？？@segmentfault]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>cookie</tag>
        <tag>set-cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题21 字符编码笔记]]></title>
    <url>%2F2018%2F01%2F02%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9821%20%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符编码笔记学习笔记。 ASCII码字节：八个二进制位，可以组合出256种状态，这称为一个字节（byte）。一个字节一共可以表示256种状态。 ASCII码是美国制定的，英语字符与二进制位之间的关系，一个规定了128个字符，比如空格SPACE是32（0010 0000），大写字母A是65（0100 0001）。这128个字符只占据了一个字节的后七位，最前面的一位统一规定为0 非ASCII码英语用128个字符编码就够了，但是非英语字符却远远不够。一些语言使用了ASCII中闲置的第一位来编入新的符号，这样一些欧洲国家的编码体系可以最多表示256个字符。 但是对于汉语，还是不够的，需要使用多个字节表达一个符号，简体中文最常见的编码方式是GB2312，用两个字节表示一个汉字，所以理论上最多可以表示256 x 256 = 63356个字符。 Unicode由于世界上存在多个编码方式，同一个二进制字符在不同编码方式下可以被解释成不同的符号。因此想要打开一个文件，就必须知道它的编码方式，否则使用错误的编码方式就会出现乱码。 Unicode是一种所有字符的编码方式，将世界上所有的符号纳入其中，每个字符都给予一个独一无二的编码。 Unicode现在可容纳100多个万个符号，每个符号编码都不一样。符号对应表可以查询unicode.org。 Unicode的符号不是一次性定义的，而是分区定义的，每个区可以放65536（$2^{16}$）字符，成为一个平面（plane），目前一个有17（$2^{5}$）平面，也就是说，整个Uniocde字符集的大小是（$2^{21}$）。 最前面的65536个字符，称为基本平面（BMP），码点范围是从0到$2^{16}-1$，写成16进制就是从0000到FFFF，所有常见字符都放在这个平面。剩下的字符都放在辅助平面（SMP）。 Unicode的问题Unicode只是一个符号集，之规定了符号的二进制代码，却没有规定到底用什么样的字节序表示这个码点。 比如汉字严的Unicode是十六进制数4E25，二进制是100111000100101，这个符号表示至少需要2个字节。 这样引出了两个问题： 如何让计算机区分Unicode和ASCII？计算机如何知道三个字节是Unicode中表示一个符号，而不是ASCII中的三个字符？ 英文字节只用一个字节表示就够了，那如果统一长度字节表示，会造成很大的浪费 UTF-32UTF-32是最直观的编码方法，每个码点用四个字节表示，字节内容一一对应码点。前位用0补齐。 它的优点是查找效率高，时间复杂度$O(1)$ 它的缺点是浪费空间。同样的英语文本，比ASCII码大了4倍。 UTF-8为了节省空间，UTF-8出现了。 UTF-8是在互联网使用最广泛的Unicode实现方式之一，其他实现方式还有UTF-16（字符用两个字节或四个字节表示）、UTF-32（字符用四个字节表示），不过在互联网环境基本不用。 UTF-8是Unicode的实现方式之一。 UTF-8的最大特点，就是它是一种变长的编码方式。他可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。 UTF-8的编码规则： 对于单字节的字符，字节的第一位设为0，后面7位是这个符号的Unicode码。因此对于英语字符，Unicode编码和ASCII码是相同的。 对于n字节（n &gt; 1），第一个字节的前n位都设为1，第n+1为设为0，后面字节的前两位一律设为10，其余的二进制位，全部为这个符号的Unicode码 1234567unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+---------------------------------------------0x0000 - 0x007F | 0xxxxxxx0x0080 - 0x07FF | 110xxxxx 10xxxxxx0x0800 - 0xFFFF | 1110xxxx 10xxxxxx 10xxxxxx0x010000 - 0x10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 解读UTF-8编码时，如果一个字节的第一位是0，那么这个字节单独就是一个字符，如果第一位是1，则连续有多少个1，就表示当前字符占据多少个字节 例如，严的Unicode编码是4E25（16进制），根据上表（实际自己尝试也会发现），它的UTF-8表示需要三个字节，即格式为1110xxxx 10xxxxxx 10xxxxxx，然后将严的最后一个二进制位开始，从后向前依次填入格式中的x，多位补0，就得到了严的UTF-8编码11100100 10111000 10100101，转换为十六进制是E4B8A5 1parseInt('111001001011100010100101', 2).toString(16).toUpperCase() UTF-16UTF-16介于UTF-8和UTF-32之间，结合了定长和变长两种编码方法的特点。 它的编码规则是，基本平面的字符占用两个字节，辅助平面字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。 UCS-2编码JavaScript采用Unicode字符集，但是只支持UCS-2这一种编码方法。 UCS-2的出现是由于历史上两只开发统一字符集的团队，在互相妥协、融合后的产物。UCS-2使用两个字节来表示基本平面的字符，没有对辅助平面字符处理。UTF-16的基本平面沿用UCS-2的编码，辅助平明字符使用4个自己表示。 UCS-2和UTF-16的关系是：UTF-16取代了UCS-2（UTF-16是UCS-2的超集），或者说UCS-2整合进了UTF-16。 由于JavaScript诞生时UTF-16还没有出现，所以只能采取UCS-2 JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字符。如果是4个字节的字符（即辅助平面上的字符），会当做两个双字节的字符处理。JavaScript的字符函数都收到这一点的影响，无法返回正确结果。 为了解决这个问题，必须对码点进行判断，然后手动调整。在遍历字符串时判断码点，如果落在0xD800和0xDBFF的区间，就要连同后面2个字节一起读取： 12345678while (++index &lt; length) &#123; // ... if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125;&#125; 类似的问题存在于所有的JavaScript字符操作函数，例如replace/substring/slice，这些函数都只对2字节的码点有效。要正确处理4字节的码点，就必须判断当前字符的码点范围。 ECMAScript 6ES6大幅增强了对Unicode的支持，基本解决了上述问题。 （1）正确识别字符ES6可以自动识别4字节的码点，因此遍历字符串就简单多了： 123for (let s of string ) &#123; // ...&#125; 但是为了保证兼容性，length属性还是原来的行为方式。为了得到正确的字符串的长度，可以用下面的方式： 1Array.from(string).length 比如，𝌆的码点为U+1D306,转换为UTF-16的编码是0xD834 DF06,长度是4个字节。length属性保持了以前的行为表现，认为2个字节是一个字符，所以认为𝌆的长度是2： 1'𝌆`.length; // 2 正确的做法是： 1Array.from('𝌆').length; // 1 （2）码点表示法JavaScript允许直接使用码点表示Unicode字符，写法是：反斜杠 + u + 码点 1'好' === '\u597D' // true 但是这样只能表示两个字节的码点，ES6修复了这个问题，只要将码点放在大括号内，就能识别4个字节的码点： 12'\u&#123;1d306&#125;'// "𝌆" （3）ES6新增了几个专门处理4字节码点的方法：12345String.fromCodePoint() // 从Unicode码点返回对应字符String.fromCodePoint('0x1d306') // "𝌆"String.prototype.codePointAt // 从字符返回对应的码点"𝌆".codePointAt(0).toString(16) // "1d306" （4）正则表达式ES6提供了u修饰符，对正则表达式提供4字节码点的支持 12345/^.$/.test('𝌆')// false/^.$/u.test('𝌆')// true 参考 Unicode与JavaScript详解@阮一峰的网络日志 字符编码笔记：ASCII，Unicode 和 UTF-8@阮一峰的网络日志]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
        <tag>UCS-2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习01 将一个JS数组彻底打乱顺序]]></title>
    <url>%2F2017%2F12%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F02%20%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A001%20%E5%B0%86%E4%B8%80%E4%B8%AAJS%E6%95%B0%E7%BB%84%E5%BD%BB%E5%BA%95%E6%89%93%E4%B9%B1%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[JS常用排序算法的总结。 所有算法的动画演示 冒泡排序（Bubble Sort）对相邻的两个对象进行比较，如果后者小于前者，把小的放前面 时间复杂度：O(n²) 123456789101112// 对比arr中的第j+1项和第j项，如果第j+1项小于第j项，就把第j+1项和第j项调换位置。// 如果没达到最终的顺序（从小到大），就继续找，继续换，直到达到最终效果function bubbleSort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; &#125; &#125; &#125; return arr;&#125; （2018.4.3补充）发现在内层循环时，可以改变内层循环的范围为 j&lt;arr.length-1-i, 原因是 当 i=0 的时候，里面的循环完整执行，第一遍排序，结果是将最大的数排到了最后 当 i=1 的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是 j&lt;arr.length-1-i 的巧妙之处 优化冒泡排序算法对冒泡排序进行优化，设定一个变量flag，用于表明是否进行了位置交换，如果没有交换位置，则说明当前排序完成，结束循环 时间复杂度：O(n²) 1234567891011121314151617function bubbleSort(arr) &#123; let isOver = false; for (var i = 0; i &lt; arr.length - 1; i++) &#123; isOver = true; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; isOver = false; &#125; &#125; // 内部循环一轮都不需要调换位置，说明全部排序已完成，没有必要再继续外部循环 if (isOver) &#123; return arr; &#125; &#125; return arr;&#125; 选择排序（Selection Sort）首先在乱序的数组中选择出最小的值，然后和每次循环后的数组第一位进行交换 时间复杂度：O(n²) 1234567891011121314151617const x = [0, 5, 3, 2, 4, 1, 10];function chooseSort (arr) &#123; let tempArr = [...arr]; for (let i = 0; i &lt; tempArr.length; i++) &#123; let maxIndex = i; for (let j = i; j &lt; tempArr.length; j++) &#123; if (tempArr[j] &gt; tempArr[maxIndex]) &#123; maxIndex = j &#125; &#125; if (maxIndex !== i) &#123; [tempArr[i], tempArr[maxIndex]] = [tempArr[maxIndex], tempArr[i]]; &#125; &#125; return tempArr;&#125;console.log(chooseSort(x)) 插入排序（Insert Sort）对数组进行循环，当循环到i时，认为i之前的项目都已经排好序了，对i+1进行处理，将i+1项插入到已经排好序的队列中，插入的方法就是从i+1开始，向回循环，两两比较，根据比较结果进行换位 时间复杂度：O(n²) 123456789101112const x = [0, 5, 3, 2, 4, 1, 10];function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &gt; 0; j--) &#123; if (arr[j - 1] &lt; arr[j]) &#123; [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(insertSort(x)) 归并排序（Merge Sort）把一个数组分为两个数组，左边排好序，右边排好序，然后合并到一起排序。 归并排序是分治法的典型实例，指的是将两个已经排序的序列合并成一个序列的操作 时间复杂度：O(nlogn) 排序过程： 1234567891011121314151617181920212223242526272829303132var arr = [-11, 17, 12, 19, 0, -222];function mergeSort(arr, s, e) &#123; if (s &gt; e) &#123; //起始位置大于终点位置，返回空数组 return []; &#125; else if (s == e) &#123; return [arr[s]]; //起始位置等于终点位置，说明数组里只有一个数字，返回只含一个数字的数组 &#125; var mIndex = Math.floor((s + e) / 2); //中间位置的Index var arrL = mergeSort(arr, s, mIndex); //将左边的数组排序 var arrR = mergeSort(arr, mIndex + 1, e); //将右边的数组排序 var resultArr = []; //结果数组 while (arrL.length &gt; 0 &amp;&amp; arrR.length &gt; 0) &#123; //当左右两个数组都不为空时 if (arrL[0] &lt; arrR[0]) &#123; resultArr.push(arrL.shift()); &#125; else &#123; resultArr.push(arrR.shift()); &#125; if (arrL.length == 0) &#123; //当左边的数组为空时 resultArr = resultArr.concat(arrR); break; &#125; else if (arrR.length == 0) &#123; resultArr = resultArr.concat(arrL); break; &#125; &#125; return resultArr;&#125;document.write(mergeSort(arr, 0, arr.length - 1)); 快速排序（quickSort） 在数据集之中，选择一个元素作为”基准”（pivot） 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 1234567891011121314151617181920212223var arr = [77, -33, 22, 32, 0, 2, 11];function quickSort(arr) &#123; // 递归结束条件 if (arr.length &lt;= 1) &#123; return arr; &#125; // 选择基准元素，并且从原数组中暂时剔除 const index = Math.floor(arr.length / 2); const base = arr.splice(index, 1)[0]; // 将数组分为左右组 let left = []; let right = []; // 对所有元素进行遍历，将大于基准值的放在左边，小于基准值的放在右边 for (let i = 0; i &lt; arr.length; i++) &#123; (arr[i] &lt; base ? right : left).push(arr[i]) &#125; // quickSort(left)对左边的合集进行递归 // quickSort(right)对右边的合集进行递归 // 连接起来，再加上基准元素就是完整合集 return quickSort(left).concat([base], quickSort(right))&#125;document.write(quickSort(arr)); 计数排序时间复杂度为O(N) 用空间换时间的算法，适用于提前知道数字范围，并且相差范围不大的情况 将数字放到对应的数组对象中，然后进行排序 这种方法不能对应数组中有负数的情况 1234567891011121314151617181920212223242526let arr = [100, 2, 3, 1, 5, 22, 33, 11, 22, 33];function sort(arr) &#123; let temp = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!temp[arr[i]]) &#123; temp[arr[i]] = 1; &#125; else &#123; temp[arr[i]]++; &#125; &#125; let result = []; for (let j = 0; j &lt; temp.length; j++) &#123; if (temp[j]) &#123; for (let k = 0; k &lt; temp[j]; k++) &#123; result.push(j) &#125; &#125; &#125; return result;&#125;console.log(sort(arr)) 参考 js算法之最常用的排序@博客园 JS-排序详解-冒泡排序@博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础08 HTTPS]]></title>
    <url>%2F2017%2F12%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8008%20HTTPS%2F</url>
    <content type="text"><![CDATA[HTTPS学习笔记。 SSL/TLS协议HTTPS（HTTP Secure）是HTTP加上加密、认证和完整性保护。不是一种新的协议，只是在HTTP通信接口部分用了SSL和TLS协议代替，也就是说在HTTP与TCP之间增加了SSL，HTTP与SSL通信，再由SSL与TCP通信。 TLS是SSL协议的升级版， 目前应用最广泛的是TLS1.0和SSL3.0。 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险： 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 SSL/TLS协议的基本思路是采用了公开密钥加密法，客户端首先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 这里面有两个问题： （1）如何保证公钥不被篡改 将公钥放在CA机构颁发的数字证书中，客户端收到服务器的公钥时会使CA机构内置在浏览器中的公钥进行验证。因此只要数字证书是可信的，公钥就是可信的 （2）公钥加密计算量太大，如何减少耗用时间 在建立连接阶段使用公开密钥加密计算，生成一个“对话密钥”，在随后的通话期间信息由“对话密钥”进行共享密钥加密。共享密钥加密是对称加密，运算速度很快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运算的时间。 HTTPS的工作模式非对称加密在性能上不如对称加密，所以HTTPS采取了对称加密和非对称加密相结合的工作模式：公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。 非对称加密需要通过证书和权威机构来验证公钥的合法性。 HTTPS的握手机制HTTPS的握手相当于SSL/TLS协议的握手和TCP协议的握手，这里主要介绍的是SSL/TLS的握手。 SSL/TLS的握手阶段设涉及四次通信，这四次通信都是明文的： （1）客户端发出请求（ClientHello） 客户端先想服务器发出加密通信的请求，提供一些基本信息，比如支持的TLS/SSL版本、用于生成“对话密钥”的随机数，支持的加密方法等。 （2）服务器回应（ServerHello） 服务器收到客户端请求后，向客户端发出回应，包含用于协商建立SSL通信的信息，比如确认使用的加密通信加密版本，服务器证书（包含服务器的公钥）、确认使用的加密方法、服务器生成的用来生成“对话密钥“的随机数 此外，如果服务器需要确认客户端身份，就会再包含一项请求，要求客户端提供“客户端证书”。比如金融机构往往只允许认证客户连入自己的网络，就会想正式客户提供USB密钥，里面包含了一张客户端证书。 （3）客户端回应 客户端收到服务器的回应后，首先验证服务器证书，如果证书不是可信机构颁布，或者证书的域名与实际域名不一致，或者证书已经过期，就会想访问者显示警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥，然后向服务器发送下面三项信息： 1231. 一个随机数（pre-master-key)。这个随机数会用服务器公钥加密2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送3. 客户端握手结束通知，表示客户端的握手阶段结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验 到此为止，握手阶段已经有了三个随机数，随后，双方就会用实现商定的加密方法，用着三个随机数各自生成用于本次会话加密的同一把“会话密钥”。为什么一定要用三个随机数呢？ SSL协议中的证书是静态的，因此十分有必要引入一种随机因素来保证每次会话协商出来的密钥的随机性。所以不管是客户端还是服务器，都需要随机数，这样每次会话生成的密钥才不会每次都一样。 对于RSA密钥交换算法来说，pre-master-key本身是一个随机数，再加上Hello消息中的随机数，三个随机数通过密钥到初七最终导出一个对称密钥。 SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么对话密钥就有可能被猜出来。而三个随机数一同生成的密钥就不容易被猜出来了，一个伪随机可能完全不随机，可是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。 此外，如果在第二步服务器要求客户端提供证书，那么客户端在这一步还会发送证书及相关信息。 （4）服务器的最后回应 服务器收到客户端的第三个随机数pre-master-key后，计算生成本次会话用的“会话密钥”，然后向客户端发最后发送下面信息 121. 编码改变通知，表示表示随后的信息都将用双方商定的加密方法和密钥发送2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束，接下来客户端与服务器进入加密通信，就是完全使用HTTP协议，只不过使用“对话密钥”加密内容。 数字证书公开密钥加密还有一个问题：每个服务器都可以生成自己的私钥和公钥，客户端并没有办法确定自己接收到到的公钥是否真的是目标网站的公钥，还是被替换过。 即：如何证明服务器下发的公钥没有被替换？ 现在通用的解决方法就是通过数字证书认证机构（Certificate Authority，CA）颁发的公开密钥证书来解决这个问题。 CA会为提交申请的服务器的公钥做认证，CA利用自己的私钥，对服务器的公钥和一些相关信息一起加密，生成数字证书（Digital Certificate）。这样服务器在建立HTTPS连接时不再直接下发公钥，而是下发包含着服务器公钥（经过CA私钥加密过的）的数字证书。 浏览器会将CA的公开密钥事先内置到浏览器当中（避免了这个证书在传递中出现的问题）。所以客户端收到信息后，会利用CA的公钥解密数字证书，拿到服务器的真实的公钥。 拿到真实的公钥后，客户端（浏览器）会根据内置的“证书管理器”来验证公钥是否真的属于目标网站 客户端的“证书管理器”有`受信任的根证书办法机构”列表，客户端会根据这个列表，查看解开数字证书的公钥是否在列表内。 如果证书不是可信机构颁布，或者证书的域名与实际域名不一致，或者证书已经过期，就会想访问者显示警告，由其选择是否还要继续通信。 SSL延迟123HTTP耗时 = TCP握手(3次)HTTPS耗时 = TCP握手(3次) + SSL握手 HTTPS肯定比HTTP耗时，这就叫SSL延迟。 从运行结果可以看到，SSL握手的耗时大概是TCP握手的三倍。也就是说，在建立连接的阶段，HTTPS连接比HTTP连接要长3倍的时间，具体数字取决于CPU的快慢和网络状况。 所以，如果是对安全性要求不高的场合，为了提高网页性能，建议不要采用保密强度很高的数字证书。一般场合下，1024位的证书已经足够了，2048位和4096位的证书将进一步延长SSL握手的耗时。 升级HTTPS（1）获取证书升级到HTTPS协议的第一步，就是要获得一张证书。 证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，要从经销商购买。 GoGetSSL.com SSLs.com SSLmate.com 证书有很多类型，首先分为三种认证级别。 域名认证（Domain Validation）：最低级别认证，可以确认申请人拥有这个域名。对于这种证书，浏览器会在地址栏显示一把锁。 公司认证（Company Validation）：确认域名所有人是哪一家公司，证书里面会包含公司信息。 扩展认证（Extended Validation）：最高级别的认证，浏览器地址栏会显示公司名。 还分为三种覆盖范围。 单域名证书：只能用于单一域名，foo.com的证书不能用于www.foo.com 通配符证书：可以用于某个域名及其所有一级子域名，比如*.foo.com的证书可以用于foo.com，也可以用于www.foo.com 多域名证书：可以用于多个域名，比如foo.com和bar.com 认证级别越高、覆盖范围越广的证书，价格越贵。还有一个免费证书的选择。为了推广HTTPS协议，电子前哨基金会EFF成立了Let&#39;s Encrypt，提供免费证书（教程和工具）。 拿到证书以后，可以用SSL Certificate Check检查一下，信息是否正确。 （2）安装证书证书可以放在/etc/ssl目录（Linux 系统），然后根据你使用的Web服务器进行配置。 （3）修改链接（前端主要的工作都在此）网页加载的HTTP资源，要全部改成HTTPS链接。因为加密网页内如果有非加密的资源，浏览器是不会加载那些资源的。 1&lt;script src="http://foo.com/jquery.js"&gt;&lt;/script&gt; 上面这行加载命令，有两种改法： 12345&lt;!-- 改法一 --&gt;&lt;script src="https://foo.com/jquery.js"&gt;&lt;/script&gt;&lt;!-- 改法二 --&gt;&lt;script src="//foo.com/jquery.js"&gt;&lt;/script&gt; 其中，改法二会根据当前网页的协议，加载相同协议的外部资源，更灵活一些。 另外，如果页面头部用到了rel=&quot;canonical&quot;，也要改成HTTPS网址。 1&lt;link rel="canonical" href="https://foo.com/bar.html" /&gt; （4）301重定向下一步，修改Web服务器的配置文件，使用301重定向，将HTTP协议的访问导向HTTPS协议。 12345server &#123; listen 80; server_name domain.com www.domain.com; return 301 https://domain.com$request_uri;&#125; HTTPS的七个误解（1）HTTPS无法缓存 许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。 （2）SSL证书很贵 如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。 （3）HTTPS站点必须有独享的IP地址 每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。 比如，https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。 （4）转移服务器时要购买新证书 IS的做法是生成一个可以转移的.pfx文件，并加以密码保护。将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。 （5）HTTPS太慢 第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。 但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。 （6）有了HTTPS，Cookie和查询字符串就安全了 虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。 （7）只有注册登录页，才需要HTTPS 这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。在Twitter和Facebook上，劫持其他人的Session是非常容易的。 参考 SSL/TLS协议运行机制的概述@阮一峰的网络日志 HTTPS 协议：点外卖的过程原来这么复杂！@infoQ HTTPS的七个误解（译文）@阮一峰的网络日志 SSL延迟有多大？@阮一峰的网络日志 HTTPS 升级指南@阮一峰的网络日志 数字签名是什么？@阮一峰的网络日志 第七章 确保Web安全的HTTPS@《图解HTTP》]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础01 常用排序算法]]></title>
    <url>%2F2017%2F12%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F01%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8001%20%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JS常用排序算法的总结。 所有算法的动画演示 冒泡排序（Bubble Sort）对相邻的两个对象进行比较，如果后者小于前者，把小的放前面 时间复杂度：O(n²) 123456789101112// 对比arr中的第j+1项和第j项，如果第j+1项小于第j项，就把第j+1项和第j项调换位置。// 如果没达到最终的顺序（从小到大），就继续找，继续换，直到达到最终效果function bubbleSort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; &#125; &#125; &#125; return arr;&#125; （2018.4.3补充）发现在内层循环时，可以改变内层循环的范围为 j&lt;arr.length-1-i, 原因是 当 i=0 的时候，里面的循环完整执行，第一遍排序，结果是将最大的数排到了最后 当 i=1 的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是 j&lt;arr.length-1-i 的巧妙之处 优化冒泡排序算法对冒泡排序进行优化，设定一个变量flag，用于表明是否进行了位置交换，如果没有交换位置，则说明当前排序完成，结束循环 时间复杂度：O(n²) 1234567891011121314151617function bubbleSort(arr) &#123; let isOver = false; for (var i = 0; i &lt; arr.length - 1; i++) &#123; isOver = true; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; isOver = false; &#125; &#125; // 内部循环一轮都不需要调换位置，说明全部排序已完成，没有必要再继续外部循环 if (isOver) &#123; return arr; &#125; &#125; return arr;&#125; 选择排序（Selection Sort）首先在乱序的数组中选择出最小的值，然后和每次循环后的数组第一位进行交换 时间复杂度：O(n²) 1234567891011121314151617const x = [0, 5, 3, 2, 4, 1, 10];function chooseSort (arr) &#123; let tempArr = [...arr]; for (let i = 0; i &lt; tempArr.length; i++) &#123; let maxIndex = i; for (let j = i; j &lt; tempArr.length; j++) &#123; if (tempArr[j] &gt; tempArr[maxIndex]) &#123; maxIndex = j &#125; &#125; if (maxIndex !== i) &#123; [tempArr[i], tempArr[maxIndex]] = [tempArr[maxIndex], tempArr[i]]; &#125; &#125; return tempArr;&#125;console.log(chooseSort(x)) 插入排序（Insert Sort）对数组进行循环，当循环到i时，认为i之前的项目都已经排好序了，对i+1进行处理，将i+1项插入到已经排好序的队列中，插入的方法就是从i+1开始，向回循环，两两比较，根据比较结果进行换位 时间复杂度：O(n²) 123456789101112const x = [0, 5, 3, 2, 4, 1, 10];function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &gt; 0; j--) &#123; if (arr[j - 1] &lt; arr[j]) &#123; [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(insertSort(x)) 归并排序（Merge Sort）把一个数组分为两个数组，左边排好序，右边排好序，然后合并到一起排序。 归并排序是分治法的典型实例，指的是将两个已经排序的序列合并成一个序列的操作 时间复杂度：O(nlogn) 排序过程： 1234567891011121314151617181920212223242526272829303132var arr = [-11, 17, 12, 19, 0, -222];function mergeSort(arr, s, e) &#123; if (s &gt; e) &#123; //起始位置大于终点位置，返回空数组 return []; &#125; else if (s == e) &#123; return [arr[s]]; //起始位置等于终点位置，说明数组里只有一个数字，返回只含一个数字的数组 &#125; var mIndex = Math.floor((s + e) / 2); //中间位置的Index var arrL = mergeSort(arr, s, mIndex); //将左边的数组排序 var arrR = mergeSort(arr, mIndex + 1, e); //将右边的数组排序 var resultArr = []; //结果数组 while (arrL.length &gt; 0 &amp;&amp; arrR.length &gt; 0) &#123; //当左右两个数组都不为空时 if (arrL[0] &lt; arrR[0]) &#123; resultArr.push(arrL.shift()); &#125; else &#123; resultArr.push(arrR.shift()); &#125; if (arrL.length == 0) &#123; //当左边的数组为空时 resultArr = resultArr.concat(arrR); break; &#125; else if (arrR.length == 0) &#123; resultArr = resultArr.concat(arrL); break; &#125; &#125; return resultArr;&#125;document.write(mergeSort(arr, 0, arr.length - 1)); 快速排序（quickSort） 在数据集之中，选择一个元素作为”基准”（pivot） 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 1234567891011121314151617181920212223var arr = [77, -33, 22, 32, 0, 2, 11];function quickSort(arr) &#123; // 递归结束条件 if (arr.length &lt;= 1) &#123; return arr; &#125; // 选择基准元素，并且从原数组中暂时剔除 const index = Math.floor(arr.length / 2); const base = arr.splice(index, 1)[0]; // 将数组分为左右组 let left = []; let right = []; // 对所有元素进行遍历，将大于基准值的放在左边，小于基准值的放在右边 for (let i = 0; i &lt; arr.length; i++) &#123; (arr[i] &lt; base ? right : left).push(arr[i]) &#125; // quickSort(left)对左边的合集进行递归 // quickSort(right)对右边的合集进行递归 // 连接起来，再加上基准元素就是完整合集 return quickSort(left).concat([base], quickSort(right))&#125;document.write(quickSort(arr)); 计数排序时间复杂度为O(N) 用空间换时间的算法，适用于提前知道数字范围，并且相差范围不大的情况 将数字放到对应的数组对象中，然后进行排序 这种方法不能对应数组中有负数的情况 1234567891011121314151617181920212223242526let arr = [100, 2, 3, 1, 5, 22, 33, 11, 22, 33];function sort(arr) &#123; let temp = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!temp[arr[i]]) &#123; temp[arr[i]] = 1; &#125; else &#123; temp[arr[i]]++; &#125; &#125; let result = []; for (let j = 0; j &lt; temp.length; j++) &#123; if (temp[j]) &#123; for (let k = 0; k &lt; temp[j]; k++) &#123; result.push(j) &#125; &#125; &#125; return result;&#125;console.log(sort(arr)) 参考 js算法之最常用的排序@博客园 JS-排序详解-冒泡排序@博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS31 JS中的事件队列（Event Loop）]]></title>
    <url>%2F2017%2F12%2F06%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS31%20JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%EF%BC%88Event%20Loop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JS中的事件队列（Event Loop）学习笔记及练习。 同步和异步首先要明确： JS是单线程语言 也就是说，JS一次只能做一件事情。 CPU处理指令速度非常快，远比磁盘I/O和网络I/O速度快，所以一些CPU直接执行的任务就成了优先执行主线任务（即同步任务），然后需要I/O返回数据的任务就成了等待被执行的任务（即异步任务） 同步任务（Asynchrono）：在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务； 异步任务（Synchrono）：不进入主线程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 所以： 当要主线程任务完成会后，就会去读取异步任务的“任务队列”，这就是JavaScript的运行机制 Microtasks和Macrotasks具体到任务队列，又分为宏任务（Microtasks）和微任务（Macrotasks） 属于微任务的任务有： Process.nextTick Promise Object.observe（已被废弃） MutationObserver 属宏任务的任务有： setTimeout setInterval setImmediate MessageChannel I/O UI渲染 具体的执行顺序： （1） 代码开始第一次循环，执行所有主线程的同步任务，遇到异步函数，分别添加到微任务队列和宏任务队列。 （2）所有同步任务执行完成后，开始执行异步任务。 （3）首先执行微任务队列中的全部任务，在执行过程中，如果遇到新的微任务，那么会加入到当前的微任务队列中，继续执行，直到所有的微任务执行完毕 （4）微任务执行完成后，开始执行宏任务中的任务，在执行过程中，如果遇到微任务，会将微任务将入到为任务队列，优先执行微任务队列中的任务，微任务执行完成后返回继续执行宏任务 （5）直到所有宏任务执行完毕。 也就是说，JavaScript在执行完主线程的同步任务后，开始执行异步任务。首先执行异步任务中的微任务队列，然后执行宏任务。在执行过程中，每次执行宏任务之前都会检查微任务队列，如果微任务队列未清空，则总会优先执行微任务。 异步中的异步面试题一般都会在异步中再次遇到异步的问题上搞事情，我比较容易犯糊涂的有下面两点。 （1）在微任务中又遇到了微任务，举例子来说明吧： 123456789101112console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;);Promise.resolve().then(() =&gt; &#123; console.log(3); process.nextTick(() =&gt; &#123; console.log(4); &#125;)&#125;); 按照上面的分析，首先打印出1，然后将console.log(2)放到宏任务的队列，在然后将console.log(3)和process.nextTick放入了微任务队列： 执行完成同步任务后，首先执行微任务队列，打印出3之后，遇到了另外一个微任务process.nextTick，所以正确的顺序是，将process.nextTick中的代码conosle.log(4)再次加入微任务队列： 然后继续执行微任务队列，打印4，此时微任务队列已经清空，这个时候才会去执行宏任务，打印`2· 所以，正确的打印顺序是1 → 3 → 4 → 2 （2）在宏任务又遇到了微任务 123456789101112console.log(1);setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3); &#125;);&#125;);setTimeout(() =&gt; &#123; console.log(4);&#125;); 同样首先先打印了1，然后将console.log(2)以及Promise.resolve()后面这一堆都加入了宏任务队列，然后将console.log(4)也加入宏任务队列 由于此时没有微任务，开始执行宏任务队列，首先打印了2，然后执行Promise.resovle的代码，由于这是一个微任务，所以会将console.log(3)加入了微任务队列 此时还未执行的任务中，由于console.log(3)是微任务，所以会优先执行，所以会先打印3，最后打印4 所以，正确的打印顺序是1 → 2 → 3 → 4 写Dome的时候，发现浏览器环境（Chrome 75）与Node（10.16）执行处的结果并不完全相同，Node环境本身执行的结果也不相同，大部分时间结果是1243，不知道为何，因为对Node的时间循环并不了解，留下疑问（2019-07-07） 练习在面试中经常会遇到考察输出顺序的题目。 第一题 12345678910111213141516setTimeout(function() &#123; console.log(4)&#125;, 0);new Promise(function(resolve) &#123; console.log(1) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function() &#123; console.log(5)&#125;);requestAnimationFrame(function () &#123; console.log(6)&#125;)console.log(3); 之所以6在4前面，因为setTimeOut即便第二个参数是0，但是HTML5标准规定了其最小值不能低于4毫秒，并且浏览器设置的最短间隔都在10毫秒左右，而requestAnimationFrame采用系统时间间隔，浏览器自动确定刷新频率，优先执行 但是今天在重温这道题目时，发现浏览（Chrome 75）的执行结果有时是4在6的前面，有时是6在4的前面，实际上这个顺序也是不确定的，不知道为何，存疑（2019-07-07） 第二题 12345678910111213141516171819202122232425262728console.log('start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve().then(() =&gt; &#123; console.log('promise 3') &#125;).then(() =&gt; &#123; console.log('promise 4') &#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve().then(() =&gt; &#123; console.log('promise 5') &#125;).then(() =&gt; &#123; console.log('promise 6') &#125;).then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise 1')&#125;).then(() =&gt; &#123; console.log('promise 2')&#125;) 第三题 123456789101112131415161718console.log('start');setTimeout(() =&gt; &#123; console.log('s1') &#125;, 0);new Promise((resolve) =&gt; &#123; console.log('p1'); resolve()&#125;).then(v =&gt; &#123; console.log('t1'); setTimeout(() =&gt; &#123; console.log('s2') &#125;, 0); new Promise((resolve) =&gt; &#123; console.log('p2'); resolve() &#125;).then(v =&gt; &#123; console.log('t2') &#125;); console.log('t3'); setTimeout(() =&gt; &#123; console.log('s3') &#125;, 0);&#125;);console.log('end'); 第四题 面试快手时遇到的，对于在执行微任务时又遇到微任务，突然又糊涂了，傻逼一个。 12345678910111213141516171819202122232425262728console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;);process.nextTick(() =&gt; &#123; console.log(3);&#125;);setImmediate(() =&gt; &#123; console.log(4);&#125;);new Promise(resolve =&gt; &#123; console.log(5); resolve(); console.log(6);&#125;).then(() =&gt; &#123; console.log(7);&#125;);Promise.resolve().then(() =&gt; &#123; console.log(8); process.nextTick(() =&gt; &#123; console.log(9); &#125;)&#125;) 参考 event loop js事件循环 microtask macrotask@CSDN Promise的队列与setTimeout的队列有何关联？@知乎]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题16 EditorConfig和ESLint]]></title>
    <url>%2F2017%2F12%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9816%20EditorConfig%E5%92%8CESLint%2F</url>
    <content type="text"><![CDATA[编程好帮手：EditorConfig + ESLint EditorConfig为了保持项目中代码缩进风格的一致，可以使用EditorConfig来定义和维护一致的编码风格，例如范缩进风格，缩进大小，Tab长度以及字符集等。 标准的.editorconfig文件中，第一行是EditorConfig的官网，第二行是用于指明.editorconfig文件的位置，*代表通配符，下面是对应的规则，现在项目中使用的配置文件是这样的： 1234567891011121314151617181920root = true[*]#缩进风格：空格indent_style = space#缩进大小2indent_size = 2#字符集utf-8charset = utf-8#行尾允许空格trim_trailing_whitespace = true#结尾总是插入新的一行insert_final_newline = true[*.md]trim_trailing_whitespace = false 没有加入的属性还有： 12#换行符lfend_of_line = lf ESLintEslint是一个用来识别ECMAScript并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，一般使用配置文件来配置ESLint，在项目的根目录下创建.eslintrc.js 可以被配置的信息主要分为3类： Environments：你的Javascript脚本将要运行在什么环境（如：Node，浏览器等）中。 Globals：执行代码时脚步需要访问的额外全局变量。 Rules：开启某些规则，也可以设置规则的等级。 安装安装推荐局部安装： 1npm i -D eslint 安装完毕后，接下来新建一个配置文件.eslintrc.js，或者使用如下的命令行来自动生成。 1234./node_modules/.bin/eslint --init# 如果是全局安装的话可以执行eslint --init 配置文件中的配置规则分为三种等级： off” 或者 0：关闭规则。 “warn” 或者 1：打开规则，并且作为一个警告（不影响exit code）。 “error” 或者 2：打开规则，并且作为一个错误（exit code将会是1）。 1234567// .eslintrc.jsmodule.exports = &#123; env: &#123; browser: true, node: true, &#125;,&#125;; 具体的配置规则非常多，具体见这里。 在Webstorm中使用在Webstorm中配置ESLint，需要在Language &amp; Frameworks → Javascript → Code Quality Tools → ESLint中进行配置，勾选Enable 一般情况下下面的对应的配置和地址都会自动填好。 AlloyTeam ESLint规则也可以使用腾讯的AlloyTeam的ESLint规则，有详细的规则描述和示例，可以在此基础上进行定制。 使用时需要首先安装eslint、babel-eslint、eslint-config-alloy，这是AlloyTeam的ESLint规则的最基础的所需要安装的依赖 1npm install --save-dev eslint babel-eslint eslint-config-alloy 然后在项目根目录下的eslintrc.js中复制以下内容： 12345678910111213141516171819202122232425module.exports = &#123; extends: [ 'eslint-config-alloy', ], globals: &#123; // 这里填入你的项目需要的全局变量 // 这里值为 false 表示这个全局变量不允许被重新赋值，比如： // // jQuery: false, // $: false &#125;, rules: &#123; // 这里填入你的项目需要的个性化配置，比如： // // // @fixable 一个缩进必须用两个空格替代 // 'indent': [ // 'error', // 2, // &#123; // SwitchCase: 1, // flatTernaryExpressions: true // &#125; // ] &#125;&#125;; 配合Vue使用可以在使用AlloyTeam预置的Vue的规则： 12345npm install eslint babel-eslint vue-eslint-parser@2.0.1-beta.2 eslint-plugin-vue@3 eslint-config-alloy --save-dev 然后将.eslintrc.js中的extends的值更改为[&#39;eslint-config-alloy/vue&#39;] 下面是在CRM系统中使用的，一份配合Vue使用的配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module.exports = &#123; "env": &#123; "browser": true, "amd": true, "jquery": true &#125;, "rules": &#123; // 禁止出现alert, prompt 和 confirm, 可以在发布的时候进行检测 "no-alert": 2, // 禁止出现console, 可以在发布的时候进行检测 "no-console": 2, // 禁止出现debugger, 可以在发布的时候进行检测 "no-debugger": 2, // 禁止不写分号 "semi": [2, "always"], // 禁止出现tab之外的缩进 "indent": [2, "tab"], // 允许定义前使用 "no-use-before-define": 0, // 允许if (!!foo) 这种形式 "no-extra-boolean-cast": 0, // 允许对函数声明进行覆盖赋值 "no-func-assign": 0, // 允许使用caller或callee "no-caller": 0, // 允许函数在不同的情况下返回不同类型的值 "consistent-return": 0, // 允许在switch的case中不加break "no-fallthrough": 0, // 允许使用__proto__ "no-proto": 0, // 允许覆盖外部变量 "no-shadow": 0, // 允许文件的最后一行不是空白行 "eol-last": 0, // 允许使用下划线开头命名变量 "no-underscore-dangle": 0, // 建议将操作符放到行尾, 而不是行首 "operator-linebreak": [1, "after"], // 建议使用已定义的变量 "no-undef": 1, // 建议return语句中不要包含赋值表达式 "no-return-assign": 1, // 建议代码列数不能超过120行 "max-len": [1, 120], // 建议启用严格模式 "global-strict": 0, "strict": 1, // 建议使用单引号 "quotes": [1, "single"], // 建议注释符要有空白隔开 "spaced-comment": [1, "always"] &#125;, // 如果使用vue单文件组件 "extends": [ "plugin:vue/essential" ],&#125; 配合React使用同样可以在使用AlloyTeam预置的React的规则： 1234npm install eslint babel-eslint eslint-plugin-react eslint-config-alloy --save-dev 然后将.eslintrc.js中的extends的值更改为[&#39;eslint-config-alloy/react&#39;]。 在Exam项目中使用的一份很简单的配置文件： 1234567891011121314151617181920212223module.exports = &#123; extends: [ 'plugin:react/recommended', ], "ecmaFeatures": &#123; "jsx": true, "modules": true &#125;, "env": &#123; "browser": true, "node": true &#125;, "parser": "babel-eslint", "rules": &#123; "quotes": [2, "single"], "react/jsx-uses-react": 2, "react/jsx-uses-vars": 2, "react/react-in-jsx-scope": 2 &#125;, "plugins": [ "react" ]&#125; 需要注意的是，如果使用的Create React App脚手架工具来搭建React项目，由于它将默认的构建配置封装了起来，而ESLint仅仅开启了最基本的规则，更重要的是默认情况下，ESLint仅仅会在IDE中对违反规则的情况进行提示，并不会在构建时在终端的输出进行终端和提示。 如果这种情况可以满足需要，而只需要开启更多的规则，那么就可以在根目录下新建一个文件.eslintrc.json，然后添加： 123&#123; "extends": "react-app"&#125; 但是如果要起到更强制性的提示作用（中断构建、终端提示），Create React App建议使用Prettier代替ESLint。如果要使用ESLint，那么就需要使用npm run eject，将配置文件吐出，按照AlloyTeam的提示进行配置即可。 ESlint对Async报错的解决方法在ESlint配置文件中增加 123parserOptions: &#123; "ecmaVersion": 8,&#125; 参考 rules@ESLint 在WebStorm中使用editorConfig插件@CSDN ESLint与EditorConfig@CSDN ESLint - 简介@简书 Displaying Lint Output in the Editor@Create React App AlloyTeam/eslint-config-alloy@github]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
        <tag>EditorConfig</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题15 网页性能优化]]></title>
    <url>%2F2017%2F11%2F19%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9815%20%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[性能优化从以下几个角度来考虑 页面性能优化 网络性能优化 网络性能优化网络性能优化主要从以下几个角度： 加快请求速度（使用CDN， keep-alive，Websocket，避免重定向，优先加载CSS文件） – 加快速度 增多请求并发（Domian-Hash） – 增大并发 减小请求数目（合并文件、雪碧图） – 减少次数 减小资源体积（压缩图片和文件，Gzip，懒加载，JS包按需加载、Cookie-Free（减少不必要的cookie），Cache-Control，合理设置缓存，使用Webp格式图像减小图像体积、使提供响应式图像，谨慎使用第三方库）– 减小体积 响应式图像：在&lt;img&gt;中使用secret属性指定浏览器选择的一组图像，或者使用&lt;picture&gt;标签帮助浏览器选择最佳格式，传送不同屏幕尺寸下不同格式的图像 页面性能优化 优化DOM性能（减少DOM操作，拼接DOM操作，事件委托，使用合理的CSS选择器，多用原生方法） 优化CSS性能（使用CSS动画代替JS动画，使用tranform完成动画，利用GPU渲染单独的复合层、提高z-index避免隐式合成过多的复合层，使用will-change属性，利用scale减小纯色复合层的尺寸） 优化JS性能（减少循环次数，合理缓存变量，减少全局变量，使用局部变量，操作节流） 优化用户体验（加载状态） 参考 网络基础09 提高网络性能 动画02 浏览器的重绘与重排以及动画性能优化 性能为何至关重要@Google Developer]]></content>
      <categories>
        <category>零散专题</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础10 Restful API设计规范]]></title>
    <url>%2F2017%2F11%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8010%20Restful%20API%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[REST 用来规范应用如何在 HTTP 层与 API 提供方进行数据交互 。 REST 描述了 HTTP 层里客户端和服务器端的数据交互规则；客户端通过向服务器端发送 HTTP（s）请求，接收服务器的响应，完成一次 HTTP 交互。这个交互过程中，REST 架构约定两个重要方面就是 HTTP 请求的所采用方法，以及请求的链接。 REST 对请求的约定REST 用来规范应用如何在 HTTP 层与 API 提供方进行数据交互 。 REST 描述了 HTTP 层里客户端和服务器端的数据交互规则；客户端通过向服务器端发送 HTTP（s）请求，接收服务器的响应，完成一次 HTTP 交互。这个交互过程中，REST 架构约定两个重要方面就是 HTTP 请求的所采用方法，以及请求的链接。 在请求层面，REST 规范可以简单粗暴抽象成以下两个规则： 请求 API 的 URL 表示用来定位资源； 请求的 METHOD 表示对这个资源进行的操作； API 的 URLURL 用来定位资源，跟要进行的操作区分开，这就意味这 URL 不该有任何动词； 下面示例中的get、create、search等动词，都不应该出现在 REST 架构的后端接口路径中。在以前，这些接口中的动名词通常对应后台的某个函数。比如： 1234/api/getUser/api/createApp/api/searchResult/api/deleteAllUsers 当我们需要对单个用户进行操作时，根据操作的方式不同可能需要下面的这些接口： 1234/api/getUser （用来获取某个用户的信息，还需要以参数方式传入用户 id 信息）/api/updateUser （用来更新用户信息）/api/deleteUser （用来删除单个用户）/api/resetUser （重置用户的信息） 更有甚者，可能在更新用户不同信息时，提供不同的接口，比如： 123/api/updateUserName/api/updateUserEmail/api/updateUser 这样的弊端在于：首先加上了动词，肯定是使 URL 更长了；其次对一个资源实体进行不同的操作就是一个不同的 URL，造成 URL 过多难以管理。 其实当你回过头看「URL」 这个术语的定义时，更能理解这一点。URL 的意思是统一资源定位符，这个术语已经清晰的表明，一个 URL 应该用来定位资源，而不应该掺入对操作行为的描述。 在 REST 架构的链接应该是这个样子： URL 中不应该出现任何表示操作的动词，链接只用于对应资源； URL 中应该单复数区分，推荐的实践是永远只用复数；比如GET /api/users表示获取用户的列表；如果获取单个资源，传入 ID，比如/api/users/123表示获取单个用户的信息； 按照资源的逻辑层级，对 URL 进行嵌套，比如一个用户属于某个团队，而这个团队也是众多团队之一；那么获取这个用户的接口可能是这样： 1GET /api/teams/123/members/234 表示获取 id 为 123 的小组下，id 为234 的成员信息 按照类似的规则，可以写出如下的接口: 1234/api/teams （对应团队列表）/api/teams/123 （对应 ID 为 123 的团队）/api/teams/123/members （对应 ID 为 123 的团队下的成员列表）/api/teams/123/members/456 （对应 ID 为 123 的团队下 ID 为 456 的成员） 特殊情况：有的时候一个资源变化难以使用标准的 Restful API 来命名，可以考虑使用一些特殊的 actions 命名。比如，“密码修改”这个接口的命名很难完全使用名词来构建路径，此时可以引入 action： 1【PUT】 /v1/users/&#123;user_id&#125;/password/actions/modify // 密码修改 API的请求方法在很多系统中，几乎只用 GET 和 POST 方法来完成了所有的接口操作；这个行为类似于全用 DIV 来布局。实际上，我们不只有GET 和 POST 可用，在 REST 架构中，有以下几个重要的请求方法：GET，POST，PUT，PATCH，DELETE。这几个方法都可以与对数据的 CRUD 操作对应起来。 CRUD 是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。即增删改查 简单来说，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。 123456【GET】 /users # 查询用户信息列表【GET】 /users/1001 # 查看某个用户信息【POST】 /users # 新建用户信息【PUT】 /users/1001 # 更新用户信息(全部字段)【PATCH】 /users/1001 # 更新用户信息(部分字段)【DELETE】 /users/1001 # 删除用户信息 1【Read】资源的读取，用 GET 请求，比如： 1GET /api/users （ 表示读取用户列表） GET 应当实现为一个安全方法。用于获取数据而不应该产生副作用。 2【Created】资源的创建，用 POST 方法； POST 是一个非幂等的方法，多次调用会造成不同效果； 幂等（Idempotent）：如果对服务器资源的多次请求与一次请求造成的副作用是一样的的话，那这个请求方法可以被认为是幂等。 比如下面的请求会在服务器上创建一个name属性为&#39;John Snow&#39;的用户；多次请求就会创建多个这样的用户。 12345POST /api/users&#123; &quot;name&quot;: &quot;John Snow&quot;&#125; 3【Update】资源的更新。用于更新的 HTTP 方法有两个，PUT 和 PATCH。 他们都应当被实现为幂等方法，即多次同样的更新请求应当对服务器产生同样的副作用。 PUT 和 PATCH 有各自不同的使用场景： PUT 用于更新资源的全部信息，在请求的body中需要传入修改后的全部资源主体； PATCH 用于局部更新，在body中只需要传入需要改动的资源字段。 设想服务器中有以下用户资源/api/users/123 12345&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;Original&quot;, &quot;age&quot;: 20&#125; 当我们往后台发送更新请求时，PATCH 和 PUT 造成的效果是不一样。 12345PUT /api/users/123&#123; &quot;name&quot;: &quot;PUT Update&quot;&#125; 上述 PUT 请求操作后的内容是： 1234&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;PUT Update&quot;&#125; 可以观察到，资源原有的 age 字段被清除掉了。 而如果改用 PATCH 的话， 12345PATCH /api/users/123&#123; &quot;name&quot;: &quot;PATCH Update&quot;&#125; 更新后的内容是： 12345&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;PATCH Update&quot;, &quot;age&quot;: 20&#125; 请求中指定的name属性被更新了，而原有的age属性则保持不变。 PATCH 的作用在于如果一个资源有很多字段，在进行局部更新时，只需要传入需要修改的字段即可。否则在用 PUT 的情况下，你不得不将整个资源模型全都发送回服务器，造成网络资源的极大浪费。 4【Delete】资源的删除，相应的请求 HTTP 方法就是 DELETE。这个也应当被实现为一个幂等的方法。如: 1DELETE /api/users/123 用于删除服务器上ID为123的资源，多次请求产生副作用都是，是服务器上ID为123的资源不存在。 5 两个不常用的HTTP动词 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。针对非简单请求的CORS请求，会在正式通信之前增加一次HTTP查询请求，称为“预检”请求，对应的请求方法就是OPTION 查询参数REST 风格的接口地址，表示的可能是单个资源，也可能是资源的集合；当我们需要访问资源集合时，设计良好的接口应当接受参数，允许只返回满足某些特定条件的资源列表。 公共参数常规的公共查询参数有： 参数名 作用 offset 返回记录的开始位置 limit 返回记录的数量 keyword 提供关键词进行搜索 sort 指定排序的字段 orderby 指定排序方式 具体来看： （1）以offset和limit参数来进行分页： 1GET /api/users?offset=0&amp;limit=20 （2）使用keyword提供关键词进行搜索： 1GET /api/users?keyword=john （3）使用sort参数和orderby参数进行排序 12GET /api/users?sort=age&amp;orderby=asc // 按年龄升序GET /api/users?sort=age&amp;orderby=desc // 按年龄降序 有的时候也可以只用orderby来进行排序： 12GET /api/users?se&amp;orderby=age_asc // 按年龄升序GET /api/users?se&amp;orderby=age_desc // 按年龄降序 个性参数上面介绍的offset、limit、 orderby 是一些公共参数。此外，业务场景中还存在许多个性化的参数： 1【GET】 /v1/categorys/&#123;category_id&#125;/enable=[1|0]&amp;os_type=&#123;field&#125;&amp;device_ids=&#123;field,field,…&#125; 注意不要过度设计，只返回用户需要的查询参数，此外，需要考虑是否对查询参数创建数据库索引以提高查询性能。 语义化设计合适的 API URL，以及选择合适的请求方法，可以语义化的描述一个 HTTP 请求的操作。 当我们都熟悉且遵循这样的规范后，基本可以看到一个 REST 风格的接口就知道如何使用这个接口进行 CRUD 操作了。比如下面这面这个接口就表示搜索ID为123的图书馆的书，并且书的信息里包含关键字game，返回前十条满足条件的结果。 1GET /api/libraries/123/books?keyword=game&amp;sort=price&amp;limit=10&amp;offset=0 同样，下面这个请求的意思也就很明显了吧。 12345PATCH /api/companies/123/employees/234&#123; &quot;salary&quot;: 2300&#125; 状态码服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 状态码 状态信息 说明 200 OK 请求成功 201 CREATED 创建成功 204 NO CONTENT 删除数据成功 400 INVALID REQUEST 错误的请求 401 Unauthorized 未授权 403 Forbidden 有授权（与401相对），但是被拒绝 404 NOT FOUND 无法找到 406 Not Acceptable 用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式） 500 INTERNAL SERVER ERROR 服务器发生错误 错误处理当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。 一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: "Invalid API key"&#125; 也可以采取下面的结构： 1234567891011HTTP/1.1 400 Bad RequestContent-Type: application/json&#123; &quot;code&quot;: &quot;INVALID_ARGUMENT&quot;, &quot;message&quot;: &quot;&#123;error message&#125;&quot;, &quot;cause&quot;: &quot;&#123;cause message&#125;&quot;, &quot;request_id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;, &quot;host_id&quot;: &quot;&#123;server identity&#125;&quot;, &quot;server_time&quot;: &quot;2014-01-01T12:00:00Z&quot;&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 1234567【GET】 /&#123;version&#125;/&#123;resources&#125; // 返回资源对象的列表（数组）【GET】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回单个资源对象【POST】 /&#123;version&#125;/&#123;resources&#125; // 返回新生成的资源对象【PUT】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回完整的资源对象【PATCH】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回完整的资源对象【DELETE】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 状态码 200，返回完整的资源对象。【DELETE】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 状态码 204，返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 12345678&#123; "link": &#123; "rel": "collection https://www.example.com/zoos", "href": "https://api.example.com/zoos", "title": "List of zoos", "type": "application/vnd.yourformat+json" &#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; "current_user_url": "https://api.github.com/user", "authorizations_url": "https://api.github.com/authorizations", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user， 然后就得到了下面结果。 1234&#123; "message": "Requires authentication", "documentation_url": "https://developer.github.com/v3"&#125; 版本号在 Restful API 中，API应当尽量兼容之前的版本。Web端很容易为了适配服务端的新的 API 接口进行版本升级，而 Android 、IOS等客户端必须通过用户主动升级产品到新版本，才能适配新接。 为了解决这个问题，在设计 Restful API时一般情况下会在 URL 中半流版本号，并同时兼容多个版本： 12【GET】 /v1/users/&#123;user_id&#125; // 版本 v1 的查询用户列表的 API 接口【GET】 /v2/users/&#123;user_id&#125; // 版本 v2 的查询用户列表的 API 接口 现在可以再不改变 V1 版本的接口情况下，新增 V2 版本的接口满足新的业务需求。服务端会同时兼容多个版本，但是同时维护版本过多也会成为不小的负担。常见的做法是，不维护全部的兼容版本，而是只维护最新的几个兼容版本，例如维护最新的三个兼容版本。在一段时间后，大部分的用户升级到新的版本后，废弃一些使用量较少的服务端老版本的API接口，并要求使用产品老旧版本的用户墙纸升级。 其他 API的身份认证应该使用OAuth 2.0框架。 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 关于 REST 的更多详细规范，可以参考这个仓库。 参考 RESTful API 设计指南@阮一峰的网络日志 RESTful 接口实现简明指南@知乎 服务端指南 | 良好的 API 设计指南@掘金]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Restful</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS28 判断对象是空对象]]></title>
    <url>%2F2017%2F11%2F09%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS28%20%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如何判断对象是空对象，总结了一下。 概述一个空的对象{}在JS中进行判断，显示为真值： 12var a = &#123;&#125;;console.log(!!a) // true 所以要判断对象中是否含有属性，需要使用特殊的手段，不同情况下有不同的手段： Reflect.ownKeys() JSON.stringify Object.keys/Object.values/Object.entries Object.getOwnPropertyNames() for...in 其他方法 这里判断对象是否是空对象，应该刨除原型链继承的影响，只观察对象自身是否含有任意属性值。 基于这个前提下，我认为可能Reflect.ownKeys()是更恰当的方法。 遍历方法的区别先来看一下各种遍历方法的区别： 自身属性 原型属性 可枚举属性 不可枚举属性 Symbol属性 for...in √ √ √ × × Object.getOwnPropertyNames √ × √ √ × Object.keys √ × √ × × Relect.ownKeys √ × √ √ √ Reflect.ownKeys(target)Relfect对象是ES6为操作对象提供的新API，它提供了许多针对对象的操作方法，其中ownKeys用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 它与其他的遍历方法最大的不同就是，它会将对象中Symbol类型的属性名遍历出来，而其他的方法不会。 123function isEmpty(obj) &#123; return Reflect.ownKeys(obj).length === 0&#125; 其他的方法都有着自己的局限性。 Object.keys()Object.keys()方法返回的数组中只包括自身可枚举的属性，不可枚举属性和Symbol属性都包括在返回结果中 Object.getOwnPropertyNames()Object.getOwnPropertyNames()返回的结果中包含自身可枚举和不可枚举的属性，但是不包含Symbol属性 它与Object.keys()相比，返回结果增加了自身不可枚举的属性 for...in利用for...in对对象进行遍历时，会返回自身以及原型链上的可枚举属性，返回结果不包含Symbol属性 我们这里的前提是不考虑原型链继承而来的属性，所以即便不考虑Symbol属性，也需要通过hasOwnProperty判断遍历的结果是继承自原型链还是属于自身的属性 JSON.stringify()JSON.stringify()方法可以将对象序列化为字符串，但是在序列化过程中会忽略方法属性和Symbol属性 12345const a = &#123; [Symbol(123)]: 123, say() &#123;&#125;&#125;;console.log(JSON.stringify(a)) // '&#123;&#125;' Lodash的isEmpty方法使用Lodash的isEmpty判断对象是否是空对象时，对象如果被认为为空，那么他们没有自己的可枚举属性的对象。 它对字符串、数组、类数组对象也考虑在内了，如果这些对象长度为0，就认为是空对象 对于Map和Set对象，如果其size为0，就认为是空对象 看一下它的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Checks if `value` is an empty object, collection, map, or set. * * Objects are considered empty if they have no own enumerable string keyed * properties. * * Array-like values such as `arguments` objects, arrays, buffers, strings, or * jQuery-like collections are considered empty if they have a `length` of `0`. * Similarly, maps and sets are considered empty if they have a `size` of `0`. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param &#123;*&#125; value The value to check. * @returns &#123;boolean&#125; Returns `true` if `value` is empty, else `false`. * @example * * _.isEmpty(null); * // =&gt; true * * _.isEmpty(true); * // =&gt; true * * _.isEmpty(1); * // =&gt; true * * _.isEmpty([1, 2, 3]); * // =&gt; false * * _.isEmpty(&#123; 'a': 1 &#125;); * // =&gt; false */function isEmpty(value) &#123; // 对于null也认为是空对象，返回true if (value == null) &#123; return true; &#125; // 对数组/类数组对象/字符串/Buffer/arguments对象，根据length属性进行判断 if (isArrayLike(value) &amp;&amp; (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) &#123; return !value.length; &#125; // 主要是通过Object.prototype.toString.call返回类型 var tag = getTag(value); // 针对Map和Set对象，根据size属性进行判断 if (tag == mapTag || tag == setTag) &#123; return !value.size; &#125; // 针对原型对象，利用for...in遍历，返回自身除了constructor之外的属性 if (isPrototype(value)) &#123; return !baseKeys(value).length; &#125; // 针对普通对象，利用for...in循环 for (var key in value) &#123; if (hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; return true;&#125; 发现它使用的是for...in来进行主要的判断，对Symbol属性也没有进行判断 123const key = Symbol(123);const a= &#123;[key]: 33&#125;;console.log(_.isEmpty(a)); // true 参考 Reflect@ECMAScript6入门 isEmpty@Lodash Object.keys()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础07 HTTP安全]]></title>
    <url>%2F2017%2F11%2F06%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8007%20HTTP%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[HTTP安全学习笔记。 XSS跨站脚本攻击现象XSS（cross site scripting），即跨站点脚本工具，发生在用户的浏览器端。用户输入非法字符，向页面植入恶意代码，在目标网站上执行非原有的脚本。 如果网页会使用用户的输入渲染为HMTL内容渲染时就会执行被植入的恶意代码，利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全。 XSS的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 分类一般会分为存储型XSS、反射型XSS和DOM型XSS （1）存储型XSS 攻击者将恶意代码提交到目标网站的数据库中，用户打开网站时网站将恶意代码从数据库中取出，拼接在HTML中返回给浏览器，在浏览器中执行恶意代码 恶意代码窃取用户数据，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 这种攻击常见于带有用户保存数据的网站功能，比如论坛发帖、商品评论、用户私信等。 （2）反射型XSS 攻击者构造出包含恶意代码的特殊的URL，用户打开URL后，网站服务端取出URL中的恶意代码，凭借在HTML中返回给浏览器，在浏览器中执行恶意代码 反射型XSS与存储型XSS的区别是，存储型XSS的恶意代码存在数据库，而反射型XSS的恶意代码存在URL中。 反射型XSS攻击常见于通通过URL传递参数的功能，比如网站搜索、跳转等。由于需要用户主动打开URL才能生效，所以攻击者往往会结合多种手段诱导用户点击。 （3）DOM型XSS 攻击者构造出包含恶意代码的特殊的URL，用户打开URL后，JavaScript取出URL中的恶意代码并执行。恶意代码窃取用户数据，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM型XSS与前两种区别是，DOM型XSS的取出和执行恶意代码都有浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种属于服务端的安全漏洞。 防护XSS攻击有两大要素： 攻击者提交恶意代码 浏览器执行恶意代码 针对第一个要素，需要对用户输入进行过滤，但是并非完全可靠，因为在提交较短并不确定内容要输出哪里，对内容的转义有可能导致乱码和不确定性问题。 所以更合理的预防方法是针对第二个要素，通过防止浏览器执行恶意代码来防范XSS，分为两类： 防止HTML中出现注入 防止JavaScript执行恶意代码 总结起来，可以采取的预防方法有： （1）一定要针对用户输入做相关的格式检查、过滤等操作，防止任何可能的前端注入 （2）对于不需要考虑SEO的内部系统、管理系统，使用纯前端渲染代替服务端渲染，把代码与数据分开 （3）对于需要服务端拼接HTML的情况，要对HTML中的敏感字符（比如&gt;、&gt;等）进行HTML转义（&amp;lt;、&amp;gt;） （4）由于HTML转义是很复杂的，不同情况下要采取不同的准一规则，应当尽量避免自己写转义库，而是采取成熟的、业界通用的转义库 （5）对于跳转链接例如&lt;a href=&quot;xxx&quot;&gt;或者location.href=&quot;xxx&quot;要检验内容，禁止以javascript:开头的链接 （6）遵循GET请求不改变服务状态的原则，改变状态的请求都是用POST或者PUT方法 （7）前端在使用innerHTML、outerHTML、document.write时要注意，不要把不可信数据作为HTML插入到页面 （8）使用Vue/React技术栈时不要使用v-html、dangerouslySetInnerHTML功能，在前端render阶段避免XSS隐患 （9）DOM中的内联事件监听器，比如onclick、onload、onmouseover、JavaScript中的eval、setTimeout、setInterval、eval都可以将字符串作为代码运行，如果不可信数据传递给上述API，很容易产生安全隐患，所以要尽量避免， 12345&lt;a href="javascript:alert(1)"&gt;&lt;/a&gt;&lt;iframe src="javascript:alert(1)" /&gt;&lt;img src='x' onerror="alert(1)" /&gt;&lt;video src='x' onerror="alert(1)"&gt;&lt;/video&gt;&lt;div onclick="alert(1)" onmouseover="alert(2)"&gt;&lt;div&gt; （10）对于不受信任的输入，可以限制合理的长度，可以增加XSS攻击的难度 （11）某些敏感cookie应该设置HTTP-only，避免通过JavaScript读取cookie （12）添加验证码，防止脚本冒充用户提交危险操作 （13）主动监测发现XSS漏洞，使用XSS攻击字符串和自动扫描工具寻找潜在的XSS漏洞 （14）JSONP的callback参数非常危险，风险性主要存在于会意外截断JS代码或者被添加恶意标签 CSRFCookie往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确Cookie的HTTP请求，这就是CSRF攻击。 现象CSRF（Corss Site Request Forgery），有时也被缩写为XSRF，跨站伪造请求，伪造不是来自于用户的意愿，诱导用户发起请求。 通过CSRF，攻击者可以盗用用户的身份，以用户的名义发送恶意请求，比如以你的名义发送邮件、发送消息、盗取账号等。 CSRF攻击的思想： 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登陆受信任网站A，并在本地生成cookie 在不登出信任网站A的情况下（session有效），访问危险网站B CSRF攻击是源于HTTP使用cookie实现的隐式身份验证机制，这种机制可以保证一个请求是来自于某个用户的浏览器，但是无法保证该请求是用户批准发送的。 攻击形式同源策略并不能访问CSRF，因为CSRF会通过&lt;img&gt;、&lt;srcipt&gt;或者通过action提交表单的形式来让用户在不知情的情况下发送请求，这些形式是不受浏览器的跨域限制的，所以请求正常发送，也就会默认将目标网站的cookie带上，伪造了用户的身份。 GET类型的CSRF一般会利用&lt;img&gt;标签： 1&lt;img src="http://bank.example/withdraw?amount=10000&amp;for=hacker" &gt; POST类型的CSRF通常会利用自动提交的表单： 123456&lt;form action="http://bank.example/withdraw" method=POST&gt; &lt;input type="hidden" name="account" value="xiaoming" /&gt; &lt;input type="hidden" name="amount" value="10000" /&gt; &lt;input type="hidden" name="for" value="hacker" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 有时候也会有通链接形式&lt;a&gt;的攻击，这种形式需要诱导用户主动点击： 123&lt;a href="http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker" taget="_blank"&gt;重磅消息！！&lt;a/&gt; 防护由于CSRF通常发生在第三方域名，并且CSRF不能获取到目标网站的Cookie，仅仅是利用，所以可以从两方面定制防护策略： 同源检测 附加信息认证 （1）同源检测 可以通过请求头Header中的Origin自断判断域名是否同源，但是它对IE11和302重定向都不支持 也可以使用Header中的Referer来确定，它记录了HTTP请求的来源地址，对于Ajax请求、图片、脚本等资源请求，Referer是发起请求的页面地址，对于页面跳转，它是打开页面历史记录的前一个页面地址。这种方式并不安全，因为攻击者可以修改或者隐藏的Referer： 1&lt;img src="http://bank.example/withdraw?amount=10000&amp;for=hacker" referrerpolicy="no-referrer"&gt; 所以同源检测的可靠性并不是很高，尤其是在Origin和Referer同时不存在的情况下，最好阻止这次网络请求，但是对外域请求如果一概阻止又会将来自搜索引擎链接的请求误伤。并且CSRF也可能来自同源页面（例如用户可以发布带链接和图片的评论等） 综上所述，同源请求是一个相对接单的防范方法，能够防范一定的CSRF攻击，但是对于安全性较高或者有较多用户输入内容的网站，就需要对关键接口进行进一步的防护。 （2）附加信息认证 附加信息认证中心思想就是在客户端页面增加伪随机数。 CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。 而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 （1） Cookie Hashing 这是比较简单的解决方案，所有的表单都包含同一个伪随机Hash值。在表单中添加一个隐藏的字段，值就是服务单构造的伪随机cookie，随表单一起发送。服务端对表单中的Hash值进行验证。 理论上攻击者无法获取第三方的cookie，那么也就无法伪造表单了，也就杜绝CSRF的攻击了。 Egg默认的预防CSRF的方式就是通过这种方式实现的，框架会在Cookie存放一个CSRF Token，放到query、body或者header中发送给服务端进行验证 注意不能放在cookie中直接验证，那样就没有意义了，因为即便是CSRF伪造的请求，也会携带cookie。 （2）验证码 这种方法也是最常见的方法之一，每次用户提交都需要在表单中填写一个图片上的伪随机字符串（或者实现某些特殊的交互），来让攻击者无法获取对应的字符串或者操作，从而伪造身份失败。 （3）JWT 可以通过JSON-WEB-Token来实现，在响应页面时将Token渲染到页面上，在提交表单的时候通过隐藏域提交上来 （4）SameSite属性 Google起草了一分草案，为Set-Cookie响应头新增SameSite属性，用来标明这个Cookie是个同站Coookie。同站Cookie只能作为第一方Cookie，不能作为第三方Cookie。 1Set-Cookie: foo=1; Samesite=Strict 设置Samesite为strict为严格模式，表明这个cookie任何情况下都不能作为第三方cookie，没有例外。假设我们为b.com设置了上面的cookie，那么在a.com发起对b.com的跨域请求，foo这个cookie都不会包含在cookie请求头中。 举个实际的例子就是，假如淘宝网站用来识别用户登录与否的Cookie被设置成了Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个Cookie，其它网站发起的对淘宝的任意请求都不会带上那个Cookie。 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 设置Samesite为lax为宽松模式，假设这个请求改变了当前页面（或者打开了新页面）且同时是一个GET请求，那么这个cookie可以作为第三方cookie 加入b.com设置了上面的两个cookie，当从a.com点击链接进入b.com时，foo这个cookie不会包含在请求头中，但是bar和baz会。 也就是说用户在不同网站之间通过链接跳转不会受影响，到那时如果在a.com发起对b.com发起网络请求，或者页面跳转是通过表单的POST请求触发的，那么bar也不会包含在请求头中。 如果将Samesite被设置为Strict，浏览器在任何网络请求中都不会携带Cookie，可以完全杜绝CSRF攻击，但是新打开标签或者跳转到子域名的网站都需要重新登录，用户体验很差。 如果将Samesite被设置为Lax可以保障链接跳转是的用户体验，但是安全性也比较低。 此外Samesite的兼容性也很差，并且不支持子域，也就是说user.a.com不能使用a.com下的Samesite Cookie，如果网站有多个子域名，不能使用Samesite Cookie在主域名存储用户登录信息。 所以Samesite Cookie是一个可能替代同源验证的方案，但还不成熟，应用场景有待观望。 关于CSRF攻击美团技术团队的这篇文章写的非常好，可以仔细阅读学习。 HTTP劫持（中间人攻击）当我们使用HTTP请求请求一个网站页面的时候，营商可在用户发起请求时直接跳转到某个广告，或者直接改变搜索结果插入自家的广告，让客户端（通常是浏览器）展示“错误”的数据，通常是一些弹窗，宣传性广告或者直接显示某网站的内容。如果劫持代码出现了BUG ，则直接让用户无法使用，出现白屏。 数据泄露、请求劫持、内容篡改等等问题，核心原因就在于HTTP是全裸式的明文请求，域名、路径和参数都被中间人们看得一清二楚。 最直接的解决方法就是使用HTTPS协议代替HTTP协议。HTTPS做的就是给请求加密，让其对用户更加安全。对于自身而言除了保障用户利益外，还可避免本属于自己的流量被挟持，以保护自身利益。 DNS劫持DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的 这种攻击作为网站开发者并没有什么好的解决方式，可能的解决方有两个： 使用大公司提供的CDN服务，减少被坚持的概率 被劫持后向工信部投诉解决，或者包茎 点击劫持点击劫持是一种视觉欺骗，将我们的网页放置到和原页面相同大小的iframe中，用透明的iframe或者图片覆盖页面，诱导用户点击，访问其他页面。 可以在前端预防，判断当前页面是否被嵌套了在iframe中，如果被嵌套了的话则重定向外层页面到我们的正常页面。 123if (top.location !== location)&#123; top.location = self.location&#125; 但是前端防护很容易被绕过，更可靠的方法是通过设置HTT响应头信息的X-FRAME-OPTION属性来进行防护，用来给浏览器指示允许一个页面可否在&lt;frame&gt;，&lt;iframe&gt;，&lt;embed&gt;或者&lt;object&gt;中展现。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持攻击。 可取的属性值有DENY/SAMEORIGIN/ALLOWFROM DENY：表示该页面不允许 frame中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN：表示该页面可以在相同域名页面的frame中展示。 ALLOW-FROM： 表示该页面可以在指定来源的frame中展示。 参考 前端安全系列（一）：如何防止XSS攻击？@美团技术团队 安全威胁 CSRF 的防范@Egg 浅谈CSRF攻击方式@hyddd JavaScript防http劫持与XSS@CSDN 浅析点击劫持攻击@FREEBUF 安全@Egg X-Frame-Options 响应头@MDN 前端安全系列之二：如何防止CSRF攻击？@掘金]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>HTTP</tag>
        <tag>安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node10 同时使用不同版本的node]]></title>
    <url>%2F2017%2F11%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode10%20%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84node%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。管理Node版本的笔记。 方法1：利用n工具利用n工具可以创建不同版本的node并且在不同版本切换 12345678npm install -g n n ls //查看可用版本 n 5.8.0 //安装5.8.0版本n stable //安装最新稳定版n lastest //安装最新版n rm 0.10.1 //删除某个版本n use 0.10.21 some.js //以指定的版本来执行脚本 使用最后一条命令就可以使用指定版本的node来运行文件， 比如，etutorweb使用的node是5.8.0， 所以当前node全局版本是5.8.0，exam的使用的node版本是6.9.1，原本的前端服务的启动命令是： 1NODE_ENV=development node ./bin/devServer.js 想要使用6.9.1版本的node需要把启动命令改为： 1NODE_ENV=development n use 6.9.1 ./bin/devServer.js ok了！并且不需要更改项目中任何关于node版本的信息 n无效的解决方法有时候通过n来切换版本会出现不生效的情况，原因可能就是node的安装目录和n默认的路径和不同 查看node当前安装路径： 123which node/opt/node/bin/node #举个例子 而n的默认安装路径是/usr/local，若你的node不是在此路径下，n切换版本就不能把文件复制到改路径中，所以我们必须通过N_PREFIX变量来修改n的默认的node安装路径 编辑环境配置文件： 1vim ~/.bash_profile 将下面两行代码插入到文件末尾： 12export N_PREFIX=/opt/node #node实际安装位置export PATH=$N_PREFIX/bin:$PATH :wq保存退出 执行source使修改生效 1source ~/.bash_profile 确认一下环境变量是否生效： 12echo $N_PREFIX/opt/node 然后再重新执行切换版本的命令就ok了 123456$ n 4.4.4install : node-v4.4.4 mkdir : /opt/node/n/versions/node/4.4.4 fetch : https://nodejs.org/dist/v4.4.4/node-v4.4.4-linux-x64.tar.gz##############100.0% installed : v4.4.4 再查看当前 node 版本： 12$ node -vv4.4.4 方法2 使用ln -s命令ln -s是linux系统中一个非常重要的命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，使用方法： 1ln -s 源文件 目标文件 这里有两点要注意： 第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 这里就是利用ln -s将项目中的node文件连接到指定版本的node文件 首先找到n创建的不同版本的node安装位置（也可以不使用n安装不同版本的node），找到要使用的版本的node的启动文件： 1/usr/local/n/versions/node/6.0.0/bin/node 然后将这个文件链接到全局，不过为了全局的node已经被node5.8.0版本占用，所以连接到node6，： 1ln -s /usr/local/n/versions/node/6.9.1/bin/node /usr/local/bin/node6 也可以将对应版本的npm链接过去1ln -s /usr/local/n/versions/node/6.9.1/bin/npm /usr/local/bin/npm6 这样执行node6就对应到6.9.1的node上了 1234ubuntu@et-zhouhao:~$ node -vv5.8.0ubuntu@et-zhouhao:~$ node6 -vv6.9.1 然后将项目的启动命令中的node改为node6即可： 1NODE_ENV=development node6 ./bin/devServer.js 但是要注意，这种方法，需要在项目中将对应的node命令都改为node6，否则会报错，比如nodemon.json中的execMap对应的node要改为node6，并且只能在本机更改，不能上传到代码仓库中： 12345678910111213141516171819202122232425&#123; &quot;restartable&quot;: &quot;rs&quot;, &quot;ignore&quot;: [ &quot;.git&quot;, &quot;node_modules/**/node_modules&quot;, &quot;test&quot;, &quot;view&quot; ], &quot;verbose&quot;: true, &quot;execMap&quot;: &#123; &quot;js&quot;: &quot;node6&quot; &#125;, &quot;events&quot;: &#123; &quot;restart&quot;: &quot;echo \&quot;App restarted\&quot;&quot; &#125;, &quot;watch&quot;: [ &quot;config&quot;, &quot;server&quot;, &quot;shared&quot; ], &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot; &#125;, &quot;ext&quot;: &quot;js json&quot;&#125; 参考 https://segmentfault.com/a/1190000007567870]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>n</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础02 HTTP缓存]]></title>
    <url>%2F2017%2F10%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8002%20HTTP%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTTP缓存学习笔记。 WEB缓存分类Web缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN缓存）、浏览器缓存。 浏览器缓存也包含很多内容：HTTP缓存、indexDB、cookie、localstorage 等等。 强缓存和协商缓存强缓存：可以理解为无须验证的缓存策略。对强缓存来说，响应头中有两个字段Expires/Cache-Control来表明规则。 协商缓存：缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差异，实际上没有必要再次请求。客户端和服务器端通过某种验证机制验证当前请求资源是否可以使用缓存。 浏览器第一次请求数据之后会将数据和响应头部的缓存标识存储起来。再次请求时会带上存储的头部字段，服务器端验证是否可用。如果返回304 Not Modified，代表资源没有发生改变可以使用缓存的数据，获取新的过期时间。反之返回200就相当于重新请求了一遍资源并替换旧资源。 ==强制缓存的优先级高于协商缓存== 缓存机制 浏览器判定是否有缓存（Cache-Control） 浏览器根据expires或者max-age（max-age会覆盖expires）判定缓存是否过期，如果未过期，则使用缓存（即==强缓存==，不需要与服务器交互，返回码200 OK (from cache)） 如果已过期，则浏览器向服务器发送请求，如果上次缓存中有Last-modified和Etag字段，这次请求的请求头中会加入If-Modified-Since（对应于Last-modified）和If-None-Match（对应于Etag）。如果服务器确定内容未更改，则使用缓存（即==协商缓存==，返回码304 Not Modified），否则重新请求资源 服务器将Cache-control、Expires、Last-modified、Date、Etag等字段在响应头中返回，便于下次缓存。 缓存控制字段ExpiresExpires指缓存过期的时间，超过了这个时间点就代表资源过期。 取值是一个日期： 12Expires: new Date(&apos;2018/12/06&apos;)Expires: Wed, 21 Oct 2015 07:28:00 GMT 当设置为一个无效的日期，比如0或者-1，代表者此资源已经过期，相当于==禁止使用缓存== Expires是HTTP/1.0的标准，如果同时设置了Cache-Control中的max-age或者s-max-age，Expires会被忽略 Cache-ControlCache-Control主要有以下几个取值： max-age: 设置缓存的最大的有效时间，单位为秒，会覆盖掉expires s-maxage: 只用于共享缓存，比如CDN缓存，在私有缓存中被忽略，会覆盖max-age和expires public：响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存，并且在多用户间共享 private: 响应只作为私有的缓存，不能在用户间共享 no-cache: 表明资源不进行缓存。但是设置了no-cache之后==并不代表浏览器不缓存==，而是在使用缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间 no-store: 绝对禁止缓存，每次请求都要向服务器重新获取数据 must-revalidate: 如果页面过期，则去服务器进行获取。 这里面最后三个属性需要单独分析一下， no-store是拒绝禁止缓存，不再查看过期时间，每次都向服务器去请求新资源据 no-cache是拒接直接使用缓存，无论时间是否过期，都强制向服务器确认缓存的有效性 must-revalidate是拒绝使用过期缓存，只要时间过期，不再像服务器确认缓存有效性，而是直接请求新资源 Last-modified/If-Modified-Since==响应头部==的Last-modified，表示服务器端资源的最后修改时间 第一次请求之后，浏览器记录这个时间，再次请求时，==请求头部==带上 If-Modified-Since即为之前记录下的时间。 服务器端收到带If-Modified-Since的请求后会去和资源的最后修改时间对比。若修改过就返回最新资源，状态码200，若没有修改过则返回304。 Etag/If-None-MatchEtag是由服务端生成的一段hash字符串 第一次请求时服务器在响应头中带上ETag: abcd，之后客户端再次发送的请求中会带上If-None-Match: abcd，服务器比对ETag，返回304或200。 last-modified和Etag区别某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。 一些资源的最后修改时间改变了，但是内容没改变，使用Last-modified看不出内容没有改变。 Etag的精度比Last-modified高，属于强验证，要求资源字节级别的一致，==优先级高==。 计算ETag也是需要占用资源的，如果修改不是过于频繁，看自己的需求用Cache-Control是否可以满足。 考虑缓存的内容： CSS样式文件 JS文件 logo、图标 HTMLl文件 可以下载的内容 可缓存的内容又分为几种不同的情况： （1）不经常改变的文件 ==给max-age设置一个较大的值==，例如设置Cache-Control: max-age=31536000 标准中规定max-age的值最大不超过一年，所以设成31536000 引入的一些第三方文件、打包出来的带有hash后缀的CSS、JS文件。一般来说文件内容改变了，会更新版本号、hash值，相当于请求另一个文件。 （2）可能经常需要变动的文件 一般设置Cache-Control: no-cache max-age=0 比如入口index.html文件、文件内容改变但名称不变的资源。选择ETag或Last-Modified来做验证，在使用缓存资源之前一定会去服务器端做验证，命中缓存时会比第一种情况慢一点点，毕竟还要发请求进行通信。 不能被缓存的请求 HTTP信息头中包含Cache-Control:no-cache，Pragma:no-cache，或Cache-Control: max-age=0等告诉浏览器不用缓存的请求 Post请求无法被缓存 HTTP响应头中不包含缓存控制字段(Last-Modified/Etag/Cache-Control/Expires的请求无法被缓存 ==业务敏感的GET请求不应该被缓存== 禁止浏览器进行缓存的方法（1）在响应头中设置： Cache-control: no-store Cache-control: no-cache max-age=0 Cache-control: no-cache Expires: -1 Pragma: no-cache（与Cache-Control: no-cache效果一致，用来向后兼容只支持 HTTP/1.0 协议的缓存服务器） （2）针对HTML文件：可以在HTML文件的&lt;Meta&gt;标签中进行设置http-eqiv： 12345678&lt;meta http-equiv="Expires" content="Wed, 20 Jun 2007 22:33:00 GMT"&gt; &lt;!--设置每次访问都需要请求最新html代码--&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;meta http-equiv="Cache-Control" content="no-store"&gt;&lt;meta http-equiv="Pragma" content="no-store"&gt; http-eqiv规定了能改变服务器和用于引擎行为的编译，具体属性值参考文档。 （3）通过对文件命名增加时间戳或者Hash值，来强制浏览器重新获取新文件。 用户行为对缓存的影响（1）CTRL+F5强制刷新浏览器 浏览器不使用缓存，发送的请求头中带有Cache-Control: no-cache，明确告诉Web服务器，客户端不使用缓存。 （2）F5刷新浏览器； 如果是在地址栏输入网址然后回车，浏览器会查找内存缓存（Memory Cache）中是否有匹配。如有则使用（缓存命中）；如没有则发送网络请求 （3）在地址栏输入网址然后回车 同F5效果相同，区别是F5时在内存缓存（Memory Cache）中查找缓存是否匹配，而这里是在磁盘缓存（Disk Cache）中进行查找。 参考 浏览器缓存@掘金 Expires@MDN Pragma@MDN HTTP 缓存机制一二三@知乎]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解07 this的理解]]></title>
    <url>%2F2017%2F08%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A307%20this%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JavaScript里this非常重要，又很让我迷惑，需要反复的学习、体会。 什么是thisthis是在运行的时候绑定的，并不是在编写的时候绑定，它的上下文取决于函数调用时候的各种条件。所以this的绑定和函数声明的位置没有关系，只与函数的调用方式有关系。this是上下文的一个属性。 上下文： 当一个函数调用的时候，会创建一个活动记录（上下文），这个记录会包含函数在哪里被调用，调用的方法，传入参数的信息。this就是这个记录（上下文）的一个属性 在全局函数中，this等于window，而当函数被视为某个对象的方法调用时，this等于那个对象。 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 也就是说，只有函数才有this属性，其他的对象并没有这个属性。 this的绑定规则上面提到了，this是在函数被调用时发生的绑定，它指向什么完全取决于在哪里调用。所以说，我们的第一步就是判断函数的调用位置。 分析出了函数的调用位置之后，接下来就是要判断它是应用于哪种绑定规则，this有4种绑定规则： 默认绑定 隐式绑定 显示绑定 new绑定 四种绑定规则的优先级从上到下依次递增，默认绑定的优先级最低，new绑定的优先级最高，而bind方法就是显示绑定的一种 （1） 默认绑定 独立函数调用时，this默认指向全局 1234567var a = 2;function foo() &#123; console.log(this.a);&#125;foo(); // 2 这个例子中，函数的调用位置是全局环境，所以其指向全局即等于window（注意这是在非严格模式下），如果在严格模式下会输出undefined （2）隐式绑定 调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。 1234567891011function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象中。当然，也有一些隐式绑定的函数丢失绑定对象的问题，例如： 1234567891011121314var a = '全局中的a';function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;var s = obj.foo;s(); // 全局中的a; s只是obj.foo的一个引用，而在当s调用的时候已经没有了上下文对象，因此将会默认绑定，从而输出全局中的a （3）显示绑定 用call/apply/bind方法，我们可以在调用时强制把函数的this绑定到某个对象上。 （4）new绑定 使用new关键字调用一个构造函数时，也会发生this的绑定，具体过程： 创建一个新对象 这个对象会被执行__proto__连接 这个新对象会绑定到函数调用的this. 如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个新对象。 1234567function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); //2 一种对this的理解方式来理解一道题： 12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // objbar() // window 为什么是这样的结果呢？ 先看 bar()，相当于是这样的调用： 1bar.call(undefined) 在非严格模式下，如果传入的 context 是 context 或者 undefined，那么就默认是 window 而对象的调用 obj.foo()，相当于是这样的调用： 1obj.foo.call(obj) 结果自然就是 obj 所以可以得出这样的结论： this 就是 call 一个函数时，传入的第一个参数 如果函数调用形式不是 call 形式，请转换为 call 形式再来看 this 指向谁 call/apply和函数执行的本质当我们执行一个函数，一下集中调用方式等价： 12345678910"use strict"function fn(a, b) &#123; console.log(this)&#125;fn(1, 2)// 等价于fn.call(undefined, 1, 2)fn.apply(undefined, [1, 2]) 在严格模式下， fn里的this就是call的第一个参数，也就是undefined。 在非严格模式下， call传递的第一个参数如果是undefined或者null，那this会自动替换为Window对象 1234567891011121314151617181920var obj = &#123; fn: function(a, b) &#123; console.log(this) &#125;, child: &#123; fn2: function() &#123; console.log(this) &#125; &#125;&#125;obj.fn(1, 2)// 等价于obj.fn.call(obj, 1, 2)obj.fn.apply(obj, [1, 2])// 所以 this 是 objobj.child.fn2()// 等价于obj.child.fn2.call(obj.chid) // 所以 this 是 obj.child 练习以上就是原理，我们根据原理来发散做几道测试题 1234567891011121314151617181920212223242526var name = '饥人谷';var people = &#123; name: '若愚', sayName: function() &#123; console.log(this.name) &#125;&#125;;var sayAgain = people.sayName;function sayName() &#123; console.log(this.name)&#125;;sayName()//解析：相当于 sayName.call(undefined) //因为是非严格模式，所以 this 被替换成 Window，所以这里输出全局的 name 即 "饥人谷"people.sayName()//解析: 相当于 `people.sayName.call(people)` //所以这里输出 `people.name` 即 "若愚"sayAgain()//解析: 相当于 `sayAgain.call(undefined)` ，//因为是非严格模式，所以 this 被替换成 Window，所以这里输出全局的 name 即 "饥人谷" 第二道：（这道题有点意思） 123456789101112131415161718192021var arr = []for (var i = 0; i &lt; 3 ; i++) &#123; arr[i] = function () &#123; console.log(this) &#125;&#125;var fn = arr[0]arr[0]()// 解析: 因为函数是个特殊的对象，所以 arr 相当于 // &#123; // '0': function () &#123;&#125;, // '1': function () &#123;&#125;, // '2': function () &#123;&#125;, // length: 3// &#125;// arr[0] 相当于 arr.0 （当然这种写法不符合规范）// 所以 arr[0] 等价于 arr.0.call(arr), this 就是 arrfn()// 解析: 相当于 `fn.call(undefined)`， 所以 fn 里面的 this 是 Window bindbind的作用和call与apply类似，区别在于使用上。bind的执行的结果返回的是绑定了一个对象的新函数 先看一个使用例子： 1234567891011var obj = &#123; name: '饥人谷' &#125;;function sayName()&#123; console.log(this.name);&#125;var fn = sayName.bind(obj) ;// 注意 这里 fn 还是一个函数，功能和 sayName 一模一样，区别只在于它里面的 this 是 objfn() // 输出： '饥人谷' bind()方法创建了一个新的函数，在bind()被调用时，这个新函数的this会被设定为bind方法传入的第一个参数，其余的参数将作为新函数的参数供调用时使用。 从上面的定义来看，bind函数的功能包括： 改变原函数的this指向，绑定this 返回原函数的拷贝，并预传参数 要注意的，当使用new调用bind返回的参数时，bind绑定this失效。这是由于上面提到过的this绑定的优先级，new的优先级高于bind 箭头函数箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时,它所处的对象（宿主对象），而不是执行时的对象, 1234567891011121314151617181920let app = &#123; fn1: function(a) &#123; console.log(this) &#125; fn2 (a) &#123; consoel.log(this) &#125;, fn3: (a) = &gt; &#123; console.log(this) &#125;&#125;;app.fn1();// appapp.fn2();// appapp.fn3();// window 粗略一看，fn1、fn2、fn3貌似都一样，实际上fn1和fn2完全等价，但fn3是有区别的 以上代码等同于 123app.fn2.call(app)app.fn2.call(app)app.fn3.call(/* 它的上一级的 this */ window) 再看一道题目： 1234567891011121314151617181920const app = &#123; init() &#123; const menu = &#123; fn1: () =&gt; &#123; console.log(this); // 相当于 menu.fn1.call(/* menu 所在的环境下的 this */) // 所以 fn1 里面的 this 也就是 app。 &#125;, fn2 () &#123; console.log(this); // 相当于 menu.fn2.call(/* menu */) // 所以 fn1 里面的 this 也就是 app。 &#125; &#125;; menu.fn1(); menu.fn2() &#125;&#125;;app.init() 再看一道题目： 123456789101112131415161718192021222324252627282930313233343536373839const app = &#123; fn1() &#123; setTimeout(function () &#123; console.log(this) &#125;, 10) &#125;, fn2() &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;, 20) &#125;, fn3() &#123; setTimeout((function () &#123; console.log(this) &#125;).bind(this), 30) &#125;, fn4: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;, 40) &#125;&#125;;app.fn1();// fn.call(undefined) ，所以输出 window// windowapp.fn2();// 箭头函数没有自己的 this，借用 setTimeout 外面的 this，也就是 app// appapp.fn3();// 创建了一个新函数，这个新函数里面绑定了外面的 this，也就是 app// appapp.fn4();// 箭头函数没有 this，用 setTimeout 外面的 this// setTimeout 所在的 fn4 也是箭头函数，没有自己的 this，借用外面的 this ，也就是 window // window 易犯错误（1）this对象指向自身 123456789101112131415function foo(num) &#123; this.count++;&#125;var count = 0;foo.count = 0;for (var i = 0; i &lt; 5; i++) &#123; foo(i)&#125;console.log(foo.count);// 0console.log(count);// 5 this并不是指向foo自身的，因此当输出foo.count值的时候,其依然是0。此时foo()作为一个全局函数被调用，this指向的window 这种错误是对this根本没有理解，this代表的是函数调用时的上下文环境，而不是从字面意义的理解，表示函数自己 （2）this指向自身的作用域 12345678var a = 1;function foo() &#123; var a = 2; console.log(this.a);&#125;foo();// 1 仍然是比较初级的错误，foo里面定义的var a是函数的局部作用于。 参考 javascript中关于this的理解@博客园 别再为了this发愁了——JS中的this机制@front-Thinking 看过这篇文章以后不要再提this@知乎 this 的值到底是什么？一次说清楚@知乎 Function.prototype.bind()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node03 Package.json]]></title>
    <url>%2F2017%2F07%2F06%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode03%20Package.json%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Package.json的学习笔记。 1 概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install --production只下载dependencies节点的包 一个完整的package.json文件实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "name": "Hello World", "version": "0.0.1", "author": "张三", "description": "第一个node.js程序", "keywords": ["node.js", "javascript"], "repository": &#123; "type": "git", "url": "https://path/to/url" &#125;, "license": "MIT", "engines": &#123; "node": "0.10.x" &#125;, "bugs": &#123; "url": "http://path/to/bug", "email": "bug@example.com" &#125;, "contributors": [&#123; "name": "李四", "email": "lisi@example.com" &#125;], "scripts": &#123; "start": "node index.js" &#125;, "dependencies": &#123; "express": "latest", "mongoose": "~3.8.3", "handlebars-runtime": "~1.0.12", "express3-handlebars": "~0.5.0", "MD5": "~1.2.0" &#125;, "devDependencies": &#123; "bower": "~1.2.8", "grunt": "~0.4.1", "grunt-contrib-concat": "~0.3.0", "grunt-contrib-jshint": "~0.7.2", "grunt-contrib-uglify": "~0.2.7", "grunt-contrib-clean": "~0.5.0", "browserify": "2.36.1", "grunt-browserify": "~1.3.0", &#125;&#125; 在package.json中可以使用通配符： 12&quot;lint&quot;: &quot;jshint *.js&quot;&quot;lint&quot;: &quot;jshint **/*.js&quot; *表示任意文件名，**表示任意一层子目录 2 name字段name字段不能含有.和_，可以使用-，不能含有非URL安全的字符 3 scripts字段3.1 概述scripts字段指定了运行脚本命令时的npm命令缩写，比如start指定了运行npm run start时要执行的命令 注意的是当运行test、start、restart和stop命令时可以省略run npm脚本中需要执行多个任务时，如果是并行执行，使用&amp;符号： 1$ npm run script1.js &amp; npm run script2.js 如果是继发执行，使用&amp;&amp;符号： 1$ npm run script1.js &amp;&amp; npm run script2.js 更多的细节参考阮一峰的文章。 3.2 自定义脚本执行脚本时，npm会临时自动将目录的node_modules/.bin加入PATH变量。这意味着，可以使用node_modules中任何脚本，而无需添加node_modules/.bin前缀。比如，当前项目的依赖里面有Mocha，只要直接写mocha test就可以了。 例如执行tap命令，你可以直接写： 1"scripts": &#123;"test": "tap test/\*.js"&#125; 而不是12&quot;scripts&quot;: &#123;&quot;test&quot;: &quot;node_modules/.bin/tap test/\*.js&quot;&#125; 3.3 传递参数如果我们在执行npm run xxx操作的时候想给里面的脚本传参数可以使用-- --，如下所示： 1234"scripts": &#123; "test": "mocha test/", "test:xunit": "npm run test -- --reporter xunit" &#125; 这种设置对于组合一些高级配置的命令是非常有用的。 1234“scripts”: &#123; "lint": "jshint **.js", "lint:checkstyle": "npm run lint -- --reporter checkstyle &gt; checkstyle.xml"&#125; 3.4 生命周期钩子npm也在不同的生命周期提供了一些钩子，可以方便你在项目运行的不同时间点进行一些脚本的编写。 它的钩子分为两类：pre-和post-，前者是在脚本运行前，后者是在脚本运行后执行。所有的命令脚本都可以使用钩子（包括自定义的脚本）。 例如：运行npm run build，会按以下顺序执行： 1npm run prebuild --&gt; npm run build --&gt; npm run postbuild pre脚本和post脚本也是出口代码敏感(exit-code-sensitive)的，这意味着如果您的pre脚本以非零出口代码退出，那么NPM将立即停止，并且不运行后续脚本。 通常可以在pre脚本上执行一些准备工作，在post脚本上执行一些后续操作。 12345&#123; "clean": "rimraf ./dist &amp;&amp; mkdir dist", "prebuild": "npm run clean", "build": "cross-env NODE_ENV=production webpack" &#125; 另外，还有很多额外的生命周期钩子，可以方便使用，例如husky和pre-commit包提供了有关git的commit的生命周期钩子。 3.5 使用环境变量根据官网的介绍，在”scripts”中编写的脚本还可以方便使用一些内置变量，这些内置变量会在Node运行的时候放在process.env下，如果是shell脚本，就直接使用环境变量$…， 这对你编写一些脚本工具特别有用。 在package.json中所有的配置项都可以通过$npm_package_前缀拿到： 1"show": "echo $npm_package_name &amp;&amp; echo $npm_package_version" 如果是使用Node： 123const &#123; log &#125; = console;log(process.env.npm_package_name);log(process.env.npm_package_version); 配置参数放在npm_config_前缀的环境中（你可以通过npm config set设置一些配置变量，下面介绍config的时候会介绍)，例如： 3.6 一些常用的脚本配置引用阮老师的一些配置，可以看到配合一定的插件，npm可是实现一些很实用的功能 12345678910111213141516171819202122232425262728&#123; // 删除目录 "clean": "rimraf dist/*", // 本地搭建一个HTTP服务 "serve": "http-server -p 9090 dist/", // 打开浏览器 "open:dev": "opener http://localhost:9090", // 实时刷新 "livereload": "live-reload --port 9091 dist/", // 构建HTML文件 "build:html": "jade index.jade &gt; dist/index.html", // 只要CSS文件有变动，就重新执行构建 "watch:css": "watch 'npm run build:css' assets/styles/", // 只要HTML文件有变动，就重新执行构建 "watch:html": "watch 'npm run build:html' assets/html", // 部署到Amazon S3 "deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/", // 构建favicon "build:favicon": "node scripts/favicon.js",&#125; 3.7 内置脚本npm自带了数十个内置命令，这些命令都可以直接通过npm执行，除了instal，还有很多实用的 npm -l 列举所有npm自带的命令简介，然后通过npm help可以详细查看某个命令 npm search 快速查询npm中的相关包（和我们去npm官网查是一样的） npm root 查看全局的node_modules目录 npm audit fix 这个命令很实用，自动扫描您的项目漏洞，并自动安装任何兼容更新到脆弱的依赖 npm restart 重新启动模块 npm prune 移除当前不在package.json中但是存在node_modules中的依赖 npm repo 浏览器端打开项目地址（GitHub），省去打开浏览器查找的操作！ npm docs 查看项目文档，同上 npm home 在浏览器端查看项目（项目主页），同上 npm search 查找包含该字符串的依赖包 npm view [field][--json] 列出依赖信息，包括历史版本，可以指定field来查看某个具体信息，比如（versions) 可以添加–json参数输出全部结果 4 npxnpm v5.2.0之后还引入了npx，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。（在node_modules中，所有可执行文件，也就是package中带bin的，都会放在node_modules/.bin中） 举例：使用create-react-app创建一个react项目，老方法： 123npm install -g create-react-app // 实际就是把package.json中的bin命令连接到了/usr/local/bin中create-react-app my-app npx方式： 12npx create-react-app my-app // 执行本`node_modules/.bin`中的对应命令 这条命令会临时安装create-react-app包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。 npx会帮你执行依赖包里的二进制文件。 举例来说，之前我们可能会写这样的命令： 1npm i -D webpack./node_modules/.bin/webpack -v 如果你对bash比较熟，可能会写成这样： 12npm i -D webpack**npm bin**/webpack -v 有了npx，你只需要这样： 12npm i -D webpacknpx webpack -v npx会自动查找当前依赖包中的可执行文件，如果找不到，就会去PATH里找。如果依然找不到，就会帮你安装！ npx甚至支持运行远程仓库的可执行文件： 1npx github:piuccio/cowsay hello 再比如npx http-server可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些） 12345678910111213npx http-servernpx: 1 安装成功，用时 3.032 秒Path must be a string. Received undefinednpx: 25 安装成功，用时 5.241 秒C:\Users\zhouhao1\AppData\Roaming\npm-cache\_npx\45232\node_modules\http-server\bin\http-serverStarting up http-server, serving ./Available on: http://10.234.98.23:8080 http://192.168.56.1:8080 http://192.168.99.1:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server 指定node版本来运行npm scripts： 1npx -p node@8 npm run build npx的优点： 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 可以执行依赖包中的命令，安装完成自动运行。 自动加载node_modules中依赖包，不用指定$PATH。 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 5 dependencies字段和devDependencies字段5.1 使用dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 123456&#123; "devDependencies": &#123; "browserify": "~13.0.0", "karma-browserify": "~5.0.1" &#125;&#125; 在单独安装某个模块时： 使用--save表示将该模块写入dependencies属性。缩写为-S 使用--save-dve表示将该模块写入devDependencies属性。缩写为-D 从命令行参数字面上，我们就能看出dependencies、devDependencies的区别： dependencies表示我们要在生产环境下使用该依赖， devDependencies则表示我们仅在开发环境使用该依赖。 举个例子，我要用Webpack构建代码，所以在开发环节，它是必需的，但对普通用户来说，它是不必要的，所以安装Wbpack时，我要执行： 1npm install webpack --save-dev 5.2 版本号版本号 major.minor.patch ：其中： patch：修复bug，兼容老版本， minor：新增功能，兼容老版本 major：新的架构调整，不兼容老版本 常用的主要有以下几种： 指定版本：比如1.2.2 波浪号（~）：表示安装1.2.x的最新版本 插入号（^）：表示安装1.x.x的最新版本，注意如果大版本号是0，则与波浪号使用相同，例如^0.2.3只会安装0.2.x的版本，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本 推荐的做法：不锁版本，用 ^ 引入。 在package.json中确定版本号，只能锁定本身依赖的包，但是包自身所依赖的包没有办法锁定，解决方法就是npm shrinkwrap或者npm 5.0版本以后增加的lock功能： 如果你使用 lock 机制，则应该将 package-lock.json 提交到 repo 中。比如 Vue 采取了该策略。 如果你不使用 lock 机制，则应该加入 .npmrc 文件，内容为package-lock=false ，并提交到 repo 中。比如 ESLint 采取了该策略。 如果你需要在程序中做版本匹配，手写是不是很麻烦，其实npm提供了一个现成的匹配版本号的工具 5.3 区别在做项目的时候，两者可以认为没有实质的区别，但是在发布npm包的时候二者区别很大：dependencies下的模块会作为依赖，一起被下载；devDependencies下面的模块就不会自动下载了 一般来说，开发时依赖的东西需要安装在devDependencies字段中，比如转义用的babel，打包用的webpack等，如果发布后还需要使用的则要安装在dependencies，比如vue、vue-router等 （2019.10.16） 今天发现之前的理解有些片面，这二者在install的时候有差别，默认的npm install会同时安装devDependencies和dependencies的依赖，但是如果是发布到服务器上，依赖环境也会安装在服务器，那么可以执行npm install -production，那么只会安装dependencies下的依赖，install的速度会更快。 但是在Webpack打包build文件时，并不会因为模块处于devDependencies就不会打包，也不会因为模块处于dependencies就一定打包，是否打包决定于是否在代码中引入import。只要import了，无论模块写在哪里，都会被打包。但是如果import之后，模块并没有使用，模块也会被打包，这就是Tree Shaking的作用，移除引入后但是没有使用到的代码。 6 其他字段6.1 main字段main字段指定了加载的入口文件，require(&#39;moduleName&#39;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js 6.2 cinfig字段用于添加命令行的环境变量，例如： 12345&#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 然后，在server.js脚本就可以引用config字段的值。 123http .createServer(...) .listen(process.env.npm_package_config_port) 用户可以改变这个值。 1$ npm config set foo:port 80 6.3 keywords和description字段description是字符串，keywords是字符串数组，简单地说，这两个东东是npm搜索系统中的搜索条件，所以。如果你试图发布的是一个开源插件，那么这两个字段你应该重视 6.4 license 字段指定的项目的许可证，它告诉他人他们是否有权利使用你的包，以及，在使用你的包的时候他们应该受到怎样的限制 6.5 author字段可以是一个字符串，也可以是一个对象。如果传入对象，要包含三个属性： name属性(必填) email属性（选填） URL属性（选填） 6.5 engines字段指明了该模块运行的平台，比如Node的某个版本或者浏览器 1&#123; "engines" : &#123; "node" : "&gt;=0.10.3 &lt;0.12" &#125; &#125; 也可以指定适用的npm版本。 1&#123; "engines" : &#123; "npm" : "~1.0.20" &#125; &#125; 6.6 os字段指明了用户执行的操作系统： 1&#123; "os": [ "darwin", "linux", "!win32" ] &#125; 7 安装非NPM上发布的包通常，我们安装的包都是在npm官网上，通过版本标明。但是，如果我想使用没上传到npm上的包怎么办？其实你可以直接加网址或git url。 git url可以是以下形式： 1234git://github.com/user/project.git#commit-ishgit+ssh://user@hostname:project.git#commit-ishgit+http://user@hostname/project/blah.git#commit-ishgit+https://user@hostname/project/blah.git#commit-ish 其中，commit-ish可以是任意的tag，branch，sha。 8 更新我们知道npm自带的npm update可以根据pacaage.json的版本号更新包，但是你==需要手动的更新版本号==，因此出现了升级插件npm-check-updates，可以自动搜索当前包的更新情况，并且修改pacage.json 1$ npm install -g npm-check-updates ncu是npm-check-updates的缩写命令 12345$ ncu -v # 查询版本号$ ncu # 直接输入ncu可以查看所有需要更新的包 12345678$ ncu -u # 更新所有的包，并修改package.json文件$ ncu -f regex # 只匹配特定的正则格式的包$ ncu -g # 更新全局包 参考 http://javascript.ruanyifeng.com/nodejs/packagejson.html http://www.cnblogs.com/penghuwan/p/7134046.html http://guxinyan.github.io/2017/11/02/%E5%8C%85%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8devDependencies%E8%BF%98%E6%98%AFdependencies/ https://blog.zfanw.com/difference-between-dependencies-and-devdependencies/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Package.json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题10 Fetch API]]></title>
    <url>%2F2017%2F05%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9810%20Fetch%20API%2F</url>
    <content type="text"><![CDATA[Fetch是基于Promise设计的，是属于window对象的方法，可以用来替代Ajax。旧浏览器不支持Promise，需要使用Polyfill进行处理 。 兼容性 目前浏览器对Fetch的原生的支持率并不高，幸运的是，引入下面这些polyfill后可以完美支持IE8+ ： 由于IE8是ES3，需要引入ES5的polyfill: es5-shim, es5-sham 引入Promise的polyfill: es6-promise 引入Fetch探测库：fetch-detector 引入Fetch的polyfill: fetch-ie8 可选：如果你还使用了Jsonp，引入fetch-jsonp 如果在Node使用，还需要安装node-fetch模块。 使用一个基本的Fetch请求如下： 1234567fetch('http://example.com/movies.json') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); &#125;); 也可以通过Request构造器函数创建一个新的请求对象，这也是建议标准的一部分。第一个参数是请求的URL，第二个参数是一个选项对象，用于配置请求。请求对象一旦创建了，便可以将所创建的对象传递给fetch()方法，用于替代默认的URL字符串。示例代码如下： 1234567const req = new Request(URL, &#123;method: 'GET', cache: 'reload'&#125;);fetch(req).then(function(response) &#123; return response.json();&#125;).then(function(json) &#123; insertPhotos(json);&#125;); 上面的代码中指明了请求使用的方法为GET，并且指定不缓存响应的结果。 参数fetch接受两个参数： 第一个参数是请求的目标URL 第二个参数是一个配置项对象，包括所有对请求的设置，可选参数有method、headers、mode、credentials、cache等 关于参数的详细说明可以参考MDN的文档。 返回值Fetch的返回值是一个Promise对象，当这个Promise对象resolve时，在then方法中获得的是一个Resopnse对象。 Response对象中包含了当次请求的相应数据，需要调用对应的方法将Response对象转换为相应格式的数据，最常用的就是json()方法，它将返回一个被解析为JSON格式的Promise对象，并将Response对象设置为已读。 Response对象常用属性包括headers、ok、redirected、status、statusText、type、url等，常用的方法包括clone()、error()、formData()、text()等，具体的说明参考MDN的文档。 与 Ajax 的区别Ajax是基于XMLHttpRequest对象来发送网络请求、获取数据的。 Fetch是基于Promise设计的，是属于window对象的方法，可以用来替代Ajax。 使用原生的Ajax发送一个JSON请求一般是这样： 12345678910111213141516var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.responseType = 'json';xhr.send(null);xhr.onredaystatechange = function() &#123; if (xhr.readystate === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.response) &#125; &#125;&#125;;xhr.onerror = function() &#123; console.log("Oops, error");&#125;; 使用Fetch来进行同样的操作： 123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e)) 可以使用Async/Await来实现“ 12345678try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125;// 注：这段代码如果想运行，外面需要包一个 async function 总结起来，Fetch与Ajax的主要的不同点在于： （1）Fetch基于Promise对象，Ajax基于XMLHttpRequest对象 （2）当收到代表错误的HTTP状态码时(4xx/5xx)，从fetch()返回的Promise不会被标记为reject，而是标记为resolve（但是会将resolve的返回值的ok属性标记为false），仅当网络故障时或请求被阻止，才会标记为reject； 来看下面的Fetch请求： 123456789101112fetch('http://127.0.0.1:7001/getTitle') .then(v =&gt; console.log('resolve, v.ok = ', v.ok)) .catch(e =&gt; console.log('reject', e)); // 当服务器返回结果正常（200）时，返回结果：// resolve, v.ok = true// 当服务器返回结果异常（500）时，返回结果：// resolve, v.ok = false// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// reject TypeError: Failed to fetch 当使用原生的Ajax时： 123456789101112131415161718192021222324252627const xhr = new XMLHttpRequest();xhr.open('GET', 'http://127.0.0.1:7001/getTitle');xhr.send();xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log('success', xhr.status); &#125; else &#123; console.log('error', xhr.status); &#125; &#125;&#125;;xhr.onerror = (e) =&gt; &#123; console.log('onerror', e.type);&#125;// 当服务器返回结果正常（200）时，返回结果：// success 200// 当服务器返回结果异常（500）时，返回结果：// error 500// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// error 0// nerror error 现在使用比较多的axios也是基于原生的XMLHttpRequest对象进行的封装，它可以在Node中使用（Fetch不行），它的行为比起Fetch更加合理，当收到代表错误的HTTP状态码时(4xx/5xx)，从axios()返回的Promise会被标记为reject， 1234567891011121314151617axios.get('http://127.0.0.1:7001/getTitle') .then(v =&gt; console.log('resolve', v.data)) .catch(e =&gt; console.log('reject', e));// 当服务器返回结果正常（200）时，返回结果：// resolve &#123;title: "OK"&#125;// 当服务器返回结果异常（500）时，返回结果：// reject Error: Request failed with status code 500// at createError (createError.js:17)// at settle (settle.js:19)// at XMLHttpRequest.handleLoad (xhr.js:78)// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// reject Error: Network Error// at createError (createError.js:17)// at XMLHttpRequest.handleError (xhr.js:87) （3）默认情况下，Fetch不会从服务端发送或接受任何cookie，要发送cookie，必须设置credentials选项。而AJAX请求默认自动带上同源的cookie，不会带上不同源的cookie。可以通过前端设置withCredentials为true、后端设置Header的方式来让Ajax带上不同源的Cookie fetch发送Cookie为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: &#39;include&#39;添加到传递给fetch()方法的init对象。 123fetch('https://example.com', &#123; credentials: 'include' &#125;) 果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加credentials: &#39;same-origin&#39;。要改为确保浏览器不在请求中包含凭据，请使用credentials: &#39;omit&#39;。 例子上传JSON数据123456789101112const url = 'https://example.com/profile';const data = &#123; username: 'example' &#125;;fetch(url, &#123; method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;)&#125;).then(res =&gt; res.json()) .catch(error =&gt; console.error('Error:', error)) .then(response =&gt; console.log('Success:', response)); 上传文件可以通过HTML&lt;input type=&quot;file&quot; /&gt;元素，FormData()和fetch()上传文件。 123456789101112var formData = new FormData();var fileField = document.querySelector("input[type='file']");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()) .catch(error =&gt; console.error('Error:', error)) .then(response =&gt; console.log('Success:', response)); 获取图片下面这个例子，是在React中，使用fetch获取图片，并将图片转换为Blob对象，赋给&lt;img&gt;的src，在页面上展示图片： 1234567891011121314151617import React, &#123; useState, useEffect, useRef &#125; from &apos;react&apos;;import fetch2 from &apos;./fetch2.png&apos;;export default function Statistics() &#123; const [src, setSrc] = useState(&apos;&apos;); useEffect(() =&gt; &#123; fetch(&apos;fetch2.png&apos;).then(v =&gt; v.blob()).then(v =&gt; &#123; setSrc(URL.createObjectURL(v)); &#125;); &#125;, [param]); return ( &lt;div className=&#123;styles.container&#125;&gt; &lt;img src=&#123;&#125; /&gt; &lt;/div&gt; );&#125; 使用Fetch需要注意的问题 考虑Fetch兼容性（IE浏览器不支持Fetch） 考虑环境对Promise的支持情况 如果在Node中使用需要安装node-fetch 服务端返回错误时（4xx/5xx），Fetch不会reject，可以通过返回的Response对象的OK属性判断 默认情况下Fetch不会接受或者发送Cookie，需要使用credentials选项开启 参考 使用Fetch@MDN fetch API@DWB 传统 Ajax 已死，Fetch 永生@segmentfault WorkerOrGlobalScope.fetch()@MDN Response@MDN 【误】Ajax不会自动带上cookie/利用withCreadentials带上cookie@知乎 XMLHttpRequest.withCredentials@MDN fetch和ajax的区别@segmentfault]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Fetch</tag>
        <tag>Axios</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router01 入门]]></title>
    <url>%2F2017%2F05%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React-Router入门学习笔记。 React-RouterReact-Router是官方插件，文档在这里。 引入安装：(4.0版本后引入的是react-router-dom，而不是原本的react-router，使用方式也有了大的变化，和阮一峰的教程以及慕课网的视频教程都不同，这里按照新版本的API写代码） 1npm install --save react-router-dom 新建一个root.js，作为入口文件，渲染到文档中，原来的index.js作为其中一个组件嵌入，需要在webpack.config.js中入口文件的更改： 12345module.exports = &#123; context: __dirname + '/app', entry: "./js/root.js", // ... &#125; 如果使用了 引入需要的方法： 1import &#123; BrowserRouter, Route, Link &#125; from 'react-router-dom'; &lt;link&gt;连接不使用a标签，使用&lt;link&gt;标签 12345&lt;ul&gt; &lt;li&gt;&lt;Link to="/"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/details"&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/list"&gt;列表页&lt;/Link&gt;&lt;/li&gt;&lt;/ul&gt; &lt;BrowserRouter&gt;Hash history不支持location.key和location.state。另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用BrowserRouter，此API不再作多余介绍。 BrowserRouter，里面的元素是在此基础上跳转的页面 12345678910111213141516171819202122232425262728import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;BrowserRouter, Route, Link&#125; from &apos;react-router-dom&apos;;import Index from &apos;./index&apos;import ComponentDetails from &apos;./components/details&apos;;import ComponentList from &apos;./components/list&apos;;import ComponentHeader from &apos;./components/header&apos;;export default class Root extends React.Component&#123; render()&#123; return( &lt;BrowserRouter basename=&quot;/a/&quot;&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/details&quot;&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/home&quot; component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/details&quot; component=&#123;ComponentDetails&#125; /&gt; &lt;Route path=&quot;/list&quot; component=&#123;ComponentList&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ) &#125;&#125;ReactDOM.render(&lt;Root /&gt;, document.getElementById(&apos;example&apos;)); &lt;Switch&gt;当进行地址匹配的时候，如果有多个匹配项值匹配首个匹配的对象（需要增加exact属性） 123456789101112131415161718export default class Root extends React.Component&#123; render()&#123; return( &lt;BrowserRouter basename=&quot;/a/&quot;&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/details&quot;&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/details&quot; component=&#123;ComponentDetails&#125; /&gt; &lt;Route path=&quot;/list&quot; component=&#123;ComponentList&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ) &#125;&#125; 此时点击首页，会将所有三个&lt;Route&gt;全部渲染，但是使用&lt;Switch&gt;只会渲染首个匹配对象 可以用这个组件实现前端页面404的功能： 123456789101112131415161718192021222324252627import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &apos;react-router-dom&apos;const NoMatch = () =&gt; (&lt;div&gt;&lt;h1&gt;Sorry, 404&lt;/h1&gt;&lt;/div&gt;);// 路由设置export default class RouterContainer extends React.Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div className=&quot;container&quot;&gt; &lt;nav&gt; &lt;div className=&quot;head&quot;&gt; &lt;Link to=&quot;/&quot; /&gt; &lt;/div&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;App&#125; /&gt; &lt;Route path=&quot;/demo1/&quot; component=&#123;Demo1&#125; /&gt; &lt;Route path=&quot;/demo2/&quot; component=&#123;Demo2&#125; /&gt; &lt;Route path=&quot;/demo3/&quot; component=&#123;Demo3&#125; /&gt; &lt;Route component=&#123;NoMatch&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125; 参数传递传递参数在&lt;Route&gt;中的path参数后面用:+paramName，在组件中使用this.props.match.params.paramName来获取传入的值 路由： 123456789101112&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/home"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/details/123"&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/list"&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path="/home" component=&#123;Index&#125; /&gt; &lt;Route path="/details/:id" component=&#123;ComponentDetails&#125; /&gt; &lt;Route path="/list" component=&#123;ComponentList&#125; /&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 页面： 1&lt;div&gt;这是详情页details idd &#123;this.props.match.params.id&#125;&lt;/div&gt; Koa-Router之前对二者的理解存在着偏差 React-Router是前端路由，而Koa-Router控制的是后端路由 React是单页面应用，也就是在单一一个页面上实现多个组件、布局的切换，React-Router实现的就是在前端页面上根据url的切换对应不同的组件 实现单页面应用的前提是服务器返回单页面应用的根地址对应的页面，也就是需要Koa-Router首先配置好url对应的地址 比如，我想要实现www.test.com这个单页面应用，并配置了前端路由： 123456&lt;Router history=&#123; browserHistory &#125; key=&#123; Date.now() &#125;&gt; &lt;Route path="/" components=&#123;keyPointPage&#125;&gt; &lt;IndexRoute component=&#123;home&#125; /&gt; &lt;Route path="page1" components=&#123;page1&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 当我访问www.test.com对应的是IndexRoute设置的home组件，当我访www.test.com/page1加载page1组件 但是前提是要服务器首先要对www.test.com这个地址的访问请求给出回应，也就是需要通过Koa-Router配置地址，并且对www.test.co后面的访问进行配置，都需要访问同一个view模版文件（单页面） 123456789// 对根地址配置router.get('/', async(ctx) =&gt; &#123; await dealPageRequest(ctx, 'keypoint_react');&#125;);// 对根地址对应的其他地址指向同一个viewrouter.get('/*', async(ctx) =&gt; &#123; await dealPageRequest(ctx, 'keypoint_react');&#125;); 坑 如果要在&lt;Link&gt;标签中使用target=&quot;_blank&quot;属性时只能使用HashRouter，不知道为什么BrowserRouter不行 根目录如果是/，一定要在&lt;Route&gt;加上exact属性，要不然都会进行匹配。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node02 NPM]]></title>
    <url>%2F2017%2F05%2F07%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode02%20NPM%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。 NPM（node package manager）是NodeJS的包管理器，用于Node插件管理（包括安装、卸载、管理依赖等），npm已经在NodeJS安装的时候顺带装好了 安装插件123npm install &lt;name&gt; [-g] [--save-dev]；npm install gulp-less --save-dev 说明： （1）通过-g来控制是否全局安装： 全局安装。将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录；全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； （2）通过--save-dev控制插件是记录到package.json，以及记录到什么位置 --save（-S）指明将插件信息记录到package.json的dependencies字段 --save-dev（-D）指明将插件信息记录到package.json的devDependencies字段， devDependencies里面的插件只用于开发环境，不用于生产环境，而dependencies是需要发布到生产环境的。 package.json为什么要保存至package.json？因为Node插件包相对来说非常庞大，将配置信息写入package.json并更新devDependencies值，以表明项目需要依赖该插件 dependencies的值可以向其他参与项目的人指明项目在开发环境和生产环境中的Bode模块依懒关，其他开发者对应下载即可 卸载插件1npm uninstall &lt;name&gt; [-g] [--save-dev] PS：不要直接删除本地插件包 删除指定插件： 1npm uninstall gulp-less gulp-uglify gulp-concat 删除全部插件需要借助rimraf： 12npm install rimraf -grimraf node_modules 更新插件12345# 更新指定插件npm update &lt;name&gt; [-g] [--save-dev]# 更新全部插件npm update [--save-dev] 当前目录已安装模块；12345# 查看所有弄快npm list# 查看一级模块npm list –depth 1 cnpm因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以淘宝团队提供了一个完整npmjs.org镜像，可以用此代替官方版本，同步频率目前为10分钟一次以保证尽量与官方服务同步。 安装： 1npm install cnpm -g --registry=https://registry.npm.taobao.org 注意：安装完后最好查看其版本号cnpm-v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm； 12# 使用cnpm install express 直接使用npm注册淘宝镜像12345678npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/mirrors/node# 配置后可通过下面方式来验证是否成功npm config get registry# 或npm info express 推荐使用npm安装插件，但是安装源改为淘宝 删除淘宝镜像1234567npm config delete registrynpm config delete disturl# 或者 npm config edit # 在打开的文件中找到淘宝那两行，删除 npm本身的升级用管理员权限打开PowerShell，然后执行以下命令： 123Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Forcenpm install -g npm-windows-upgradenpm-windows-upgrade npxnpm从5.2版开始，增加了npx命令 npx有三个作用： （1）Npx会到node_modules/.bin路径和环境变量$PATH里调用项目内部安装的模块，比如项目内安装了Mocha，如果想要在命令行中调用 12345# 在项目根目录下调用node-modules/.bin/mocha --version# 使用npxnpx mocha --version （2）避免安装全局模块，npx会将本地不存在的模块下载到临时目录，使用后再删除 12345678910npx create-react-app my-react-app# 可以指定版本npx uglify-js@3.1.0 main.js -o ./dist/main.js# 使用--no-install强制使用本地模块npx --no-install http-server# 使用--ignore-existing强制使用远程模块npx --ignore-existing create-react-app my-react-app （3）利用下载模块的特点还可以指定某个版本的Node运行脚本 1npx node@0.12.8 -v 更详细可以参考阮一峰的网络日志。 参考 国内优秀npm镜像推荐及使用]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题09 Moment.js和date-fns]]></title>
    <url>%2F2017%2F04%2F26%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9809%20Moment.js%E5%92%8Cdate-fns%2F</url>
    <content type="text"><![CDATA[介绍JavaScript的两个日期处理工具库Moment.js和date-fns。 Moment.jsMoment.js是一个（轻量级）的Javascript日期处理类库，使用它可以轻松解决前端开发中遇到的种种日期时间问题。 Moment.js不依赖任何第三方库，支持字符串、Date、时间戳以及数组等格式，可以格式化日期时间，计算相对时间，获取特定时间后的日期时间等等。 支持中文在内的多种语言。 格式化日期1234moment().format('MMMM Do YYYY, h:mm:ss a'); // 四月 26日 2017, 12:12:53 中午moment().format('dddd'); // 星期三moment().format("MMM Do YY"); // 4月 26日 17moment().format('YYYY [escaped] YYYY'); // 2017 escaped 2017 相对时间12345moment("20111031", "YYYYMMDD").fromNow(); // 5 年前moment("20120620", "YYYYMMDD").fromNow(); // 5 年前moment().startOf('day').fromNow(); // 12 小时前moment().endOf('day').fromNow(); // 12 小时内moment().startOf('hour').fromNow(); // 14 分钟前 日历时间12345678moment().subtract(10, 'days').calendar(); // 2017年4月16日moment().subtract(6, 'days').calendar(); // 上周四中午12点14moment().subtract(3, 'days').calendar(); // 上周日中午12点14moment().subtract(1, 'days').calendar(); // 昨天中午12点14分moment().calendar(); // 今天中午12点14分moment().add(1, 'days').calendar(); // 明天中午12点14分moment().add(3, 'days').calendar(); // 本周六中午12点14moment().add(10, 'days').calendar(); // 2017年5月6日 Moment.js提供了丰富的说明文档，使用它还可以创建日历项目等复杂的日期时间应用。日常开发中最常用的是格式化时间，下面是常用的格式： date-fnsdate-fns是另外一个比热门的JavaScript日期处理工具库，越来越多的人用它来替换Moment.js。它一样提供了大量的函数来操作日期。 安装： 1npm install date-fns --save date-fns是使用纯函数构建的，并且可以再不改变传递日期实例的情况下保持不变。并且由于date-fns里面每一个方法都是一个文件，所以可以非常方便的只引入需要的部分，这相比于Moment.js可以更方便的降低打包体积。 123const moment = require('moment');const format1 = moment.format;const format2 = require('date-fns/format'); 具体使用方法参考官方文档。 比较Moment.js存在一些问题，导致了date-fns越来越流行，Moment.js存在的一些问题时hi： Moment.js是可变的 具有复杂的面向对象的API 复杂的API带来大量性能开销 使用Webpack将其打包在构建结果中，会导致构建结果尺寸增加很多 那么date-fns是如何解决这些问题呢？一个一个来看： （1）Moment.js是可变的 Moment.js中的日期是可变的，这可能会导致不可预料的行为，什么意思呢： 12345678910111213const moment = require('moment');const now = moment(new Date());console.log('now: ', now.format());// now: 2019-05-09T18:08:40+08:00now.add(3, 'days');console.log('now: ', now.format());// now: 2019-05-12T18:08:40+08:00now.add(3, 'days');console.log('now: ', now.format());// now: 2019-05-15T18:08:40+08:00 Momment.js生成的moment对象是可变的，now在一开始代表5月9日，加3天后变为了5月12日，再加三天变为了5月15日。 这是因为Moment.js是面向对象的原因，它产生的是一个可变的对象。 而date-fns是纯函数式，它更加纯净简洁，它产生的对象是不可变的，每次调用都会返回新的对象： 12345678910111213141516const addDays = require('date-fns/add_days');const now = new Date();console.log('now: ', now);// now: 2019-05-09T10:10:30.079Zconst day1 = addDays(now, 3);console.log('day1: ', day1);// day1: 2019-05-12T10:10:30.079Zconsole.log('now: ', now);// now: 2019-05-09T10:10:30.079Zconst day2 = addDays(now, 3);console.log('day2: ', day2);// day2: 2019-05-12T10:10:30.079Zconsole.log('now: ', now);// now: 2019-05-09T10:10:30.079Z 在加3天后，产生新的日期，但是原来的now对象一直都是5月9日，是不变的。 （2）具有复杂的面向对象的API和复杂的API带来大量性能开销 相对来说，date-fns作为纯函数，API可能会稍微更简洁一下，这个还是看官网的文档吧。 （3）使用Webpack将其打包在构建结果中，会导致构建结果尺寸增加很多 Moment加载时默认会将所有方法和所有的语言locale文件打包，打包出体积Gzip压缩后可能也要60kb，如果需要按需加载需要Webpack的配合，在Webpack的配置文件中使用自带的IgnorePlugin插件来过滤掉所有的locale文件： 12345678const webpack = require('webpack');module.exports = &#123; //... plugins: [ // Ignore all locale files of moment.js new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/), ],&#125;; 当需要语言包时手动引入： 1234const moment = require('moment');require('moment/locale/ja'); moment.locale('ja'); 但是这样只能排除不必要的locale文件，但是没使用的方法还是会全部引入的。 而date-fns每个方法、每个locale都是一个单独的文件： 在使用的时候完全做到了按需引入： 1234567891011const addDays = require('date-fns/add_days');const format = require('date-fns/format');const eoLocale = require('date-fns/locale/eo');const result = format( addDays(new Date(2014, 6, 2), 3), 'Do [de] MMMM YYYY', &#123;locale: eoLocale&#125;);console.log(result);// 5-a de julio 2014 在Webpack构建的时候，自动就可以做到按需引入，非常方便。 参考 Moment.js 文档@Moment date-fns文档@date-fns date-fns —— 轻量级的 JavaScript 日期库@可译网 在webpack打包时精简moment.js@CSDN]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Moment</tag>
        <tag>date-fns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解03 非构造函数的继承]]></title>
    <url>%2F2017%2F04%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A303%20%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JavaScript中非构造函数的继承 什么是”非构造函数”的继承？让一个对象去继承一个不相关对象，由于这两个对象都是普通对象，不是构造函数，所以无法使用构造函数方法实现继承。 object()方法JSON格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。 123456function object(o) &#123; function F() &#123;&#125; F.prototype = o; // child.__proto__ = F.prototype = o return new F(); &#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。 使用的时候，第一步先在父对象的基础上，生成子对象： 1var Doctor = object(Chinese); 实现了子对象对父对象的继承。 ES6中的Object.create方法的原理就是这样。 Object.create()方法Object.create是直接通过原型，而非模拟类，来实现普通对象（非构造函数）之间的继承。ES6之后这也是最常用的实现普通对象继承的方法 1let child = Object.create(father, descriptors); 这样就可以实现child与father的继承，继承关系是通过child.__proto__ = father实现的，再通过描述符对象descriptors添加属于自己的属性 实际上，可以把上面object()方法看做Object.create方法的简易Pollyfill Object.setPrototypeOf()方法Object.setPrototypeOf()和Object.create都是更改原型链的手段，Object.getPrototypeOf(a)是用来获取对象的__proto__属性 Object.setPrototypeOf(a, b)实现的是a.__proto__ = b，最常用来避免直接操作对象的非标属性__proto__ 1Object.setPrototypeOf(child, father) 注意的是，更改__proto__性能很差，应该避免设置一个对象的[[Prototype]]，应该使用 Object.create()来创建你想要的[[Prototype]]的新对象 浅拷贝除了prototype链的思路之外，可以通过对象浅拷贝的方法实现继承： 12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c; &#125; 浅拷贝的问题就是如果父对象的属性等于数组或另一个对象，那么子对象获得的就是指向这个数组或对象的指针，因此存在父对象被篡改的可能。 深拷贝深拷贝可以实现真正意义上的数组和对象的拷贝，原理是递归调用浅拷贝。 123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125; 之所以不用判断p的类型是对象还是数组，原因出在for...in上，会遍历p的原型上的属性，具有所有数组原型属性的对象，就是数组了。 ==一次面试的时候，发现下面的这个函数有些问题，之前没有注意到== 在进行这个判断typeof p[i] === &#39;object&#39;时，对JSON/Math/RegExp对象是有问题的，问题还是出现在了对象判断上，还是使用Object.prototype.toString.call判断更准确 1234567891011121314151617181920212223function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; const type = Object.prototype.toString.call(p[i]).match(/\s(.+)\]/)[1].toLowerCase(); switch (type) &#123; case 'array': &#123; c[i] = []; deepCopy(p[i], c[i]); break; &#125; case 'object': &#123; c[i] = &#123;&#125;; deepCopy(p[i], c[i]); break; &#125; default: &#123; c[i] = p[i]; break; &#125; &#125; &#125; return c;&#125; jQuery的extend方法第一个参数默认为false，此时实现的是浅拷贝，如果为true则实现的其实就是上述的深拷贝。 1jQuery.extend([deep], target, object1[, objectN]) 参考 Javascript面向对象编程（三）：非构造函数的继承@阮一峰的网络日志 Object.create()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node05 常用模块]]></title>
    <url>%2F2017%2F04%2F19%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode05%20%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。常用模块的介绍（未完成） 1 http模块略 2 url模块用来生成和解析URL，使用前需要通过require加载 2.1 url.resolve(base, path)用来生成URL，第一个参数是基准URL，其余参数是根据基准URL，生成对应的位置 12url.resolve('/one/two/three', 'four')// '/one/two/four' 3 querystring模块用来解析查询字符串，将一个查询字符串解析为JavaScript对象 1234var str = 'foo=bar&amp;abc=xyz&amp;abc=123';querystring.parse(str)// &#123; foo: 'bar', abc: [ 'xyz', '123' ] &#125; 一共接受四个参数 1querystring.parse(str[, sep[, eq[, options]]]) str是需要解析的查询字符串 seq是多个键值对之间的分隔符，默认为&amp; eq是键名与键值之间的分隔符，默认为= options是配置对象，有两个属性，decodeURIComponent属性是一个函数，用来将编码后面的字符串还原，默认是querystring.unescape()，maxKeys属性指定最多解析多少个属性，默认是1000 完整调用形式如下： 123456querystring.parse( 'w=%D6%D0%CE%C4&amp;foo=bar', null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) 参考 url模块@JavaScript标准参考教程 querystring模块@JavaScript标准参考教程]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URL</tag>
        <tag>querystring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node09 swig模版引擎]]></title>
    <url>%2F2017%2F04%2F04%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode09%20swig%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Swig模版引擎学习笔记。 简介swig 是node端的一个优秀简洁的模板引擎，类似Python模板引擎Jinja，目前不仅在node端较为通用，相对于jade、ejs优秀，而且在浏览器端也可以很好地运行。 这是官方文档 。 语法swig的变量123&#123;&#123; foo.bar &#125;&#125;&#123;&#123; foo[&apos;bar&apos;] &#125;&#125;//如果变量未定义，输出空字符。 swig的标签extends使当前模板继承父模板，必须在文件最前 123&#123;% exdtends file %&#125;// 参数file：父模板相对模板root的相对路径 block定义一个块，使之可以被继承的模板重写，或者重写父模板的同名块 12&#123;% block blockName %&#125;something can be entended and modified...&#123;% endblcok %&#125;// 参数name：块的名字，必须以字母数字下划线开头 parent将父模板中同名块的内容注入当前块中 12345&#123;% extends &quot;./foo.html&quot; %&#125;&#123;% block content %&#125; My content. &#123;% parent %&#125;&#123;% endblock %&#125; include包含一个模板到当前位置，这个模板将使用当前上下文 参数file是包含模板相对模板 root 的相对路径 123&#123;% include &quot;a.html&quot; %&#125;&#123;% include &quot;template.js&quot; %&#125; //将引入的文件内容放到被引用的地方 raw停止解析swig标签，其中所有内容都将按照字面意思输出 参数file是包含模板相对模板 root 的相对路径 123// foobar = &apos;&lt;p&gt;&apos;&#123;% raw %&#125;&#123;&#123; foobar &#125;&#125;&#123;% endraw %&#125;// =&gt; &#123;&#123; foobar &#125;&#125; set设置一个变量，在当前上下文中复用，设置的值会覆盖已定义值 12345// foods = &#123;&#125;;// food = &apos;chili&apos;;&#123;% set foods[food] = &quot;con queso&quot; %&#125;&#123;&#123; foods.chili &#125;&#125;// =&gt; con queso 模版继承Swig 使用 extends 和 block 来实现模板继承 example: 12345678910111213141516//layout.html&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&#123;% block title %&#125;My Site&#123;% endblock %&#125;&lt;/title&gt; &#123;% block head %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819//index.html&#123;% extends &apos;./layout.html&apos; %&#125;&#123;% block title %&#125;My Page&#123;% endblock %&#125;&#123;% block head %&#125;&#123;% parent %&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;p&gt;This is just an awesome page.&lt;/p&gt; &lt;h1&gt;hello,lego.&lt;/h1&gt; &lt;script&gt; //require(&apos;pages/index/main&apos;); &lt;/script&gt;&#123;% endblock %&#125; swig模板经过编译后： 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; My Page&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is just an awesome page.&lt;/p&gt; &lt;h1&gt;hello,lego.&lt;/h1&gt; &lt;script src=&quot;pages/index/main&quot;&gt; //require(&apos;pages/index/main&apos;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在express中使用swig在express框架中，默认的模版是jade，可以更改为其他模版引擎。修改app.js 123456789101112var app = express(); app.set(&apos;view engine&apos;, &apos;jade&apos;);// 把上面的代码改为下面的// view engine setupvar app = express(),swig = require(&apos;swig&apos;),app.engine(&apos;html&apos;, swig.renderFile); //使用swig渲染html文件app.set(&apos;view engine&apos;, &apos;html&apos;); //设置默认页面扩展名app.set(&apos;view cache&apos;, false); //设置模板编译无缓存app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;)); //设置项目的页面文件，也就是html文件的位置swig.setDefaults(&#123;cache: false&#125;); //关闭swig模板缓存swig.setDefaults(&#123;loader: swig.loaders.fs(__dirname + &apos;/views&apos;)&#125;); //从文件载入模板，请写绝对路径，不要使用相对路径 然后把原来的views文件夹下得文件后缀都改为html 模板文件layout.html 123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% block head %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; index.html 1234567891011&#123;% extends &apos;layout.html&apos; %&#125;&#123;% block title %&#125;index &#123;&#123;title&#125;&#125; &#123;%endblock%&#125;&#123;% block head %&#125;&#123;&#123;title&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;p&gt;This is just an awesome page.&lt;/p&gt;&#123;% endblock %&#125; 然后再路由中设置即可使用： 123router.get(&apos;/&apos;, function(req, res) &#123; res.render(&apos;index&apos;, &#123; title: &apos;标题&apos; &#125;);&#125;); 参考 http://www.iqianduan.net/blog/how_to_use_swig http://node-swig.github.io/swig-templates/docs/ http://www.joryhe.com/2016-05-21-hexo-swig-advance-grammar.html http://www.ithao123.cn/content-10830341.html]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Swig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node08 Express]]></title>
    <url>%2F2017%2F04%2F04%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode08%20Express%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Express学习笔记。 简介express是基于nodejs平台的web框架，它可以让我们快速开发出==web应用==。Express主要解决了 请求路由 和 视图模板 的问题 安装express项目的命令如下 123express -e nodejs-product//-e, --ejs add ejs engine support //-J, --jshtml add jshtml engine support (defaults to jade) 验证版本如果是express 4.0之前版本，那么执行“express -V”就可以得到版本号了，可express 4.0之后还需要再安装express-generator包，如果没有安装还执行“express -V”命令会报错。 12$ npm install -g express-generatorexpress -V 项目目录 bin:真实的执行程序（在命令行输入express命令时，其实对应的其实是去执行bin目录下的express程序）。 app.js： 项目的启动文件(项目入口)，可以改成index.js或者main.js都成 node_modules： 存放项目的依赖库 package.json： 项目依赖配置及开发者信息 public： 静态文件如 css,js,img (PS:俺其实习惯叫static) routes： 路由文件 Views： 页面文件(Ejs或者jade的模板，默认是jade) express() 表示创建express应用程序。简单几行代码其实就可以创建一个应用，如下： express默认的模版是jade模版，想要更改模版需要在app.js中更改： 1234// 原本是“app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 修改为app.engine(&apos;.html&apos;, ejs.__express);app.set(&apos;view engine&apos;, &apos;html&apos;); app.engine方法用来重新设置模板文件的扩展名，上面的代码意思是用ejs模板引擎来处理“.html”后缀的文件 12app.engine(ext, callback) //注册模板引擎的 callback 用来处理ext扩展名的文件。 PS：__express不用去care，其实就是ejs模块的一个公共属性，表示要渲染的文件扩展名。 app.use用来指定中间件function：1app.use([path], function) 可选参数path默认为”/“。使用 app.use() “定义的”中间件的顺序非常重要，它们将会顺序执行，use的先后顺序决定了中间件的优先级; app.render用来渲染view同时传进对应的数据: 12app.render(view, [options], callback)// 渲染 view, callback 用来处理返回的渲染后的字符串。 app.jsapp.js是项目的主文件,为这个主文件里面有创建服务和监听端口的语句： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var express = require(&apos;express&apos;); //引入express框架var session = require(&apos;express-session&apos;); //设置session的中间件var redisStore = require(&apos;connect-redis&apos;)(session); //实现redis存储sessionvar glob = require(&apos;glob&apos;); //使用类似shell的模式语法匹配文件路径var path = require(&apos;path&apos;); //path模块用于处理和转换文件路径var bodyParser = require(&apos;body-parser&apos;); //解析请求的body的中间件var swig = require(&apos;swig&apos;); //swig模板引擎var staticTag = require(&apos;./swig/static&apos;); //swig模板相关设置var morgan = require(&quot;morgan&quot;); //控制台日志var app = express(); //创建一个express应用app.locals.ENV = NODE_ENV; //将环境变量NODE_ENV存在app.locals里app.locals.ENV_DEV = (NODE_ENV === &apos;dev&apos;); //是否是dev环境// view engine setupapp.engine(&apos;html&apos;, swig.renderFile); //使用swig渲染html文件app.set(&apos;view engine&apos;, &apos;html&apos;); //设置默认页面扩展名app.set(&apos;view cache&apos;, false); //设置模板编译无缓存app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;)); //设置项目的页面文件，也就是html文件的位置swig.setDefaults(&#123;cache: false&#125;); //关闭swig模板缓存swig.setDefaults(&#123;loader: swig.loaders.fs(__dirname + &apos;/views&apos;)&#125;); //从文件载入模板，请写绝对路径，不要使用相对路径staticTag.init(swig); //这个init函数是自定义的，对swig模板做了一些自定义设置app.use(session(&#123; //设置session中间件的写法，session会存在服务端 cookie: &#123; maxAge: 2502000 * 1000 //设置最大生命周期，过了这个时间后cookie会失效，单位毫秒 &#125;, name: &apos;lbn_sid&apos;, //用来保存session的cookie名称 secret: &apos;what are you thinking?&apos;, //用来对session数据进行加密的字符串.这个属性值为必须指定的属性 store: new redisStore(&#123; //设置session的存储仓库为redis数据库 ttl: 2502000, //redis session生命周期，单位秒 url: REDIS_URL //redis缓存服务地址 &#125;), saveUninitialized: false, //false选项不会强制存储未初始化的session到redis里，未初始化意味着新的还没有修改的 resave: false //如果是true选项，强制重新存储session到redis里，即使session没有被修改，false意味着如果没有变化就不用重新存&#125;));// app.use(morgan(&apos;combined&apos;)); //morgan控制台日志，会在控制台输出所有http请求日志，combined是标准Apache日志格式app.use(bodyParser.json()); //bodyParser.json是用来解析请求体的json数据格式app.use(bodyParser.urlencoded(&#123; extended: true, limit: &apos;10mb&apos;&#125;));/*bodyParser.urlencoded则是用来解析我们通常的form表单提交的数据， *也就是请求头中包含这样的信息： Content-Type: application/x-www-form-urlencoded *extended选项为true会使用qs library来解析数据，false会使用querystring来解析 *limit选项限制请求体的大小 */app.use(&apos;/&apos; + global.STATIC_URL, express.static(path.join(__dirname, STATIC_DIR)));//为静态资源的请求添加虚拟路径，只有请求静态资源的路径前加了global.STATIC_URL前缀后，才可请求成功var controllers = glob.sync(&apos;./controllers/*.js&apos;); //获取到controllers文件夹下的所有js文件，这些文件里都是路由controllers.forEach(function (controller) &#123; require(controller)(app);&#125;);//将所有路由循环到主文件中使其生效app.use(function (err, req, res, next) &#123; //当请求出现500错误，渲染500错误页面 res.locals = &#123;env: NODE_ENV&#125;; // treat as 404 if (err.message &amp;&amp; (~err.message.indexOf(&apos;not found&apos;) || (~err.message.indexOf(&apos;Cast to ObjectId failed&apos;)))) &#123; return next(); &#125; res.status(500).render(&apos;500&apos;, &#123; error: err.stack &#125;);&#125;);app.use(function (req, res, next) &#123; //当请求出现404错误，渲染404错误页面 res.status(404).render(&apos;404&apos;, &#123; url: req.originalUrl, error: &apos;Not found&apos; &#125;);&#125;);module.exports = app; //将app应用导出成模块 这其中session的设置值得注意，session的设置写在了app.use()中，也就是中间件中，中间件也是路由，只是所有的请求都会经过它的处理。这里设置session时有一个cookie的设置，这个cookie就是session的唯一标示，是sessionId，也就是说，第一次访问网站的时候，在请求通过session设置的中间件时，响应头里会设置一个set-cookie来强制浏览器存储一个cookie，也就是在浏览器存下sessionId，然后会在node端新建一个session，这里浏览器存的sessionId和node端的session是对应关系，之后的请求也会经过session设置的中间件，此时的请求头里会自动带上浏览器的所有cookie，当中间件发现已经有sessionId的时候，就不会新建了，只用更新对应的session就可以了。 binexpress4.0之后的版本，项目目录下会有bin/这个目录，这个目录专门用于自定义启动脚本，这样就把与启动服务的代码和主文件分离了，而且你可以定义多个启动脚本，而不用去修改app.js这个主文件。 文件内容： 123456789101112131415161718#!/usr/bin/env node/*这一句是写给类unix系统看的 *如果用户没有将nodejs装在默认的/usr/bin路径里 *当系统看到这一行的时候，首先会到env设置里查找nodejs的安装路径 *再调用对应路径下的解释器程序完成操作 */var app = require(&apos;../app&apos;);//引入app主应用app.set(&apos;port&apos;, PORT || 3000);//设置端口为环境变量.env文件里的PORT，如果.env里没有，就默认3000var server = app.listen(app.get(&apos;port&apos;), function() &#123; console.log(&apos;Express server listening on port &apos;, app.get(&apos;port&apos;), &quot; with pid &quot;, process.pid);&#125;);/*app.listen(path,[callback])的写法是启动一个socket连接，然后在给定的端口上监听连接 *app.get(name)的写法是获取app设置，设置的时候通过app.set(&apos;port&apos;, &apos;my port&apos;);来设置。 */ 路由Web需要通过不同uri区分功能，如：/user/profile 表示用户信息，/about 表示网站简介，路由可以实现这一功能。 我个人理解的就是当在地址栏输入一个地址，要对应的页面去往何处，完成这一功能的命令就是路由。 路由用get去设置，默认的路由/对应routes.index,/user对应应routes.user 12345678910111213141516171819202122var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.all(&quot;*&quot;, function(request, response, next) &#123; console.log(&quot;step1&quot;); next();&#125;);app.get(&quot;/&quot;, function(request, response) &#123; response.end(&quot;Home Page!&quot;);&#125;);app.get(&quot;/about&quot;, function(request, response) &#123; response.end(&quot;About Page!&quot;);&#125;);app.get(&quot;*&quot;, function(request, response) &#123; response.end(&quot;404!&quot;);&#125;);http.createServer(app).listen(1984); VIEW处理Express加入了View处理机制，一起看看： 1234567891011var express = require(&quot;express&quot;);var app = express();// 模板目录：./viewsapp.set(&quot;views&quot;, __dirname + &quot;/views&quot;);// 使用jade引擎app.set(&quot;view engine&quot;, &quot;jade&quot;); // 寻址views/index，提交jade渲染，并返回结果app.get(&quot;/&quot;, function(request, response) &#123; response.render(&quot;index&quot;, &#123; message: &quot;I&apos;m hyddd&quot; &#125;); &#125;); 参考 http://www.cnblogs.com/Darren_code/p/node_express.html http://www.cnblogs.com/hyddd/p/4237099.html http://www.cnblogs.com/hahazexia/p/6027787.html http://www.cnblogs.com/hahazexia/p/6213286.html]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node07 events事件模块]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode07%20events%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。 Nodejs的大部分核心API都是基于异步事件驱动设计的，所有可以分发事件的对象都是EventEmitter类的实例。 如何使用实例化events.EventEmitter这个类，然后就可以使用手册上的一些方法了。 12var event = require("events")//引入事件模块var emitter = new event.EventEmitter();//实例化事件触发器 实例化之后就可以添加EventEmitter的一些方法了。 12emitter.on("事件名称",监听函数)；emitter.emit("事件名称"，[参数1], [参数2]...) on和emit是最基本的方法，on用来建立普通的事件监听（也就是监听器），当事件触发则执行监听函数； emit用来触发某个事件，然后将参数按顺序传入监听函数。 下面是一个基本的例子，当emiiter的event1事件被触发后就执行了func1，如果定义了多个evnet1，则event1也会在触发后执行多次。 1234emitter.on("event1", function func1(msg1, msg2)&#123; console.log(msg1+"+"+msg2)&#125;);emitter.emit("event1","this is event1", "this is event2"); 其他监听方法12345678910111213141516171819emitter.addListener(event, listener) // 与on相同，都是建立监听器emitter.once(event, listener)// 建立一次性监听器，执行listener后删除本监听器emitter.removeListener(event, listener)// 从指定事件中除去某一个监听函数，也就是再触发这个事件，指定的监听函数不执行了emitter.removeAllListeners(event)// 删除所有对这个事件的监听函数，也就就是再触发这个事件，没函数执行了emitter.setMaxListeners(n) // 设置这个emitter实例的最大事件监听数，默认是10个，设置0为不限制// 如果设置了最大监听数量，则同一事件的监听最好不要超过该最大值，否则很可能发送内存泄漏。emitter.listeners(event) // 返回这个事件的监听函数的数组，例如返回：[function1, function2, function3]// 修改会改变此事件的监听函数，例如emitter.listeners(event).length = 2;就相当于执行了：emitter.removeListener(event, function3) ; 看一个例子： 12345678910111213141516171819202122232425262728293031var event = require("events"), emitter = new event.EventEmitter();var func1 = function(msg1, msg2)&#123; console.log(msg1+msg2)&#125;;var func2 = function()&#123;console.log("this is event2")&#125;;var func3 = function()&#123;console.log("this is event3")&#125;;emitter.on("event1",func1);emitter.addListener("event1", func2);emitter.on("event1",func3);console.log(emitter.listeners("event1"));// [ [Function], [Function], [Function] ]emitter.emit("event1","this is ", "event1");// this is event1// this is event2// this is event3emitter.removeListener("event1", func1);console.log(emitter.listeners("event1"));// [ [Function], [Function] ]emitter.emit("event1","this is event1", "this is event2");// this is event2// this is event3emitter.removeAllListeners("event1");console.log(emitter.listeners("event1"));// []emitter.emit("event1","this is event1", "this is event2");// nothing here 应用实例比如有一个秒杀活动，只有第一个点击按钮的人才有机会获取奖品，网站会记录本次活动有多少人点击这个按钮，同时又要根据用户ID记录此用户点过多少次这个按钮。 不使用事件监听代码可能这么写： 123456789101112131415var prize = false; //false表示奖品未被领取var isactive = true; //活动是否开启if(有人点击抽奖按钮)&#123; if(!isactive ) return false; //先判断活动是否已经关掉了 if(!prize)&#123; getprize(此人id, 按钮id); //getprize是领奖的方法 prize = true; &#125; addbutton(此人id, 按钮id); //此按钮点击统计+1 addclick(此人id, 按钮id); //此人点击此按钮统计+1&#125;setTimeout(function()&#123; isactive = false; &#125;, 1000*60*60*24); //活动时间1天，1天以后活动结束 上面这段代码对我自己也是有启发的： 奖品是否被领取、活动是否开启在这个代码的开始部分都用了布尔值作为标识符，这样在后面根据条件、状态的变化改变对应的标识符即可，然后将这些标识符作为if的判断条件。 如果用事件监听改写上面代码，看上去更清晰，而且可能效率更高一些。 1234567891011121314151617var events = require("events");var btclick = new events.EventEmitter();btclick.once('bt0click',getprize)//getprize是领奖的方法，触发一次后，自动删除本触发器btclick.on('bt0click', addbutton);//此按钮点击统计+1btclick.on('bt0click', addclick);//此人点击此按钮统计+1if(有人点击抽奖按钮)&#123; btclick.emit('bt0click', 此人ID, 按钮ID); //等于触发了bt0click事件的所有监听器&#125;setTimeout(function()&#123; btclick.removeAllListeners('bt0click'); //移除所有监听器&#125;, 1000*60*60*24); //活动时间1天，1天以后活动结束 参考 http://snoopyxdy.blog.163.com/blog/static/6011744020118212553691/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Events</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node06 fs模块]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode06%20fs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。fs模块和fs-extra的学习笔记。 概述Node中的fs模块用来对本地文件系统进行操作。文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。 fs模块中提供的方法可以用来执行基本的文件操作，包括读、写、重命名、创建和删除目录以及获取文件元数据等。每个操作文件的方法都有同步和异步两个版本。 异步操作的版本都会使用一个回调方法作为最后一个参数。当操作完成的时候，该回调方法会被调用。而回调方法的第一个参数总是保留为操作时可能出现的异常。如果操作正确成功，则第一个参数的值是null或undefined。 同步操作的版本的方法名称则是在对应的异步方法之后加上一个Sync作为后缀。比如异步的rename() 方法的同步版本是renameSync()。 使用方法：fs.readFile属于fs模块，使用前需要首先引入fs模块 1const fs= require(“fs”) fs.readFile以异步的方式读取文件内容。 API读取文件readFile1fs.readFile(filename, [options], [callback(err,data)]) filename：必选参数，文件路径，可以是绝对路径，也可以是相对路径。如果是相对路径，是相对于当前进程（process.cwd）的路径，而不是相对于当前脚本的路径。 options：可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性 callback：回调函数，传递2个参数，异常err和文件内容data 注意，文件编码可取值包括’ascii’/‘utf-8’/‘base64’，如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法将其转换为字符串。 12345678910111213const fs = require('fs');console.log('start');fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log(file);&#125;);// fs.readFile('./test.txt', (error, file) =&gt; &#123;// console.log('before:', file.toString());// &#125;);console.log('finish'); 输出结果： 123startfinishContent: 你好啊 写文件writeFile1fs.writeFile(filename, data, [options], callback(err)); filename：必选参数，文件路径 data：写入的数据，可以是字符或一个Buffer对象 options：flag, mode(权限)，encoding callback：回调函数，传递1个参数，异常err 12345678910111213const fs = require('fs');console.log('start');fs.writeFile('./test.txt', '难判谁人错与对', 'utf-8', (error, file) =&gt; &#123; console.log('write finish');&#125;);fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('Content:', file);&#125;);console.log('finish'); 输出结果： 1234startfinishwrite finishContent: 难判谁人错与对 注意，在同一个文件多次使用fs.writeFile且不等待回调是不安全的，对于这种情况应该使用fs.createWriteStrem 以追加方式写文件appendFile1fs.appendFile(filename, data, [options], callback(err)); 异步地将数据追加到文件，如果文件尚不存在则创建该文件。 data可以是字符串或Buffer。 1234567891011const fs = require('fs');fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('before:', file);&#125;);fs.appendFile('./test.txt', '你随河流而来', 'utf-8', (error) =&gt; &#123; fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('after:', file); &#125;);&#125;); 结果： 1234before: 难判谁人错与对after: 难判谁人错与对你随河流而来 打开文件open1fs.open(filename, flags, [mode], callback(err,fd)); filename：必选参数，文件名 flags：操作标识，如r,读方式打开 [mode]：权限，如777，表示任何用户读写可执行 callback：打开文件后回调函数，参数默认第一个err，第二个fd为一个整数，表示打开文件返回的文件描述符，Window中又称文件句柄 监视文件watchFile1fs.watchFile(filename, [options], listener(curr, prev)); 对文件进行监视，并且在监视到文件被修改时执行处理 filename, 完整路径及文件名； [options], persistent为true表示持续监视，不退出程序；interval单位毫秒，表示每隔多少毫秒监视一次文件 listener, 文件发生变化时回调，有两个参数：curr为修改后的fs.Stat对象，prev为修改之前的fs.Sta对象 1234fs.watchFile('./test.txt', (curr, prev) =&gt; &#123; console.log('current', curr); console.log('previous', prev);&#125;); 改动文件后，输出结果： 1234567891011121314151617181920212223242526272829303132333435363738current Stats &#123; dev: 16777218, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 4636749, size: 46, blocks: 8, atimeMs: 1556524554000, mtimeMs: 1556524553000, ctimeMs: 1556524553000, birthtimeMs: 1556524553000, atime: 2019-04-29T07:55:54.000Z, mtime: 2019-04-29T07:55:53.000Z, ctime: 2019-04-29T07:55:53.000Z, birthtime: 2019-04-29T07:55:53.000Z &#125;previous Stats &#123; dev: 16777218, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 4636495, size: 42, blocks: 8, atimeMs: 1556524547000, mtimeMs: 1556524320000, ctimeMs: 1556524320000, birthtimeMs: 1556524319000, atime: 2019-04-29T07:55:47.000Z, mtime: 2019-04-29T07:52:00.000Z, ctime: 2019-04-29T07:52:00.000Z, birthtime: 2019-04-29T07:51:59.000Z &#125; fs.unwatfile方法用来接触对文件的监听。 判断路径是否存在原本判断路径是否存在的fs.exists已经在V1.0.0被废弃，改为使用fs.stat或者fs.access fa.stat用来查询文件信息 1234567fs.stat('./test.txt', (err, stat) =&gt; &#123; if (stat &amp;&amp; stat.isFile()) &#123; console.log(stat); &#125; else &#123; console.log('file does not exist'); &#125;&#125;); fs.access用来检查文件的访问权限 123456789// 检查文件是否存在fs.access('/etc/passwd', function(err) &#123; console.log(err ? '文件存在' : '文件不存在');&#125;);// 检查文件是否有读写权限fs.access('/etc/passwd', fs.R_OK | fs.W_OK, function(err) &#123; console.lo(err ? '不可操作!' : '可以读/写');&#125;); 新建目录fs.mkdir()1fs.mkdir(path[, options], callback) mkdir接受三个参数吗，第一个是目录名，第二个是权限制，第三个是回调函数 1fs.mkdir('./hello', '0777', err =&gt; console.log(err)); 读取目录readdir1fs.readdir(path[, options], callback) 用来读取目录，返回一个所包含的文件和子目录的数组，不会递归寻找内部目录，需要手动递归实现： 1234567891011121314const list = (path) =&gt; &#123; fs.readdir(path, (err, files) =&gt; &#123; console.log(files); files.forEach(file =&gt; &#123; fs.stat(file, (error, stat) =&gt; &#123; if(stat &amp;&amp; stat.isDirectory()) &#123; list(file) &#125; &#125;) &#125;) &#125;)&#125;;list(process.cwd()); 创建读/写操作的数据流createReadStream/createWriteStreamcreateReadStrem方法旺旺用来打开大型的文本文件，创建一个读取操作的数据流。大型文本文件体积很大，读取操作的缓存装不下，只能分成几次发送。每次发送会触发data时间，发送结束会触发end时间 12345678910111213141516171819202122232425262728293031const func = data =&gt; &#123; console.log('Line: ' + data);&#125;;const readLines = (input, func) =&gt; &#123; let remaining = ''; input.on('data', data =&gt; &#123; remaining += data; let index = remaining.indexOf('\n'); let last = 0; while(index &gt; -1) &#123; let line = remaining.substring(last, index); last = index + 1; func(line); index = remaining.indexOf('\n', last); &#125; remaining = remaining.substring(last); &#125;); input.on('end', () =&gt; &#123; if(remaining.length &gt; 0) &#123; func(remaining) &#125; &#125;)&#125;;const input = fs.createReadStream('./test.txt');readLines(input, func); createWriteStream用来创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作 12345const out = fs.createWriteStream(fileName, &#123; encoding: 'utf8'&#125;);out.write(str);out.end(); createReadStream和createWriteStream配合，可以实现拷贝大型文件。 1234567891011121314151617181920212223const fileCopy = (filename1, filename2, done) =&gt; &#123; const input = fs.createReadStream(filename1); const output = fs.createWriteStream(filename2); input.on('data', data =&gt; &#123; output.write(data); &#125;); input.on('error', err =&gt; &#123; console.log(err); &#125;); input.on('end', () =&gt; &#123; output.end(); if (done) &#123; done() &#125; &#125;)&#125;;fileCopy('./test.txt', './hello.text', () =&gt; &#123; console.log('copy finish');&#125;); 删除文件unlink和删除文件夹rmdir1234// 删除文件fs.unlink('./hello.text', (err) =&gt; &#123; console.log('deleted');&#125;); 1234// 删除文件夹只能删除空文件夹，如果里面有内容则不能直接删除，会报错fs.rmdir('./world', (err) =&gt; &#123; console.log(err, 'deleted');&#125;); 如果world文件夹不为空，无法删除： 12345&#123; [Error: ENOTEMPTY: directory not empty, rmdir &apos;./world&apos;] errno: -66, code: &apos;ENOTEMPTY&apos;, syscall: &apos;rmdir&apos;, path: &apos;./world&apos; &#125; 重命名rename1234// 重命名fs.rename('./hello', './world', err =&gt; &#123; console.log(err);&#125;); 同步方法上面提到的异步API都有着对应的同步方法，比如readFile对应的同步方法readFileSync(): 12345const fs = require("fs");const file = fs.readFileSync("./test.txt", "utf-8");console.log(file);console.log("finish"); 执行的顺序就是按照一条时间链由上至下执行： 12你好哇~finish fs-extra模块fs-extra模块是fs模块的一个扩展，文档在这里。 fs-extra集成了fs模块的所有方法，提供了很多遍历的API，并且添加了Promise的支持，可以使用它来代替fs模块。 安装使用它不是Node自带的模块，需要单独安装 1npm i -S fs-extra 使用时完全可以替代fs模块，如果希望明确表示在使用fs-exra，可以将fs标示改为fse 1const fse = require('fs-extra'); 异步方法fs-extra的异步方法可以使用回调函数的形式，更推荐的是使用Promise形式，也可以使用Async/Await的语法： 1234567891011121314151617181920212223242526// 回调函数fse.copy('./test.txt', './world/test.txt', err =&gt; &#123; if (err) &#123; console.error(err); return; &#125; console.log('success!');&#125;);// Promisefse.copy('./test.txt', './world/test.txt').then(() =&gt; &#123; console.log('success');&#125;).catch(e =&gt; &#123; console.error(e);&#125;);// Async/Awaitconst copyFile = async () =&gt; &#123; try &#123; await fse.copy('./test.txt', './world/test.txt'); console.log('success'); &#125; catch (e) &#123; console.error(e); &#125;&#125;;copyFile() APIfs-extra提供了很多遍历的API，这些API都有异步和同步的两个版本，简单列举一部分异步的API，详细的API文档看这里。 1234567891011121314151617181920212223242526272829303132333435fse.copy(src: string, dest: string, [options: object, callback: func])// 复制文件或目录，目录可以包含内容fse.emptyDir(dir: string, [callback: function])// 确保目录为空，如果目录不为空，则删除目录下内容，如果目录不存在，则创建该目录fse.ensureFile(file: string, [callback: func])// 确保文件存在。如果请求创建的文件位于不存在的目录中，则会创建这些目录。如果该文件已存在，则不进行修改。（别名：createFile）fse.ensureDir(dir: string, [callback: func])// 确保目录存在，如果目录结构不存在，则创建它，如果目录存在则不进行操作fse.ensureLink(srcpath: string, dstpath: string, [callback: func])// 确保链接存在。如果目录结构不存在，则创建它。fse.move(src: string, dest: string, [options: object, callback: func])// 移动文件或目录fse.outputFile(file: stirng, data: string|Buffer|Uint8Array, [options: string|object, callback: func])// 几乎与writeFile相同，除了如果父目录不存在则创建它，file必须是文件路径（不允许使用缓存区或文件描述符）fse.outputJson(file: string, object: object, [options: object, callback: func])// 将对象写入JSON文件，几乎与writeJSON相同，除了如果目录不存在，则创建它fse.writeJson(file, object, [options, callback])// 将对象写入JSON文件，几乎与outputJSON相同，除了必须保证目录存在之外fse.pathExists(file: string [, callback: func]);// 检查文件系统来测试给定路径是否存在fse.readJson(file: string, [options: object, callback: func])// 读取JSON文件，并将其解析为对象fse.remove(path: string, [callback: func])// 删除文件或者目录，该目录可以包含内容，类似rm -rf 参考 fs 模块@JavaScript标准参考教程（alpha） Node.js v10.15.3 文档@nodejs.cn 使用Node.js的fs模块操作文件之检查文件是否存在 node-“fs-extra”模块代替fs使用@掘金]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>fs</tag>
        <tag>fs-extra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node04 模块化]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode04%20%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Node中模块化的学习笔记。 几种形式模块导入和导出有几种形式： require：Node和ES6都支持的引入 export/import：只有ES6支持的导出/引入格式 module.exports/exports：只有Node支持的导出格式 NodeNode的模块系统遵循的是CommonJS规范，CommonJS定义的模块分为模块标识（module）、模块定义（exports）、模块引用（require） exports和module.exportsNode在执行一个文件时，会给这个文件内生成一个exports和module对象，module又有一个exports属性，他们的关系如下，都指向一个内存区域： 1exports = module.exports = &#123;&#125;; 如果人为将二者指向不同的内存区域，最终导出的内容是module.exports的内容，而不是exports的内容，所以尽量都使用module.exports导出，用require导入 requireNode.js提供了exports和require两个对象，其中exports是模块公开的接口，require用来从外部获取一个模块接口，即获取模块的exports对象。 Node.js可以加载的文件模块分为三种： .js，通过fs模块同步读取JS文件并编译执行 .node，通过C/C++进行编写的Addon。通过dlopen方法进行加载 .json，读取文件，调用JSON.parse解析加载 require可以接受以下几种参数的传递： lodash、jQuery等原生模块 相对路径的文件模块 绝对路径的文件模块 非原生模块的文件模块 在引用文件模块的时候后要加上文件的路径： /.../.../xxx.js表示绝对路径、 ./xxx.js表示相对路径(同一文件夹下的xxx.js) ../表示上一级目录 如果既不加/.../、../又不加./的话，则该模块要么是核心模块，要么是从一个node_modules文件夹加载 小例子test1.js文件： 12345678910const tt1 = function (a, b) &#123; return a + b;&#125;;function tt2(a, b) &#123; return a * b;&#125;module.exports.tt1 = tt1;module.exports.tt2 = tt2; test2.js文件 1234const test1 = require("./test1.js");console.log(test1.tt1(1, 2));//3console.log(test1.tt2(1, 2));//2 在命令行执行 1node test2.js 上面代码要注意： 被引用的test1.js需要将要导出的对象存入module.exports（或者是exports）中 在test2.js文件中引入test1.js的结果，引入的就是module.exports对象，该对象对应的方法就是在test1.js中定义的函数 在使用require时要表明路径，否则会找不到对应的文件。 ES6的模块化ES6中的规范是使用export和import来导出和导入模块 导出的时候有的时候会增加一个default关键字，它其实就是一个语法糖： 123456// test.jsconst a = 123;export default a// 等同于 export &#123; a as default &#125; 引入的时候就可以直接使用任意变量名引入： 123import x from './test.js'// 等同于 impor &#123; default as x &#125; from './test.js' 要注意的是一个模块里面只能有一个export default。 还要注意，ES6导出的模块是静态的，我是这样理解的：导出的只是一段代码，并没有实际运行，导出的如果是函数也没有执行 参考 exports、module.exports 和 export、export default 到底是咋回事@掘金]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Exports</tag>
        <tag>Module</tag>
        <tag>Require</tag>
        <tag>Import</tag>
        <tag>Export</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node01 入门]]></title>
    <url>%2F2017%2F03%2F31%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。一篇Node入门的笔记。 什么是Node.jsNode是一个服务器端JavaScript解释器。Node的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个物理机的连接代码。处理高并发和异步I/O是Node受到开发人员的关注的原因之一。 Node本身运行Google V8 JavaScript引擎，所以速度和性能非常好，而且Node对其封装的同时还改进了其处理二进制数据的能力。因此，Node不仅仅简单的使用了V8，还对其进行了优化，使其在各种环境下更加给力。 第三方的扩展和模块在Node的使用中起到重要的作用，npm就是模块的管理工具，用它安装各种Node的软件包并发布自己为Node写的软件包。 安装Node在macOs下安装可以通过homebrew来安装，可以通过brew -v来查看是否安装了homebrew，如果没有安装，则通过终端命令安装 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装成功后，来安装node： 123brew link nodebrew uninstall nodebrew install node 也可以直接在官网下载Node的安装包，为pkg格式，双击安装包安装即可。 在Windows下安装直接在官网下载Node的安装包，为msi格式，双击安装包安装即可。 在centos下安装进入要存放下载资源的目录，比如/usr/local/src/目录，然后执行安装命令 1wget http://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x64.tar.gz 上述命令是下载6.9.4的64位nodejs版本，如果你想下载其他版本，可以将命令中的两处v6.9.4替换成其他版本号； 如果系统是32位(一般是64位)，也可以将x64改成x32 下载完成后，执行解压命令 1tar -zxvf node-v6.9.4-linux-x64.tar.gz 解压完成，可以看到当前目录解压后的文件夹node-v6.9.4-linux-x64，重命名一下 1mv node-v6.9.4-linux-x64 node 现在，node文件夹就是程序目录，但是还不能够全局使用，需要添加变量 首先在root目录下找到.bash_profile文件，编辑 1vim ~/.bash_profile 找到PATH=$PATH:$HOME/bin，在后面添加路径为： 1PATH=$PATH:$HOME/bin:/usr/local/src/node/bin 保存修改:wq，然后重载一下 1source ~/.bash_profile OK！大功告成！现在可以在任何目录下执行node和npm命令了！ Hello Node12345678910var http = require('http'); http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); // text/plain是无格式正文 res.end('Hello World\n'); &#125;).listen(1337, "127.0.0.1"); console.log('Server running at http://127.0.0.1:1337/'); 代码逻辑： 全局方法require()是用来导入模块的，一般直接把require()方法的返回值赋值给一个变量，在JavaScript代码中直接使用此变量即可。require(&quot;http&quot;)就是加载系统预置的http模块； http.createServer是模块的方法，目的就是创建并返回一个新的web server对象，并且给服务绑定一个回调，用以处理请求； 通过http.listen()方法就可以让该HTTP服务器在特定端口监听 Node实现了console.log方法，执行hello.js代码，相关信息会显示在命令行中， 在命令行，成功启动会看见console.log()中的文本。 Node Moudle在Node中，不同的功能组件被划分成不同的模块。应用可以根据自己的需要来选择使用合适的模块。每个模块都会暴露一些公共的方法或属性。模块的使用者直接使用这些方法或属性即可，对于内部的实现细节就可以不用了解。除了Node本身提供的API外，开发人员也可以利用这个机制来将应用拆分成多个模块，以提高代码的可复用性。 如何使用模块在Node中使用模块是非常方便的，在代码中可以直接使用全局函数require()来加载一个模块。 自己如何开发模块？使用require()导入模块的时候，模块名称以&quot;./&quot;开始的这种，就是自己开发的模块文件。 代码中封装了模块的内部处理逻辑，一个模块一般都会暴露一些公开的方法或属性给其他的人使用。模块的内部代码需要把这些方法或属性给暴露出来。 hello.js的内容： 12345678var method = &#123; number: 50, add: function(a, b) &#123; return a + b; &#125;&#125;;exports.method = method; 在另外一个文件myNode.js中引用hello.js： 12345var hello = require("./hello.js");var sum = hello.method.add(5, 10);console.log(sum);console.log(hello.method.number) 运行后结果： 123$ node myNode.js1550 Node的优势Node核心思想： 非阻塞 单线程 事件驱动 在目前的web应用中，客户端和服务器端之间有些交互可以认为是基于事件的，那么Ajax就是页面及时响应的关键。每次发送一个请求时（不管请求的数据多么小），都会在网络里走一个来回。服务器必须针对这个请求作出响应，通常是开辟一个新的进程。那么越多用户访问这个页面，所发起的请求个数就会越来越多，就会出现内存溢出、逻辑交错带来的冲突、网络瘫痪、系统崩溃这些问题。 Node的目标是提供一种构建可伸缩的网络应用的方案，服务器可以同时处理很多客户端连接。 Node和操作系统有一种约定，如果创建了新的链接，操作系统通知Node后进入休眠。如果有人创建了新的链接，那么它（Node）执行一个回调，每一个链接只占用了非常小的（内存）堆栈开销。 Node异步执行的例子： hello.js的内容： 12345678var method = &#123; number: 50, add: function(a, b) &#123; return a + b; &#125;&#125;;exports.method = method; 在另外一个JS文件myNode.js中引用hello.js： 12345678910var fs = require("fs");fs.readFile("./hello.js", function(err, data) &#123; if (err) &#123; throw err &#125; console.log("successful")&#125;);console.log("async") 文件执行结果首先执行打印async，然后打印异步执行的successful，运行后结果： 123$ node myNode.jsasyncsuccessful Node是无阻塞的，新请求到达服务器时，不需要为这个请求单独作什么事情。Node仅仅是在那里等待请求的发生，有请求就处理请求。 因此，Node更擅长处理体积小的请求以及基于事件的I/O。Node不仅仅是做一个Web服务的框架，它可以做更多，比如它可以做Socket服务，可以做比方说基于文件的，然后基于像一些比方说可以有子进程，然后内部的，它是一个很完整的事件机制，包括一些异步非注射的解决方案，而不仅仅局限在网络一层。同时它可能，即使作为一个Web服务来说，它也提供了更多可以深入这个服务内核、核心的一些功能，比方说Node使用的Http Agent，这块就是它可以更深入这个服务内核来去做一些功能。 Node的事件流因为Node采用的是事件驱动的模式，其中的很多模块都会产生各种不同的事件，可由模块来添加事件处理方法，所有能够产生事件的对象都是事件模块中的EventEmitter类的实例。 12345678var event = require("events");var emitter = new event.EventEmitter();emitter.on("myEvent",function(msg)&#123; console.log(msg)&#125;);emitter.emit("myEvent","this is my event") 上面的代码中： 使用require()方法添加了events模块并把返回值赋给了一个变量 new events.EventEmitter()这句创建了一个事件触发器，也就是所谓的事件模块中的EventEmitter类的实例 on(event, listener)用来为某个事件event添加事件处理方法监听器 emit(event, [arg1], [arg2], [...])方法用来产生事件。以提供的参数作为监听器函数的参数，顺序执行监听器列表中的每个监听器函数。 在Node中，存在各式各样不同的数据流，Stream（流）是一个由不同对象实现的抽象接口。 例如请求HTTP服务器的request是一个流，类似于stdout（标准输出）；包括文件系统、HTTP 请求和响应、以及 TCP/UDP 连接等。流可以是可读的，可写的，或者既可读又可写。所有流都是EventEmitter的实例，因此可以产生各种不同的事件。 可读流主要会产生以下事件： data： 当读取到流中的数据时，此事件被触发 end： 当流中没有数据可读时，此事件被触发 error： 当读取数据出现错误时，此事件被触发 close： 当流被关闭时，此事件被触发，可是并不是所有流都会触发这个事件。（例如，一个连接进入的HTTP request流就不会触发close事件） fd事件 ： 当在流中接收到一个文件描述符时触发此事件。只有UNIX流支持这个功能，其他类型的流均不会触发此事件。 强大的File System文件系统模块Node中的fs模块用来对本地文件系统进行操作。文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。所有的方法都提供了异步和同步两种方式。 fs模块中提供的方法可以用来执行基本的文件操作，包括读、写、重命名、创建和删除目录以及获取文件元数据等。每个操作文件的方法都有同步和异步两个版本。 异步操作的版本都会使用一个回调方法作为最后一个参数。当操作完成的时候，该回调方法会被调用。而回调方法的第一个参数err总是保留为操作时可能出现的异常。如果操作正确成功，则第一个参数的值是null或undefined。 同步操作的版本的方法名称则是在对应的异步方法之后加上一个Sync作为后缀。比如异步的rename()方法的同步版本是renameSync()。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础01 入门]]></title>
    <url>%2F2017%2F03%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8001%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React入门笔记。 简介React是一个用于构建用户界面的JavaScript库，主要用于构建UI，可以认为React是MVC中的 V（视图）。React起源于Facebook的内部项目，用来架设Instagram的网站，并于2013年5月开源。 特点 声明式设计 − React采用声明范式，可以轻松描述应用。 高效 − React通过对DOM的模拟，最大限度地减少与DOM的交互。 灵活 − React可以与已知的库或框架很好地配合。 JSX − JSX是JavaScript语法的扩展。React开发不一定使用JSX，但建议使用。 组件 − 通过React构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 单向响应的数据流 − React实现了单向响应的数据流，减少了重复代码，这也是它为什么比传统数据绑定更简单。 ReactJS的背景和原理在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。 React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。 尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。 这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。 服务器端Render的纯Web页面那么应该知道，服务器端所要做的就是根据数据Render出HTML送到浏览器端。如果这时因为用户的一个点击需要改变某个状态文字，那么也是通过刷新整个页面来完成的。服务器端并不需要知道是哪一小段HTML发生了变化，而只需要根据数据刷新整个页面。 换句话说，任何UI的变化都是通过整体刷新来完成的。而React将这种开发模式以高性能的方式带到了前端，每做一点界面的更新，你都可以认为刷新了整个页面。至于如何进行局部更新以保证性能，则是React框架要完成的事情。 组件化虚拟DOM(virtual-dom)不仅带来了简单的UI开发逻辑，同时也带来了组件化开发的思想。 所谓组件，即封装起来的具有独立功能的UI部件。React推荐以组件的方式去重新思考UI构成，将UI上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。例如，Facebook的instagram.com整站都采用了React来开发，整个页面就是一个大的组件，其中包含了嵌套的大量其它组件。 在React中，按照界面模块自然划分的方式来组织和编写代码，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。 React认为一个组件应该具有如下特征： （1）可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； （2）可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； （3）可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； JSX语法12345678910111213141516&lt;script type="text/babel"&gt; const test = ["xx", "yy", "zz"]; ReactDOM.render( &lt;div&gt; &lt;h1&gt; Hello, world! &lt;/h1&gt; &#123; test.map(function(name)&#123; return &lt;div&gt;nice! &#123;name&#125;&lt;/div&gt; &#125;) &#125; &lt;p&gt; test &lt;/p&gt; &lt;a&gt;&#123;test[1]&#125;&lt;/a&gt; /div&gt;, document.getElementById('example2') );&lt;/script&gt; 上面代码体现了JSX的基本语法规则：遇到HTML标签（以&lt;开头），就用HTML规则解析；遇到代码块（以 {开头），就用JavaScript规则解析。上面代码的运行结果如下： 12345678Hello, world!nice! xxnice! yynice! zztestyy JSX允许直接在模板插入JavaScript变量。如果这个变量是一个数组，则会展开这个数组的所有成员 12345678910111213&lt;script type="text/babel"&gt;const test=[ &lt;h1&gt;this is h1&lt;/h1&gt;, &lt;h2&gt;this is h2&lt;/h2&gt;];ReactDOM.render( &lt;div&gt;&#123;test&#125;&lt;/div&gt;, document.getElementById('example2')); //this is h1//this is h2&lt;/script&gt; 在 JSX 中不能使用if else语句，但可以使用三元运算表达式来替代。 1234567891011121314&lt;script type="text/babel"&gt;const test=[ &lt;h1&gt;this is h1&lt;/h1&gt;, &lt;h2&gt;this is h2&lt;/h2&gt;];const a = true;ReactDOM.render( &lt;div&gt; &#123;a ? test : 'oops'&#125; &lt;/div&gt;, document.getElementById('example2'));&lt;/script&gt; React推荐使用内联样式。可以将样式作为一个对象，插入到模板中并且{}括起来 12345678910111213&lt;script type="text/babel"&gt;let myStyle=&#123; "width": "120px", "background": "#9f9f9f"&#125;;ReactDOM.render( &lt;div style=&#123;myStyle&#125;&gt; &#123; a ? test : 'oops' &#125; &lt;/div&gt;, document.getElementById('example'));&lt;/script&gt; 注释需要写在花括号中 123456&lt;script type="text/babel"&gt;const test=[ &lt;h1&gt;this is h1&lt;/h1&gt;, &lt;h2&gt;this is h2&#123;/* test */&#125;&lt;/h2&gt;];&lt;/script&gt; 组件123456789101112&lt;script type="text/babel"&gt; const MyComponent = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello, &#123;this.props.title&#125;&lt;/div&gt; &#125; &#125;); ReactDOM.render( &lt;MyComponent title="周杰伦" /&gt;, document.getElementById("example") )&lt;/script&gt; 新的React版本不在推荐使用React.createClass()来创建组件，而是使用ES6的class和extends创建组件： 1234567export default class MyComponent extends React.Component &#123; render() &#123; return ( &lt;h1&gt; Hello &#123;this.props.title&#125;&lt;/h1&gt; ); &#125;&#125; 或者使用纯函数式的组件： 1234567const MyComponent = (props) =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;Hello &#123;props.title&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;; 如果仅使用ES5的语法，需要单独引入一个第三方的工具库createReactClass来代替原来的React.createClass()方法创建组件： 1234567var createReactClass = require(&apos;create-react-class&apos;);var MyComponent = createReactClass(&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;); 组件本身的使用和直接使用HTML标签是非常相似的。但是要注意，组件类的第一个字母必须大写，否则会报错。另外，组件类只能包含一个顶层标签，否则也会报错。 组件的用法与原生的HTML标签完全一致，可以任意加入属性，比如&lt;Hello title=&quot;周杰伦&quot; /&gt;，就是 Hello组件加入一个title属性，值为周杰伦。组件的属性可以在组件类的this.props对象上获取。 添加组件属性，有一个地方需要注意，就是class属性需要写成className，for属性需要写成htmlFor，这是因为class和for是JavaScript的保留字。 组件元素的属性可以完全是用户自定义的属性，而DOM元素的属性必须是标签自带属性，使用自定属性必须加上data前缀。 Propsthis.props对象的属性与组件的属性一一对应，但是有一个例外，就是this.props.children属性。它表示组件的所有子节点。 1234567891011121314151617181920212223242526class NotesList extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;// 函数式组件const NotesList = (props) =&gt; &#123; return ( &lt;div&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;;ReactDOM.render( &lt;NotesList&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;world&lt;/p&gt; &lt;/NotesList&gt;, document.body); 上面的NoteList组件有两个&lt;p&gt;子节点，它们都可以通过this.props.children读取，运行结果如下。 12helloworld this.props.children的值有三种可能： 如果当前组件没有子节点，它就是undefined; 如果有一个子节点，数据类型是object； 如果有多个子节点，数据类型就是array。 所以，处理this.props.children的时候要小心。 React提供一个静态方法React.Children来处理this.props.children： 1React.Children.map(this.props.children, v =&gt; v) 使用React.Children.map来遍历子节点，不用担心this.props.children的数据类型是undefined还是object。 propTypes自React v15.5起，React.prototypes已经移入到了另一个包prop-types中，需要单独引入这个库： 12345678910111213import PropTypes from &apos;prop-types&apos;;class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.string&#125;; 指定参数的默认值只需要指定组件的defaultProps属性即可： 1234567891011121314151617// 指定 props 的默认值：Greeting.defaultProps = &#123; name: &apos;Stranger&apos;&#125;;// 如果使用了fransform-class-properties的Babel工具，可以在类中生命静态属性class Greeting extends React.Component &#123; static defaultProps = &#123; name: &apos;stranger&apos; &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125; 如果使用了ES5环境下使用的createReactClass来创建组件，需要使用getDefaultProps函数来设置属性的默认值： 1234567var Greeting = createReactClass(&#123; getDefaultProps: function() &#123; return &#123; name: 'Mary' &#125;; &#125;,&#125;); prop-types提供了多种验证器，可以参考文档来使用。 refs根据React的设计，所有的DOM变动，都先在虚拟DOM上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做DOM diff，它可以极大提高网页的性能表现。但是有些时候必须获取真实的DOM，比如： 管理焦点，文本选择或媒体播放。 触发强制动画。 集成第三方 DOM 库。 需要在虚拟DOM上插入ref属性，这样通过this.ref.[refName]就能获取到真实的DOM节点。要注意的是， 由于this.refs.[refName]属性获取的是真实DOM，所以必须等到真实DOM插入文档以后，才能使用这个属性，否则会报错。 123456789101112131415161718class Greeting extends React.Component &#123; componentWillMount() &#123; console.log(this.refs.myRef, &apos;componentWillMount&apos;); &#125; componentDidMount() &#123; console.log(this.refs.myRef, &apos;componentDidMount&apos;); &#125; render() &#123; return ( &lt;div ref=&quot;myRef&quot;&gt;Hello&lt;/div&gt; ) &#125;&#125;// undefined, componentWillMount// &lt;div&gt;Hello&lt;/div&gt;, componentDidMount 但是在React 16.3版本以后，上面这种方式已经不再被推荐了，引入了React.createRef这个API，来创建ref属性 123456789class Greeting extends React.Component &#123; myRef = React.createRef(); render() &#123; return ( &lt;div ref=&#123;this.myRef&#125;&gt;Hello&lt;/div&gt; ); &#125;&#125; 如果使用的较早版本的React，无法使用React.createRef这个API时，应该使用回调函数形式的refs来代替： 1234567891011class Greeting extends React.Component &#123; componentDidMount() &#123; console.log(this.myRef); &#125; render() &#123; return ( &lt;div ref=&#123;el =&gt; &#123; this.myRef = el &#125;&#125;&gt;Hello&lt;/div&gt; ); &#125;&#125; 这时候引用DOM元素实在回调函数中将DOM元素赋值给实例属性，通过引用实例属性来引用到React的。 要注意，避免使用refs来做任何可以通过声明式实现来完成的事情。比如，避免在Dialog组件里暴露open()和close()方法，最好传递isOpen属性。一定不要过度使用refs，如果一定要通过refs来让触发某个组件的功能，那么应该再反思一下组件的state属性是否可以被提升到父组件中。 另外，不能在函数组件上使用ref属性，应为它们没有实例，可以在函数组件的内部的DOM元素或者class组件上使用ref属性。 statestate组件内部的状态，它是一个对象，完全又组件自身来控制。改变它的方法应该是使用setState方法，当它的值改变后，React会自动调用render方法，重新渲染组件。 注意不能直接修改state的属性值，这不会让组件重新渲染。 定义state有几种方法，当在使用ES5环境下的createReactClass来创建组件时，需要使用getInitialState方法来定义state： 123456var Counter = createReactClass(&#123; getInitialState: function() &#123; return &#123;count: this.props.initialCount&#125;; &#125;, // ...&#125;); 而ES6的class组件中有以下几种方法： （1）在constructor中： 12345678class Greeting extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; x: 1 &#125; &#125;&#125; 这种方式是比较主流的方式，要注意的是，如果显式的声明了constructor方法，必须调用super来获取this对象 （2）直接在class中定义 另外一种方式是直接定义在class中，效果与定义在constructor上一样的，都是定义的类的实例属性。这是ES7的提案，有一定的兼容性问题，最好配合Babel的转换使用。 12345class Greeting extends React.Component &#123; state = &#123; x: 1 &#125;&#125; （3）使用useState在函数组件中定义 这是React16.8中新提出的Hooks API，它让函数式组件也可以拥有了自己的state（以前是不行的）： 123456const Greeting = () =&gt; &#123; const [name] = useState(&apos;Jay&apos;); return ( &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt; );&#125;; 具体关于Hooks API的使用参考文档。 关于state有几个要注意的点： （1）由于componentWillMount生命周期在React 16.8版本中已经被标记为不推荐的方法，有可能在随后的版本中被放弃，所以不要在这个生命周期中初始化state，应该在上面提到的方法中进行初始化。 （2）不要直接修改state，因为这样不会重新渲染组件。 （3）state的更新可能是异步的，React出于性能的考虑，可能会把多个state调用合并为一个调用，因此this.state可能会一步更新，不要依赖它们的值来更新下一个状态。 比如，下面的代码不会更新state.count的值 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 正确的做法是让setState接受一个函数，这个函数的第一个参数是上一个state值，第二个参数是更新时的props值： 12345this.setState((state, props) =&gt; &#123; return &#123; count: state.count + props.increment &#125;; &#125;); 生命周期当前React16.8版本的生命周期： 组件的生命周期分成三个状态 Mounting：创建阶段 Updating：更新阶段 Unmounting：移除阶段 （1）在创建阶段涉及到的生命周期及在该周期内可以完成的功能如下： 1234567891011121314151617181920212223constructor()&#123; // 初始化 state&#125;getDgetDerivedStateFromProps(nextProps, prevState) &#123; // 根据 props 来更新 state // 当 props 改变时，获取外部数据&#125;// 此生命周期在V16.3版本中已被标记为不安全，所以不再推荐使用！！！componentWillMount() &#123; // 初始化 state // 获取外部数据 // 添加事件订阅&#125;render() &#123;&#125;componentDidMount &#123; // 获取外部数据 // 添加事件订阅&#125; （2）在更新阶段涉及到的生命周期及在该周期内可以完成的功能如下： 123456789101112131415161718192021222324252627282930313233getDgetDerivedStateFromProps(nextProps, prevState) &#123; // 根据 props 来更新 state // 当 props 改变时，获取外部数据&#125;// 此生命周期在V16.3版本中已被标记为不安全，所以不再推荐使用！！！componentWillReceiveProps() &#123; // 根据 props 来更新 state // 当 props 改变时，执行相关操作 // 当 props 改变时，获取外部数据&#125;shouldComponentUpdate(nextProps, nextState) &#123; // 判断组件是否应该继续更新&#125;// 此生命周期在V16.3版本中已被标记为不安全，所以不再推荐使用！！！componentWillUpdate(nextProps, nextState) &#123; // 执行外部回调 // 在组件更新之前读取 DOM 节点&#125;render() &#123;&#125;getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 在组件更新之前读取 DOM 节点&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; // 执行外部回调 // 当 props 改变时，执行相关操作、 &#125; （3）销毁阶段 123componentWillUnmount() &#123; // 取消事件订阅&#125; （4）其他 123componentDidCatch() &#123; // 捕获子组件的异常&#125; 综上，React16时期，推荐使用的生命周期如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react'export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); // 初始化state方式（1） this.state = &#123; &#125; &#125; static defaultProps = &#123; &#125; // 初始化state方式（2） state = &#123; &#125; static getDerivedStateFromProps(props, state) &#123; return state &#125; componentDidCatch(error, info) &#123; &#125; render() &#123; &#125; componentDidMount() &#123; &#125; shouldComponentUpdate(nextProps, nextState) &#123; &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; &#125; componentWillUnmount() &#123; &#125;&#125; 网络请求组件的数据来源，通常是通过网络请求从服务器获取，一般网络请求都会放在componentWillMount和componentDidMount生命周期内。 原来我有一个误解，以为如果网络请求放在componentWillMount内，获取到数据后组件才会render，只会执行一次操作，而网络请求放在componentDidMount中，组件会以空数据首先渲染一次，然后再根据网络请求的结果更新组件，多了一次组件更新过程。 但是实际上，由于componentWillMount和render的时间间隔是非常短的，所以网络请求即使放在componentWillMount中，组件也会执行两次渲染过程，基本上无法做到性能优化的。 而且由于componentWillMount已经被被标记为不安全的方法，可能在未来的某个版本中被丢弃，所以网络请求还是应该放在componentDidMount中，在网络请求的回调函数或者then方法中，通过setState重新渲染UI。 Babel编译JSX文件实际生产环境中，不会将JSX文件的转换放在浏览器端进行，需要在上线之前对JSX文件进行预编译。 一般情况下使用类似Create-React-App这样的脚手架工具，会配置好Babel进行预编译。如果需要手动配置的话可以按照下面的步骤： （1）在项目中安装Babel 1npm install --save-dev babel-cli （2）在项目中安装Babel需要的转码规则： 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 （3）配置Babel 新建配置文件文件.babelrc，存放在项目的根目录下。使用Babel必须配置这个文件，根据安装的转码规则，加入配置文件： 12345678&#123; "presets": [ "es2015", "react", "stage-2" ], "plugins": []&#125; （4）在package.json,中增加bulid指令： 123456&#123; // ... "scripts": &#123; "build": "babel src -d lib" // 也可以自定义其他对应的 babel 命令 &#125;,&#125; 转码时执行下面命令即可 1npm run bulid 上面的命令是直接将src文件夹里的文件输出到lib文件夹中 参考 React 入门实例教程@阮一峰的网络日志 Babel 入门教程@阮一峰的网络日志 使用 PropTypes 进行类型检查@React Refs and the DOM@React State &amp; 生命周期@React 关于React v16.3 新生命周期@掘金]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git02 常用命令]]></title>
    <url>%2F2017%2F03%2F21%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F12%20Git%2FGit02%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1234- Workspace：工作区- Index / Stage：暂存区- Repository：仓库区（或本地仓库）- Remote：远程仓库 1 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [版本库的网址] [本地目录名] 1.1 git init用init命令进行GIT项目的初始化： 1$ git init 这个命令会为你创建.git的目录，并生成一些基本的信息。仅进行初始化没有生成master branch，也没有任何commit的信息。需要自己做第一个commit(root commit)，这时GIT会为你自己生成master branch。 12C:\workspace\git\startuproject&gt;git add README.txtC:\workspace\git\startuproject&gt;git commit -m "initialization" 1.2 git clone每个项目都有一个 Git 目录，它是Git用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 执行如下命令以创建一个本地仓库的克隆版本： 1git clone /path/to/repository 如果是远端服务器上的仓库，该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 1$ git clone https://github.com/notechsolution/gitDemo.git mylibgit 以上命令告诉GIT：用https协议从github.com/notechsolution/gitDemo.git把代码克隆下来，并且放在本地的mylibgit目录下面。 关于checkout分支，clone的时候如果不指明，则默认checkoutmaster分支，如果需要，则可以在clone命令的最后用-b参数 指明： 1$ git clone https://github.com/notechsolution/gitDemo.git mygitdemo -b test 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 123$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery 2 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 12345678910111213# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]"# 增加提交代码时的用户信息$ git config -add [--global] user.name "[name]"$ git config -add [--global] user.email "[email address]" 读取配置文件时GIT会查看你项目里面.git\config这个文件，如果没有配置，则再读取用户目录（%HOMEPATH%）下的.gitconfig文件。 我们可以直接把作者的用户名和email配置写到这些文件里面，也可以通过命令行写进去。通过git config –add添加的配置参数时,该参数加到项目里面的.git\config，而如果是通过git config –add –global的话，那么将添加到全局环境里面，也就是所有的项目都共享这个config。 3 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 4 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 在所有的版本控制系统中，每一个commit都有4W 要素(Who-When-Why-What) Who: 谁做了这些代码改动，并提交了commit， When: 什么时候做的这个commit （请注意：这个时间是做git commit命令的时候，而不是你push的时间） Why: 这个commit是为了什么而做的。也就是commit message What: 列出这个commit究竟做了哪些改动，增删改了哪些文件的内容 以上4W要素中，when是系统生成的，why是用户自己写的（在提交commit的时候，commit –m “message”，其中的message就是why)，what是GIT从暂存区detect出来的，而who是从配置文件读取的。 commit时如果没有加上-m参数，系统也会需要输入提交信息，进入编辑器：按i进入插入状态，编写提交信息。按Esc键退出插入状态，然后:wq退出保存即可。 5 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream-to [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 除非将分支推送到远端仓库，不然该分支就是不为他人所见的 6 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 7 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 显示远程分支提交历史$ git log origin/master -n 3 8 远程同步1234567891011121314151617181920212223242526272829# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 删除远程主机。$ git remote rm &lt;主机名&gt;# 远程主机的改名$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 需要记住，fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。 可以使用git pull命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下git clone命令本质上就是自动创建了本地的master分支用于跟踪远程仓库中的master分支（假设远程仓库确实有master分支）。所以一般我们运行git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。 8.1 git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。merge之前需要先却换到需要被merge的分支上。 12$ git checkout master$ git merge origin/master 上面命令表示在当前分支上，合并origin/master。 8.2 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样 1$ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 12$ git fetch origin$ git merge origin/next 如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数-p就会在本地删除远程已经删除的分支。 1234$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p 8.3 git pushgit push命令用于将本地分支的更新，推送到远程主机。 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 1$ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支。 可以使用下面的命令建立本地分支和远程分支之间的追踪关系，这样在push的时候就不必每次都输入远程分支的名字，更不会因为忘记输入远程分支名，而master分支未开启保护的情况下，导致误推到master分支上 1git branch --set-upstream-to=origin/remote_branch your_branch 其中，origin/remote_branch是你本地分支对应的远程分支，your_branch是你当前的本地分支。 9 撤销123456789101112131415161718192021222324252627# 恢复指定文件，工作区没有add的（没有提交到暂存区）的修改$ git checkout [file] # 恢复所有文件，工作区没有add的（没有提交到暂存区）的修改$ git checkout .# 撤销commit，保留工作空间改动代码，保留add$ git reset --soft [file] [commit] # 撤销commit，保留工作空间改动代码，撤销add（不加参数时的默认值)$ git reset --mixed [file] [commit] # 撤销commit，删除工作空间改动代码，撤销add$ git reset --hard [file] [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未add的变化移除，存储起来$ git stash# 恢复stash的变化$ git stash pop# 修改commit注释$ git commit -amend 参考 Git远程操作详解@阮一峰的网络日志 GIT - 一些基本概念@CSDN git使用情景2：commit之后，想撤销commit@CSDN]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解02 构造函数的继承]]></title>
    <url>%2F2017%2F02%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A302%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JavaScript中的继承。 如何继承现在有一个”动物”对象的构造函数 123function Animal() &#123; this.spices = "动物"&#125; 还有一个”猫”对象的构造函数。 12345function Cat(name, age) &#123; this.name = name; this.age = age;&#125;var cat1 = new Cat("tom", 23); 此时，二者是没有关系的 12console.log(cat1.spices) // undefined 怎样才能使”猫”继承”动物”呢？ 1 构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行： 12345678910111213function Animal() &#123; this.spices = "动物"&#125;Animal.prototype.say = "hello";function Cat(name, age) &#123; Animal.apply(this, arguments); // 加入构造函数绑定 this.name = name; this.age = age;&#125;var cat1 = new Cat("tom", 23);console.log(cat1.spices); // 动物console.log(cat1.say); // undefined 这种方法用call/apply把父对象的this指向改为子对象。 缺点：不能继承原型上的属性和方法 2 prototype模式第二种使用prototype属性，即把子对象的prototype对象指向父对象的一个实例。（注意：当改了prototype对象的constructor时，记得改回来，否则将造成继承链紊乱，后面所有涉及改动子类的prototype的方法都要注意） 比如Cat的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。 123456789101112131415function Animal() &#123; this.spices = "动物"&#125;function Cat(name, age) &#123; this.name = name; this.age = age;&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("tom", 24);console.log(cat1.name + "今年年纪" + cat1.age + "岁，是一种" + cat1.spices);// tom今年年纪24岁，是一种动物 通过Cat.prototype = new Animal()，我们将Cat的prototype对象指向一个Animal的实例,它相当于完全删除了prototype对象原先的值，然后赋予一个新值。 任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。因此，在运行Cat.prototype = new Animal();这一行之后，cat1.constructor也指向Animal！ 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。 这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象， 12&gt; o.prototype = &#123;&#125;;&gt; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。 12&gt; o.prototype.constructor = o;&gt; 这种方法的缺点：执行并且建立了一个Animal的实例（其实是没有实质意义的）会浪费内存。 直接将b赋值给a，a = b，会导致二者指向内存同一个地址，对其中一个的更改对会另外一个产生影响（也就是浅赋值）。但是实例化相当于给构造函数一个子元素，对子元素的更改不会影响到上层，也就是说构造函数的相关属性不会变化。 3 直接继承prototype直接继承prototype，即child.prototype = parent.prototype; 由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过Animal()，直接继承Animal.prototype。 12345678910111213function Animal() &#123;&#125;Animal.prototype.spices = "动物";function Cat(name, age) &#123; this.name = name; this.age = age;&#125;Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("tom", 24);console.log(cat1.name + "今年年纪" + cat1.age + "岁，是一种" + cat1.spices); //tom今年年纪24岁，是一种动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。 缺点是Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 所以，上面这一段代码其实是有问题的。请看第二行 1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！ 1alert(Animal.prototype.constructor); // Cat 这种方法相比第二种效率更高，比较省内存，因为节省了创建父类实例的过程，缺点是子对象的prototype对象修改后父对象的prototype也会被修改; 4 利用空对象作为中介由于”直接继承prototype“存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。 12345678910111213141516function Animal() &#123;&#125;Animal.prototype.spices = "动物";function Cat(name, age) &#123; this.name = name; this.age = age;&#125;var F = function() &#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat;var cat1 = new Cat("tom", 24);console.log(cat1.name + "今年年纪" + cat1.age + "岁，是一种" + cat1.spices);console.log(Animal.prototype.constructor === Cat); //false F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。 可以将上面的方法封装成为一个函数，便于使用（YUI就是使用这种方法实现继承）： 1234567function extend(Child, Parent) &#123; var F = function() &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 另外，说明一点，函数体最后一行 1Child.uber = Parent.prototype; 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 5 利用拷贝实现继承上面是采用prototype对象，实现继承。也可以换一种思路，纯粹采用“拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象。 首先，还是把Animal的所有不变属性，都放到它的prototype对象上。 12345function Animal() &#123;&#125;Animal.prototype.spices = "动物";Animal.prototype.say = function() &#123; alert("333")&#125;; 然后，再写一个函数，实现原型上属性拷贝的目的。 12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象prototype对象。使用的时候，这样写： 12345extend2(Cat, Animal);var cat1 = new Cat("tom", 24);console.log(cat1.name + "今年年纪" + cat1.age + "岁，是一种" + cat1.spices);console.log(Animal.prototype.constructor === Cat); //falsecat1.say(); 6 使用Object.setPrototypeOfObject.setPrototypeOf方法设置一个指定的对象的原型（即内部的__proto__属性到另一个对象） 1Object.setPrototypeOf(Cat.prototype, Animal.protoype) 执行之后，相当于执行写下面的操作： 1Cat.prototype.__prot__ = Animal.prototype 7 使用ES6的class和extends实现继承对于ES6的class，使用extends实现继承 12345class Cat extends Animal &#123; constructor (...props) &#123; super (...props) &#125;&#125; 类的继承模式分为了三种： 类的实例属性是通过class内部的constructor里的super实现的 类的原型上的属性是通过Object.setPrototypeOf(B.prototype, A.prototype)实现的 类的静态属性是通过Object.setPrototypeOf(B, A)实现的 8 小总结 如果是单单继承父函数内部的属性和方法可以使用Call()或者Apply()方法 如果是单单继承原型链的方法，可以遍历父函数的prototype来实现继承 最简便的方法目前看也是使用原型链prototype，令子函数的prototype成为父函数的一个实例，可以同时继承父函数内部和原型链的属性和方法 方法 总结 在子类函数内部使用call或者apply加入构造函数绑定 只能继承构造器里的属性 把子对象的prototype对象指向父对象的一个实例。 既能继承构造器里的属性,也能继承原型上的属性 令子类的prototype直接等于父类的prototype 只能继承原型上的属性和方法 用空对象函数作为中介,空对象的原型等于父类原型，子类原型为空对象实例 只能继承原型上的属性和方法 通过拷贝继承原型上的方法 只能继承原型上的属性和方法 通过Object.setPrototypeOf实现 只能继承原型上的属性和方法 通过extends实现class的继承 同时实现实例属性、原型链以及静态属性的继承 参考 Javascript面向对象编程（二）：构造函数的继承@阮一峰的网络日志 Object.setPrototypeOf()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语言理解01 Javascript中的封装]]></title>
    <url>%2F2017%2F02%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2F01%20%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%2FJS%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A301%20Javascript%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JavaScript中的封装。 1 封装1.1 私有变量和私有函数JavaScript的函数作用域，在函数内定义的变量和函数如果不对外提供接口，那么外部将无法访问到，也就是变为私有变量和私有函数。 12345function animal(name)&#123; var type=&quot;cat&quot;,//私有变量 say=function()&#123;alert(&quot;wawawa&quot;)&#125;;//私有函数&#125;alert(type);//undefined 在函数对象animal外部无法访问变量type和函数say，它们就变成私有的，只能在animal内部使用，即使是函数animal的实例仍然无法访问这些变量和函数. 12var dog=new animal(&quot;seven&quot;);alert(dog.type);//undefined 1.2 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 12345678function animal(name,age)&#123; this.name=name; this.age=age;&#125;var cat=new animal(&quot;tom&quot;,23);var dog=new animal(&quot;jerry&quot;,24);console.log(cat.name);//tomconsole.log(dog.age);//24 cat和dog会自动含有一个constructor属性，指向它们的构造函数。 1console.log(cat.constructor===animal);//true Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。1console.log(cat instanceof animal);//true 注意，instanceof是一个操作符，不是一个方法，所以用法是a instanceof b 1.3 构造函数的问题12345678910function animal(name,age)&#123; this.name=name; this.age=age; this.type=&quot;animal&quot;; this.say=function()&#123;alert(&quot;hello&quot;)&#125;&#125;var cat=new animal(&quot;tom&quot;,23);var dog=new animal(&quot;jerry&quot;,24);console.log(cat.type);//animaldog.say();//hello 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和say()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。 1console.log(cat.say===dog.say);//false 利用原型（Prototype）模式就可以让type属性和say()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢从而提升性能。 1.4 原型Prototype无论什么时候，只要创建了一个新函数，该函数就会有一个prototype属性，这个属性也是一个对象，默认情况下prototype属性会默认获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针（即函数自己）。 123456789101112function animal(name,age)&#123; this.name=name; this.age=age;&#125;animal.prototype.type=animal;animal.prototype.say=function()&#123; alert(&quot;hello&quot;)&#125;;var cat=new animal(&quot;tom&quot;,23);var dog=new animal(&quot;jerry&quot;,24);console.log(cat.__proto__.constructor.name);//animalconsole.log(animal.prototype.constructor.name);//animal 构造函数的prototype的constructor指向构造函数本身，而实例的将包含一个__proto__指针，指向构造函数的prototype。 注意，实例是没有prototype属性的，通过new关键字声明的实例获得的是指向其构造函数的prototype的__proto__指针。 每一个函数被创建时，都会自动的拥有prototype属性。这个属性并无什么特别之处，它和其他的属性一样可以访问，可以赋值。不过当我们用 new关键字来创建一个对象的时候，prototype就起作用了：它的值（也是一个对象）所包含的所有属性，都会被关联到新创建的实例对象的__proto__指针上。 1.5 利用原型Prototype创造实例每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。 就像上面的例子一样，此时所有实例的type和say方法都是指向同一个内存地址，提高了运行效率。 1console.log(cat.say===dog.say);///true 1.6 Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 1.6.1 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。 123console.log(animal.prototype.isPrototypeOf(cat));//trueconsole.log(animal.prototype.isPrototypeOf(dog));//trueconsole.log(animal.prototype.isPrototypeOf(animal));//false 1.6.2 hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性 123console.log(cat.hasOwnProperty(&quot;name&quot;));//trueconsole.log(cat.hasOwnProperty(&quot;say&quot;));//false 1.6.3 in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性. 12console.log(cat.hasOwnProperty(&quot;say&quot;));//falseconsole.log(&quot;say&quot; in cat);//true in运算符还可以用来遍历某个对象的所有属性. 123456789for(var i in cat)&#123; var str=&quot;&quot;; str=&quot;cat[&quot;+i+&quot;]:&quot;+cat[i]; console.log(str)&#125;/*运行结果cat[name]:tomtest11.js:29 cat[age]:23test11.js:29 cat[say]:function ()&#123;alert(&quot;hello&quot;)&#125;*/ 1.7 注意事项1 只能把不变的属性和方法，绑在prototype对象上，而不能把可变属性绑上去。 2 用new的这种方法构造对象，如果忘记加上new，“既没有编译时警告，也没有运行时警告”，所以为了避免忘记加 new，最好的办法是类名首字母大写。 参考 http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html http://www.jb51.net/article/40964.htm]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础18 跨域知识总结]]></title>
    <url>%2F2016%2F12%2F06%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8018%20%E8%B7%A8%E5%9F%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[跨域知识总结。 跨域及产生原因什么是跨域跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com页面去请求www.google.com的资源。 跨域的严格一点的定义是：协议（http&amp;https）、端口(80&amp;81)、域名（baidu&amp;google）、二级域名（news&amp;sports）不相同，都为跨域。 受到跨域的限制，浏览器不能用AJAX获取不同源的数据，也不能在同一个页面但是处于不同域的框架之间的进行数据传递。 123456789101112131415161718192021URL 说明 是否允许通信http://www.domain.com/a.js 同一域名，不同文件或路径 允许http://www.domain.com/b.js http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.js 同一域名，不同端口 不允许http://www.domain.com/b.js http://www.domain.com/a.js 同一域名，不同协议 不允许https://www.domain.com/b.js http://www.domain.com/a.js 域名和域名对应相同ip 不允许http://192.168.4.12/b.js http://www.domain.com/a.js 主域相同，子域不同 不允许http://x.domain.com/b.js http://domain.com/c.js http://www.domain1.com/a.js 不同域名 不允许http://www.domain2.com/b.js 为什么浏览器要限制跨域访问==首先要注意，跨域是浏览器的限制，服务端不存在跨域的问题~== 原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题： 用户访问www.mybank.com，登陆并进行网银操作，这时浏览器会生成对应的cookie。用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站www.xiee.com，这时该网站就可以在它的页面中，拿到银行的cookie，cookie中可能存放着很多敏感信息比如用户名，登陆token等，然后发起对www.mybank.com的操作。如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。 为什么要跨域有时公司内部有多个不同的子域，比如一个是location.company.com, 而应用是放在app.company.com, 这时想从app.company.com去访问location.company.com的资源就属于跨域。 不受跨域限制的情况有两种情况是不受浏览器同源策略的限制的，第一种是HTML标签中像&lt;srcipt&gt;、&lt;img&gt;等获取资源的标签是没有跨域限制的，第二种是提交表单是不受跨域的限制的。 要注意的是，表单提交只有通过指定表单的action这种形式才是不受跨域限制的，而通过Ajax手动控制表单提交的情况还是会收到跨域的限制的。 这是因为通过action提交表单，剩余的操作就交给了action里面的域，本页面的逻辑和这个表单没关系，不需要表单里的域的吓响应，所以浏览器认为是安全的。 而使用Ajax来发送表单的请求的时候，页面JS会需要知道请求的返回值，这个时候表单的情况会收到跨域的限制。 跨域限制的是哪个步骤当我们尝试发送一个跨域请求的时候，会被浏览器阻止，在控制台收到错误信息： 我们是收不到对方服务器的返回结果的，但是浏览器阻止的究竟是请求的发出还是响应的读取呢？ 首先使用Koa2搭建一个HTTP服务，运行在8080端口： 123456789101112const Koa = require('koa');const app = new Koa();app.use(async (ctx) =&gt; &#123; console.log('收到跨域请求', ctx.request.query.test); ctx.body = &#123;val: 'node'&#125;; ctx.cookies.set('userId', '123');&#125;);app.listen(8080, () =&gt; &#123; console.log('app is listening 8080...');&#125;); 前端页面运行在http://localhost:63342，当页面访问http://localhost:8080进行跨域请求接口数据的时候，浏览器由于跨域的原因报错，没有收到服务器响应的数据，并且cookie也没有写入成功。 但是服务端的控制台会显示这次请求的信息： 证明，浏览器的同源策略，并没有限制请求的发送，而是在浏览器接受响应数据前进行了检查和限制。 为什么这样限制呢？因为有可能服务端进行了允许特定网站的跨域请求，浏览器如果从发送请求就限制住，那么就不存在任何跨域的可能性了，所以需要根据服务端返回的结果在进行检查，是要限制还是将数据解析展示。 跨域的方法跨域类型我个人觉得可以分为两种，一种是接口跨域，也就是需要跨域去请求接口，返回服务端的数据，是页面与服务端的通信；另外一种是页面跨域，是两个页面间的通信，可能是两个Tab间的通信，也可能是主页面与iframe之间的通信。 接口跨域的方法： 动态创建script JSONP CORS Nginx反向代理跨域 利用后端转发请求跨域 &lt;img&gt;标签 Websocket SSE + EventSource 页面跨域的方法： document.domain window.name postMessage 接口跨域（1）动态创建script由于HTML标签中像&lt;srcipt&gt;、&lt;img&gt;等获取资源的标签是没有跨域限制的，利用这一点就可以实现跨域。 在本地定义一个方法cb，在一个&lt;srcipt&gt;标签中的src访问跨域的目标地址，并通过查询参数将函数名传递给服务端。服务端在接受到请求后将数据作为cb的参数，返回序列化的cb(params)。 由于请求是由&lt;script&gt;标签发出的，所以接受到服务端的结果后就会立即调用cb，并且参数就会返回的数据。 前端代码： 1234567&lt;script type="text/javascript"&gt; var localHandler = function(data) &#123; console.log('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;;&lt;/script&gt;&lt;!-- 这个标签可以通过 document.createElement 动态创建 --&gt;&lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt; 服务端代码（使用Node）： 1234567891011121314151617181920var http = require('http');var urllib = require('url');var port = 8081;var data = &#123;'name': 'jifeng', 'company': 'taobao'&#125;;http.createServer(function(req, res)&#123; // 解析参数 var params = urllib.parse(req.url, true); if (params.query &amp;&amp; params.query.callback) &#123; // JSONP var str = params.query.callback + '(' + JSON.stringify(data) + ')'; res.end(str); &#125; else &#123; res.end(JSON.stringify(data)); &#125; &#125;).listen(port, function()&#123; console.log('server is listening on port ' + port); &#125;) 这种方式比较常用，只要服务端部署了响应的代码，前端按照约定传递一个callback的查询参数即可，但是要注意的就是对XSS的防范，防止攻击者构造特殊的callback代码，实现注入攻击。 可以将创建&lt;script&gt;标签的过程封装起来 123456function getJSON (url, callBack) &#123; const src = `$&#123;url&#125;?callback=$&#123;callBack&#125;`; const script = document.createElement('script'); script.src = src; document.body.appendChild(script);&#125; （2）JSONPJSONP就是对上面的方法的一个封装，一种是get/getJSON的方式，另一种是$.ajax()的方式，都支持GET请求，不支持POST请求。 前端代码： 12345678910111213141516171819//getJOSN方法$.getJSON("http://localhost:8080/msg/front/jcj/t1.jsp?callback=?", function(result) &#123;&#125;);//ajax方法$.ajax(&#123; type: "get", url: "http://localhost:8080/msg/front/jcj/t1.jsp", //也可以直接将callback写在url中 //url: "http://localhost:8080/msg/front/jcj/t1.jsp?callback=m1", dataType: "jsonp", jsonpCallback: "m1", success: function(data) &#123; //处理返回的数据 &#125;&#125;);function m1(data) &#123; alert(data);&#125; 第一种方式的callback=?回调函数标志着Ajax请求是以JSONP的方式发送请求，客户端请求会自动在问号处增加一个方法名，方法名是以jquery开头的一串数字 而第二种方式的是参数dataType=&quot;jsonp&quot;来说明是以JSONP的方式发送请求，所以可以直接在callback后面直接指定方法名callback=m1，而不需要jsonpCallback: &quot;m1&quot;这一行代码。 （3）CORS（跨域资源共享）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing），这种跨域方式如果不携带cookie跨域，那么前端发送请求不需要额外处理，如果需要携带cookie，那么需要添加withCredential: true这个字段 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 主要的工作量都在后端代码，来设置响应头，如果是简单请求，那么只需要设置Access-Control-Allow-Origin即可，如果是非简单请求那么需要同时设置Access-Control-Allow-Origin、Access-Control-Request-Method和Access-Control-Allow-Headers，如果需要跨域那么还需要额外设置Access-Control-Allow-Credentials 一般都会使用专门的中间件来帮助我们完成，比如koa-cors。 （4）Nginx反向代理跨域 以前其实并不了解Nginx跨域的原理，其实就是利用了服务度不存在跨域的原理，前端JS访问自己本地的资源，而Nginx将访问跨域目标的请求进行了拦截，将请求转发到真实的地址，获取到数据。 上面的的方法都有一个共同的限制，那就是必须在要跨域的目标服务器上进行相应的部署，但是有一种最常遇到的情形，就是想要获取的数据的网站是不受自己控制的，开发者只能控制一个域。 这时候可以通过Nginx进行反向代理跨域，具体的配置可以参考这篇笔记《零散专题33 Nginx （5）利用后端转发请求跨域除了使用Nginx，也可以使用其他的框架来进行本地请求的转发，比如如果使用Node的Express框架编写的服务端程序，那可以使用request模块进行请求转发，实现跨域请求。 123456var request = require('request');app.use('/api', function(req, res) &#123; var url = apiUrl + req.url; req.pipe(request(url)).pipe(res);&#125;); 上面完整的请求传递给API，并且将相应传递给请求的发起者，支持GET/PUT/DELETE的其他请求方式 使用的时候，前端只需将需要跨域的请求请求到/api地址，将真实地址放到查询参数中： 1234export const QUERY_URL = 'https://wallstreetcn.com/live/global';const X_URL = `/api/proxy?url=$&#123;encodeURIComponent(QUERY_URL)&#125;`;fetch(X_URL).then(v =&gt; console.log(v.text())) （6）&lt;img&gt;标签使用&lt;img&gt;标签原理与使用&lt;srcipt&gt;的原理是相同的，&lt;img&gt;标签不存在跨域的问题，可以访问任意其他网页的图片，并且可以通过onload和onerror事件了解到响应是何时完成的 1234567let img = new Image();img.onload = img.onerror = function () &#123; alert('done')&#125;img.src = 'http://www.baidu.com/test?name=123' 当img的src被设置那一刻，请求就发出了，服务器的响应一般是像素图或204 No-Content 一般用来跟踪用户点击页面或动态广告曝光字数，是一种==单向的跨域方式==，==只能是GET请求==，并且无法访问服务器的相应文本。 （7）WebsocketWebsocket建立的连接不存在跨域问题，因此可以通过建立Websocket打开到任何站点的俩进阶，至于是否可以与页面通信，完全取决于服务器（通过握手信息就可以知道请求来自何方） 前端代码： 123456789101112131415161718192021&lt;div&gt;user input： &lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;); &#125;); document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value); &#125;;&lt;/script&gt; 服务端Node代码： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); （8）SSE + EventSourceSSE（server-sent events）是服务器发送事件，是一种服务器向客户端推送的单向通信技术。它的API就是EventSource接口 URL可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开withCredentials属性，表示是否一起发送Cookie。 1234567891011121314151617181920212223242526272829303132333435if (window.EventSource) &#123; // 参数是一个URL，可以使与当前网址同域，也可以跨域 // 打开withCredentials属性，表示是否一起发送Cookie。 const source = new EventSource('myEvent.com', &#123; withCredentials: true &#125;); // EventSource实例的readyState属性，表明连接的当前状态 if (source.readyState === 0) &#123; // 0 相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。 &#125; else if (source.readyState === 1) &#123; // 1 相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。 &#125; else if (source.readyState === 2) &#123; // 2 相当于常量EventSource.CLOSED，表示连接已断，且不会重连。 &#125; // 连接一旦建立，就会触发open事件，可以在onopen属性定义回调函数。 source.addEventListener('open', function(event) &#123; // ... &#125;, false); // 客户端收到服务器发来的数据，就会触发message事件，可以在onmessage属性的回调函数。 source.addEventListener('message', function(event) &#123; var data = event.data; // handle message &#125;, false); // 如果发生通信错误（比如连接中断），就会触发error事件，可以在onerror属性定义回调函数。 source.addEventListener('error', function(event) &#123; // handle error event &#125;, false); // close方法用于关闭 SSE 连接。 source.close();&#125; 页面跨域（1）document.domain + iframe适用于主域相同，子域不同的情况，并且需要对跨域的两个网页的JS脚本都进行修改。例如在http://www.a.com/a.html和http://script.a.com/b.html之间的跨域就可以使用这种方法。 主域名是不带www的域名，比如a.com， 主域名带前缀的通常是二级域名或者多级域名，比如www.a.com。 首先在a.html中添加下面的 1234567891011121314151617// a.html// 设置共同的 domaindocument.domain = "a.com";var ifr = document.createElement("iframe");ifr.src = "ttp://script.a.com/b.html";ifr.style.display = "none";document.body.appendChild(irf);ifr.onload = function() &#123; //在这里操作b.html的contentWindow var contentWindow = ifr.contentDocument; console.log(contentWindow.message); // hello // 还可以获取 document var doc = ifr.contentDocument || contentWindow.document;&#125; 将b.html通过iframe添加到a.html页面下，也需要在b.html中设置相同的domain 123456// b.html// 设置共同的 domaindocument.domain = "a.com";// 添加数据window.message = 'hello' 这样就将两个原本跨域的网页的域统一了，此时就和平时同一个域镶嵌iframe一样，通过iframe的contentDocument中就可以实现数据交互。 页面默认的domain是window.loaction.hostname，document.domain只能设置成自身或更高一级的父域，比如a.b.example.com中的某个页面的document.domain可以设置为a.b.example.com、b.example.com、example.com，但是不能是设置为c.a.b.example.com或baidu.com。 因此为保证两个主域相同，子域不同的页面跨域，二者的document.domain只能设置为二者的共同的主域，即a.com 这种方法依赖于iframe，iframe的缺点也是一堆，现在的大部分网站避免使用iframe。 历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。现在，应该使用iframe的例子如： 沙箱隔离。 引用第三方内容。 独立的带有交互的内容，比如幻灯片。 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。 缺点也很明显：大量使用，打开一个网页加载过多iframe体验很不友好而且影响网页加载速度，对爬虫不够友好。 （2） window.name将JSON格式的数据写入到window.name中，通过共享一个Tab窗口的两个页面的共同的window.name实现跨域的数据传递 window.name属性在一个窗口（window）生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写权限。 window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而重置。window.name只能是字符串，最大允许2M左右数据。 这种方法的限制太多，不展开了。 （3）postMessage页面和其打开的新窗口的数据传递、页面与嵌套的iframe消息传递都可以使用postMessage方法跨域或同源传递数据。 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1window.postMessage(message, targetOrigin); message是要发送的数据，可以是JavaScript的任意基本类型或可复制的对象，但是出于兼容性考虑，最好使用JSON.stringify()方法对对象参数序列化。 targetOrigin用来限制otherWindow对象所在的域，指明目标窗口的URL，可以将参数设置为”*“传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 接受消息的页面通过通过监听window的message事件获取传过来的消息，消息内容存储在message事件对象的data属性中。 123window.addEventListener("message", function(e)&#123; console.log(e.data)&#125; （4）代码示例 a.com上的a.html的代码： 123456789101112&lt;iframe id="ifr" src="b.com/b.html"&gt;&lt;/iframe&gt;&lt;!--对接受信息页面的引用--&gt;&lt;script type="text/javascript"&gt; window.onload = function() &#123; var ifr = document.getElementById("ifr").contentWindow; //获取框架的window对象 var targetOrigin = "http://b.com" //对目标的限定 setTimeout(() =&gt; &#123; ifr.postMessage("i love you", targetOrigin); &#125;) &#125;&lt;/script&gt; b.com上的b.html的代码： 123456789&lt;script type="text/javascript"&gt; window.addEventListener("message", function(event) &#123; //注册message事件用来接收消息 if (event.origin === "http://a.com") &#123; //通过origin判断消息来源地址 alert(event.data); //通过data属性获取"i love you" alert(event.source); //对a.com/a.html中window对象的引用 alert(event.origin); //发送消息窗口的源（协议+主机+端口号） &#125; &#125;, false)&lt;/script&gt; 参考 跨域与跨域访问@CSDN Iframe 有什么好处，有什么坏处？国内还有哪些知名网站仍用Iframe，为什么？有哪些原来用的现在抛弃了？又是为什么？@知乎 Iframe 有什么好处，有什么坏处？国内还有哪些知名网站仍用Iframe，为什么？有哪些原来用的现在抛弃了？又是为什么？@知乎 html5 postMessage解决跨域、跨窗口消息传递@博客园 jQuery的Ajax的跨域请求@博客园 jquery中ajax处理跨域的三大方式@脚本之家 为什么提交表单不受同源政策限制@segmentfault 同源策略和跨域请求研究@博客园]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
</search>
