<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络基础18 跨域知识总结]]></title>
    <url>%2F2019%2F06%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8018%20%E8%B7%A8%E5%9F%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[跨域知识总结。 跨域及产生原因什么是跨域跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com页面去请求www.google.com的资源。 跨域的严格一点的定义是：协议（http&amp;https）、端口(80&amp;81)、域名（baidu&amp;google）、二级域名（news&amp;sports）不相同，都为跨域。 受到跨域的限制，浏览器不能用AJAX获取不同源的数据，也不能在同一个页面但是处于不同域的框架之间的进行数据传递。 1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 为什么浏览器要限制跨域访问==首先要注意，跨域是浏览器的限制，服务端不存在跨域的问题~== 原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题： 用户访问www.mybank.com，登陆并进行网银操作，这时浏览器会生成对应的cookie。用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站www.xiee.com，这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对www.mybank.com的操作。如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。 为什么要跨域有时公司内部有多个不同的子域，比如一个是location.company.com, 而应用是放在app.company.com, 这时想从app.company.com去访问location.company.com的资源就属于跨域。 跨域的方法 document.domain+iframe window.name + iframe postMessage 动态创建script JSONP CORS（跨域资源共享） Nginx反向代理跨域 利用后端转发请求跨域 利用&lt;img&gt;标签 Websocket SSE + EventSource 方法1 document.domain + iframe（1）适用范围： 适用于主域相同，子域不同的情况，并且需要对跨域的两个网页的JS脚本都进行修改。例如在http://www.a.com/a.html和http://script.a.com/b.html之间的跨域就可以使用这种方法。 主域名是不带www的域名，比如a.com， 主域名带前缀的通常是二级域名或者多级域名，比如www.a.com。 （2）如何实现 首先在a.html中创建一个iframe，将b.html通过iframe添加到a.html页面下，然后在www.a.com/a.html和http://script.a.com/b.html中都增加JS脚本，脚本中加入代码： 1document.domain = "a.com" 这样就将两个原本跨域的网页的域统一了，此时就和平时同一个域镶嵌iframe一样，通过iframe的contentDocument中就可以实现数据交互。 页面默认的domain是window.loaction.hostname，document.domain只能设置成自身或更高一级的父域，比如a.b.example.com中的某个页面的document.domain可以设置为a.b.example.com、 b.example.com、 example.com，但是不能是设置为c.a.b.example.com或baidu.com。 因此为保证两个主域相同，子域不同的页面跨域，二者的document.domain只能设置为二者的共同的主域，即a.com iframe元素就是文档中的文档，拥有自己的事件,拥有自己的窗口对象(contentWindow)。浏览器会在打开一个HTML文档时创建一个对应的window对象。 如果一个文档定义了一个或多个框架(即包含一个或多个frame或iframe标签)，浏览器就会为原始文档创建一个window对象，再为每个框架创建额外的window对象。这些额外的对象是原始窗口的子窗口，可能被原始窗口中发生的事件所影响。contentWindow属性是指指定的frame或者iframe所在的window对象，contentWindow兼容各个浏览器，可取得子窗口的window对象[2]。 （3）限制 要实现跨域，a、b两个页面都必须由你自己来开发，对不受控制的对方进行跨域时无能为力； 依赖iframe，iframe的缺点也是一堆，现在的大部分网站避免使用iframe。 历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。现在，应该使用iframe的例子如： 沙箱隔离。 引用第三方内容。 独立的带有交互的内容，比如幻灯片。 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。 缺点也很明显：大量使用，打开一个网页加载过多iframe体验很不友好而且影响网页加载速度，对爬虫不够友好。 （4）代码示例 www.a.com上的a.htm增加脚本： 1234567891011document.domain = "a.com";var ifr = document.createElement("iframe");ifr.src = "ttp://script.a.com/b.html";ifr.style.display = "none";document.body.appendChild(irf);irf.onload = function() &#123; var doc = irf.contentDocument || ifr.contentWindow.document; //在这里操作b.html的contentWindow&#125; script.a.com上的b.html增加脚本： 1document.domain="a.com"; 方法2 window.name + iframe（1）适用范围 适用于控制跨域双方代码的情况，也就是说需要对方的支持。 （2）如何实现 将JSON格式的数据写入到window.name中，通过共享一个窗口的两个页面的共同的window.name实现跨域的数据传递 window.name属性在一个窗口（window）生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写权限。 window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而重置。window.name只能是字符串，最大允许2M左右数据，可以传递JSON格式的数据。 a.html和b.html可以通过window.location实现同一个窗口下的跳转，这样a就可以取得b页面中window.name中写入的数据。 如果想要不同源的a页面在不由b页面跳转而来的情况下获得数据，就不能直接使用window.location实现，需要利用一个隐藏的iframe来充当跳板，由iframe获取b页面的数据（需要将iframe的src设置为b页面的地址），然后需要将iframe的src再次设置为与a页面同源，a页面再去获取iframe的数据。 （3）限制 同样的，a、b两个页面都必须由你自己来开发，因为需要将数据写入到window.name中，因此对不受控制的对方进行跨域时无能为力； window.name只能是字符串，最大允许2M左右数据，还是有一定限制的。 （4）代码示例 第一种情况就是发生跳转的情况。 页面b.html的代码如下： 1234window.name = "jay111";setTimeout(function() &#123; window.location = "../test10/test10.html"&#125;, 3000) 页面a.htm的代码如下： 1234function doSomething(jsonDate) &#123; alert(window.name)&#125;doSomething() 当b页面跳转a页面后，a会取得在b页面中写入window.name的值jay111。 第二种情况就是不发生跳转，使用iframe作为跳板的情况。 b页面代码如下： 1window.name="jay111"; a页面的代码如下： 12345678910111213141516&lt;body&gt; &lt;iframe id="test" src="b.html"&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById("test"); iframe.onload = function() &#123; // 这里c.html为任意的页面，只需要与a.html同源既可，设置成about:blank也可以 iframe.src = "c.html"; iframe.onload = function() &#123; var data = iframe.contentWindow.name; // 获取a.html中的window.name数据 alert(data); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 注意，更改iframe的src需要在iframe载入后执行，所以添加到onload事件里。 方法3 postMessage（1）适用范围 页面和其打开的新窗口的数据传递、多窗口之间消息传递、页面与嵌套的iframe消息传递都可以使用postMessage方法跨域或同源传递数据。 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 （2）如何实现 window.postMessage(message, targetOrigin)方法是HTML5引入的新特性，用来向其他的window对象发送消息，无论其他的window对象是否跨域。语法如下： 1window.postMessage(message, targetOrigin); message是要发送的string数据，HTML5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化。 targetOrigin用来限制otherWindow对象所在的域，字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*“，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 接受消息的window对象otherWindow是通过监听自身的message事件获取传过来的消息，消息内容存储在message事件对象的data属性中。 123window.addEventListener("message", function(e)&#123; console.log(e.data)&#125; （3）限制 对不受控制的对方进行跨域时无能为力 （4）代码示例 a.com上的a.html的代码： 123456789&lt;iframe id="ifr" src="b.com/b.html"&gt;&lt;/iframe&gt;&lt;!--对接受信息页面的引用--&gt;&lt;script type="text/javascript"&gt; window.onload = function() &#123; var ifr = document.getElementById("ifr").contentWindow; //获取框架的window对象 var targetOrigin = "http://b.com" //对目标的限定 ifr.postMessage("i love you", targetOrigin); &#125;&lt;/script&gt; b.com上的b.html的代码： 123456789&lt;script type="text/javascript"&gt; window.addEventListener("message", function(event) &#123; //注册message事件用来接收消息 if (event.origin === "http://a.com") &#123; //通过origin判断消息来源地址 alert(event.data); //通过data属性获取"i love you" alert(event.source); //对a.com/a.html中window对象的引用 alert(event.origin); //发送消息窗口的源（协议+主机+端口号） &#125; &#125;, false)&lt;/script&gt; 上面的集中方法都主要侧重于前端通讯。 方法4 动态创建script（1）适用范围 两个域开发者都需要控制，被访问的域需要返回一段JS代码。 （2）如何实现 浏览器可以在页面中引用其他域的JS文件，并且执行引入的JS的文件中的function，所以可以通过创建script的方法实现跨域通信。 原理就是在本域内页面a的&lt;script&gt;标签内的SRC指向另外一个域的某个页面b，b通过返回JS代码返回数据。因为&lt;script&gt;的src属性是可以跨域的。 （3）限制 两个域开发者都需要控制。 （4）代码示例 详细代码在总结JSON和JSONP的时候曾经总结过，这里简单的提一下： 在需要跨域的页面动态插入一个script标签，可以动态插入，也可以直接在HTML文件中插入，这个标签的src指向要跨域的目标，然后定义一个函数localHandler，这个函数是供给另外一个域的脚本调用的函数名 123456&lt;script type="text/javascript"&gt; var localHandler = function(data) &#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;;&lt;/script&gt;&lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt; 在remote.js中调用我们本地定义的函数： 1localHandler(&#123;"result":"我是远程js带来的数据"&#125;); 即可跨域成功 这样的问题时，我们必须让远程JS指导我们本地定义的函数名称，这样可以将这个函数名拼到url的查询参数中： 1http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler 方法5 JSONP（1）适用范围 使用返回与上一个方法相同，开发者都需要控制两个域。 （2）如何实现 利用&lt;script&gt;标签的src来实现跨域获取数据，而jQuery的Ajax也正好支持并且封装了这种方式，思路是客户端以JSONP的这种方式(协议)向目标服务器发送请求，服务器端构建出一个callback的回调函数，类似JS的方法+参数的字符串返回给客户端，客户端调用自己写好的回调函数来执行这段js代码，于是就实现了跨域请求的目的。 jQuery给出了两种情况的跨域请求，一种是get/getJSON的方式，另一种是$.ajax()的方式，原理都差不多，只是写法不一样。 （3）限制 服务器端需要部署相应的代码，响应客户端的请求。 只支持GET，不能很好的支持POST。 （4）代码示例 本地服务器上同时运行了2个项目，端口分别是8080和8081，在8081的客户端上面请求8080端口的数据，端口不同也是跨域。 12345678910111213141516171819//getJOSN方法$.getJSON("http://localhost:8080/msg/front/jcj/t1.jsp?callback=?", function(result) &#123;&#125;);//ajax方法$.ajax(&#123; type: "get", url: "http://localhost:8080/msg/front/jcj/t1.jsp", //也可以直接将callback写在url中 //url: "http://localhost:8080/msg/front/jcj/t1.jsp?callback=m1", dataType: "jsonp", jsonpCallback: "m1", success: function(data) &#123; //处理返回的数据 &#125;&#125;);function m1(data) &#123; alert(data);&#125; 服务器端需要部署相应的代码，响应客户端的请求。服务器端使用NodeJS实现： 1234567891011121314151617var http = require('http');var urllib = require('url');var port = 8081;var data = &#123;'name': 'jifeng', 'company': 'taobao'&#125;;http.createServer(function(req, res)&#123; var params = urllib.parse(req.url, true); if (params.query &amp;&amp; params.query.callback) &#123; var str = params.query.callback + '(' + JSON.stringify(data) + ')';// jsonp res.end(str); &#125; else &#123; res.end(JSON.stringify(data));// 普通的json &#125; &#125;).listen(port, function()&#123; console.log('server is listening on port ' + port); &#125;) 说明：第一种方式的callback=?回调函数标志着Ajax请求是以JSONP的方式发送请求，客户端请求会自动在问号处增加一个方法名，方法名是以jquery开头的一串数字 而第二种方式的是参数dataType=&quot;jsonp&quot;来说明是以JSONP的方式发送请求，所以可以直接在callback后面直接指定方法名callback=m1，而不需要jsonpCallback: &quot;m1&quot;这一行代码。 可以使用豆瓣的API来测试跨域： 12345678910111213function getJSON(url, callBack) &#123; const src = `$&#123;url&#125;?callback=$&#123;callBack&#125;`; const script = document.createElement('script'); script.src = src; document.body.appendChild(script);&#125;function handleFunc(e) &#123; console.log(e);&#125;const url = 'https://api.douban.com/v2/book/user/119280372/collections';getJSON(url, 'handleFunc'); 结果： 服务器端要布置响应的代码，并且把API放出来给使用者，最好配有相应的接口说明文档 方法6 CORS（跨域资源共享）（1）适用范围 在服务端进行处理，客户端支持H5 （2）如何实现 HTML5中提供的XMLHttpRequest Level2实现了跨域访问，只需要在服务端填上响应头： 1234# 星号表示接受来自所有域的访问header(“Access-Control-Allow-Origin: *”);header(“Access-Control-Allow-Methods: GET, POST”); （3）限制 服务器端需要部署相应的代码，响应客户端的请求。 IE10以下不支持这种方式。 方法7 Nginx反向代理跨域 以前其实并不了解Nginx跨域的原理，其实就是利用了服务度不存在跨域的原理，前端JS访问自己本地的资源，而Nginx将访问跨域目标的请求进行了拦截，将请求转发到真实的地址，获取到数据。 实际上和后面的利用Express的转发原理是相同的。 上面的所有的方法都有一个共同的限制，那就是必须在对方的网页（或者服务器）上进行相应的部署，不论是JS代码还是服务器端代码。 但是有一种最常遇到的情形，就是想要获取的数据的网站是不受自己控制的，开发者只能控制一个域。 这时候只能依靠Nginx进行反向代理跨域。 方法8：利用后端转发请求跨域如果是用Node编写的配套的服务端程序，那可以使用Express的request模块进行请求转发，实现跨域请求。 123456var request = require('request');app.use('/api', function(req, res) &#123; var url = apiUrl + req.url; req.pipe(request(url)).pipe(res);&#125;); 上面完整的请求传递给API，并且将相应传递给请求的发起者，支持GET/PUT/DELETE的其他请求方式 使用的时候，前端只需将需要跨域的请求请求到/api地址，将真实地址放到查询参数中： 1234export const QUERY_URL = 'https://wallstreetcn.com/live/global';const X_URL = `/api/proxy?url=$&#123;encodeURIComponent(QUERY_URL)&#125;`;fetch(X_URL).then(v =&gt; console.log(v.text())) 方法9： &lt;img&gt;标签&lt;img&gt;标签不存在跨域的问题，可以访问任意其他网页的图片，并且可以通过onload和onerror事件了解到响应是何时完成的 12345let img = new Image();img.onload = img.onerror = function () &#123; alert('done')&#125;img.src = 'http://www.baidu.com/test?name=123' 当img的src被设置那一刻，请求就发出了，服务器的响应一般是像素图或204 No-Content 一般用来跟踪用户点击页面或动态广告曝光字数，是一种==单向的跨域方式==，==只能是GET请求==，并且无法访问服务器的相应文本。 方法10 WebsocketWebsocket建立的连接不存在跨域问题，因此可以通过建立Websocket打开到任何站点的俩进阶，至于是否可以与页面通信，完全取决于服务器（通过握手信息就可以知道请求来自何方） 前端代码： 123456789101112131415161718192021&lt;div&gt;user input： &lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;); &#125;); document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value); &#125;;&lt;/script&gt; Node代码： 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 方法11：SSE + EventSourceSSE是服务器发送事件，是一种服务器向客户端推送的单向通信技术。 URL可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开withCredentials属性，表示是否一起发送Cookie。 123456789101112131415161718192021222324252627if(window.EventSource) &#123; // 参数是一个URL，可以使与当前网址同域，也可以跨域 // 打开withCredentials属性，表示是否一起发送Cookie。 const source = new EventSource('myEvent.com', &#123; withCredentials: true&#125;); // EventSource实例的readyState属性，表明连接的当前状态 if(source.readyState === 0) &#123; // 0 相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。 &#125; else if (source.readyState === 1) &#123; // 1 相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。 &#125; else if (source.readyState === 2) &#123; // 2 相当于常量EventSource.CLOSED，表示连接已断，且不会重连。 &#125; // 连接一旦建立，就会触发open事件，可以在onopen属性定义回调函数。 source.addEventListener('open', function (event) &#123; // ... &#125;, false); // 客户端收到服务器发来的数据，就会触发message事件，可以在onmessage属性的回调函数。 source.addEventListener('message', function (event) &#123; var data = event.data; // handle message &#125;, false); // 如果发生通信错误（比如连接中断），就会触发error事件，可以在onerror属性定义回调函数。 source.addEventListener('error', function (event) &#123; // handle error event &#125;, false); // close方法用于关闭 SSE 连接。 source.close(); 参考 跨域与跨域访问@CSDN Iframe 有什么好处，有什么坏处？国内还有哪些知名网站仍用Iframe，为什么？有哪些原来用的现在抛弃了？又是为什么？@知乎 Iframe 有什么好处，有什么坏处？国内还有哪些知名网站仍用Iframe，为什么？有哪些原来用的现在抛弃了？又是为什么？@知乎 html5 postMessage解决跨域、跨窗口消息传递@博客园 jQuery的Ajax的跨域请求@博客园 jquery中ajax处理跨域的三大方式@脚本之家 URL 和 URI 有什么不同?@知乎]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成01 入门]]></title>
    <url>%2F2019%2F06%2F26%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F02%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%9001%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[持续集成入门学习笔记。123123123 持续集成的概念Continuous Intergration（CI），指的是开发代码频繁地合并进主干，式中保持可发布状态的这个过程。 优点： 快速发现错误 防止分支大幅度偏离主干 让产品可以快速迭代，同时还能保持高质量 CI的核心措施：代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成 与持续集成相关的还有两个概念，持续交付和持续部署（CD） 持续交付和持续部署持续交付是持续集成的下一步，指的是频繁地将软件的新版本交付给智联团队或者用户，以供评审。 持续部署是持续交付的下一步，指的是代码通过评审后，自动部署到生产环境。它的前提是能自动化完成测试、构建、部署都步骤。 持续集成的流程（1）提交：开发者向代码仓库提交代码（commit）。 （2）第一轮测试：代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并主干就会进行自动化测试。测试种类包括单元测试（必须）、集成测试、端对端测试。这一轮测试可以省略，因为在构建完成后会有第二轮测试。 （3）构建：通过测试后，代码合并进主干，进行构建（构建包括安装依赖、配置资源等），常用的构建工具有Jenkins和Travis。 （4）第二轮测试：构建完成后要进行第二轮测试，第二轮测试是前面测试，单元测试和集成测试都要进行，有条件也要做段对端测试，所有测试以自动化测试为主，少数无法自动化测试的用例需要人工进行。新版本的每个更新点要必须要测到。 （5）部署：第二轮测试通过后，将这个版本的所有文件打包存档，发到生产网服务器，生产服务器将打包文件解压为本地目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。 （6）回滚：一旦当前版本发生问题，需要回滚到上一个版本的构建结果。最简单的做法就是修改符号链接，指向上一个版本的目录。 参考 持续集成是什么？@阮一峰的网络日志]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>持续部署</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题33 Nginx]]></title>
    <url>%2F2019%2F06%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9833%20Nginx%2F</url>
    <content type="text"><![CDATA[以前的Nginx的学习笔记，重新总结了一下。 关于NginxNginx是一个强大的轻量级的高性能网页服务器、反向代理服务器和电子邮件代理服务器。作为负载均衡服务器，Nginx可以在内部直接支持Rails和PHP程序对外进行服务，也可以支持作为HTTP代理服务器对外进行服务。 Nginx的正向代理正向代理的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器这个代理服务器呢,他能访问那个我不能访问的网站。 于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录。有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。 结论就是正向代理是一个位于客户端和原始服务器(Origin Server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 Nginx的反向代理 正向代理代理的是客户端，反向代理代理的服务器 什么是反向代理所谓反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 从上图可以看出，反向代理服务器位于网站机房，代理网站web服务器接受Http请求，对请求进行转发。 例用户访问http://ooxx.me/readme，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情。这里所提到的ooxx.me这个域名对应的服务器就设置了反向代理功能。 反向代理对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 反向代理的作用（1）保护网站安全：任何来自Internet的请求都必须先经过代理服务器； （2）通过配置缓存功能加速Web请求：可以缓存真实Web服务器上的某些静态资源，减轻真实Web服务器的负载压力； （3）实现负载均衡：充当负载均衡服务器均衡的分发请求，平衡集群中各个服务器的负载压力； Nginx的一些基本知识在介绍下面的使用Nginx进行跨域之前，需要对Nginx的一些基本知识有所了解。 基本命令使用Nginx的命令需要首先定位到nginx.exe所在的目录（Windows系统） Nginx的一些基本命令： 123456789101112131415161718# 查看版本nginx -v# 启动start nginx# 停止nginx -s stop # 快速停止Nginx，可能并不保存相关信息nginx -s quit # quit完整有序的停止Nginx，并保存相关信息。# 重新启动nginx -s reload # 当配置信息修改，需要重新载入这些配置时使用此命令# 重新打开日志文件nginx -s reope# 查看配置文件路径及是否调用有效nginx -t 配置文件Nginx的功能都是通过nginx.conf配置文件来实现的，一个服务器上可能会有多个配置文件，可以执行nginx -t来查看配置文件的路径以及是否调用有效。 Nginx的配置文件主要分为四部分： main，全局设置，设置的指令将影响其他所有部分的设置 server，主机设置，用于指定虚拟主机域名、IP和端口 upstream，上游服务器设置，主要为反向代理、负载均衡相关配置 location，URL匹配特定设置 他们之间，location继承server，server继承main，upstream既不会继承指令也不会被继承。 关于locationNginx配置文件中的loaction是主机访问的地址，在Nginx服务器做一个代理，转发到location中配置的地址。它有如下的匹配指令： =表示进行普通字符精确匹配，只有请求的URL路径与后面的字符串完全相等时，才会命中 ~表示执行一个正则匹配，区分大小写 ~*表示执行一个正则匹配，不区分大小写 ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @定义一个命名的location，使用在内部定向时，例如error_page, try_files loaction匹配的优先级（与loaction在配置文件中的顺序无关） =精确匹配会第一个被处理。如果发现精确匹配，Nginx停止搜索其他匹配。 普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。 ^~则只匹配该规则，Nginx停止搜索其他匹配，否则Nginx会继续处理其他loaction指令。 最后匹配理带有~和~*的指令，如果找到相应的匹配，则Nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。 123456789101112131415161718192021location = / &#123; # 只匹配"/". [ configuration A ] &#125;location / &#123; # 匹配任何请求，因为所有请求都是以"/"开始 # 但是更长字符匹配或者正则表达式匹配会优先匹配 [ configuration B ] &#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location [ configuration C ] &#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配以 gif, jpg, or jpeg结尾的请求. # 但是所有 /images/ 目录的请求将由 [Configuration C]处理. [ configuration D ] &#125; 关于rewriterewrite只能对URL中的路径部分除去传递的参数外的字符串起作用，不关心域名部分和查询参数，例如： 1http://www.baidu.com/a/bb/ccc.php?id=1&amp;uu=str rewrite只会对/a/bb/ccc.php重写。 语法： 1rewrite regex replacement [flag] 执行顺序是首先执行location匹配，然后执行location中的rewirte指令。 关于proxy_passproxy_pass地址后面加上了/则相当于转发到绝对根路径，Nginx不会对loaction中匹配的路径部分进行转发，例如： 1234location ^~/proxy/html/ &#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 proxy_pass http://www.b.com/&#125; 如果请求的url为：http://localhost/proxy/html/test.json，则转发后的地址是：http://www.b.com/test.json。 如果proxy_pass地址后面不加/，则Nginx会对loaction中匹配的路径部分进行转发，例如: 1234location ^~/proxy/html/&#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 proxy_pass http://www.b.com&#125; 如果请求的url为：http://localhost/proxy/html/test.json，则转发后的地址是：http://www.b.com/proxy/html/test.json。 利用Nginx的反向代理实现跨域利用Nginx反向代理实现跨域，不需要目标服务器配合，但需要搭建中转Nginx服务器，用于转发请求。 实现原理 对于请求者而言，发送的不是跨域的请求，而是对本地资源的请求，Nginx识别出特定的本地资源请求，转发到真实的跨域的资源的地址。 而作为服务端而言，是不存在跨域的（需要添加对应的请求头），所以会把资源返回给Nginx服务，再由Nginx服务将资源返回给真正的请求页面。 基础配置首先找到nginx.conf中的下面这部分内容： 12345678server &#123; listen 80; server_name localhost; location / &#123; root ../Project; index index.html index.htm; &#125;&#125; 其中server代表启动的一个服务，location是一个定位规则，是Nginx用来跨域的入口。 location /的意思是所有以/开头的地址，实际上是所有请求，后面的地址可以是绝对地址，也可以是相对地址；root的意思是去请求相对上一层中的Project文件夹里的文件，index是去指定首页。 在location /{}中添加一下代码： 12345add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;&apos;;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;rewrite regex replacement [flag]proxy_pass http://ip:port/; 其中： （1）第一条指令：授权从other.subdomain.com的请求；是W3C标准里用来检查该跨域请求是否可以被通过； （2）第二条指令：当该标志为true时，响应于该请求可以被暴露； （3）第三条指令：制定请求的方式，可以使GET/POST等； （4）第四条指令：对域名（根路径）后面除去传递的参数外的字符串的url进行重写及重定向； URL是URI的子集。任何东西，只要能够唯一地标识出来，都可以说这个标识是URI。如果这个标识是一个可获取到上述对象的路径，那么同时它也可以是一个URL；但如果这个标识不提供获取到对象的路径，那么它就必然不是URL。 （4）第五条指令：实际要访问的请求地址； 前三条是用来指定自己的服务器是否可以被跨域访问的指令，是可以没有的。 第四条利用Nginx提供的变量，结合正则表示和标志位来实现比较复杂的重定向，简单的情况也是可以没有的。 实现方法1：location + proxy_pass适用于将location直接转发至proxy_pass地址的情况，这种情况一般比较简单。 比如我们要访问的跨域资源位于http://115.29.203.53:10013/students/，前端代码如下： 1234567891011121314151617181920var button = document.getElementById("button");$(button).click(function() &#123; $.get("students", function(data) &#123; alert(data.data[0].id) &#125;, "json"); $.getJSON("students", function(data) &#123; alert(data.data[0].id) &#125;); $.ajax(&#123; url: "students", type: "GET", dataType: "json", success: function(data) &#123; alert(data.data[0].id) &#125; &#125;)&#125;) 上面的三种方法都可以实现跨域，要注意的是使用get方法获取JSON数据时一定要声明第四个参数dataType为JSON，否则总是无法获得正确的对象。 跨域的部分，url地址是一个相对地址students，转化为绝对地址就是http://localhost/Project2/task5/students/。而本地并没有这样的资源，所以需要利用Nginx进行转发处理。 1234567server &#123; listen 80; server_name localhost; location ^~/Project2/task5/students/ &#123; proxy_pass http://115.29.203.53:10013/students/; &#125;&#125; 配置完成后重启Nginx服务，首先定位到nginx.exe所在的目录（Windows系统），然后： 1nginx.exe -s reload 这个是比较蠢的做法，直接将全部的URL替换为最终的真实URL，这样就将地址转发出去了，实现了跨域。 实现方法2：location + proxy_pass + rewrite适用于直接将location转发至proxy_pass不能满足需要，需要对虚拟根路径及后面的路径使用rewrite进行改写的情况。例如： 我们主机的地址是www.a.com/html/index.html，想请求www.b.com/api/msg?method=1&amp;para=2，请求如下： 1234567$.ajax(&#123; type: "get", url: "www.b.com/api/msg?method=1&amp;para=2", success: function(res) &#123; alert("success") &#125;&#125;) 这样必然因为跨域问题发生错误，无法获得b网站的数据。将请求更改为： 12345678$.ajax(&#123; type: "get", url: "proxy/api/msg?method=1&amp;para=2", // 绝对路径是 www.a.com/proxy/html/api/msg?method=1&amp;para=2 success: function(res) &#123; alert("success") &#125;&#125;) 这是的URL请求的就是本地的资源了，但是在本地并不存在相应的数据，所以需要将这个地址通过Nginx转发出去。 在刚才的路径中匹配到这个请求，在location下面再添加一个location： 1234567891011121314server &#123; listen 80; server_name localhost; location / &#123; root ../Project; index index.html index.htm; &#125; # 匹配任何以 /proxy/html/ 开头的地址，匹配符合以后不继续往下搜索 location ^~/proxy/html/ &#123; rewrite ^/proxy/html/(.*)$ /$1 break; proxy_pass http://www.b.com/ &#125;&#125; location ^~/proxy/html/用于拦截请求，是一个匹配规则，匹配任何以proxy/html/开头的地址，这里匹配到的就是proxy/html/api/msg?method=1&amp;para=2 rewrite ^proxy/html/(.*)$ /$1 break用来重写拦截的请求，并且只对域名后面除去传递参数外的字符起作用，即重写上面匹配到的地址的这一部分进行重写：proxy/html/api/msg rewrite后面是一个正则表达式，表示匹配以/proxy/html/开头的任何字符至结尾，并且将proxy/html/后面的任意字符存到第一个捕获组$1之中，break表示匹配一个后停止。 重写的结果是：/api/msg proxy_pass http://www.b.com/用来把请求代理到其他主机，即www.a.com代理到www.b.com，请求路径最终变为http://www.b.com/api/msg? method=1&amp;para=2 配置完成后重启Nginx服务即可。 这样就可以更改上面的情况1中的做法，JS文件不变，Nginx的location的配置如下： 12345678server &#123; listen 80; server_name localhost; location ^~/Project2/task5/students/ &#123; rewrite ^/Project2/task5/(.*)$ /$1 break; proxy_pass http://115.29.203.53:10013/; &#125;&#125; 同样可以实现跨域 又一个例子前端请求： 12345678$.ajax(&#123; type: "get", url: "sohu/api/msg?method=1&amp;para=2", // 真实地址是 www.c.com/proxy/html/api/msg?method=1&amp;para=2 success: function(res) &#123; alert("success") &#125;&#125;) Nginx进行如下配置： 123456789server &#123; listen 80; server_name localhost; location ^~/sohu&#123; # 匹配任何以/proxy/html/开头的地址，匹配符合以后不继续往下搜索 rewrite ^.+sohu/?(.*)$ /$1 break; proxy_pass http://www.sohu.com/ &#125;&#125; 所以： location定位到：/sohu/api/msg?method=1&amp;para=2 rewrite的结果：api/msg proxy_pass后的结果：http://www.sohu.com/api/msg?method=1&amp;para=2 最后一个例子 参考 nginx服务器安装及配置文件详解@Sean’s Note nginx反向代理服务器的工作原理@CSDN nginx配置location总结及rewrite规则写法@segmentfault Nginx proxy pass简单用法@51CTO 最简单实现跨域的方法—-使用nginx反向代理@CSDN 一文弄懂Nginx的location匹配@segmentfault]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习07 数字组合总和]]></title>
    <url>%2F2019%2F06%2F23%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A007%20%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个不含重复数字的数组arr，指定个数n，给出目标和sum，判断是否含有由n个不同数字相加得到sum的情况 分析题目和LeetCode的39题和40题相似，我这个代码自我验证是对的，也不知道是否有问题。 先把《算法图解》入门看完，再刷LeetCode，刷到的时候回来重新看一下吧。 我现在的思路是，基线条件就是n === 1，这个时候的返回条件就是当前循环中的arr[i]与sum是否相等，如果相等就返回true，如果不相等就继续遍历，直到遍历结束，返回false 递归条件是对arr和n和sum同时修改，每次让n不断减少，缩小规模 代码123456789101112131415161718function getSum(arr, n, sum) &#123; if (arr.length &lt; n) &#123; return false &#125; for (let i = 0; i &lt; arr.length; i++) &#123; if (n === 1) &#123; if (arr[i] === sum) &#123; return true &#125; &#125; else &#123; const result = getSum(arr.slice(i + 1), n - 1, sum - arr[i]); if (result) &#123; return true &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS33 关于居中的总结]]></title>
    <url>%2F2019%2F06%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS33%20%E5%85%B3%E4%BA%8E%E5%B1%85%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于CSS中水平、垂直居中的总结 准备工作HTML结构： 123&lt;div class="container"&gt; &lt;span class="text"&gt;你好&lt;/span&gt;&lt;/div&gt; 公共样式： 12345678.container &#123; width: 300px; height: 300px; background: royalblue;&#125;.text &#123; background: darkgoldenrod;&#125; 水平居中的方法（1）使用text-align: center 对于行内元素，可以直接使用text-align: center来水平居中 123.container &#123; text-align: center;&#125; （2）使用margin: 0 auto 对于宽度确定的块级元素，可以使用margin: 0 auto来水平居中，原理和后面的绝对定位加margin: auto的原理类似，后面单独结合总结。 12345.text &#123; display: block; width: 100px; margin: 0 auto;&#125; （3）flex布局 如果不考虑兼容性，很完美的方案： 1234.container &#123; display: flex; justify-content: center;&#125; （4）grid布局 显然兼容性有着问题的方案： 1234.container &#123; display: grid; justify-content: center;&#125; （5）绝对定位+移动 父元素相对定位，子元素绝对定位，并且使用transfrom移动自身宽度的-50%（如果子元素的高度已知也可以通过margin向左移动自身高度的一半 12345678.container &#123; position: relative;&#125;.text &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; （6）绝对定位和margin: auto 1234567891011.container &#123; position: relative;&#125;.text &#123; position: absolute; left: 0; right: 0; width: 100px; margin: auto;&#125; 一定要指定子元素的宽度，否则子元素就会充满父元素 垂直居中的方法（1）vertical-align: middle 针对行内元素，并且需要有一个兄弟行内元素，撑满父元素： 12345678910.container:after &#123; content: ''; display: inline-block; height: 100%; background: aliceblue; vertical-align: middle;&#125;.text &#123; vertical-align: middle;&#125; （2）line-height === height 让父元素的height和line-height相等，一般适用于文字的居中 123.container &#123; line-height: 300px;&#125; （3）padding 适用于父元素高度不确定，或者说父元素高度是根据子元素高度确定的情况： 1234567/* container 不能指定 height */.container &#123; padding: 20px 0;&#125;.text &#123; background: darkgoldenrod;&#125; （4）绝对定位+移动 父元素相对定位，子元素绝对定位，并且使用transfrom移动自身高度的-50%（如果子元素的高度已知也可以通过margin向上移动自身高度的一半 123456789.container &#123; position: relative;&#125;.text &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; （5）flex布局 如果不考虑兼容性，很完美的方案： 1234.container &#123; display: flex; align-items: center;&#125; （6）grid布局 显然兼容性有着问题的方案： 1234.container &#123; display: grid; align-items: center;&#125; （7）display: table-cell + vertical-align: middle 1234.container &#123; display: table-cell; align-items: middle;&#125; 平时没怎么用，不知道有什么缺点呢~ （8）绝对定位和margin: auto 1234567891011.container &#123; position: relative;&#125;.text &#123; position: absolute; top: 0; bottom: 0; margin: auto; height: 30px;&#125; 一定要指定子元素的高度，否则子元素就会充满父元素。 利用margin: auto居中的原理123456789101112131415.father &#123; position: relative; width: 500px; height: 500px;&#125;.child &#123; position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; width: 100px; height: 50px;&#125; 优点：兼容性好 缺点：子元素需要指定宽高（否则会充满父元素） 原理：以水平方向举例，垂直方向相同。 当绝对定位的元素只定义了一个方向属性时（比如left），并且元素没有利用width指定宽度，宽度是0；当同时指定了相反的两个方向的属性时且相等（left和right都为0），此时如果没有指定width，则宽度会充满父元素，自定宽度会沿着left摆放。 此时指定marign： 如果一侧定值，一侧auto，auto为剩余空间大小 如果两侧均是auto，则平分剩余空间，所以就居中了。 块级元素利用margin: 0 auto水平居中的原理也是这样。 参考 小tip: margin:auto实现绝对定位元素的水平垂直居中]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高20 日期选择器插件]]></title>
    <url>%2F2019%2F06%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E6%8F%90%E9%AB%9820%20%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[以前收藏了一篇自己动手实现日期选择器的插件，最近没什么事，就想着仿照ElementUI的DatePicker，自己也写了一个简易的日期选择器，本以为不会很麻烦，实际动手才发现有很多问题需要解决。并且在写完之后，才发现可扩展性很差，距离ElementUI的水平差的很远，下一步就是把ElementUI的源码学习一下，看清楚自己的差距。 以前收藏了一篇自己动手实现日期选择器的插件，最近没什么事，就想着仿照ElementUI的DatePicker，自己也写了一个简易的日期选择器，本以为不会很麻烦，实际动手才发现有很多问题需要解决。并且在写完之后，才发现可扩展性很差，距离ElementUI的水平差的很远，下一步就是把ElementUI的源码学习一下，看清楚自己的差距。 结构我将这个日期选择做成了Vue的插件的形式，有三个文件： 123- index.js- MyDate.js- MyDatePicker.vue index.js很简单，只有一个方法intstall，在install里面注册了全局组件： 1234567import MyDatePicker from './MyDatePicker'export default &#123; install(Vue) &#123; Vue.component('MyDatePicker', MyDatePicker) &#125;&#125; MyDatePicker.vue是UI部分，在这里定义样式和交互事件，我将数据单独放到了MyDate.js中，以Class形式导出 数据部分我的顺序是先完成MyDate.js的数据部分，一个日期选择器基本结构如下： 最后导出一个二维数组，二维数组外层包含6个数组，对应日期选择器中的每一行的数据，内层数组又包含7个对象元素，对应周一到周日，这样相当于总共有42个元素，正好对应面板中的42个日期。 当选择一个日期后，首先通过new Date构造函数获得当前日期所在月的第一天及这一天是星期几 123// 当前选择日期所在月的第一天及这一天是星期几const firstDayOfCurrentMonth = new Date(this.current.year, this.current.month - 1);const firstDayOfWeek = firstDayOfCurrentMonth.getDay(); 要注意的是，new Date().getMonth()的范围是[0, 11]，和我们日常使用的月份是少1的。而我在current里面存的日期是为了显示所用的，已经加过1了，所以需要在上面减1 接下来，通过两层的遍历来生成我们所需要的二维数组，外层遍历是对应的是行数据： 12for (let row = 0; row &lt; 6; row++) &#123;&#125; 关键是内层数据，假设我们选择的就是2019年6月，6月1日是星期六，在二维数组的内部数组里面的七个元素，应该吻别对应[&#39;日&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;]，现在6月1日星期六，它位于数组的第七项，补齐这个数组的结果应该是： 1[5.26, 5.27, 5.28, 5.29, 5.30, 5.31, 6.1] JS的Date构造函数会自动对超出当前月份的日期进行转换，意思就是，当我们构造一个日期new Date(2019, 5, 0)，它会自动往前倒一天，生成的日期就是2019-05-31 所以上面的数组转为对应的以6月为天数就是： 1[-5, -4, -3, -2, -1, 0, 1] 所以当前遍历的范围就是[-5, 1]，起始点与6月1日的星期几存在这样的关系： 12// 内层遍历起始点let weekLoopStart = -firstDayOfWeek + 1; // -5 结束点是7 + weekLoopStart - 1 这样当内层遍历结束一次时，将weekLoopStart加7，就可以生成新的一行数据了： 1[2, 3 4, 5, 6, 7, 8] 所以两层遍历的基本形式就是： 12345678910// 行数据for (let row = 0; row &lt; 6; row++) &#123; const rowDate = []; // 列数据 for (let weekDay = weekLoopStart; weekDay &lt;= 7 + weekLoopStart - 1; weekDay++) &#123; // 生成需要的对象 &#125; weekLoopStart += 7; this.dates.push(rowDate)&#125; 有点绕，而且可扩展性也不是很好，还是太笨了。 在内层遍历生成的对象有这样几个属性： 1234567891011const targetDate = new Date(this.current.year, this.current.month - 1, weekDay);const day = targetDate.getDate();const month = targetDate.getMonth() + 1;rowDate.push(&#123; date: targetDate, value: format(targetDate), label: day, key: weekDay, isCurrentMonth: month === this.current.month, isToday: +targetDate === +this.today&#125;) date是标准的日期对象，value是选择后用于展示的格式化的日期，label是在日历中选择的日期，key是整个遍历过程中它实际的标号，isCurrent用来判断这个日期是否属于当前月份，还是以-5这样的格式转换为前一个月的日期（这样的日期在面板上是有不同的样式），isToday用来标识今天的日期： 这样就生成了一个二维数组放到了this.dates这个实例属性中 当改变选择的月份，面板的日期也会随着变化，对应的实例方法就是changeDate，因为刚才的生成数据的getDateArray方法都是依赖于this.current来进行的，所以只需要改变this.current的值，然后重新执行getDateArray方法就行了 12345678// 改变日期changeDate(date = new Date()) &#123; this.current = &#123; year: date.getFullYear(), month: date.getMonth() + 1 &#125;; this.getDateArray()&#125; 这样基本的数据就完成了。 UI部分UI部分是在.vue的单文件组件完成的，面板使用了&lt;table&gt;标签，在date里面引入MyDate的实例，其余都声明为计算属性，与MaDate的实例相关联，这样形成了这样的变化过程： 1234graph LR用户点击--&gt;改变实例属性改变实例属性--&gt;计算属性改计算属性改--&gt;UI界面改变 有三个事情需要记录一下 （1）设定单元格样式 12345&lt;tr v-for="(row, rowIndex) in tbody" :key="'row-' + rowIndex"&gt; &lt;td v-for="cell in row" :key="cell.key" @mousedown="selectDate(cell)"&gt; &lt;span :class="tableCellClass(cell)"&gt;&#123;&#123;cell.label&#125;&#125;&lt;/span&gt; &lt;/td&gt;&lt;/tr&gt; 因为单元格的原始和遍历的数据cell有关系，如果卸载模板中会有一大堆的代码，不太直观，用计算属性生成一个对象有没有办法传入参数，所以可以用一个method，返回一个对象传给:class 12345678// 设定日期单元格样式tableCellClass(cell) &#123; return &#123; 'not-current-month': !cell.isCurrentMonth, today: cell.isToday, selected: cell.value === this.selectedDate &#125;&#125;, （2）动画效果 ElementUI的动画效果是向上滑出 它是通过Vue的&lt;transition&gt;组件实现的，而&lt;transition&gt;是用JS实现的动画，使用了requestAnimationFrame的API，很流畅，而且便于复用。找个时间还是要好好看一些Vue的源码，学习一下。 我使用了CSS动画来实现，当选择框出现时，添加一个类container-visible，将原本的height由0改为320px，同时将opacity由0改为1，同时添加了will-change和transform: translateZ(0)来提升性能： 12345678910111213141516171819202122.date-container &#123; position: absolute; left: 0; top: 46px; color: #606266; box-shadow: 0 2px 12px 0 rgba(0, 0, 0, .1); background: #fff; border-radius: 4px; line-height: 30px; margin: 5px 0; transition: all 0.5s ease; border: 1px solid #e4e7ed; height: 0; overflow: hidden; will-change: height; opacity: 0; transform: translateZ(0);&#125;.container-visible &#123; height: 320px; opacity: 1;&#125; 实现的效果还可以，但是有两个问题，一是不太好复用，而是需要改为固定的高度，如果面板高度变化，效果就有可能有偏差 （3）第三个问题是日期选择框的出现和隐藏，它具体的逻辑如下： 点击输入框，出现选择框 点击输入框和选择框之外的部分，选择框消失 点击输入框和选择框之内的部分，选择框不消失 点击选择框的快速选择月份（那几个小箭头），选择框发生相应改变，不消失 点击选择框的具体日期，选择框消失，选择成功 我选用的方案是使用&lt;input&gt;的focus和blur事件，发生两个事件时，改变控制选择框是否显示的变量containerVisible focus没有问题，但是blur有着比较大的问题，首先遇到的问题时，当点击选择框的按钮功能和时期时，没有触发对应的功能，选择框就消失了（以前在开发业务的时候遇到过类似的问题），这主要是因为blur事件发生的时机： 1234graph LRmousedown--&gt;blurblur--&gt;mouseupmouseup--&gt;$&#123;click&#125; 在click事件发生之前blur事件就发生了，导致click事件没有发生时，元素就隐藏了，click事件无效。 所以像以前一样，将选择框绑定的click事件改为了mousedown事件，这样做的效果是，点击日期能够选择了，并且选择事件执行了，并且之后选择框失效了，这时候上面的五条逻辑满足了1/2/5，但是3/4又出问题了，点击选择框的小按钮，选择框意外消失了。 之所以这样，是因为mousedown事件之后，blur事件执行，导致选择框小事，我们要做的是在mousedown之后，不触发blur事件，所以应该使用peventDefault方法（注意不是stopImmdeiation，因为不是冒泡导致的），Vue中提供的修饰符是prevent，所以在所有的mousedown事件后面添加上修饰符prevnet： 123&lt;button type="button" class="btn next-month-btn" @mousedown="changeMonth(1)"&gt; &lt;span class="iconfont icon-el-icon-arrow-right"&gt;&lt;/span&gt;&lt;/button&gt; 这样条件4满足了，但是3不行，所以需要在整个选择框的容器上添加一个mousedonw事件，并且使用prevnet修饰符，里面的点击事件只需要使用mousedown就可以了 12&lt;div class="date-container" :class="&#123;'container-visible': containerVisible&#125;" @mousedown.prevent&gt;&lt;/div&gt; 这样基本上就成功了，但是还是有一些小瑕疵，一个问题就是blur事件发生的过于容易，比如我点击浏览器之外的桌面部分，blur事件也会发生，选择框会消失，而ElementUI的并不会消失，还有就是绑定了没有必要的点击事件，不好复用，并且不知道如果同时有多个弹出框的时候还不会有其他的问题。 ElementUI是把这块单独提出了一个方法，位于element/src/utils/clickoutside.js，它对这种情况的点击事件做了统一的处理，主要的思路就是在document绑定了统一的点击事件，通过收集此刻的弹窗元素到一个队列中，隐藏这个队列中的元素，它没有使用blur事件，更可控，也更适合更多的元素。 优化这个日期选择器插件的基本功能能够满足，但是如果作为ElementUI那样的轮子，还差的很多，扩展非常困难（快速选择月、年的面板我就没有做） 下一步的计划就是首先学习clickoutside的实现，然后学习ElementUI的源码，这个计划也好久了，要尽快执行啊~ 最后，代码都在这里。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>日历</tag>
        <tag>blur</tag>
        <tag>focus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 浏览器渲染优化]]></title>
    <url>%2F2019%2F06%2F17%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F04%20%E4%BC%98%E8%BE%BE%E5%AD%A6%E5%9F%8E%2F01%20%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优达学城浏览器渲染优化的学习笔记。 第一课 关键渲染路径Web网页应该尽量避免不稳定性。 多数设备刷新屏幕的频率为每秒60帧，即60fps 渲染流程 生成DOM树，（Parse HTML） 生成CSS树 合并成为渲染树（Recalculate Styles），计算样式 计算布局，生成盒模型（Layour/Reflow） 将页面由矢量转为光栅（Paint） 处理复合层（compositive layer） 注意，复合层上方的元素也会变为单独的图层（隐式复合） 对于样式改变，导致的渲染流程： 对于JavaScript部分，指的是能够引起外观的变化，不仅可以通过JavaScript来改变页面外观，也可以使用CSS动画或者Web Animation API来实现。 改变外观后可能会需要重新计算Style属性（比如媒体查询等），有可能不需要。 改变的CSS属性不同，后续触发流程也不同。 改变宽度、高度、位置等几何结构，会触发后续的Layout、Paint、Composite步骤 改变背景图片、颜色、阴影等不涉及几何几何尺寸的属性，不会再触发Reflow，只会触发后续Paint、Composite步骤 改变transform、opacity等会生成单独的图层的属性，不会再触发Reflow和Repaint，只需触发Composite步骤 CSS属性的改变应该尽可能触发少量的工作，避免Reflow和Repaint，提高性能。 练习（1）第一题 渲染树中只包含了最终显示在屏幕上的元素内容，它与DOM树并不完全相同，比如它不会包含display:none的元素，不会包含&lt;head&gt;标签中的元素。 所以这道题目的答案是A，而其他的属性，虽然不会占据屏幕空间，但是还是属于页面的一部分，仍然会包含在渲染树中。 （2）第二题 无论是改变body还是改变其中内部的div的宽度，浏览器都会做出最坏的打算，就是需要对全部DOM元素的样式进行计算，对整个文档进行Reflow和Repaint。所以答案是C （3）第三题 题目中是一个弹性部局的容器（flex），但改变容器的大小，内部元素的尺寸会随机发生变化。当新的页面渲染时，浏览器会经历那些步骤？ 弹性容器的尺寸发生变化，内部元素的尺寸会发生变化，但是它们的Style并没有发生变化（因为宽度都是弹性确定的，而非固定值，并且不涉及媒体查询短点改变样式的条件），所以不会重新计算Style，但是由于宽度发生了变化，所以后续的Layout、Paint、Composite都会执行。 （4）第四题 会触发Layout+Paint+Composite的属性很多，比如margin、width等 触发Paint+Composite的属性有color、background等 触发Composite的属性变transform、opacity等 可以通过CSS Triggers网站来查找CSS属性分别会触发哪些过程。 第二课 App 生命周期网络应用的生命周期包含了四个主要阶段：RAIL 按照时间先后顺序： Load， 加载阶段，有大概1秒的时间来渲染网页，然后用户的关注级别降低，这个阶段要下载和加载关键资源 Idle，闲置阶段，加载后进入闲置阶段。这时候适合执行不太重要的工作，确保在此之后出现的任何舞动都能及时作出响应，闲置时间在50毫秒左右，以便在用户开始交互时立刻停止闲置阶段 Animations，动画阶段，例如用户滚动屏幕或者出现动画，只有16毫秒的时间来渲染一帧，这样才能保证60fps Responsiveness，响应阶段，人类大脑可以忍受100毫秒的停顿时间，更久的话就会让人觉得卡顿不流畅。这就意味着应用要以某种方式在100毫秒内对用户输入做出响应。 第三课 卡顿杀伤性武器学习使用Chrome的Devtools中的性能分析面板Performance（以前的Timeline） 现在的面板和课程讲解中已经发生了很大声变化，但是大体思路是相同的，录制之后再中间的Main的下拉部分去分析什么导致的卡顿 它是倒火焰图，上方的行为调用了下方的命令，不同的行为有不同的颜色表示，黄色是JavaScript脚本，紫色是重新计算样式，绿色是绘制 可以找到哪个行为事件过长（大于16ms）导致卡顿，然后进行分析、优化 第四课 JavaScriptJavaScript运行时并不是我们编写的样子，而是通过JavaScript解释器提供的即时编译器，编译为更有效率的代码来执行的，所以编写代码时没有必要去做一些while和for谁更快之类的微优化。 JavaScript是渲染管道的开始，后续有重新计算样式、重排、重绘、复合的过程。要想不卡顿需要达到60fps，所以每一帧只有16ms的时间，分配给JavaScript部分的也就只有10-12ms。所以在每一帧渲染开始时，应当尽早执行JavaScript函数，这样才能够有足够的时间完成后续的过程。 在执行JavaScript动画时，应当使用requestAnimationFrame来代替setTimeout/setInterval，因为后者不会关注渲染管道的流程，而前者会自动的在每一帧开始时运行JavaScript函数。 12345function animate() &#123; // do something here requestAnimationFrame(anmiate)&#125;requestAnimationFrame(anmiate) 可以使用上节课提到的Chrome的performance面板分析JavaScript的运行时间和内存占用情况。JavaScript会自动进行内存回收，所以我们不必担心指针、删除对象、局部变量的内存占用问题。可以通过performance分析是否存在内存泄漏等情况。 当有大量耗时的计算任务时，可以考虑使用Web Worker，将耗时的任务移动到Web Worker线程进行计算，而主线程（Main Thread）负责渲染流畅的UI。 Web Worker可以在不同于主窗口的线程下，完全独立的操作系统线程下手运行JavaScript。主线程与Web Worker线程之间通过postMessage和onmessage事件进行通信，各个Worker之间不能通信。 主线程:12345const myWorker = new Worker('./scripts/worker.js');myWorker.postMessage(data)myWoker.onmessage = function(e) &#123; console.log(e.data)&#125; Worker线程 worker.js 1234567// 通过importScipts导入其他脚本importScipts('other.js')this.onmessage = function(e) &#123; console.log(e.data) this.postMessage(data)&#125; 第五课 样式和布局重新计算样式（Recalculate Style）造成的性能代价与元素数量基本上是线性增长的关系。 可以采用BEM规则来为CSS的类命名，更加模块化、可复用、可读性好，且新跟那个好（因为使用class选择器的关系） BEN中的B是Block，指一个UI构成单元，E是Element，是B的后代，M是Modifer，表达状态，比如three、current、active等。 BEM使用连接符连接BEM，但不能使用相同的连接符连接BEM，例如使用__连接BE，使用_连接EM，使用-做连字符，比如header__item-list_active 第二个CSS选择器是速度快的，它只使用了BEM规则的类选择器，不仅性能最好，而且可读性良好。 选择器性能优化有时候不如良好的布局导致的节点数减少带来的性能提升更高。 当在一个循环中，先访问一些尺寸、位置等会导致Layout的属性，然后再改变尺寸，重新计算样式计算，会导致强制布局，当反复如此，会出现布局抖动。 应当尽量避免强制布局，在循环外读取属性，在循环内改变尺寸，不会造成强制布局。 第六课 合成和绘制可以使用Chrome的分析工具来分析页面的绘制过程，但是课程中的Show paint rectangles已经不再原来的位置了 为了分析绘制过程，需要在开发者的工具的More tools里面找到Rendering，在打开的Rendering面板中勾选Paint flasing选项： 勾选之后，它会告诉你绘制流程在页面上的什么地方发生了，何时发生了。当页面有元素被绘制时，对应的元素会显示为绿色： 还可以使用Paint Profiler来确定页面的那些区域被绘制了，何时绘制的。但是新版本的Chomre开启Paint很麻烦。首先勾选Enable advanced paint instruments(slow) 然后点击Record进行录制，录制结束后找到绿色的Paint块并点击： 点击之后再下方出现了Paint Profiler的选项： 可以根据左侧的命令结合上方的新的时间线和右侧的绘制结果，查看每一刻的绘制情况和绘制命令。 绘制之后的流程就是合成，就是将多个图层合并成为一个，当改变一个图层时，不会引起其他图层的绘制。 看下面的练习题，左侧是一个导航栏，那些元素应该放在一个图层上？ 一起移动的元素，应该放在一个图层上。 Chrome的性能分析记录中有两个与图层合成有关，一个是Update Layer Tree。当Chrome的引擎需要知道页面的哪个图层时就会出现该记录，查看元素的样式，弄清楚需要多少图层，另一个是Compositie Layers，浏览器将页面合成到一起发送给屏幕。 图层越多，图层管理和合成花费的时间就越多，所以需要在减少绘制时间和增加图层管理时间二者之间做出权衡。 图层管理大多数情况下是浏览器自动完成的，但是当遇到绘制问题时，可以考虑将某个元素单独放到一个图层中。在创建图层之前，应该看一下看元素是否已经有了自己的图层，在刚才的Rendering的功能面板在宏，勾选上Layers borders选项 勾选之后，页面上除了绿色的框框，还会出现褐色的框框，绿色框框是浏览器对图层的划分，我们没有办法控制，橘色的框框表示元素位于自己的合成图层上。 如何创建属于自己的图层呢？ 一般来说有两种方式： will-change，使用will-change，属性值可以是transform、left、top等外观属性，浏览器会根据这些提示为这些属性进行布局和绘制流程，由于浏览器创建图层也是要耗费性能的，使用will-change最大的好处就是避免浏览器匆忙创建图层带来的性能代价。 使用3D移动transform: translateZ(0)或者transform: translate3D(0, 0, 0) 这两种方式是在为静止的元素（不改变其原始位置）创建单独图层，实际上还有一些其他的方式也会创建单独的图层，比如： transform的对应移动，transalte、rotate、scale等 video/canvas/iframe等元素 opacity改变 position: fixed filter 有合成层后代，并且自身overflow不为visible（隐式合成） Chrome创建层的标准是什么呢？完整的标准： What else gets its own layer? Chrome’s heuristics here have evolved over time and continue to, but currently any of the following trigger layer creation: 3D or perspective transform CSS properties &lt;video&gt; elements using accelerated video decoding &lt;canvas&gt; elements with a 3D (WebGL) context or accelerated 2D context Composited plugins (i.e. Flash) Elements with CSS animation for their opacity or using an animated transform Elements with accelerated CSS filters Element has a descendant that has a compositing layer (in other words if the element has a child element that’s in its own layer) Element has a sibling with a lower z-index which has a compositing layer (in other words the it’s rendered on top of a composited layer) 可以参考这篇文章，讲得不错。 可以使用Layesr工具来查看页面中有多少个图层： 注意要避免隐式提升，下图中的totes promited成为单独图层的原因就是它覆盖在了于具有单独图层的元素的上方 所有元素都提升为单独的图层会消耗大量内存，并花费很多时间，在移动设备上问题更加明显。所以将元素提升到图层上时一定要谨慎，因为有可能会不小心由于存在重叠而创建了大量的其他的图层。 总结如何提升性能： （1）JS 避免多次访问尺寸、更改尺寸，导致布局抖动、强制布局 使用requestAnimation来代替setTimeout/setInterval创建动画 使用Web Worker，将复杂的计算过程放到子线程，避免主线程（渲染线程）的卡顿 （2）CSS 使用will-change提示浏览器将要发生的变化，并且创建单独的图层 使用3D变化来创建单独的图层 使用transform和opacity来创建单独的图层，实现动画 更多的使用类选择器（BEM）来提升选择元素的 避免隐式提升创建太多的图层 分析工具： Performance Rendering Laryouts 参考 浏览器渲染优化@优达学城]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题32 生成PDF]]></title>
    <url>%2F2019%2F06%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9832%20%E7%94%9F%E6%88%90PDF%2F</url>
    <content type="text"><![CDATA[JavaScript生成PDF方案调研，以及PDFKit调研。 生成pdf的方案（1）JSPDF(前端生成 ) 优点：不需要服务端安装无头浏览器，使用CSS方便控制样式，生成的PDF文字可复制 缺点：对中文支持不好 （2）PDFKit( 服务端生成) 优点：服务端直接解决，生成的PDF文字可复制，通过引入字体，可支持中文 缺点：样式控制复杂 （3）node-html-pdf(服务端生成) 优点：服务端通过控制HTML模板生成PDF，支持中文，样式控制方便 缺点：不支持图片，需要安装无头浏览器，性能有隐患 （4）JSPDF + HTMLToCanvas(前端生成) 优点：样式控制方便，支持中文，比较美观 缺点：生成的PDF内容是图片，无法复制 （5） 使用打印(前端生成) 优点：简单，代码量少 缺点：需要引导用户，且不美观 PDFKit简介PDFKit使用来在Node服务端生成PDF文件的JS包（也支持在浏览器使用），它可以轻松生成复杂的、多页的、可打印的PDF文档。 它的API是链式语法，与操作Canvas的API有一些类似 安装： 1npm install pdfkit -S 创建PDFKit文档很容易： 12const PDFDocument = require('pdfkit');const doc = new PDFDocument(); PDFDocument实例是可读的Node流，它不会自动的保存，但是可以使用pipe方法将输出的PDF文档传递给另一个可写的Node流。当PDF文档编写成功后，调用end方法来结束流程。下面的例子来展示如何将生成的文档传递给PDF文件或者HTTP响应： 1234567doc.pipe(fs.createWriteStream('/path/to/file.pdf')); // 写入PDF文件doc.pipe(res); // 传递给HTTP响应// 用后面介绍的API来为PDF添加内容// 结束编辑，关闭流doc.end(); 在浏览器中使用PDFKit的0.6版本后支持在浏览器中使用，有两种方法在浏览器端使用PDFKit，一种是在浏览器端使用browserify加载Node模块，另一种方法是直接使用PDFKit的预编译版本，可以从Github上下载。 在浏览器端使用PDFKit和Node中使用的唯一区别就是输出结果，在浏览器端输出结果必须是浏览器支持的格式，比如Blob。Blob格式可以允许浏览器在一个iframe中直接展示生成的PDF文档，或者将PDF上传到服务器，或者让用户下载它。 将PDFDcument输出为Blob格式，需要将他传递给blob-stream，这个模块可以将Node的流转换为Blob。下面的例子使用了Browserify来加载PDFKit和blob-stram（如果没有使用Browserify可以直接使用&lt;script&gt;标签代替） 1234567891011121314151617181920212223// 引入依赖const PDFDocument = require('pdfkit');const blobStream = require('blob-stream');// 创建文档const doc = new PDFDocument();// 传递给Blobconst stream = doc.pipe(blobStream());// 在这里添加PDF的内容// 结束时得到的是Blobdoc.end();stream.on('finish', function() &#123; // 将blob转换为PDF文档 const blob = stream.toBlob('application/pdf'); // 或者得到Blob URL，直接在浏览器中展示 const url = stream.toBlobURL('application/pdf'); iframe.src = url;&#125;); 添加页面PDFKit文档的第一页是在创建文档时自动添加的，除非使用了autoFirstPage: false选项。后续的页面必须手动添加： 1doc.addPage() 可以使用pageAdded事件，让每个页面创建后都添加上相同的内容： 1doc.on('pageAdded', () =&gt; doc.text("Page Title")); 可以通过为addPage传递参数设置页面的尺寸、方向： layout，页面方向，可取值portrait（默认值）/landscape size，页面尺寸，取值是一个数组[宽, 高]，单位是PDF的点（1/72英寸）。可以传入字符串指定一些预设值，默认值是letter margin，设定页边距，可以设为一个数字，那么各边距都等于它，也可以设为一个对象，分top/left/bottom/right四个属性分别设定各边距 1234567891011121314// Add a 50 point margin on all sidesdoc.addPage(&#123; margin: 50&#125;);// Add different margins on each sidedoc.addPage(&#123; margins: &#123; top: 50, bottom: 50, left: 72, right: 72 &#125;&#125;); 给PDFDocument构造函数传递页面参数对象，可以设置每一页的默认尺寸和布局，它会被每个addPage传递的页面参数覆盖。 bufferPage有的时候需要在后面的页面完成后回到前面的页面，对前面的页面进行修改，可以在PDFDocument构造函数传递一个参数bufferPages: true，来手动控制页面流。 一般这个情况可能不多见，具体可以参考文档这部分内容。 设定文档基础信息基础信息包括标题、作者等，可以通过对doc.info赋值，也可以在创建文档时传递参数实现。可以设定的基础信息包括（需要首字母大写）Title/Author/Subject/Keywords/CreationDate/ModDate 加密和访问权限可以对PDF加密，并且使用密码打开文件。也可以设定PDF文件的访问权限。具体内容参考文档。 矢量图形PDF格式兼容矢量图形，PDFKit提供了类似于HTML5 Canvas的API来创建矢量图形。图形通过一些列的直线和曲线构成，看一个例子： 123456doc.moveTo(0, 20) // 设定起点 .lineTo(100, 160) // 直线 .quadraticCurveTo(130, 200, 150, 120) // 二次曲线 .bezierCurveTo(190, -40, 200, 200, 300, 150) // 贝塞尔曲线 .lineTo(400, 90) // 直线 .stroke(); // 画 SVG路径PDFKit包含了SVG路径解析器，所以可以使用SVG路径画出一个图形，上面的图形使用SVG路径同样可以实现： 12doc.path('M 0,20 L 100,160 Q 130,200 150,120 C 190,-40 200,200 300,150 L 400,90') .stroke() 图形小助手PDFKit提供了一些封装好的方法来画出一些常用的图形，包括： 12345678910// 长方形 rect(x, y, width, height) // 圆角长方形roundedRect(x, y, width, height, cornerRadius) // 椭圆ellipse(centerX, centerY, radiusX, radiusY = radiusX) // 圆形circle(centerX, centerY, radius) // 多边形polygon(points...) 使用ploygon方法通过传输一系列由横纵坐标组成的数组，会创建一系列的直线，并连起来成为多边形： 12doc.polygon([100, 100], [200, 200], [200, 300]) .stroke() 边框和填充样式使用storke是画线，使用fill画出来的是填满空间的实体，使用fillAndStroke同时实现： 1doc.polygon([100, 100], [200, 200], [200, 300]).fillAndStroke('green', 'red') PDFKit可以设定的属性有： lineWidth lineCap lineJoin miterLimit dash fillColor strokeColor opacity fillOpacity strokeOpacity 其中lineCap用来设定直线的端点形状，可取值有butt/round/square，lineJoin用来设定直线交汇处的形状，可取值有miter/round/bevel 虚线使用dash方法画虚线： 123doc.circle(100, 50, 50) .dash(5, &#123; space: 10 &#125;) .stroke(); dash接受的第一个参数是每一段虚线的长度，第二个参数是一个选项对象，其中space属性用来指定每个虚线段的间隔，默认值与虚线段长度相等，phase属性指定虚线段的起点（不知道有什么用） 当使用dash方法后，后续的直线都是虚线的，可以使用undash方法恢复实现： 123456789doc.moveTo(100, 50) .lineTo(100, 150) .dash(5, &#123; space: 10, phase: 10 &#125;) .stroke();doc.moveTo(100, 150) .lineTo(300, 150) .undash() .stroke(); 颜色可以使用一个数组表示RGB或者CMYK颜色，或者字符串的16进制颜色或者CSS颜色的名称 fill和stroke方法的参数可以指定颜色，也可以使用fillColor和strokeColor来指定颜色，第一个参数是颜色，第二个参数是透明度 也可以使用fillOpacity、strokeOpacity或者opacity来单独指定透明度 渐变使用linearGradient和radialGradient实现渐变色，详见文档。 保存恢复图形堆栈图形堆栈是所有创建的样式和移动的快照，每次调用save方法当前的图形堆栈就会被推入一个堆栈中，当调用restore方法后，堆栈中的最后一个状态就会被应用到环境中。 所以，你可以保存状态，改变一些样式，然后恢复到之前的状态。 移动通过移动，可以再不改变图形本身的基础上，改变图形的样式。有三种移动的类型可用：translate/rotate/sacle 详见文档。 剪切途径剪切与填充（fill）和连线（stroke）不同，它是一个蒙版，会隐藏掉图形中不想要的部分。 所有落在剪切路径内部的图形都是可见的，外部的都是不可见的。 123456789101112// Create a clipping pathdoc.circle(100, 100, 100) .clip();// Draw a checkerboard patternfor (let row = 0; row &lt; 10; row++) &#123; for (let col = 0; col &lt; 10; col++) &#123; const color = (col % 2) - (row % 2) ? '#eee' : '#4183C4'; doc.rect(row * 20, col * 20, 20, 20) .fill(color); &#125;&#125; 结果： 想要取消剪切，需要在clip之前调用save方法，完成剪切部分的操作后调用restore方法。 文字使用text方法添加文字 1doc.text('Hello world!') 每次调用text方法都会另起一行，并且自动与之前行的位置对其。可以为text方法传两个参数，指定其位置。 12doc.text('hello1');doc.text('hello2').text('hello3', 0, 0) 可以调用moveDown或moveUp方法来按行移动 文字换行和对其text方法接受一个对象作为参数，用来指定一些配置项。 在不传递任何参数的情况下，text方法生成的文字横向沿着页面的左边距排放，纵向沿着页面上边距摆放，后续文字排在已有文字的下方。 PDFKit会根据文字内容，自动添加下一页，无需手动控制。 PDFKit还提供了文字折行的功能。文字会自动换行，除非指定lineBreak为false。默认情况下文字遇到页面边距会换行，但是指定width属性会让文字按照不同的宽度换行。如果指定了height属性，文字会调整到能放下的最多的行数，多余的行会被剪切 123doc.text(t, &#123; width: 200&#125;) 1234doc.text(t, &#123; width: 200, height 200,&#125;) 当文字在允许换行时，可以通过align属性指定对其方式，可取的值有left/right/center/justify 文字样式text接受一系列的参数来指定文字样式。 ellipsis为true时用来指定当文字太长时用省略号来代替多余的文字，可以传入字符串指定代替的字符 使用columns和columnGap来将文字按列排布 12345678doc.fillColor('red') .text(t, &#123; columns: 3, columnGap: 15, height: 100, width: 300, align: 'justify'&#125;); 文字测量当文档需要精确的布局时，需要知道一段文字的尺寸，可以使用widthOfString(text, options)和heightOfString(text, options)方法 这两个方法不会绘制文字，只会返回测量后的尺寸。 列表使用list方法可以创建无需列表，第一个参数是一个由各项文字组成的数组，后续参数可以指定横纵坐标。 可以通过嵌套数组创建嵌套列表 富文本在text的选项参数里面参数continued为true，可以生成连续的文字 12doc.fillColor('red').text('123', &#123; continued: true &#125;) .fillColor('green').text('456'); 字体PDFKit默认支持14种字体，使用font方法可以直接使用字符串指定这14种字体： ‘Courier’ ‘Courier-Bold’ ‘Courier-Oblique’ ‘Courier-BoldOblique’ ‘Helvetica’ ‘Helvetica-Bold’ ‘Helvetica-Oblique’ ‘Helvetica-BoldOblique’ ‘Symbol’ ‘Times-Roman’ ‘Times-Bold’ ‘Times-Italic’ ‘Times-BoldItalic’ ‘ZapfDingbats’ 除了这14种字体，PEFKit也支持外嵌字体，支持的字体格式有.ttf/.otf/.ttc/.dfont 在默认情况下，PDFKit是不支持中文的，所以需要上传包含中文的字体并指定，下载了开源的思源宋体并上传到文件夹中： 1234doc.font('./fonts/Source-Han.otf');doc.text('你好');doc.text('你也好'); PDFKit也支持注册字体，这样就不必每次使用字体时都输入一大串的路径名了： 12345678// 注册字体doc.registerFont('source font','./fonts/Source-Han.otf');// 使用字体doc.font('source font');doc.text('你好');doc.text('你也好'); 图像通过image方法来创建图像，图像的形式可以是路径、buffer对象、BASE64编码后的data uri。PDFKit支持JPEG和PNG格式 如果没有提供X/Y参数，图像会在当前文字流的位置（在最后一行文字后）渲染。如果提供了坐标，图像会在指定的位置渲染。 image方法可配置的参数有： width/height，指定图像的宽高，当都未指定时会按照图片的实际尺寸渲染，如果指定了某一方向的尺寸，图像会按照指定方向的尺寸按原比例缩放，如果都指定了，图像会拉伸至指定尺寸 sacle，对图像进行缩放 fit，接受一个数组，图像以这个数组提供的宽度和高度中较小的尺寸进行缩放（类似CSS的background-size的contain属性），会留白 cover，接受一个数组，图像以这个数组提供的宽度和高度中较大的尺寸进行缩放（类似CSS的background-size的cover属性），会剪切 注释PDF中的注释是具有可交互特性的文字，比如可点击的链接、注释或者高亮、下划线、删除线等文字样式。支持的注释有： 要注意的是，这些文字样式都不是直接加载文字上，而是以矩形的方式覆盖到文字上。所以使用的时候需要使用widthOfString计算出要添加注释的文字的宽度，使用currentLineHeight计算出当前的行高。 还要注意注释的堆栈顺序，比如添加link，需要保证link是最后一个被添加的，否则会被其他的注释覆盖，导致无法点击。 123456789101112// Add the link textdoc.fontSize(25) .fillColor('blue') .text('This is a link!', 20, 0);// Measure the textconst width = doc.widthOfString('This is a link!');const height = doc.currentLineHeight();// Add the underline and link annotationsdoc.underline(20, 0, width, height, &#123;color: 'blue'&#125;) .link(20, 0, width, height, 'http://google.com/'); 对于比较常用的链接、下划线，可以直接在text方法的选项中添加，更为方便： 1234567doc.fontSize(20) .fillColor('red') .text('Another link!', 20, 0, &#123; link: 'http://apple.com/', underline: true &#125; ); pdfmake后来又发现了PDFMake，它是基于PDFKit的基础上做的封装，可以直接生成表格，神器一个，方便极了（本来想借着做项目的机会，在PDFKit的基础上封装一个做表格的轮子，这下省了）。文档在这里。 它也支持浏览器端的使用，暂时先不管它，来看Node端的使用。 安装1npm i pdfmake -S 使用不想再像pdfKit把文档在过一遍了，官网在这里，Gihutb的仓库里上也给出了一系列的例子和结果展示，还有可在线编辑的例子。官网的文档并不是很详细，具体的API和用法可以再上面的两个例子里找到。 pdfmake基本上把pdfkit链式调用的API改为了面向对象（？）的API，其实就是传入一个大对象作为参数，然后就没有然后了，PDF就生成了。 直接看例子吧，我要生成的DEMO是这样的： 从上到下一点点来吧 主流程它的使用方法和PDFKit类似，都是需要新建一个文档的实例，然后传入一个参数对象： 12345678910111213const fs = require('fs');const PdfPrinter = require('pdfmake');// 创建实例const printer = new PdfPrinter();// 参数对象const docDefinition = &#123;&#125;const pdfDoc = printer.createPdfKitDocument(docDefinition);pdfDoc.pipe(fs.createWriteStream(`document-$&#123;Date.now()&#125;.pdf`));pdfDoc.end(); 按照这个流程就可以生成一个空白的PDF文档，我们要做的就是编辑docDefinition这个对象，添加PDF的内容，docDefinition中可以添加的属性有： 123456const docDefinition = &#123; content: [], defaultStyle, styles, watermark&#125;; content是一个数组，其中的每一个对象元素（或者是字符串）都代表要添加到PDF的一项内容，defaultStyle是文档的默认样式设置，styles是注册样式，定义在这个对象中的样式就可以直接在添加内容时的style属性使用，利用样式的复用，watermark用来给文档添加水印。 这些这是我这个DEMO中用到的内容，可以根据实际情况改变。 接下来要做的就是一些文档的准备工作。 字体pdfMake默认支持的字体和PDFKit是相同的，也就是说也不支持中文字体，需要手动引入包含中文的字体（一般中文字体包都在10M以上，所以这也是这个方案在浏览器端使用的一个很难解决的问题） 手动引入字体的方法是在新建实例的时候参数一个字体定义的对象，每一个属性对应一种字体，每个字体又有bold/normal/italics/bolditalics几种预设的分类，也是根据需要引入。 12345678910111213// 引入字体const fonts = &#123; sourceHan: &#123; normal: './fonts/Source-Han.otf', &#125;, PingFangSC: &#123; normal: './fonts/PingFang-SC-Regular.ttf', bold: './fonts/PingFang-SC-Bold.ttf', &#125;&#125;;// 创建实例const printer = new PdfPrinter(font); 默认样式在default定义默认样式，会应用到全局，可以被单独定义的样式覆盖： 1234567// 全局样式const defaultStyle = &#123; font: 'PingFangSC', fontSize: 10, color: FONT_COLOR, lineHeight: 1.2&#125;; 注册预置样式实际上这个步骤应该是一边添加内容一边完成的，将能复用的样式提出来，放到这里，也便于后期维护： 123456789// 预置样式const styles = &#123; tableTitle: &#123; fontSize: 20, margin: [0, 20, 0, 10], bold: true &#125;, tableHeader: &#123; bold: true, fontSize: 12, color: TABLE_HEAD_COLOR &#125;, dangerLabel: &#123; lineHeight: 1, color: '#F14D58', background: '#F2E6E7' &#125;, dangerText: &#123; lineHeight: 1, color: '#F14D58' &#125;, safeLabel: &#123; lineHeight: 1, color: '#34BA3B', background: '#E1F8E9' &#125;, safeText: &#123; lineHeight: 1, color: '#34BA3B', &#125;&#125;; 使用的时候只需要在style选项中使用属性名即可： 1&#123; text: '检测项', style: 'tableHeader' &#125; 水印可以使用watermark选项添加水印，可以定义的包括颜色、家族、透明度、文本等： 1234567// 水印const watermark = &#123; text: '隐私信息管理平台', color: '#EEE', opacity: 0.1, bold: true,&#125;; 水印的尺寸是不能直接设置的，它会默认从文档左下到右上，在版本更新之前，如果想要调整水印尺寸，那么有一个hack的办法，就是为水印的文本添加空格，用不可见的空格占据空间： 1234567// 水印const watermark = &#123; text: ' 隐私信息管理平台 ', color: '#EEE', opacity: 0.1, bold: true,&#125;; 搞定这些后，来为文档添加具体的内容。 标题首先生成最上方的标题中的文字 1234567// 标题const titleIntro = &#123; text: '小米隐私信息管理平台', fontSize: 28, bold: true, alignment: 'center',&#125;; 选项中设定了字体尺寸并且加粗，如果设定了加粗，但是导入的字体中没有设定加粗对应的字体就会报错，然后通过alignment设定文本居中。 标题前面还有一个小图标，用文本来搞定，引入图片后，默认图片和标题会分行防止，解决方法就是对图片添加absolutePosition选项，相当于CSS的绝对定位，输入坐标值，就可以让图标脱离文档流，随意摆放： 123456// 标题图标const titleImage = &#123; image: './images/mi-logo.png', width: 40, absolutePosition: &#123; x: 98, y: 40 &#125;&#125;; 下方的报告名“隐私检测报告”和前面的标题设定基本一致，居中防止，但是为了设定上下间距需要设定margin选项 12345678// 报告名const titleLineY = 10;const titleText = &#123; text: '隐私检测报告', fontSize: 38, alignment: 'center', margin: [0, titleLineY],&#125;; 分割线标题下方还有一道分割线，需要使用canvas选项来画出这条线： 12345678910// 标题分割线const titleLine = &#123; canvas: [&#123; type: 'line', x1: 0, y1: titleLineY, x2: 500, y2: titleLineY, lineColor: LINE_COLOR &#125;], margin: [0, 0, 0, 20],&#125;; 通过更改type可以画出不同的图形，其余的设置都好理解。 概览信息下面有一堆概览信息，由于原型图没有用列表形式的小点，说以不能直接使用ul选项，直接添加文字即可，将这部分内容放到一个数组中： 123456789101112131415161718// 概览信息const data = &#123; id: '0de3a12b-20190611174750', name: '浏览器', appVersion: '8.9.2', deviceName: 'chiron', miuiVersion: 'MIUI 9 SPT-2019.05.15', developer: '马化腾',&#125;;const id = `编号: $&#123;data.id&#125;`;const name = `软件名称: $&#123;data.name&#125;`;const appVersion = `版本号: $&#123;data.appVersion&#125;`;const deviceName = `测试机型: $&#123;data.deviceName&#125;`;const miuiVersion = `操作系统: $&#123;data.miuiVersion&#125;`;const developer = `开发者: $&#123;data.developer&#125;`;const overview = [id, name, appVersion, deviceName, miuiVersion, developer]; 表格表格的标题没什么特别的： 12345// 隐私信息检测标题const privacyDetailTitle = &#123; text: '隐私信息将策详情', style: 'tableTitle',&#125;; 表格的整体配置如下： 123456789101112// 隐私信息监测表格const privacyDetailTable = &#123; table: &#123; headerRows: 1, widths: ['*', '*', '*', '*', '*'], body: [ privacyDetailTableHeader, ...privacyDetailTableBody ], &#125;, layout: tableLayout&#125;; 如果表格分页时，会自动将在新的页面上再次生成表格，可以通过headerRows定义表格的前多少行作为表头被复制到新的页面，width定义的是表格每一列的宽度，有以下几种取值形式： &#39;*&#39;：会自动扩展占满剩余的宽度，在它其中的内容不会换行 &#39;auto&#39;：会根据内容自动确定宽度，其中的内容会换行，如果想不换行，需要设置noWrap: true 50：根据给定的数值确定宽度，注意是Number类型，不是字符串，否则会报错 我的第一个表格希望这五列占满全部空间，并且平均分配，所以widths（注意有s）是[&#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;] 我将表头单独拿出来定义： 12345678// 隐私信息监测表格-表头const privacyDetailTableHeader = [ &#123; text: '检测项', style: 'tableHeader' &#125;, &#123; text: '是否读取', style: 'tableHeader' &#125;, &#123; text: '是否上传', style: 'tableHeader' &#125;, &#123; text: '是否明文上传', style: 'tableHeader' &#125;, &#123; text: '检测结果', style: 'tableHeader' &#125;]; 表头用style属性指定了使用我在前面注册的tableHeader的样式。 具体表格内容则根据数据动态生成，我的DMO做了一些假数据，和表头一起放到body里面，构成了一个二维数组 最后是layout选项，它用来定义表格单元格和表格的边框，它有几个预设值noBorders/headerLineOnly/lightHorizontalLines，也可以传入一个对象对表格的样式自定义： 123456789101112131415161718// 表格样式const tableLayout = &#123; hLineWidth(i, node) &#123; return 1; &#125;, vLineWidth(i, node) &#123; return 1; &#125;, hLineColor(i, node) &#123; return LINE_COLOR; &#125;, vLineColor(i, node) &#123; return LINE_COLOR; &#125;, paddingLeft(i, node) &#123; return 5 &#125;,&#125;; 传入了一些方法，设定对应的样式，除此之外还可以设置fillColor等，具体的参考官方的例子吧。 这样就可以完成一个表格，另外一个表格知识宽度和内容不同。 最后将所有内容放到生成createPdfKitDocument参数对象中： 12345678910111213141516171819// 参数对象const docDefinition = &#123; content: [ titleImage, titleIntro, titleText, titleLine, overview, privacyDetailTitle, privacyDetailTable, permissionDetailTitle, permissionDetailTable, ], defaultStyle, styles, watermark&#125;;const pdfDoc = printer.createPdfKitDocument(docDefinition); 一份排版还算精美、代码复杂度也可以接受的PDF文档就生成了。 不仅如此，pdfmake还可以包括了生成二维码等功能，确实非常方便。 上面的完整的代码在我的Github仓库中。 总结PDFKit可以在Node环境和浏览器环境使用： 优点：引入字体后支持中文，支持图片，支持缩放、旋转，生成的PDF文字可复制，功能比较强大，API与操作Canvas的API非常类似，有一些使用的方法帮助快速操作，可以生成可点击的链接； 缺点是样式控制需要使用手动控制，不方便且繁琐，如果PDF的布局复杂时（有表格）样式控制也会很复杂。所以比较适合于布局简单的、没有复杂表格、布局以大块内容分割的PDF的生成，或者以现有的API抽象出生成表格等方法，便于复用。 pdfmake是在PDFKit基础上封装的： 优点：提供了直接绘制表格的API，功能比较强大，使用方便，还提供了添加水印、生成二维码等功能，生成较复杂的PDF的代码量可以接受 缺点是调试比较麻烦，每次都需要生成PDF查看样式，样式语法错误一般也不会报错，知识不生效，还有就是如果样式多了维护还是有一点麻烦，可使用类似LESS编写样式的思路。 总的来说，如果需要在Node服务端生成可复制的PDF文件，推荐使用pdfmake。 参考 pdfKit pdfmake bpampuch/pdfmake@Gtihub playground@pdfmake]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>PDFKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础20 换行的处理]]></title>
    <url>%2F2019%2F06%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E5%9F%BA%E7%A1%8020%20%E6%8D%A2%E8%A1%8C%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vue中的数据使用双大括号插值插入DOM中，如果数据中含有标签或者换行符\n时，是无法正常被解析为HTML标签的，而是解析为纯文字的 要想正常换行有一下几个解决方法： v-html使用v-html会将数据内容作为HTML标签插入到DOM中，这时候就可以用&lt;br&gt;来代替\n进行换行，这个时候就可以换行成功了 white-space使用v-html要注意防范XSS攻击，我们也可以直接使用CSS属性来实现换行： 将容器的white-sapce属性设置为pre-wrap就可以了，注意，如果设置为pre和使用&lt;pre&gt;标签效果是一样的，它虽然会正常换行了，但是它们式中会保留HTML标签。 如果一定需要动态插入HTML标签，那么还是需要使用v-html innerHTML和innerText设置一个节点的innerHTML和innerText都会保留\n，但是区别是innerHTML会插入HTM标签，innerText则会以字符串的形式显示HTML标签 12345678document.querySelector('test').innerText = '&lt;em&gt;123\n\r45&lt;br /&gt;6&lt;/em&gt;'// &lt;em&gt;123//// 45&lt;br /&gt;6&lt;/em&gt;document.querySelector('test').innerHtml = '&lt;em&gt;123\n\r45&lt;br /&gt;6&lt;/em&gt;'// 123 45// 6 Vue中使用双大括号差值与这两种方式都是不同的，猜测可能是它对\n有特殊的处理 参考 插值@Vue white-space@MDN]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>换行</tag>
        <tag>white-space</tag>
        <tag>innerHTML</tag>
        <tag>innerText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg06 参数校验和异常处理]]></title>
    <url>%2F2019%2F06%2F12%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg06%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Egg中参数校验和异常处理的实践 参数校验手动校验之前的参数都是在Controller的入口处，手动的进行校验： 1234567891011121314151617181920212223async index() &#123; const &#123;ctx &#125; = this const &#123; query &#125; = ctx.request try &#123; const &#123; type &#125; = query // 缺少参数，没法查 if (!type) &#123; const errMsg = '缺少参数' ctx.response.status = this.config.httpCodeHash.badRequest ctx.response.body = ctx.helper.makeErrorResponse(errMsg) this.logger.error(new Error(errMsg)) return &#125; // 响应内容 const data = await ctx.service.settings.findSettings(type) ctx.response.status = this.config.httpCodeHash.ok ctx.response.body = data &#125; catch (err) &#123; ctx.response.body = err.message || '查询规则错误' ctx.response.status = this.config.httpCodeHash.serverError this.logger.error(err) &#125;&#125; 这样很很导致大量的代码冗余，每个Controll都要写这样进行校验，如果失败手动返回错误结果（实际上参数校验失败也应该统一处理，后面的异常处理部分会提到） egg-validate实际上使用egg-validate插件可以大大简化和标准化参数校验的流程。 安装： 1npm i egg-validate --save 需要在plugin.js中开启插件： 12345// config/plugin.jsexports.validate = &#123; enable: true, package: 'egg-validate',&#125;; egg-validate实际上是由parameter这个库封装而来，它可以针对很多类型的参数进行校验，比如string、dateTime、number、enum等，具体的使用方法可以参考它的文档。 使用egg-validate进行参数校验的正确姿势： 123456789101112131415161718192021222324252627282930'use strict'const Controller = require('egg').Controller// 创建规则的校验规则const createRule = &#123; type: &#123; type: 'enum', values: [ 'pre', 'single', 'other' ] &#125;, name: &#123; type: 'string', trim: true &#125;, packageName: &#123; type: 'string', trim: true &#125;, content: &#123; type: 'object' &#125;,&#125;class PrivacyController extends Controller &#123; // 新建预设规则 async create() &#123; const &#123; ctx &#125; = this const &#123; name, packageName, type, content &#125; = ctx.request.body // 参数校验 ctx.validate(createRule, ctx.request.body) // 创建新规则 const data = await ctx.service.settings.createSetting(name.trim(), packageName.trim(), type.trim(), content) // 创建成功 ctx.response.status = this.config.httpCodeHash.created.code ctx.response.body = insertSetting &#125;&#125;module.exports = PrivacyController ctx.validate的第一个参数就是校验的规则，第二个参数是被校验的参数，我们的请求方法是POST，所有的参数都在body中，所以传入的是ctx.request.body 如果参数校验没有通过，将会抛出一个status为422的异常： 这个错误我们没有在Controller中捕获，后面会提到是如何处理的。 要注意的是，在校验规则中，某些类型是可以传入自定义的错误提示信息的，比如对string的校验，如果使用了formate选项，那么传入的message就会有效，其他时刻传入message无效，无法自定义错误提示信息： 1234const indexRule = &#123; id: &#123; type: 'string', trim: true, format: /^.&#123;24&#125;$/, message: '非法ID' &#125;, // Mongo生成的ID长度为24位 packageName: &#123; type: 'string', trim: true &#125;,&#125; 查看它的源码，发现它只有显示或者隐式（type为email等）这种情况下才会提示自定义的提示信息： 123456789101112131415161718192021222324252627282930313233343536373839function checkString(rule, value) &#123; if (typeof value !== 'string') &#123; return this.t('should be a string'); &#125; // if required === false, set allowEmpty to true by default if (!rule.hasOwnProperty('allowEmpty') &amp;&amp; rule.required === false) &#123; rule.allowEmpty = true; &#125; var allowEmpty = rule.hasOwnProperty('allowEmpty') ? rule.allowEmpty : rule.empty; if (!value) &#123; if (allowEmpty) return; return this.t('should not be empty'); &#125; if (rule.hasOwnProperty('max') &amp;&amp; value.length &gt; rule.max) &#123; return this.t('length should smaller than %s', rule.max); &#125; if (rule.hasOwnProperty('min') &amp;&amp; value.length &lt; rule.min) &#123; return this.t('length should bigger than %s', rule.min); &#125; if (rule.format &amp;&amp; !rule.format.test(value)) &#123; return rule.message || this.t('should match %s', rule.format); &#125;&#125;function checkEnum(rule, value) &#123; if (!Array.isArray(rule.values)) &#123; throw new TypeError('check enum need array type values'); &#125; if (rule.values.indexOf(value) === -1) &#123; return this.t('should be one of %s', rule.values.join(', ')); &#125;&#125; 有时间想提一个PR，支持所有的类型校验都支持自定义提示信息，但是现在由于无法完全自定义，所以索性在异常处理的时候不对外暴漏具体的message了，只给出统一的参数校验失败的提示： 1234&#123; "code": -1, "message": "Validation Failed"&#125; 统一异常处理一开始我都是在Controller中使用try...catch来捕获错误，每个Controller都这样做很烦，虽然编写了一个helper中的生成错误响应的方法，但是到处都要调用也很麻烦。 在Controller和Service中都有可能抛出异常，这也是Egg推荐的编码方式。当发现客户端参数传递错误或者调用后端服务异常时，通过抛出异常的方式来进行中断 常见的终端的情形有： Controller中this.ctx.validate进行参数校验，失败抛出异常 Service中调用this.ctx.curl()进行HTTP请求，可能由于网络问题等原因抛出服务端异常 Service中获取到this.ctx.curl()的调用失败的结果，也会抛出异常 其他意料之外的错误，也会抛出异常 Egg提供了默认的异常处理，但是可能与系统中统一的接口约定不一致，因此需要自己实现一个统一错误处理的中间件来对错误处理。 在app/middleware目录下新建errorHanlder.js文件，新建一个中间件： 1234567891011121314151617181920212223242526// app/middleware/error_handler.jsmodule.exports = () =&gt; &#123; return async function errorHandler(ctx, next) &#123; try &#123; await next() &#125; catch (err) &#123; // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志 ctx.app.emit('error', err, ctx) const status = err.status || 500 const message = err.message || 'Internal Server Error' // HTTP Code ctx.status = status // 生产环境 const isProd = ctx.app.config.env === 'prod' // 错误响应对象 ctx.body = &#123; code: -1, message: (status === 500 &amp;&amp; isProd) ? 'Internal Server Error' : message, // detail: status === 422 ? err.errors : undefined, // 参数校验未通过 &#125; &#125; &#125;&#125; 生产环境时500错误的消息错误内容不应该返回给客户端，因为可能包含敏感信息，所以只返回固定的错误信息。 通过这个中间件，可以捕获所有异常，并且按照想要的格式封装了响应，将这个中间件通过配置文件加载进来： 123456789// config/config.default.jsmodule.exports = &#123; // 加载 errorHandler 中间件 middleware: [ 'errorHandler' ], // 只对 /api 前缀的 url 路径生效 errorHandler: &#123; match: '/api', &#125;,&#125;; 中间件的加载单独拿出来这一节，是因为当时踩了一个坑，按照上面的配置之后，发现所有的请求根本没有经过我们的errorHandler中间件。 这是因为Egg支持定义多个环境的配置文件： 12345config|- config.default.js|- config.prod.js|- config.unittest.js`- config.local.js config.default.js是默认的配置文件，所有所有环境都会加载这个配置文件，一般也会作为开发环境的默认配置文件。 当指定env时也会同时加载对应的额配置文件，并且覆盖默认配置文件的同名配置，比如prod环境会加载config.prod.js和config.default.js文件，前者会覆盖后者的同名配置 配置合并使用了extend2模块进行深度拷贝，对数组进行合并时会直接覆盖数组，而不是进行合并 123456789const a = &#123; arr: [ 1, 2 ],&#125;;const b = &#123; arr: [ 3 ],&#125;;extend(true, a, b);// =&gt; &#123; arr: [ 3 ] &#125; 这就是我们的中间件没有生效的原因，我们的目录里面同时配置了config.local.js和config.default.js，在config.default.js虽然配置了中间件，但是在config.local.js中的middleware对应的属性值是一个空数组 根据上面的合并规则，导致最终的middleware是一个空数组，没有加载任何的中间件，所以或者在所有的配置文件的middleware的数组中都加上errorHandler中间件，或者直接在除了config.default.js之外的配置文件中删除middleware属性。 统一的错误对象我们现在有了统一的异常处理机制，在Controller或者Service中有时候我们要主动抛出异常，抛出的异常应该是一个Error对象，这样才会带上堆栈信息。 但是有一些与HTTP状态有关的异常，应该统一进行管理，保持整个系统的统一。所以使用了egg-errors插件，它内置了统一的异常和错误对象。 安装： 1npm i egg-errors --save 这里主要使用的是egg-errors内置的HTTP错误对象，它内置了400到500的错误对象，它提供了对应的status和headers属性： 123const &#123; ForbiddenError &#125; = require('egg-errors');const err = new ForbiddenError('your request is forbidden');console.log(err.status); // 403 也可以使用简写来调用对应的错误： 123const &#123; E403 &#125; = require('egg-errors');const err = new E403('your request is forbidden');console.log(err.status); // 403 我们在config中新建了一个httpCodeHash.js配置文件，在这个配置文件中引入了egg-errors，根据语义化的HTTP返回值进行了配置： 12345678910111213141516171819202122// HTTP 响应代码: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Statusconst errors = require('egg-errors')// TODO: httpCodeHash.codemodule.exports = &#123; continue: &#123; code: 100, message: 'Continue' &#125;, ok: &#123; code: 200, message: 'OK' &#125;, created: &#123; code: 201, message: 'Created' &#125;, noContent: &#123; code: 204, message: 'No Content' &#125;, movedPermanently: &#123; code: 301, message: 'Moved Permanently' &#125;, found: &#123; code: 302, message: 'Found' &#125;, notModified: &#123; code: 304, message: 'Not Modified' &#125;, badRequest: &#123; code: 400, message: 'Bad Request', error: errors.E400 &#125;, unauthorized: &#123; code: 401, message: 'Unauthorized', error: errors.E401 &#125;, forbidden: &#123; code: 403, message: 'Forbidden', error: errors.E403 &#125;, notFound: &#123; code: 404, message: 'Not Found', error: errors.E404 &#125;, conflict: &#123; code: 409, message: 'Conflict', error: errors.E409 &#125;, unprocessable: &#123; code: 422, message: 'Unprocessable Entity', error: errors.E422 &#125;, serverError: &#123; code: 500, message: 'serverError', error: errors.E500 &#125;, otherServerError: &#123; code: 502, message: 'Bad Gateway', error: errors.E502 &#125;, errors,&#125; 使用的时候如果只需要加载对应的信息而不需要抛出错误，那么对应的信息都是统一的： 1234// 响应内容const data = await ctx.service.log.findPrivacyLog(&#123; id, packageName &#125;)ctx.response.status = this.config.httpCodeHash.ok.codectx.response.body = data 如果需要抛出错误的时候，那么就是用对应的error属性，新建一个错误对象，并传入对应的自定义错误提示： 1throw new this.config.httpCodeHash.notFound.error('检测记录不存在') 这样保证了抛出的错误对象的语义化且统一。 参考 开启 validate 插件@Egg eggjs/egg-validate@github node-modules/parameter@github Config 配置@Egg eggjs/egg-errors@github]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>validate</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg05 Session]]></title>
    <url>%2F2019%2F06%2F11%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg05%20Session%2F</url>
    <content type="text"><![CDATA[Session是Web应用在Cookie基础上的封装，主要目的就是进行用户身份识别。 关于Session为什么要有SessionHTTP是无状态的协议，但是在很多情况下服务端需要记录用户的状态，典型的场景比如用户登录、购物车等。所以服务端需要某种机制来识别具体的用户，这种机制就是Session。 当用户购物时，服务端并不知道是那个用户操作的，所以需要为特定的用户创建特定的Session，来标识、跟踪这个用户，才能弄清楚用户购物车内的东西并且不与其他用户的购物车混淆。 Session的保存Session是保存在服务端的，有一个唯一的标识。服务端保存Session的方法很多，内存、数据库、文件都有。大型的网站一般会有专门的Session服务器集群，用来保存用户回话，这个时候Session是保存在内存的。 Session如何是识别用户身份Session是使用Cookie来识别用户身份的。每次HTTP请求时，客户端会发送响应的Cookie到服务器。 第一次创建Session的时候，服务端会在HTTP响应中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求都需要把这个ID发送到服务器，服务端就知道是哪个用户发送的请求了。 这个Session ID是维持Session回话的客户端的唯一标识，是Session实现的核心。 如果浏览器禁用了Cookie，Session ID需要通过url来传递。 与cookie的区别Session是存储在服务端的数据，用来跟踪是被用户的状态，可以保存在集群、数据库、内存、文件中 Cookie是客户端保存信息的一种机制，用来记录用户的一些信息，会随着网络请求发送给服务端，也是实现Session的一种方式 其他的实现方式除了使用Session实现用户身份的识别，也可以使用JWT的机制实现，详情可以参考之前的笔记《JS42 JWT实现单点登录》 Egg中对Session的处理Egg内置了egg-session插件，可以直接使用ctx.session访问或者修改当前用户的Session 1234567891011121314151617class HomeController extends Controller &#123; async fetchPosts() &#123; const ctx = this.ctx; // 获取 Session 上的内容 const userId = ctx.session.userId; const posts = await ctx.service.post.fetch(userId); // 修改 Session 的值 ctx.session.visited = ctx.session.visited ? (ctx.session.visited + 1) : 1; ctx.body = &#123; success: true, posts, &#125;; &#125;&#125; Session可以直接读取或者修改，删除的话直接置为null就可以了： 1ctx.session = null; 需要特别注意的是，设置Session属性时要避免以_开头，并且不能为isNew这个属性，会造成字段丢失。 Session的实现是基于Cookie的，默认配置下，用户Session的内容加密后直接存储在Cookie的一个字段中： 用户每次发送请求时都会带上这个Cookie，在服务端解密后使用。 Session的默认配置如下： 123456exports.session = &#123; key: 'EGG_SESS', maxAge: 24 * 3600 * 1000, // 1 天 httpOnly: true, encrypt: true,&#125;; 这些参数中，key代表存储Session的Cookie的键值对的key是什么，其他的参数都与Cookie的设置参数相同。在默认的配置下，存放Session的Cookie将会加密存储、不能被前端JavaScript访问，这样保证用户的Session是安全的。 扩展存储Session默认放在cookie中，当Session过大时，会带来两个问题： cookie存储空间有限制，可能无法存储过大的Session 每次请求都要发送庞大的Cookie信息 Egg提供了将Session存储到除了Cookie之外的其他存储的扩展方案，只需要设置app.seesionStore就可以将Session存储到指定的位置 123456789101112131415// app.jsmodule.exports = app =&gt; &#123; app.sessionStore = &#123; // support promise / async async get (key) &#123; // return value; &#125;, async set (key, value, maxAge) &#123; // set key to store &#125;, async destroy (key) &#123; // destroy key &#125;, &#125;;&#125;; 可以使用egg-session-redis配合egg-redis，将Session存储到redis中。 注意，一旦选择了将Session存储到外部存储中，就意味着系统强依赖于这个外部存储，当它挂了后，我们就完全无法使用Session的相关功能了。因此Egg推荐大家只将必要的信息存储到Session中，保持Session的精简并使用默认的Cookie存储。用户级别的缓存不要存到Session中。 Session实践修改用户Session失效时间Session的配置中的maxAge只能设置全局Session的有效期，有一些登陆页面的“记住我”的功能会让登陆用户的Session有效期更长，这种针对特定用户的Session有效时间社会可以通过ctx.session.max来实现 1234567891011121314const ms = require('ms');class UserController extends Controller &#123; async login() &#123; const ctx = this.ctx; const &#123; username, password, rememberMe &#125; = ctx.request.body; const user = await ctx.loginAndGetUser(username, password); // 设置 Session ctx.session.user = user; // 如果用户勾选了 `记住我`，设置 30 天的过期时间 if (rememberMe) ctx.session.maxAge = ms('30d'); &#125;&#125; 延长用户Session有效期默认情况下，当用户请求没有导致Session被修改时，框架不会延长Session的有效期。有些时候希望用户长时间都在访问我们的站点，要延长其Session有效期，不让用户退出登录状态。 框架提供了renew配置项来实现上述功能，它会在发现当用户Session的有效期仅剩下最大有效期的一般时，重置Session的有效期。 123456// config/config.default.jsmodule.exports = &#123; session: &#123; renew: true, &#125;,&#125;; 参考 Session@Egg 详解 Cookie 和 Session 关系和区别@Ruby China]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高19 插件]]></title>
    <url>%2F2019%2F06%2F11%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E6%8F%90%E9%AB%9819%20%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue插件学习笔记。 插件和组件的区别（1）组件分为全局注册和局部注册，全局注册使用Vue.component(&#39;componetName&#39;, component)实现，全局注册后可以在Vue系统中任意使用，局部注册的组件每次使用都需要import，然后在组件的componentes中注册，它的目的是复用模板和逻辑，影响的范围大多数是组件自身范围内 （2）插件的范围和能力比组件更大，插件内可以包含多个组件，可以在插件内注册全局组件，并且可以实现其他功能，比如： 添加全局方法或者属性（挂载到Vue的静态方法） 添加Vue实例方法（挂载到Vue.prototype上实现），在组件中通过this调用 通过全局混入来添加组件选项（通过Vue.mixin实现），比如在所有组件created的钩子上完成一些功能 添加自定义指令（通过Vue.directive实现） 使用组件使用组件需要通过全局方法Vue.use()实现，需要在调用new Vue之前完成 1234567891011Vue.use(MyDatePicker);new Vue(&#123; el: '#app', data: &#123; eventBus: new Vue() &#125;, router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 也可以传入一个可选的选项对象： 1Vue.use(MyDatePicker, &#123; someOption: true &#125;); Vue.use会自动阻止多次注册相同插件，即使多次调用也只会注册一次该插件。 开发插件插件应该暴露一个install方法，提供给Vue.use()调用。 install方法第一个参数是Vue构造器，第二个参数是传入的可选的选项对象 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 通过在Vue构造器上添加一些属性、方法，就可以实现添加全局的方法和属性。 在install方法也可以通过Vue.component注册全局组件： 1234567import MyDatePicker from './MyDatePicker'export default &#123; install(Vue, options) &#123; Vue.component('MyDatePicker', MyDatePicker); &#125;&#125; 例子：开发Loading插件首先创建一个MyLoading.vue，接受一个msg参数显示在组件内部，loading的效果通过CSS实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class="container my-loading"&gt; &lt;div class="logo"&gt;&lt;/div&gt; &lt;p class="text"&gt;This is My Loading -- &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'msg' ], name: 'MyLoading' &#125;&lt;/script&gt;&lt;style scoped&gt; .container &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); overflow: hidden; padding-top: 200px; &#125; .logo &#123; margin: 0 auto; width: 100px; height: 100px; border: 10px solid darkcyan; border-right-color: darkgray; border-radius: 50%; animation: myRotate 2s linear infinite &#125; @keyframes myRotate &#123; 0% &#123; transform: rotate(0); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; .text &#123; margin-top: 20px; text-align: center; &#125;&lt;/style&gt; 然后创建插件主体文件，创建index.js，这个文件需要导出一个对象，对象中必须有一个install方法，在install方法中来完成主要的逻辑 1234567891011121314151617import MyLoading from './MyLoading'export default &#123; install(Vue, options) &#123; const comp = Vue.extend(MyLoading); Vue.prototype.showMyLoading = (msg) =&gt; &#123; if (document.querySelector('.my-loading')) &#123; return &#125; const tpl = new comp(&#123; propsData: &#123; msg &#125; &#125;).$mount().$el; document.body.appendChild(tpl); setTimeout(function () &#123; document.body.removeChild(tpl); &#125;, 3000) &#125; &#125;&#125; 在上面的代码中，定义了实例的showPicker方法，在这个方法中首先使用Vue.extend来创建一个继承自MyLoading的Vue子类，然后使用new关键字将其实例化。 注意，使用new创建的实例，想要传递给组件props，必须使用propsData参数 12345678910var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'&#125;)var vm = new Comp(&#123; propsData: &#123; msg: 'hello' &#125;&#125;) 然后使用$mount方法创建一个未挂载的实例，这个实例没有关联的DOM元素，它返回实例自身，所以可以链式调用其他实例方法，然后通过$el获取实例自身的根DOM元素，通过appendChild将这个元素手动的挂载到DOM中 使用插件的时候在main.js中： 12import MyLoading from '@/plugin/myLoading/index'Vue.use(MyLoading); 这样在任意Vue中间中就可以调用实例的this.showPicker()方法动态的创建一个Loading元素，3秒后自动消失。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;使用MyLoading插件&lt;/h1&gt; &lt;button @click="showLoading"&gt; Show Loading&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'demo33', props: [], data() &#123; return &#123; title: '' &#125; &#125;, mounted() &#123; &#125;, methods: &#123; showLoading()&#123; this.showMyLoading('你好') &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 这是命令式的创建动态实例，适合Loading、对话框等形式的元素。主要的思路和之前总结的笔记《Vue提高09 动态创建实例》类似。 当然也可以在插件中注册全局组件，类似于ElementUI的用法。 参考 插件@Vue vm.$el@Vue vm.$mount@Vue propsData@Vue Vue插件开发与实战@H2O Vue.js 插件开发详解@掘金]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题31 JS中的日期对象]]></title>
    <url>%2F2019%2F06%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9831%20JS%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[最近做一个重构的业务，使用到了Mongo数据库，在接口中需要返回数据的的更新时间。之前数据库中都使用了时间戳记录时间，返给前端的数据直接使用时间戳进行格式化，并且查询条件也是由时间戳进行比对。 没想到，做数据写入接口的同事，将这个字段由时间戳改为了使用Mongo自带的标准的日期格式：ISODate(&quot;2016-01-01T00:00:00Z&quot;) 突然发现自己一时间对JS中的日期对象、对时间的各种表示方法并没有一个比较清晰的脉络。所以想用一点时间对这块知识做一个梳理、总结。 1 几种时间标准首先要明确，时间标准和时刻的关系。 我理解，时刻对于整个地球来说是唯一的。就在我写下这行文字的这一时刻，无论是美国、老挝还是柬埔寨，大家都经历了同一时刻，对于时间轴的刻度，全球是唯一的。 但是在不同的时区的人，代表这一刻的时间是各不相同的，我所在的北京时间是晚上21:26，但是对于美国、老挝、柬埔寨可能时间各不相同。 时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。 不同给的时区有对应的时间标准，对于中国的开发者来说，常见的时间标准有GMT/UTC/CST （1）GMT GMT，格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义为通过那里的经线。但是格林尼治时间本身有一些缺陷，并不准确，已经被原子钟报时的协调世界时（UTC）替代。 （2）UTC 刚才提到了UTC，协调世界时，是目前最主要的是世界时间标准，以原子时为基础。它的精确度比GTM更高，但是对于大多数用途，UTC时间被认为能够与GMT时间互换。 （3）CST CST，是北京时间，也叫做中国标准时间，比UTC时间快八个小时，与澳门、香港、台北、吉隆坡、新加坡等地的标准时间相同。 （4）小结 也就是说，UTC时间是GMT的时间的升级版，基本可以认为是相同的，有如下的关系： 1GTM ≈ UTC = CST + 8 2 ISO时间ISO时间与前面提到的时间标准属于不同的概念，它并不是一种时间标准，二是一种时间的表示方法。 ISO时间的全称是ISO 8601，是国际标准化组织的日期和时间的表示方法。目前是2004年12月1日发行的第三版标ISO8601:2004 标准中规定了日期和时间的组合表表示法，只使用数字为基本格式，使用冒号间隔开小时、分、秒，小时、分和秒都用2位数表述。日期和时间之间要一个大写字母T。 如果时间与UTC时间相同，那么（不加空格地）在时间最后加一个大写字母Z，比如下午2点30分5秒表示为14:30:05Z，其他时区用实际时间加上时差表示，比如当地的UTC+8时间表示为22:30:05+08:00 所以： 123452004-05-03T17:30:08+08:00// 北京时间2004年5月3日下午5点30分8秒2004-05-03T17:30:08Z// UTC时间2004年5月3日下午5点30分8秒 前面提到的，Mongo里的时间ISODate(&quot;2016-01-01T00:00:00Z&quot;)使用的就是ISO表示法的UTC时间。 3 时间戳时间戳也是常见的表达时间的方式，Unix时间戳指的是格林威治时间1970-01-01 00:00:00（北京时间1970-01-01 08:00:00）其到现在（或某个指定时间）的总秒数。它用来唯一的标识某一刻的时间。 那么，北京时间的时间戳和UTC的时间戳是一样的吗? 当然是一样的，前面提到了，时间戳是用来唯一的标识某一刻的时间，它是独一无二的。虽然北京时间和UTC时间相差了8个小时，但是正如上面提到的，北京时间和UTC时间计算时间戳的起点也相差了8个小时。 所以时间戳是没有时区的区别的。 4 JavaScript中的日期对象ECMAScript中的Date类型使用UTC时间的1970年1月1日午夜（零时）开始经过的毫秒数（注意是毫秒）来保存日期。 创建一个日期对象： 1const now = new Date() 在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒时间戳。 构造函数也可以接受一个字符串返回相应的日期对象，这是因为构造函数在后台调用了Date.parse()方法，将字符串转换为了对应日期的毫秒数。 Date可以接受多种日期格式，常用的有以下几种： 1234567891011// 时间戳new Date(1559569974691)// 月/日/年new Date('6/13/2004')// 年-月-日 时:分:秒new Date('2019-03-18 00:00:00')// ISO 8601 格式日期new Date('2019-03-18T00:00:00.000Z') 在使用Date构造函数创建一个日期对象时，日期和时间都是基于本地时区而非GMT来创建的： 12new Date()// Mon Jun 03 2019 21:56:47 GMT+0800 (中国标准时间) 上面的代码创造的日期对象是基于本地时区，也就是CST时区（为GMT+8)。当然JavaScript也提供了各种方法来进行各种事件标准间的转换： 1234567891011121314151617181920const now = new Date()// Mon Jun 03 2019 22:01:55 GMT+0800 (中国标准时间)now.toString()// "Mon Jun 03 2019 22:01:55 GMT+0800 (中国标准时间)"now.getTime()// 1559570515646now.toLocaleString()// "2019/6/3 下午10:01:55"now.toGMTString()// "Mon, 03 Jun 2019 14:01:55 GMT"now.toUTCString()// "Mon, 03 Jun 2019 14:01:55 GMT"now.toISOString()// "2019-06-03T14:01:55.646Z" Date对象的各种API可以查看MDN的文档，要注意的是日期对象的valueOf方法是取时间戳的值，效果与getTime是相同的。日期对象转换为数字，结果就是其时间戳。 12now.valueOf() === now.getTime()true 日期对象进行比较时，如果是两个对象进行比较，结果永远是不等的，原因和你直接比较两个{}不等是相同的，它们指向的不同的内存地址。但是可以将它们转换为字符串或者数字（时间戳）进行比较，而且在进行大于或者小于的比较时，是不用进行转换可以直接进行比较的（我猜测执行了隐式的转换，先转换为了数字，实际进行比较的是时间戳的值） 123456789101112131415var startDate1 = new Date("02/10/2012");var startDate2 = new Date("02/10/2012");var startDate3 = new Date("01/10/2012");startDate1 === startDate2// falsestartDate1.toISOString() === startDate2.toISOString()// true+startDate1 === +startDate2// truestartDate1 &gt; startDate3// true 对于日期对象，比较简单的转换和使用完全可以使用原生API实现，稍微复杂的一些可以借助Moment.js和date-fns，后者是纯函数，是不变的，而且更容易做到按需引入，所以更加推荐。 参考 时区@维基百科 格林尼治平时@维基百科 协调世界时@维基百科 北京时间@维基百科 ISO 8601@维基百科 时间戳@百度百科 JavaScript高级程序设计（第三版） Date@MDN]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UTC</tag>
        <tag>GMT</tag>
        <tag>IOS</tag>
        <tag>CST</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg04 cookie]]></title>
    <url>%2F2019%2F05%2F30%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg04%20cookie%2F</url>
    <content type="text"><![CDATA[通过ctx.cookie可以很便捷的在Controller中设置、读取Cookie。 开发之前还是应该精读文档啊。 设置Cookie1ctx.cookies.set(key, value, options) 设置Cookie其实是通过在HTTP响应中设置set-cookie头完成的，每个set-cookie都会让浏览器在Cookie中存储一个键值对。 在设置Cookie时还支持很多参数来配置Cookie的传输、存储和权限，具体参考文档。 其中有几个参数需要注意： { Boolean } overwrite，设置key相同时如何处理，如果设置为true，后设置的值会覆盖前面设置的值 { Boolean } singed，设置是否对Cookie进行签名，如果设置为true，则设置键值对是会同时对这个键值对的值进行前面，后面取的时候会进行校验，防止前端对这个值进行篡改。默认为true { Boolean } encrypt，设置是否对Cookie进行加密，如果设置为true，会在发送Cookie前对这个键值对的值进行加密，客户端无法读取Cookie的明文值。默认为false 在默认配置下，Cookie是加签不加密的，浏览器可以看到明文，JS不能访问，不能被客户端手工篡改。 在设置Cookie时需要考虑清楚这个Cookie的作用，需要保存多久，是否可以被JS获取，是否可以被前端修改。 （1）Cookie可以在前端访问并修改： 1234ctx.cookies.set(key, value, &#123; httpOnly: false, signed: false,&#125;); （2）如果想要Cookie在浏览器端不能被修改，不能看到明文： 1234ctx.cookies.set(key, value, &#123; httpOnly: true, // 默认就是 true enctypt: true,&#125;); 由于浏览器对Cookie有长度限制限制，所以尽量不要设置太长的Cookie。一般来说不要超过4093 bytes。当设置的value大于这个值时，框架会打印一条警告日志。 Cookie设置的编码由于浏览器和其他客户端实现的不确定性，为了保证Cookie可以写入成功，应该将value通过Base64或者其他编码方式进行编码后写入。 如果直接写入中文字符会失败： 1ctx.cookies.set('test', '你好') 可以使用encodeURIComponent转义，它会转义除了字母、数字、(、)、.、!、~、*、&#39;、-和_之外的所有字符。 encodeURI自身无法产生能适用于GET或POST请求的URI，例如对于XMLHTTPRequests, 因&amp;, +和=不会被编码，然而在GET和POST请求中它们是特殊字符。然而encodeURIComponent这个方法会对这些字符编码。 1ctx.cookies.set('test', '你好') 这样写入的就是通过编码后的信息： 也可以使用Base64进行加密。 关于Base64的题外话之前面试的时候有面试官问我的项目中为什么要用到base64-js这个库进行Base64加密，为什么不用原生的。我说的是API更简单，其实并不是的，是因为我当时不知道浏览器已经原生支持Base64的加解密了。 在浏览器环境下的window对象有两个方法，window.atob用于解密，window.btoa进行加密： 1234567let str = 'hello'let x = btoa(str)// "aGVsbG8="let y = atob(x)// 'hello' 既然有原生了，那么base64-js在npm上还有8559097的周下载量呢，原因有二： （1）兼容性，window.atob和window.btoa方法不支持IE10以下的浏览器，而base64-js就都解决了： （2）对中文的支持，原生的方法直接对中文编码是会报错的： 1234let str = '你好'btoa(str)// Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range. 解决方法就是对中文字符进行安全转码： 1234567let str = '你好'let x = btoa(encodeURIComponent(str))// "JUU0JUJEJUEwJUU1JUE1JUJE"let y = decodeURIComponent(atob(x))// '你好' base64-js有中文的支持，减少了我们的工作量。 选用一个包，也有这么大的学问，自己还是太不认真。 Node中的Base64加解密说了这么多题外话，回到整体，在Egg中也可以使用Base64加密后再Set-cookie。在Node环境中不能使用刚才提到的atob和btoa方法，我们也不一定需要引用base64-js，Node原生也是支持Base64加解密的，要利用到Buffer对象的toString方法 1234567&gt; let str = '你好'&gt; let x = new Buffer(str).toString('base64')// '5L2g5aW9'&gt; let y = new Buffer(x, 'base64').toString()// '你好' 也可以不新建Buffer实例，而是使用Buffer的静态方法from来实现，原理是一样的 1234567const str = '你好'ctx.cookies.set('base64', Buffer.from(str).toString('base64'))const base64 = ctx.cookies.get('base64')const result = Buffer.from(base64, 'base64').toString()// '你好' 读取Cookie1ctx.cookies.get(key, options) HTTP请求中的Cookie是在Header中穿过来的，而且是字符串中键值对的形式： 1&quot;test=%E4%BD%A0%E5%A5%BD; test.sig=bQpP88NGWWHrDUIuTcFH-D8DqTPU4VmalNWGQDIjnwU; base64=5L2g5aW9; base64.sig=Xbh30SgqJt8y9WY7fdicbtq-YE2E_qUUK5CMthAH4UQ&quot; 框架提供的get方法可以快速的解析Cookie并获取对应的键值对的值。由于在传输时指定了options.signed对Cookie进行签名，所以Cookie中会自动带来base.sig这个签证，用来对Cookie进行校验。 如果设置的时候指定了singed，获取时未指定，则不会再获取时对渠道的值做验签，导致Cookie可能经过客户端篡改而无法发现 如果设置是指定了encrypt，获取时未指定，则无法获取到真实的值，而是加密过后的密文 如果要获取前端或者其他系统设置的cookie，需要指定参数singed为false，避免对它做验签而导致获取不到cookie值 123ctx.cookies.get('frontend-cookie', &#123; signed: false,&#125;); 由于没有好好看文档，在使用Postman发送Cookie时，无论如何都无法成功，就是因为没有设置signed为false，这个时候要想获取成功，只能从浏览器里面将base.sig的值复制到Postman中一起发送。 要注意的是，即便设置了signed为false，在Postman里面直接设置Cookie的键值对的值为中文（这很方便）， 在Egg中也是无法解码的，它不会报错，Postman也给不出原因： 还是应该在Postman中对中文字符进行安全编码，选中中文部分，点击右键，在菜单中选择encodeURIComponet，在接受到之后进行解码就OK了 Cookie密钥在Cookie中需要用到加解密和验签，需要配置一个密钥供加密使用，在config/config.default.js中 123module.exports = &#123; keys: 'key1,key2',&#125;; kyes配置成为一个字符串，使用逗号分割多个key。Cookie在使用这个配置进行加解密时： 加密和加签只会使用第一个密钥。 解密和验签时会遍历keys进行解密 这样做的好处是，如果我们想要更新Cookie的密钥，但是又不希望之前设置到用户浏览器的Cookie失效，可以将新的密钥配置到keys的最前面，过一段事件后再删除不需要的密钥即可。 参考 Cookie 与 Session@egg encodeURIComponent()@MDN encodeURI()@MDN 原来浏览器原生支持JS Base64编码解码@鑫空间鑫生活 How to do Base64 encoding in node.js?@stack overflow Node.js Base64 Encoding和Decoding@Jaxu’s home]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>encodeURIComponent</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序09 小程序中的数据]]></title>
    <url>%2F2019%2F05%2F29%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F10%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F09%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[对小程序中的数据相关知识的学习笔记。 小程序中数据的作用域 逻辑层负责产生、处理程序，小程序的JS脚本运行在同一个JSCore线程中 逻辑层和渲染层是一对多关系，但页面对象（Page）和页面层级（Webview）一一对应。 （1）全局数据 12345678// app.jsApp(&#123; globalData: 'I am global data' // 全局共享数据&#125;)// 其他页面脚本other.jsvar appInstance = getApp()console.log(appInstance.globalData) // 输出: I am global data App实例是单例的，因此在App中定义的数据可以在不同页面共享 （2）页面共享数据 12345678console.log('加载 page.js')var count = 0Page(&#123; onLoad: function() &#123; count += 1 console.log('第 ' + count + ' 次启动这个页面') &#125;&#125;) 在Page构造器外面定义的变量，会一直保存在内存中，不会随着页面销毁而销毁。因此上面的count值会递增 这是因为页面所在的JS文件、app.js以及其他被require的JS文件，在小程序启动时会自动执行且被基础库注册，所以这些文件仅会被执行一次。之后页面都是通过Page构造器来创建Page实例来渲染的。 所以一般require的依赖或者第三方库JS以及getApp()都会放在页面共享数据中，避免重复加载。 （3）Page实例中的数据 12345678910111213Page(&#123; data: &#123; text: "我用来改变界面显示" &#125;, onLoad: function(options) &#123;&#125;, onReady: function() &#123;&#125;, onShow: function() &#123;&#125;, onHide: function() &#123;&#125;, onUnload: function() &#123;&#125;, text: "我不显示在页面上", myData: &#123; a: '我也不显示在页面上', b: true &#125;&#125;) 定义在Page构造函数中的数据，随着每次页面创建、销毁，这些数据也会被创建、销毁，不会被保留在内存当中。这些数据的生命周期与页面的生命周期是相同的。 定义在data中的数据用来渲染页面，就像在Vue中定义在data属性中的数据是一样的，只不过在Vue中是直接通过this.text取值，在小程序中需要通过this.data.text取值 与界面渲染无关的数据不要放在data中，可以提高性能表现。 合理操作数据，提升性能（1）数据通信 视图层在接收到初始数据data时进行初始渲染，在使用setData更新数据时，视图层进行重新渲染。当用户出发事件，视图层会将信息反馈给逻辑层。 这一切都是逻辑层与视图层两个线程通信的结果。数据量小于64kb时总时长可以控制在30ms以内。传输数据过大将导致这一事件增长。因此减少数据传输量是降低数据传输时间的有效方式。 （2）提升性能的准则 调用setData进行重渲染后，视图层会进行一个节点树Diff的过程，合并数据，用新节点数替换旧节点数，用于下次渲染。 setData发送数据不会进行Diff，而是全量发送，生成新的节点树在进行Diff、合并。 所以： 不要过于频繁调用setData，考虑将多次合并为一次 每次setData只改动的最小的单位数据 与界面渲染无关的数据不要设置的data中 事件绑定时需要传输target和currentTarget的dateset，所以不要再节点的data属性中放置过大的数据 精简优化WXML结构，降低JS代码复杂性，必要时使用分包优化 注意： 如果不使用setData而是直接对this.data中的数据赋值，不仅不会改变页面状态，还会导致数据不一致（和React中是一样的，不用多说了）。 不要将data中的属性值设为undefined，会导致一些莫名其妙的bug 组件中的通信（1）业务组件，也业务数据紧密耦合 从全局变量获取参数，通过更改全局变量与外界通信 通过props获取参数，通过triggerEvent与外界通讯 （2）纯组件，与业务数据无关 只能通过props获取参数，通过triggerEvent与外界通讯 缓存数据这里的缓存数据是小程序存储在设备硬盘的数据，类似WebStorage。小程序宿主环境从不同小程序和不同用户两个维度来隔离缓存空间。每个小程序的缓存空间上线为10MB （1）缓存充当全局数据 通过wx.getStorage/wx.getStorageSync读取本地缓存 通过wx.setStorage/wx.setStorageSync写入本地缓存 （2）利用缓存提前渲染截面 在拉取数据（比如商品列表）后缓存在本地，在onLoad发起请求前，先检查本地是否有缓存，如果有缓存的话使用缓存渲染界面。然后等待wx.request请求成功后在success回调中再次重新渲染页面，并且更新缓存。 一般对数据实时性和一致性要求不高的页面可以利用这个方法做提前渲染，可以提供类似PWA的体验。 状态管理Westore很多基于小程序的框架，类似mpVue，主打的是其他技术栈编译转小程序，并且可以编译为在H5等其他端运行的代码。 但是据统计，开发小程序使用最多的技术栈就是小程序本身的开发工具和语法，因为小程序本身的组件化、调试、发布、回滚、灰度、上报、统计、监控都是很优秀的。 但是小程序现在本身的状态管理可能是一个需要解决的痛点，官方还没有推出类似Redux、Vuex的解决方案。所以组件间叫复杂的数据共享、通讯以及跨页面的组件通讯，还是很容易让小程序难以维护和调试。 Westore是一款腾讯微信小程序解决方案，覆盖状态管理、跨页通讯、插件开发和云数据库开发。其技术方案： 有需要时可以尝试引入。 参考 【223期】 深入理解小程序中的数据@灵感周末 Tencent/westore@github]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>数据</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg03 断点调试]]></title>
    <url>%2F2019%2F05%2F16%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg03%20%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[断点调试Egg应用的方法。 使用Chrome调试需要Node 8.x+版本以上。 首先执行npm run debug（与node app.js --inspect原理相同） 然后有两种方法启动控制台（不是访问接口的控制台，而是直接启动一个新的针对Node的控制台） （1）执行npm run debug之后，在控制台最后会输出DevTools对应的地址，该地址是代理后的worker，无需担心重启问题。直接访问该地址即可进行断点调试。 12345678910111213141516➜ showcase git:(master) ✗ npm run debug&gt; showcase@1.0.0 debug /Users/tz/Workspaces/eggjs/test/showcase&gt; egg-bin debugDebugger listening on ws://127.0.0.1:9229/f8258ca6-d5ac-467d-bbb1-03f59bcce85bFor help see https://nodejs.org/en/docs/inspector2017-09-14 16:01:35,990 INFO 39940 [master] egg version 1.8.0Debugger listening on ws://127.0.0.1:5800/bfe1bf6a-2be5-4568-ac7d-69935e0867faFor help see https://nodejs.org/en/docs/inspector2017-09-14 16:01:36,432 INFO 39940 [master] agent_worker#1:39941 started (434ms)Debugger listening on ws://127.0.0.1:9230/2fcf4208-4571-4968-9da0-0863ab9f98aeFor help see https://nodejs.org/en/docs/inspector9230 openedDebug Proxy online, now you could attach to 9999 without worry about reload.DevTools → chrome-devtools://devtools/bundled/inspector.html?experiments=true&amp;v8only=true&amp;ws=127.0.0.1:9999/__ws_proxy__ （2）第二种方法对于普通的Node应用都适用（前提时使用了--inspect模式），访问chrome://inspect，配置相应的端口（Egg需要将9229和9230端口加入到配置中），然后点击Open dedicated DevTools for Node即可打开调试控制台。 使用Webstorm调试egg-bin会自动读取Webstorm下设置的环境变量$NODE_DEBUG_OPTION。 按照下图进行配置： 使用Webstorm的NPM调试启动即可进行Debug。 果然Webstorm太牛逼。 使用VSCode调试可以通过2个方式： 方式一：开启VSCode配置Debug: Toggle Auto Attach，然后在Terminal执行npm run debug 即可。 方式二：配置VSCode的.vscode/launch.json，然后F5一键启动即可。（注意，需要关闭方式一中的配置） 1234567891011121314151617181920// .vscode/launch.json&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Launch Egg", "type": "node", "request": "launch", "cwd": "$&#123;workspaceRoot&#125;", "runtimeExecutable": "npm", "windows": &#123; "runtimeExecutable": "npm.cmd" &#125;, "runtimeArgs": [ "run", "debug" ], "console": "integratedTerminal", "protocol": "auto", "restart": true, "port": 9229, "autoAttachChildProcesses": true &#125; ]&#125; 也提供了一个vscode-eggjs扩展来自动生成配置 参考 Node 调试工具入门教程@阮一峰的网络日志 使用 DevTools 进行调试@Egg]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS32 FOUC]]></title>
    <url>%2F2019%2F05%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS32%20FOUC%2F</url>
    <content type="text"><![CDATA[FOUC，Flash Of Unstyled Content，中文名称无样式内容闪烁。就是当浏览器在解析一个网页的时候，会出现的内容样式闪烁的现象。 什么是FOUCFOUC，Flash Of Unstyled Content，中文名称无样式内容闪烁。就是当浏览器在解析一个网页的时候，会出现的内容样式闪烁的现象。 具体的过程是，当页面加载渲染时，首先以样式A渲染，当页面加载渲染完成时，页面突然改为由样式B渲染，导致出现页面样式闪烁。 原理为什么会出现FOUC呢？这和浏览器渲染页面的流程机制有关系： （1）浏览器会首先构建DOM树， （2）处理CSS，生成样式树 （3）将DOM树和样式树合并，构建渲染树 （4）生成盒模型 （5）绘制信息 在第二步中，我们的CSS样式是放在&lt;head&gt;标签中的，样式树的构建过程不会阻塞DOM树的构建，但是由于渲染树依赖于样式树，所以只会在DOM树和样式树都解析完成后才会构建渲染树，进行后面的绘制。这样当文档的内容被绘制在屏幕上时，是已经加载了样式的内容。 但是，如果在CSS外部样式表没有放在&lt;head&gt;中，而是放在文档尾部，第二步中的样式树会采用浏览器内置样式（user agent stylesheet）来生成样式树。这样开始绘制内容采用的样式就是浏览器内置样式。当解析到文档尾部的自定义样式表时，会停止之前的渲染，重新加载样式，这就导致了页面样式有一个突变的过程，出现了FOUC的现象。 具体原因一般来说，出现FOUC的原因都是在浏览器开始绘制信息后才加载样式，一般会产生FOUC的操作有： （1）样式表没有放放在&lt;head&gt;中，而是放在页面底部，原因上面说过了。 （2）通过import导入样式表，它会组织并行加载代码， 解决方法将CSS外部样式表通过&lt;link&gt;的方式放在&lt;head&gt;中加载 Create-React-App在使用Create-React-App脚手架创建React的应用时，遇到了FOUC的问题，这是Create-React-App的2.1.4和2.1.5版本的bug 解决方法就是回退到2.1.3版本，或者试一下2.1.5+版本是否解决了这个问题。 参考 前端魔法堂：解秘 FOUC@掘金 什么是FOUC？如何避免FOUC？@咸鱼老弟]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>FOUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS31 网页换肤]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F09%20HTML%2BCSS%2FHTML%2BCSS31%20%E7%BD%91%E9%A1%B5%E6%8D%A2%E8%82%A4%2F</url>
    <content type="text"><![CDATA[实现网页换肤的三种办法。 常规做法1一个全局class来控制样式，切换皮肤时通过更改全局样式来实现换肤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;style&gt; /*默认样式*/ .default &#123; color: #000; background: #ddd; &#125; .default .text &#123; border: 1px solid #000; &#125; /*样式1*/ .green &#123; color: lemonchiffon; background: green; &#125; .green .text &#123; border: 1px solid darkblue; &#125; /*样式2*/ .red &#123; color: navajowhite; background: red; &#125; .red .text &#123; border: 1px solid pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="default"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const skinContainer = document.querySelector('#skin-container'); const inputContainer = document.querySelector('.input-container'); const changeSkin = theme =&gt; &#123; const &#123; classList &#125; = skinContainer; const &#123; value &#125; = classList; classList.replace(value, theme) &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 这种方法的缺点是，加入了一个全局的class控制样式，提高了样式优先级，如果换肤样式多，代码会非常罗嗦（Less可以简化一部分代码，但是维护还是不方便） 常规做法2第二种做法是新建多个对应皮肤样式的CSS文件，通过改变&lt;Link&gt;元素的href属性来切换皮肤 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;link id="skinLink" href="../styles/default.css" rel="stylesheet" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="theme"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const skinLink = document.querySelector('#skinLink'); const inputContainer = document.querySelector('.input-container'); const changeSkin = theme =&gt; &#123; skinLink.href = `../styles/$&#123;theme&#125;.css` &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 几个不同的CSS文件default.css、red.css、green.css中定义不同皮肤的样式 这种方法的缺点是使用JS改变href属性会带来加载延迟，样式切换不流畅（因为新切换的CSS文件原本没有加载，改变了href属性后才会加载，会有延迟） 第三种方法可以借助&lt;link&gt;标签的rel属性的alternate属性值来实现： 123456&lt;link href="reset.css" rel="stylesheet" type="text/css"&gt;&lt;link href="default.css" rel="stylesheet" type="text/css" title="默认"&gt;&lt;link href="red.css" rel="alternate stylesheet" type="text/css" title="红色"&gt;&lt;link href="green.css" rel="alternate stylesheet" type="text/css" title="绿色"&gt; 上面有4个&lt;link&gt;元素，出现了三种不同性质的CSS文件加载： 没有title属性，rel属性值仅仅是stylesheet的&lt;link&gt;元素（第一种），无论如何都会加载，可以利用它来加载reset.css 有title属性，rel属性值仅仅是stylesheet的&lt;link&gt;元素（第二种），作为默认的CSS文件加载并渲染，如default.css 有title属性，rel属性值同时包含alternate stylesheet的&lt;link&gt;元素（第三种和第四种），作为备选的CSS样式文件加载，但不渲染，通过控制其disabled属性来确定是否渲染，用来指定皮肤样式 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="../styles/base.css" rel="stylesheet" type="text/css"&gt; &lt;link id="theme-default" title="默认" href="../styles/default.css" rel="stylesheet" type="text/css"&gt; &lt;link id="theme-green" title="绿色" href="../styles/green.css" rel="stylesheet alternate" type="text/css"&gt; &lt;link id="theme-red" title="红色" href="../styles/red.css" rel="stylesheet alternate" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="skin-container" class="theme"&gt; &lt;p class="text"&gt;Hello!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-container"&gt; &lt;label class="input"&gt;&lt;input type="radio" value="default" name="skin" checked&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="green" name="skin"&gt;&lt;/label&gt; &lt;label class="input"&gt;&lt;input type="radio" value="red" name="skin"&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const inputContainer = document.querySelector('.input-container'); const links = document.querySelectorAll('link[title]'); const changeSkin = theme =&gt; &#123; [...links].forEach(link =&gt; &#123; link.disabled = true; link.disabled = link.id !==`theme-$&#123;theme&#125;`; &#125;); console.log(links) &#125;; inputContainer.addEventListener('change', (e) =&gt; &#123; changeSkin(e.target.value) &#125;)&lt;/script&gt;&lt;/html&gt; 要注意的是，如果具有alternate的元素有两个及以上的disbaled都为false，那么哪个都不会加载。 这种方法的优点是： 兼容性好 语义非常好 交互体验好，因为CSS文件被提前加载了，切换皮肤时不会有延迟 文档中的代码在这里。 参考 link rel=alternate网站换肤功能最佳实现@鑫空间鑫生活]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router03 按需加载]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router03%20%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[为了提高页面加载性能，加载首屏的加载速度，有的时候我们需要对路由进行懒按需加载，减少首屏需要加载的代码包的体积。 按需加载就是不加载当前路由匹配的组件代码，而不加载其他组件的代码 V3中的实现在V4版本之前，需要利用getComponet这个API来实现按需加载： 12345678const about = (location, cb) =&gt; &#123; require.ensure([], require =&gt; &#123; cb(null, require(&apos;../Component/about&apos;).default) &#125;, &apos;about&apos;)&#125;//配置route&lt;Route path=&quot;helpCenter&quot; getComponent=&#123;about&#125; /&gt; 其中require.ensuire是Webpack的语法： 123456require.ensure( dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String) 给定dependencies参数，将对应的文件拆分到单独的bundle中，此bundle会被异步加载。可以实现动态加载依赖（使用CommonJS的模块语法时这是动态加载依赖的唯一方法），这样能够做到在模块执行时才运行代码，只有在满足某些条件时才加载依赖项。 V4中的实现由于V4版本的动态路由的机制，以及废除了getComponent这个API，实现按需加载的方法比较复杂，首先需要介绍bundle-loader这个Webpack插件，它可以将模块改成异步方式引用，需要单独安装并且在Webpack中进行配置，具体参考Webpack的文档。 准备好bundle-loader之后，正式开始： （1）第一步，创建包装组件模型bundle.js，用来处理经过bundle-loader处理后的组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &apos;react&apos;;class Bundle extends React.Component &#123; constructor(arg)&#123; super(arg) this.state = &#123; mod: null, &#125; &#125; componentWillMount() &#123; this.load(this.props); &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.load !== this.props.load) &#123; this.load(nextProps); &#125; &#125; // load 方法，用于更新 mod 状态 load(props) &#123; // 初始化 this.setState(&#123; mod: null &#125;); /* 调用传入的 load 方法，并传入一个回调函数 这个回调函数接收 在 load 方法内部异步获取到的组件，并将其更新为 mod */ props.load(mod =&gt; &#123; this.setState(&#123; mod: mod.default ? mod.default : mod &#125;); &#125;); &#125; render() &#123; /* 将存在状态中的 mod 组件作为参数传递给当前包装组件的&apos;子&apos; */ return this.state.mod ? this.props.children(this.state.mod) : null; &#125;&#125;export default Bundle ; （2）第二步，创建包装组件的方法 12345678910111213141516171819import React from &apos;react&apos;;import Bundle from &apos;./Bundle&apos;;// 默认加载组件，可以直接返回 nullconst Loading = () =&gt; &lt;div&gt;Loading...&lt;/div&gt;;/* 包装方法，第一次调用后会返回一个组件（函数式组件） 由于要将其作为路由下的组件，所以需要将 props 传入 */const lazyLoad = loadComponent =&gt; props =&gt; ( &lt;Bundle load=&#123;loadComponent&#125;&gt; &#123;Comp =&gt; (Comp ? &lt;Comp &#123;...props&#125; /&gt; : &lt;Loading /&gt;)&#125; &lt;/Bundle&gt;);//实际上lazyLoad就是一个函数,组件调用即可export default lazyLoad; 在上面的代码中回到出一个函数供组件调用，传入的参数loadComponent就是要加载的组件，在路由中调用，而bundle.js作为按需加载的核心，传入的参数load就是要加载的组件，其中的内容是动态的子组件 （3）在路由中使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from &apos;react&apos;;import &#123; NavLink, Route, Switch, BrowserRouter as Router &#125; from &apos;react-router-dom&apos;;import &apos;./style/style.css&apos;;import &apos;bundle-loader&apos;;// bundle模型用来异步加载组件import Bundle from &apos;../routes/Bundle.js&apos;;import lazyLoad from &apos;../routes/lazyLoad&apos;;import Page1 from &apos;bundle-loader?lazy&amp;name=page1!../components/page1/index&apos;;import Page2 from &apos;bundle-loader?lazy&amp;name=page2!../components/page2/index&apos;;import Page3 from &apos;bundle-loader?lazy&amp;name=page3!../components/page3/index&apos;;class AppPage extends React.Component &#123; constructor(arg) &#123; super(arg); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;Router basename=&quot;/&quot;&gt; &lt;div className=&quot;appWried&quot;&gt; &lt;div className=&quot;appBtn&quot;&gt; &lt;NavLink to=&quot;/page1&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE1 &lt;/NavLink&gt; &lt;NavLink to=&quot;/page2&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE2 &lt;/NavLink&gt; &lt;NavLink to=&quot;/page3&quot; className=&quot;button&quot; activeClassName=&quot;active&quot;&gt; PAGE3 &lt;/NavLink&gt; &lt;/div&gt; &lt;Switch&gt; &lt;Route path=&quot;/page1&quot; component=&#123;lazyLoad(Page1)&#125; /&gt; &lt;Route path=&quot;/page2&quot; component=&#123;lazyLoad(Page2)&#125; /&gt; &lt;Route path=&quot;/page3&quot; component=&#123;lazyLoad(Page3)&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default AppPage; 在上面的代码中，使用bundle-loader加载模块时语法为 1import Page1 from 'bundle-loader?lazy&amp;name=page1!../components/page1/index'; 其中lazy表示懒加载，name表示要异生成的文件的名字。 （4）最后需要在webpack.config.js文件中进行配置 12345output: &#123; path: path.resolve(__dirname, './output'), filename: '[name].[chunkhash:8].bundle.js', chunkFilename: '[name]-[id].[chunkhash:8].bundle.js',&#125;, 参考 模块方法@weback 前端性能优化之按需加载(React-router+webpack)@xiaobe]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
        <tag>按需加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router02 静态路由和动态路由]]></title>
    <url>%2F2019%2F05%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router02%20%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[React-RouterV3/V4两个版本理念上的区别。 静态路由传统的路由一般都是静态路由，像Express等框架，使用的都是静态路由： 12345678React.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 路由集中配置，UI与路由强绑定。 React-Router V3版本采用的就是静态路由，本质就是path到模块的映射，这种映射关系是静态的。只要程序已启动，映射关系就不能改变了。 从V4版本开始变为了动态路由。这是因为静态路由存在着天生的问题： （1）路就有写法需要满足约定的格式，比如不能将&lt;Route&gt;脱离&lt;Router&gt;使用，这与React倡导的“可以声明式灵活性进行组件组装”的理念。 12// 静态路由不支持const CoolRoute = (props) =&gt; &lt;Route &#123;...props&#125; cool=&#123;true&#125;/&gt; （2）因为&lt;Router&gt;接管了组件，内部实现了createElement、render等方法，同时提供了组件生命周期回调onEnter、onLeave、·onChange`等，而这些生命周期React本身是为组件提供了的。 （3）为了适应代码拆分，引入了getComponent和getChildRoutes 动态路由为了解决以上问题，V4版本中引入了动态路由的概念。 既然React组件渲染时动态发生的，在V4中可以将路由看成普通的React组件，传递props来正常使用，借助它来控制组件的展现。展示的逻辑及权利回归到了组件本身。这样没有了静态配置的路由规则，取而代之的是程序在运行渲染过程中动态控制的展现。 这边是V4中的动态路由的概念。 当&lt;Router&gt;作为普通组件后，React-Router提供的一些特殊的API就不存在了，因为React会为组件提供对应的生命周期函数等API。 通过代码看一下静态路由和动态路由的区别： 123456789101112131415161718192021222324252627// V3import &#123; Router, Route, IndexRoute &#125; from &apos;react-router&apos;const PrimaryLayout = props =&gt; ( &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 3 App &lt;/header&gt; &lt;main&gt; &#123;props.children&#125; &lt;/main&gt; &lt;/div&gt;)const HomePage =() =&gt; &lt;div&gt;Home Page&lt;/div&gt;const UsersPage = () =&gt; &lt;div&gt;Users Page&lt;/div&gt;const App = () =&gt; ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;PrimaryLayout&#125;&gt; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/users&quot; component=&#123;UsersPage&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;)render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)) 在上面的路由中，配置集中在App中，&lt;Route&gt;直接嵌套与&lt;Router&gt;，页面组件作为路由的一分部分与路由机密耦合。这便是整个路由的配置。 V4版本的写法： 123456789101112131415161718192021222324import &#123; BrowserRouter, Route &#125; from &apos;react-router-dom&apos;const PrimaryLayout = () =&gt; ( &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 4 App &lt;/header&gt; &lt;main&gt; &lt;Route path=&quot;/&quot; exact component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/users&quot; component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;)const HomePage =() =&gt; &lt;div&gt;Home Page&lt;/div&gt;const UsersPage = () =&gt; &lt;div&gt;Users Page&lt;/div&gt;const App = () =&gt; ( &lt;BrowserRouter&gt; &lt;PrimaryLayout /&gt; &lt;/BrowserRouter&gt;)render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)) V4中React-Router仓库拆分成了多个包进行发布： react-router，路由基础库 react-router-dom，浏览器中使用的封装 react-router-native，React Native的封装 嵌套路由相比于V3中的集中式的静态路由，V4中似乎看不到路由的影子了，它穿插在了各组件中。尤其是在需要路由嵌套的情况下更加明显，路由嵌套到了组件中，而不再是像V3中那样，&lt;Route&gt;中嵌套&lt;Route&gt;，V4中&lt;Route&gt;中不允许再嵌套&lt;Route&gt; 1234567891011121314151617181920// V3const App = () =&gt; ( &lt;BrowserRouter&gt; &lt;div&gt; &#123;/* 外层路由 */&#125; &lt;Route path=&quot;/tacos&quot; component=&#123;Tacos&#125;/&gt; &lt;/div&gt; &lt;/BrowserRouter&gt;)// 当URL匹配`/tacos`时渲染Tacos组件const Tacos = (&#123; match &#125;) =&gt; ( &lt;div&gt; &#123;/* 嵌套路由，match.url可以更方便的使用相对地址 */&#125; &lt;Route path=&#123;match.url + &apos;/carnitas&apos;&#125; component=&#123;Carnitas&#125; /&gt; &lt;/div&gt;) 上面的代码中，&lt;Tacos&gt;组件是否展示，取决于当前路由是否与/tacos匹配，而&lt;Route&gt;可以理解为一个容器，它做的事情很简单，将传入的path与当前的location进行比较，撇皮则渲染component属性传入的组件，否则return null 在看一个嵌套路由的例子，V3中&lt;Route&gt;中嵌套&lt;Route&gt;： 12345678&lt;Router history=&#123;history&#125; createElement=&#123;createElement&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&quot;home&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 最顶层的&lt;Route&gt;对应的是&lt;App&gt;这个组件，这个组件的事情就是渲染&lt;TopMenu&gt;，并且把传入的子组件全部渲染出来： 12345678const App = (&#123;children&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;TopMenu /&gt; &lt;div&gt;&#123;children&#125;&lt;/div&gt; &lt;/div&gt; );&#125;; 因为&lt;App&gt;对应的URL是/，所以所有的路由都会鲜明中&lt;App&gt;，然后&lt;App&gt;会渲染子组件，而它的子组件除了&lt;TopMenu&gt;之外就是其他的路由&lt;Route&gt;，于是/home就会命中对应的路由，渲染结果中既包含了&lt;TopMenu&gt;也包含了&lt;Home&gt; 在V4中，&lt;Route&gt;不能再包含&lt;Route&gt;，代码需要改为： 12345678910&lt;Router history=&#123;history&#125;&gt; &lt;div&gt; &lt;TopMenu /&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route exact path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;*&quot; component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; &lt;Route&gt;变成了普通的React组件，可以认为它是在渲染时动态决定路由对应什么组件的。&lt;Switch&gt;的左右就是只渲染子组件中&lt;Route&gt;第一个匹配的。 动态路由的问题动态路由也有着自己的问题： 不够直观，由于路由分散，无法一下子了解程序中所有的路由 测试难度增加，组件中掺杂了路由逻辑，原本针对组件的单元测试需要考虑路由的逻辑 实际上，React开发者对V4版本的改变也是喜忧参半，React官方也并没有强制开发者升级，因为V2/3版本会持续维护。 参考 心中无路由，处处皆自由/react-router v4 动态路由@github React Router v4 几乎误我一生@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础12 React中的this绑定]]></title>
    <url>%2F2019%2F05%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8012%20React%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[React组件中的this绑定到底是怎么一回事？学习一下。 为什么要bind(this)React的Class组件中常常会用到bind(this)来绑定this，但是究竟为什么要这么做呢？难道Class中的方法拿不到实例的this吗？ 来试验一下： 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125; say() &#123; console.log('my name is ' + this.name); &#125;&#125; 上面代码的Person类中，say方法去获取了this，然后当我们实例化一个对象时，并调用say()方法时，结果是： 123let p1 = new Person('Jay');p1.say();// my name is Jay 结果说明在Class的方法中，是可以直接通过this获得实例对象的。所以实际上在React的Class中直接使用this是没有问题的，例如在生命周期函数或者render中。但是在render函数中的JSX模板中的事件处理函数，这里面的调用的方法的this就不会指向组件实例： 12345678910111213export default class Demo5 extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 上面的handleClick函数作为JSX中的事件处理函数，其中的this不会指向组件实例，而是指向了事件响应的上下文环境（非严格环境下是window，严格环境下是undefined），而类声明和类表达式的主体以严格模式执行（主要包括构造函数、静态方法和原型方法以及getter和setter函数），所以this指向undefined 为什么this不能指向组件实例实际上这与React和JSX语法没有关系，是JavaScript的this绑定机制导致了上述情况的发生。要明确的是，函数内部的this取决于该函数被调用时的上下文环境。 默认绑定12345function display()&#123; console.log(this); // 'this' 将指向全局变量&#125;display(); 在上面的情况下，display方法中的this在非严格模式下指向window，在严格模式下指向undefined 隐式绑定12345678const obj = &#123; name: 'Saurabh', display: function()&#123; console.log(this.name); // 'this' 指向 obj &#125;&#125;;obj.display(); // Saurabh 在上面的情况下，通过obj对象来调用这个函数时，display内部的this指向了obj。 但是如果将这个函数赋值给其他变量，并且通过这个变量去调用该函数时，在display中获得this就不同了： 123var name = 'hello';const outer = obj.display;outer(); // 'hello' 我们调用outer时，并没有指定一个具体的上下文对象，这个时候this值与默认绑定的结果是相同的，在非严格模式下指向window，在严格模式下指向undefined 在将一个方法以回调的形式传递给另外一个函数，或者像setTimeout这样的内置JavaScript函数时，就可以依照上面的过程进行判断 例如我们自定义一个setTimeout方法并调用，预测一下会发生什么： 12345678//setTimeout 的虚拟实现function setTimeout(callback, delay)&#123; //等待 'delay' 数个毫秒 callback();&#125;setTimeout(obj.display, 1000); 在调用setTimeout时，函数内部将obj.display赋值给参数callback: 1callback = obj.display; 在一段时间后调用这个方法时，调用的实际上是callback()，而这种调用会让display方法丢失上下文，其中的this会退回至默认绑定，指向全局变量 1234var name = "uh oh! global";setTimeout( obj.display, 1000 );// uh oh! global 显示绑定为了避免上面的情况，可以使用bind来显式的为方法绑定上下文： 12345var name = "uh oh! global";var outerDisplay = obj.display.bind(obj); outerDisplay();// Saurabh 绑定了this后，在调用对应的方法也能够渠道我们绑定的上下文。同理，粗若将obj.display作为callback参数传递给函数，display中的this也会正确指向obj React编译时的处理明确了隐式绑定时，将方法作为参数传递给另一个函数时会导致该方法的上下文丢失。而在React的类的写法中，JSX的事件处理程序的this会丢失，就是因为这个原因。 在编译JSX的过程中，事件处理程序会作为属性值被放置在一个对象中，调用时会识别为函数调用模式，上下文丢失。 举个例子，下面的Class组件： 123456789101112131415export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; this.handleClick(); return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 编译完是下面这样的： 12345678910111213141516171819const Demo = function (_Component) &#123; _inherits(Deom, _Component); function Demo() &#123; _classCallCheck(this, Demo); return _possibleConstructorReturn(this, _Component.apply(this, arguments)); &#125; Demo.prototype.handleClick = function handleClick() &#123; console.log(this); &#125; Demo.prototype.render = function render() &#123; this.handleClick(); return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement( 'div', &#123; onClick: this.handleClick &#125;, 'hello', ) &#125; return Demo;&#125;(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]) 很明显的看到，当编译完成后，JSX中的事件处理程序handleClick是放置在{ onClick: this.handleClick }中，当点击事件触发时实际上调用的是onClick，和隐式调用中的结果一样，上下文丢失了，this指向undefined。 而如果我们在JSX中使用bind绑定this： 1&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;Hello&lt;/div&gt; 那么编译后就变成了{ onClick: this.handleClick.bind(this) }，这就显式的绑定了this。 解决方法（1）React官方首推的一种方法就是使用实验性的语法public class fileds，可以使用class fields正确的绑定回调函数： 12345678910111213export default class Demo extends Component &#123; handleClick = () =&gt; &#123; console.log(this); &#125;; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 上面的写法会会保证handleClick内的this被正确绑定，要注意的是这是一个实验性的语法，但是Create React App默认启用了这个语法。 如果没有使用Create React App的话需要手动开启这个语法，使用Babel的transform-class-properties或者enable stage-2 in Babel这两项功能 （2）第种方式是在JSX的回调函数中使用箭头函数： 12345678910111213export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这种语法的主要问题还是来自于性能的担忧，因为每次渲染组件时都会创建不同的回调函数。大多数情况时没有什么问题，但是如果该回调函数作为prop传入子组件时，这些组件可能会进行额外的重新渲染。 （3）第三种方式是在JSX的回调函数中使用bind进行绑定： 12345678910111213export default class Demo extends Component &#123; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这种方法的问题和上一种是类似的，有可能带来性能的问题。 （4）第四种方式是在构造函数constructor中进行显示的绑定： 123456789101112131415161718export default class Demo extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log(this); &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; Hello &lt;/div&gt; ); &#125;&#125; 这样就可以避免第二种方法可能带来的性能问题，而且很直观，但问题是增加了代码数量，而且为了绑定this必须声明constructor，在constructor中还不能忘记super，有点麻烦 所以，从性能角度上考虑，如果开启了对应的public class fileds语法（使用了Create React App），那么建议使用第一种方式，否则的话建议使用最后一种方式。 参考 事件处理@React react为什么需要手动绑定方法？@React教程中文网 [译] 为什么需要在 React 类组件中为事件处理程序绑定 this@掘金 React與bind this的一些心得@medium]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础11 React中初始化state的两种方法]]></title>
    <url>%2F2019%2F05%2F12%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact01%20%E5%9F%BA%E7%A1%80%2FReact%E5%9F%BA%E7%A1%8011%20React%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96state%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在React的组件中可以在两个位置来初始化state：（1）在组件的constructor中；（2）直接在class中利用属性赋值的方式 在constructor中在constructor中初始化state如下所示： 12345678910111213141516171819class App extends React.Component &#123; constructor(props) &#123; // 必须在这里通过super调用父类的constructor super(props); // 给state赋值，可以使用props this.state = &#123; loggedIn: false, currentState: "not-panic", // 在使用props为state赋值时要格外仔细 someInitialValue: this.props.initialValue &#125; &#125; render() &#123; // whatever you like &#125;&#125; 当一个class组件创建之后，constructor会首先被调用，所以在construcot中可以来初始化所有值，包括state。class实例在内存中已经被创建，所以可以使用this来为state赋值 要注意的是，在constructor中可以不使用this.setState来为state直接赋值，除此之外其他位置都不能这样做： 12// 除了在constructor中，其他位置都不要这样做this.state.a = 123 只有通过setState才能通知React，我们修改了数据，React需要重新渲染组件。 还有要注意的是，在constructor中不要忘记使用super(props)来调用父类的constructor。默认的constructor（当创建一个class时，如果我们没有显式的声明constructor，JS会默认提供一个）会自动调用super，将将所有的参数传入 使用prop来初始化state大多数情况下都不要使用prop来为State的初始化赋值，因为这会让你的数据来源不唯一，这常常会导致Bug。数据源唯一是最佳实践。 当组件的prop发生改变，组件会重渲染，所以没有必要将prop复制为state来保证porp永远是最新的值。 123456789101112131415161718192021222324252627282930313233343536// 不要这样做class BadExample extends Component &#123; state = &#123; data: props.data &#125; componentDidUpdate(oldProps) &#123; // 复制了prop的值给state之后 // 必须保证在props更新时，state的值也随之更新 if(oldProps.data !== this.props.data) &#123; // This triggers an unnecessary re-render this.setState(&#123; data: this.props.data &#125;); &#125; &#125; render() &#123; return ( &lt;div&gt; The data: &#123;this.state.data&#125; &lt;/div&gt; ) &#125;&#125;// 正确的做法：class GoodExample extends Component &#123; render() &#123; return ( &lt;div&gt; The data: &#123;this.props.data&#125; &lt;/div&gt; ) &#125; &#125; constructor是必须的吗？并一定必须显式的定义constructor，因为JS会提供默认的constructor。比如下面这个例子： 12345678910class Parent &#123; constructor(arg) &#123; console.log('constructing Parent with', arg) &#125; &#125;class Child extends Parent &#123;&#125;new Child(5);// constructing Parent with 5 当创建Child的实例时，控制台会打印出constructing Parent with 5，虽然Child类并没有显式的定义constructor，也没有显式的通过super(props)调用父类。当我们没有定义自己的constructor时，JS会自动完成super的步骤。 直接在Class中定义第二种初始化state的方法就是直接在Class的内部，使用Class的属性来定义： 1234567891011class App extends React.Component &#123; state = &#123; loggedIn: false, currentState: "not-panic", someDefaultThing: this.props.whatever &#125; render() &#123; // whatever you like &#125;&#125; 比如使用construcot更加得直接、简介。要注意的是： 没有定义constructor state属性是直接引用的，并不是通过this.state来引用的 state的作用域是在Class内部，并不是一个方法的内部 仍然可以使用this.props和this.context state是class的实例属性，并不是静态属性，不需要添加static关键字（就像为static propTypes {...}） 哪种更好习惯使用哪种，就使用哪种。 class属性的方式看起来更加简单，不再需要额外的模板代码（constructor），也不需要提醒自己调用super(props) 有的时候需要在constructor中处理事件处理函数（为函数绑定this，就像： 12345678910class Thing extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick(event) &#123; // do stuff &#125;&#125; 可以通过Class属性的另外一种形式来替代上面的形式，可以让一个属性等于一个箭头函数，箭头函数获得了class实例的this，所以不再需要在constructor中显式的去绑定： 12345class Thing extends React.Component &#123; handleClick = (event) =&gt; &#123; // do stuff &#125;&#125; 参考 Where to Initialize State in React@Dave Ceddia]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>state</tag>
        <tag>constructor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg02 使用Postman发送Post请求]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg02%20%E4%BD%BF%E7%94%A8Postman%E5%8F%91%E9%80%81Post%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用Postman测试Egg框架实现的API 关闭安全防范默认情况下，Egg在框架中内置了安全插件egg-security，插件中针对post请求做出了一些处理，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的enable属性为false即可。 写例子的话可临时在config/config.default.js中设置 123exports.security = &#123; csrf: false&#125;; 在网页发送请求在AJAX请求中，默认配置下，token会被设置在Cookie中，在AJAX请求时，可以从Cookie中获取到token，放置到query、body或者header中发送给服务端： 使用jQuery： 12345678910111213var csrftoken = Cookies.get('csrfToken');function csrfSafeMethod(method) &#123; // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));&#125;$.ajaxSetup(&#123; beforeSend: function(xhr, settings) &#123; if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) &#123; xhr.setRequestHeader('x-csrf-token', csrftoken); &#125; &#125;,&#125;); 通过header传递CSRF token的字段可以在配置中改变： 12345678// config/config.default.jsmodule.exports = &#123; security: &#123; csrf: &#123; headerName: 'x-csrf-token', // 通过 header 传递 CSRF token 的默认字段为 x-csrf-token &#125;, &#125;,&#125;; 在Postman中发送请求使用Postman来测试API时，直接发送POST请求，会返回403，因为没有传递CSRF token，这个时候可以通过环境配置，来让Postman自动生成CSRF token。 这个功能需要使用独立的Postman APP，Chrome插件是不行的。 在Postman右上角，新建一个环境： 点击Add添加后，将环境切换为新建的环境： 然后在Tests标签下，通过下面的脚本，获取cookie中的csfrtoken，并且写入到postman的全局变量中： 123var csrf_token = postman.getResponseCookie("csrftoken").valuepostman.clearGlobalVariable("csrftoken");postman.setGlobalVariable("csrftoken", csrf_token); 然后发送一个Get请求，来写入Cookie： 在发送Post请求时，在Header中添加字段： 再点击发送Post请求就没问题了。 参考 安全@Egg postman自动设置token(csrf及authorization token)@knktc的杂乱空间]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa01 中间件]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F02%20Koa%2FKoa01%20%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。基本上，Koa 所有的功能都是通过中间件实现的。 概念Koa中间件的最大特色就是中间件（middleware）的设计。 中间件是一个函数，它处在HTTP Request和HTTP Response中间，用来实现某种中间功能，通过app.use()来加载中间件。 1234567891011const Koa = require('koa');const app = new Koa();app.use(async (ctx) =&gt; &#123; ctx.response.body = 'GO'&#125;);app.listen(8080, () =&gt; &#123; console.log('app is listening 8080...');&#125;); 中间件的执行顺序多个中间件会形成栈结构，以先进后出的顺序执行： 最外层的中间件首先执行 代用next函数，把执行权交给下一个中间件 …… 最内层的中间件最后执行 执行结束后，把执行权交回上一层的中间件 …… 最外层的中间件收回执行权后，执行next函数后面的代码 看下面的例子： 12345678910111213141516171819202122app.use(async (ctx, next) =&gt; &#123; console.log(1-1); ctx.response.body = 'GO'; next(); console.log(1-2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(2-1); next(); console.log(2-2);&#125;);app.use(async (ctx, next) =&gt; &#123; console.log(3-1); next(); console.log(3-2);&#125;);app.listen(8080, () =&gt; &#123; console.log('app is listening 8080...');&#125;); 执行结果是： 1234561-12-13-13-22-21-2 这种先进后出的加载模型也可以叫做洋葱圈的模型： 如果中间件内部没有调用next函数，那么执行权就不会传递下去。 异步中间件当中间件中包含异步操作时，中间件应该写成Async函数： 123app.use(async (ctx, next) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 注意，如果调用next，必须等待完成 12345678app.use(async (ctx, next) =&gt; &#123; console.log(1); next();&#125;);app.use((ctx) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 如果是上面的形式，返回的body中将没有任何内容，这是因为Koa在Promise链被机械系了之后就结束了请求，这意味着我们在设置ctx.response.body之前，response就已经被发送了给客户端，正确的做法应该是在第一个中间件的next之前添加await： 12345678app.use(async (ctx, next) =&gt; &#123; console.log(1); await next();&#125;);app.use((ctx) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8');&#125;); 当使用纯粹的Promise（不使用Async/Await）应该写成这样： 123456app.use((ctx, next) =&gt; &#123; ctx.status = 200 console.log('Setting status') // need to return here, not using async-await return next()&#125;) 处理中间件中的错误为了方便处理错误，最好使用try...catch将其捕获。但是为每个中间件写try...catch太麻烦，可以让最外层的中间件负责所有中间件的错误处理 123456789101112131415161718192021const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (e) &#123; ctx.response.status = e.statusCode || e.status || 500; ctx.response.body = &#123; message: e.message &#125; &#125;&#125;;app.use(handler);app.use(async (ctx, next) =&gt; &#123; ctx.response.body = await fse.readFile('../demo3/test.txt', 'utf-8'); await next();&#125;);app.use((ctx) =&gt; &#123; ctx.throw(500)&#125;); 运行中，没有被catch的错误都会触发Koa的error时间，监听这个事件，也可以处理错误： 1234567const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', (err, ctx) =&gt; console.error('server error', err);); 但是如果错误被catch捕获，就不会触发error事件，这时候必须调用ctx.app.emit()手动释放error事件，才能使监听函数生效。 1234567891011121314151617// demos/18.js`const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit('error', err, ctx); &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', function(err) &#123; console.log('logging error ', err.message); console.log(err);&#125;); 中间件的开发generator中间件的开发Koa1中的异步流程控制使用的是Generator函数，所以Koa1的中间件都是基于generator的。 Generator中间件返回的是function *(){}函数： 123456789101112131415function log(ctx) &#123; console.log(ctx.method, ctx.header.host + ctx.url);&#125;module.exports = function () &#123; return function* f(next) &#123; // 执行中间件的操作 log(this); if (next) &#123; yield next; &#125; &#125;&#125;; Generator中间件在Koa1中可以直接使用，在Koa2中需要使用koa-convert转换后进行使用 1app.use(convert(loggerGenerator())); Async中间件的开发1234567891011121314function log(ctx) &#123; console.log(2, ctx.method, ctx.header.host + ctx.url);&#125;module.exports = function () &#123; return async function f(ctx, next) &#123; // 执行中间件的操作 log(ctx); if (next) &#123; await next(); &#125; &#125;&#125;; Async中间件在Koa2中可以直接使用： 1app.use(loggerAsync()); 中间件引擎简单实现Koa中的中间件的加载和解析主要是通过Koa的中间件引擎koa-compose模块来实现的，也是Koa实现洋葱模型的核心引擎。 1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa');let app = new Koa();const middleware1 = async (ctx, next) =&gt; &#123; console.log(1); await next(); console.log(6); &#125;const middleware2 = async (ctx, next) =&gt; &#123; console.log(2); await next(); console.log(5); &#125;const middleware3 = async (ctx, next) =&gt; &#123; console.log(3); await next(); console.log(4); &#125;app.use(middleware1);app.use(middleware2);app.use(middleware3);app.use(async(ctx, next) =&gt; &#123; ctx.body = 'hello world'&#125;)app.listen(3001)// 启动访问浏览器// 控制台会出现以下结果// 1// 2// 3// 4// 5// 6 上面await next前后的操作，很像数据结构的一种场景——栈，先进后出，并且各个中间件有着统一的上下文，便于管理、操作数据，所以Koa的中间件具有以下特性： 有统一的上下文对象context 执行顺序先进后出 通过next来控制先进后出的机制 有提前结束机制 可以简单的用Promise来实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Created By zh on 2019-05-05 */// 所以 Koa 的中间件具有以下特性：// 1 有统一的上下文对象 context// 2 执行顺序先进后出// 3 通过 next 来控制先进后出的机制// 4 有提前结束机制// 可以使用 Promise 来做一个简单的实现let context = &#123; data: []&#125;;class MyKoa &#123; constructor() &#123; this.middlewares = []; this.context = &#123; data: [] &#125; &#125; use(middleware) &#123; this.middlewares.push(middleware) &#125; compose() &#123; let count = -1; const dispatch = () =&gt; &#123; count += 1; return Promise.resolve(this.middlewares[count](this.context, async () =&gt; &#123; if (this.middlewares.length - 1 === count) &#123; return Promise.resolve() &#125; return dispatch() &#125;)) &#125;; return dispatch().then(() =&gt; &#123; console.log('end'); console.log('context = ', this.context); &#125;); &#125;&#125;async function middleware1(ctx, next) &#123; console.log('action 001'); ctx.data.push(1); await next(); console.log('cation 006'); ctx.data.push(6)&#125;async function middleware2(ctx, next) &#123; console.log('action 002'); ctx.data.push(2); await next(); console.log('cation 005'); ctx.data.push(5)&#125;async function middleware3(ctx, next) &#123; console.log('action 003'); ctx.data.push(3); await next(); console.log('cation 004'); ctx.data.push(4)&#125;const app = new MyKoa();app.use(middleware1);app.use(middleware2);app.use(middleware3);app.compose();// action 001// action 002// action 003// cation 004// cation 005// cation 006// end// context = &#123; data: [ 1, 2, 3, 4, 5, 6 ] &#125; 源码解读核心原理就如同上面的compose方法所示，洋葱模型的先进后出顺序，对应Promise.resolve的前后操作，来看一下koa-compose的源码： 12345678910111213141516171819202122232425262728293031323334353637383940const compose = middleware =&gt; &#123; if (!Array.isArray(middleware)) &#123; throw new TypeError('Middleware stack must be an array') &#125; for (const fn of middleware) &#123; if (typeof fn !== 'function') &#123; throw new TypeError('Middleware must be composed of functions') &#125; &#125; return function (context, next) &#123; let index = -1; return dispatch(0); function dispatch(i) &#123; console.log(index, 888); console.log(i, 999); // 理论上 i 会大于 index，因为每次执行一次都会把 i 递增， // 如果相等或者小于，则说明 next() 执行了多次 if (i &lt;= index) &#123; return Promise.reject(new Error('next() called multiple times')); &#125; index = i; // 取到当前的中间件 let fn = middleware[i]; if (i === middleware.length) &#123; fn = next; &#125; if (!fn) &#123; return Promise.resolve(); &#125; try &#123; return Promise.resolve(fn(context, function () &#123; return dispatch(i + 1); &#125;)) &#125; catch (err) &#123; return Promise.reject(err); &#125; &#125; &#125;&#125;; 一个中间件中是不能够调用两次next，这是通过if (i &lt;= index)这条代码来判断的，我想了好一会，才理解这是什么原理。先把它放在这里，把主题逻辑理清楚再回过头说它。 compose返回了一个匿名函数，匿名函数里定义了dispatch函数，并传入0作为初始函数。 在dispatch函数中，i用于标识当前的中间件的下标（中间件通过use方法收集到了middleware这个数组中）。 然后判断next是否在一个中间件中多次调用（暂时略过），然后将当前的i赋值给index，index的唯一的作用也是用来记录当前中间件的下标，判断next方法调用的次数，后面再说。 接下来对fn赋值，获得中间件，在定义中间件时传入了两个参数，第一个就是上下文对象ctx，第二个参数是用来控制流程的next方法，这个next方法中我们通过执行dispatch(i + 1)来递归调用，执行下一个中间件。 这也是为什么我们在自己编写中间件时需要手动执行await next()，只有执行了next函数，才能正确的执行下一个中间件 在多个中间件级联执行时，第一个中间件需要等待第二个中间件返回一个resolved的Promise，也就是在await next()后才能继续执行剩余代码，第二个中间件同样需要等待下一个中间件返回resolved的Promise，这样就实现了洋葱圈模型的执行顺序。 所以如果要写一个Koa2的插件就应该如同上面说的一样： 12345678910async function koaMiddleware(ctx, next)&#123; try&#123; // do something await next() // do something &#125;.catch(err)&#123; // handle err &#125;&#125; 使用时： 1app.use(koaMiddleware) 多次next的判定虽然只有一行代码用来判断如果在一个中间件中执行了多次next方法，却真让我想了好一会才理解，还是我太笨了。 1if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) 正常情况下，index必然会小于i，在执行dispatch(i+1)时，实际上可以认为将当前中间件改变为了下一个中间件，每一个中间件都有着自己的闭包作用域，闭包中的i是固定的，而index是在闭包之外的变量，当执行到下一个中间件时index的值会发生改变。 如果执行了两次next，每个中间件的i是固定的，但是index一直在增大，出现了i &lt;= index的情况，拿下面的情况举例吧： 有两个中间件： 1234567891011async function middleware1(ctx, next) &#123; console.log('action 001'); await next(); console.log('action 004');&#125;async function middleware2(ctx, next) &#123; console.log('action 002'); await next(); console.log('action 003');&#125; 同时我们在dispatch中打印出index和i的值： 12345function dispatch(i) &#123; console.log('index: ', index); console.log('i: ', i); // ...&#125; 在正常情况下打印的结果： 123456789101112index: -1i: 0action 001index: 0i: 1action 002index: 1i: 2action 003action 004 如果在第一个中间件中执行两个next，执行结果： 1234567891011121314151617181920index: -1i: 0action 001index: 0i: 1action 002index: 1i: 2action 003index: 2i: 1something wrong-- Error: next() called multiple times at dispatch (/Users/duola/projects/node-learning/demo4/koa-compose.js:33:31) at /Users/duola/projects/node-learning/demo4/koa-compose.js:46:18 at middleware1 (/Users/duola/projects/node-learning/demo4/koa-compose.js:87:9) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) 执行时，进入“洋葱圈”的过程是不变的，但是在执行完action3之后，在第一个中间件中再次执行了next，而在第一个中间件中，i是一个闭包中固定的值，为0，所以在执行的dispatch是dispatch(1)，在执行完action3之后，index已经变成了2，这时候在判断时，i &lt;= index相当于1 &lt;= 2是成立的，抛出了错误。 参考 Koa 框架教程@阮一峰的网络日志 掌握 Koa 中间件@Joe’s Blog koa中间件开发和使用@Koa2进阶学习笔记 深入理解 Koa2 中间件机制@掘金]]></content>
      <categories>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>Koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node14 Buffer对象]]></title>
    <url>%2F2019%2F05%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode14%20Buffer%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Buffer对象是Node处理二进制数据的一个接口，它是Node原生提供的全局对象，可以直接使用，不需要require 概述Buffer对象是Node处理二进制数据的一个接口，它是Node原生提供的全局对象，可以直接使用，不需要require Buffer对象是一个构造函数，生成的实例代表了V8引擎分配的一段内存，是一个类数组对象，成员是0到255的数值，即一个8位的字节 123let btyes = new Buffer(2)// &lt;Buffer 00 00&gt; 与二进制数组的关系TypedArray构造函数可以接受Buffer实例作为参数，生成一个二进制数组，例如new Unit32Array(new Buffer([1, 2, 3, 5]))会生成一个4个成员的二进制数组 这时二进制数组对应的内存是从Buffer对象拷贝的，而不是共享的，二进制数组的buffer属性，保留指向原Buffer对象的指针。 Buffer构造函数Buffer作为构造函数，可以使用new命令生成一个实例，可以接受多种形式的参数： 123456789101112131415161718// 参数是整数，指定分配多少个字节内存var hello = new Buffer(5);// 参数是数组，数组成员必须是整数值var hello = new Buffer([0x48, 0x65, 0x6c, 0x6c, 0x6f]);hello.toString() // 'Hello'// 参数是字符串（默认为utf8编码）var hello = new Buffer('Hello');hello.length // 5hello.toString() // "Hello"// 参数是字符串（不省略编码）var hello = new Buffer('Hello', 'utf8');// 参数是另一个Buffer实例，等同于拷贝后者var hello1 = new Buffer('Hello');var hello2 = new Buffer(hello1); 类的方法（1）Buffer.isEncoding()，返回布尔值，表示是否为指定编码 12Buffer.isEncoding('utf8')；// true （2）Buffer.isBuffer()，接受一个对象作为参数，返回布尔值，表示该对象是否是Buffer实例： 12Buffer.isBuffer(Date)；// false （3）Buffer.byteLength()，返回字符串实际占据的字节长度，默认编码为utf-8 1Buffer.byteLength('Hello', 'utf8') // 5 （4）Buffer.concat()，用来将一组Buffer对象合并为一个Buffer对象 12345var i1 = new Buffer('Hello');var i2 = new Buffer(' ');var i3 = new Buffer('World');Buffer.concat([i1, i2, i3]).toString()// 'Hello World' 可以接受第二个参数，指定合并后的Buffer对象的总长度 实例属性/方法（1）length，返回Buffer对象所占据的内存涨肚，与Buffer对象内容无关 12345buf = new Buffer(1234);buf.length // 1234buf.write("some string", 0, "ascii");buf.length // 1234 上面length返回值总是Buffer对象的空间长度，内容的长度通过Buffer.byteLength来获取 length属性是可写的，但是会导致意外，不建议使用，如果想修改Buffer对象的长度，建议使用slice方法返回新的Buffer对象 （2）write()，、向指定的Buffer对象写入数据，第一个参数是写入的内容，第二个参数是写入的起始位置（可省略，默认从0开始），第三个参数是编码方式（默认是utf-8，可省略） 12345678let buf = new Buffer(5)buf.write('Hello')console.log(buf)// &lt;Buffer 48 65 6c 6c 6f&gt;console.log(buf.toString())// 'Hello' （3）slice()，返回一个按照指定位置，所原对象切割的Buffer实例，两个参数是切割的起始位置和终止位置（[start, end) （4）toString()，将Buffer实例按照指定编码（默认为utf-8）转换为字符串 （5）toJSON()，将Buffer实例转换为JSON对象 参考 Buffer对象@JavaScript 标准参考教程（alpha）]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题29 OAuth 2.0]]></title>
    <url>%2F2019%2F04%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9829%20OAtuth%202.0%2F</url>
    <content type="text"><![CDATA[OAuth是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 定义OAuth是一种授权机制，数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 例子举个例子，京东App要求访问我的微信头像和昵称，这里面，我是数据的所有者，而微信就是服务提供商，也就是上面的系统，而京东就是第三方的客户端。 当京东要求获取我的微信数据时，我不会将我的微信账号和密码直接告诉京东，然后让京东自己去登陆我的微信账号去获取对应的数据，因为这样做会有以下的缺点： 京东也许会保存我的密码，这样很不安全 京东通过密码能够获取我在微信的全部数据，我没有办法限制京东能获得哪些数据、不能获得哪些数据 我除了修改密码之外，没有能够取消京东获取我的微信数据的能力 只要有一个京东这样的、知晓我的密码的第三方APP被破解，我的微信密码就会泄露 所以京东需要通过OAuth这种授权机制来获得我的微信数据。思路是这样的： 京东在它的APP里选择以微信账号登陆京东APP； 京东客户端会跳转到微信设置的认证服务器，向我询问是否允许获取我的微信相关资料； 当我同意之后，微信的认证服务器就会向京东APP颁发登陆令牌（token），这个token与用户密码不同，并且在登陆的时候可以指定token的权限范围有效期； 京东APP获得令牌后，就可以向微信的资源服务器来申请获取用户的微信资料，微信的资源服务器根据令牌的权限和有效期向京东APP开放我的微信头像和昵称。 授权模式OAuth的核心就是向第三方应用颁发令牌，OAuth 2.0定义了四种授权方式来让客户端得到用户的授权： 授权码（authorization-code） 隐藏式（implicit） 密码式（password） 客户端凭证（client credentials） 以上这些授权方式，第三方应用在申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端ID（client ID）和客户端密钥（client secret）。 授权码模式授权码（authorization-code）模式，指的是第三方应用先申请授权码，然后用该授权码获取令牌。 这种方式是最常用的，也是安全性最高的，适用于后后端的Web应用。授权码通过前端传送，令牌存储在后端，所有与资源服务器的通信都在后端完成。这样的前后端分离可以避免令牌泄露。 仍旧以京东和微信举例 （1）第一步，当用户点击京东APP以微信登陆的链接后，就会跳转到微信的认证服务器，下面就是一个示意的跳转链接： 12345https://weixin.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read weixin.com/oauth/authorize就是微信认证服务器的URL，response_type参数表示要求返回授权码（code），client_id参数用来表明客户端的ID，redirect_uri是认证服务器接受或拒接请求后的跳转网址，scope参数表示请求的授权范围 （2）第二步，用户跳转到认证服务器的页面后，会要求用户登录，然后询问是否同意给京东APP授权。用户表示同意后，认证服务器就会调回redirect_uri参数指定的网址，在跳转时会以URL中的query参数的形式传回一个授权码（code） 1https://jd.com/callback?code=AUTHORIZATION_CODE 上面的URL中，code参数对应的值就是授权码 （3）第三步，京东拿到授权码后，就可以在后端向微信认证服务器请求令牌（token） 123456https://weixin.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL 上面URL中，client_id和client_secert参数用来让认证服务器确认京东APP的身份（client_secret是保密的，所以只能在后端发送请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uir参数是令牌颁发后的回调地址。 （4）第四步，微信认证服务器收到请求后，核对信息后就会办法令牌，具体的做法是向redirect_uri指定的网址发送一段JSON数据： 1234567891011121314HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;:&#123;...&#125;&#125; 上面JSON对象中，access_token就是令牌，京东在后端服务器拿到了。整个过程如下图所示： 第二种方式：隐藏式有一些Web应用是纯前端应用，没有后端，这时就不能使用第一种方式了，需要将令牌存储在前端。这种方式成为隐藏式（implicit），允许直接向前端颁发令牌，而没有授权码这个中间步骤。 （1）第一步，A网站提供一个连接，要求用户跳转到B网站，授权用户数据给A网站使用 12345https://b.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read 上面的URL中，response_type参数为token，表示要求直接返回令牌 （2）第二步，用户跳转到上面的URL后，登陆，然后同意向A网站授权。这时B网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为URL的Hash参数，传递给A网站。 1https://a.com/callback#token=ACCESS_TOKEN 上面的token参数就是令牌，A网站直接在前端拿到令牌。 注意，令牌在URL中是使用了Hash参数，也就是锚点位置储存，而不是使用查询字符串。这是因为当跳转网址时HTTP协议时，存在“中间人攻击”的风险，而浏览器跳转时Hash参数不会发送到服务器，减少了令牌泄露的风险。 下面于OAuth的安全设置的内容笔记，专门讨论这一部分内容。 这个过程如下所示： 这种方式把令牌直接传给前端，是很不安全的。因此只适用于安全性不搞的场景，且令牌的有效期必须非常短，通常是会话期间有效，浏览器关了令牌就失效。 第三种方式：密码式如果高度信任某个应用，允许用户把用户名和密码直接告诉该应用，该应用使用密码来申请令牌。这种方式称为密码是（password） （1）第一步，A网站要求用户提供B网站的用户名和密码，拿到以后，A就直接向B请求令牌 12345https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID 上面的URL中，grant_type参数是password，代表授权方式是密码式，username和password就是B的用户名和密码。 （2）第二步，B网站验证身份通过后，直接给出令牌，这里给出令牌的方式不再是通过URL的跳转，而是将令牌放在JSON数据中，作为HTTP响应，返回给A网站。 这种方式需要用户给出用户名和密码，风险很大，因此只适用于其他授权方式都无法采用、并且对应用高度信任的情况下。 第四种方式：凭证式凭证式（client credentials）适用于没有前端的命令行应用，即在命令行下请求令牌。 （1）第一步，A应用在命令行向B发出请求 1234https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET 上面的URL中，grant_type参数client_credentials表示采用凭证式的授权方式，client_id和client_sercret用来表示A应用的身份。 （2）第二步，B网站验证通过后，直接返回令牌。 这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，有可能多个用户共享一个令牌。 令牌的使用拿到令牌后，A网站就可以向B网站提供数据资料的API请求数据了。 此时，每个发到API的请求，都必须带有令牌，具体做法是在请求的头信息加上Authoization字段，令牌就在这个字段里。 12curl -H "Authorization: Bearer ACCESS_TOKEN" \"https://api.b.com" 上面的命令中，ACCESS_TOKEN就是拿到的令牌。 curl命令是一个命令行工具，支持多种协议，可以再命令行发出网络请求，然后得到和提取数据，显示在标准输出（stdout）上面。-H参数用来自定义头信息发送给服务器。 更新令牌令牌的有效期到了，如果让用户重新走一遍上面的获取流程，申请新的令牌，体验会很差。OAuth 2.0允许用户自动更新令牌。 具体做法是，B网站颁发令牌的时候，一次性颁发两个令牌，一个用来获取数据，一个用于获取新的令牌。令牌到期前，用户使用refresh token发送请求，更新令牌 12345https://b.com/oauth/token? grant_type=refresh_token&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN 上面的URL中，grant_type参数为refresh_token表示要求更新令牌，refresh_token参数与就是用于更新令牌的令牌。 B网站验证通过后，就会颁发新的令牌。 例子按照阮一峰的例子，做一个Demo，通过OAuth，以Github进行第三方登录，获取API数据。代码在这里。 登陆的过程就是OAuth授权，实际上和前面以微信账号登陆京东APP的例子是一样的。这里面我们的网站是A，允许使用Github账号登陆。 流程如下： 用户点击A网站“使用Gihutb登陆”的链接，页面跳转到Github的授权页面； Github要求用户登陆，然后循环是否授权使用当前Github账号登陆A网站 用户同意登陆，Github会重定向回A网站在最开始的链接中指明的地址，同时发回一个授权码。 A网站使用授权码，向Github请求令牌。这个过程必须在后端完成。 Github返回令牌。 A网站使用令牌，向Github请求用户数据。 具体过程： （1）应用要求OAuth授权，必须在对方网站登记，换取clientID和clientSecret，证明自己的身份。Github的登记地址是这个网址。 注意，应用的callback URL必须是Homepage下的子域名。 （2）新建了一个index.html作为项目的首页 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;OAuth 2.0 Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a id="login"&gt;Login with Github&lt;/a&gt;&lt;/body&gt;&lt;script&gt; const client_id = 'f38d5d8c4b1bb8259159'; const authorize_uri = 'https://github.com/login/oauth/authorize'; const redirect_uri = 'http://localhost:8080/oauth/redirect'; const link = document.querySelector('#login'); link.href = `$&#123;authorize_uri&#125;?client_id=$&#123;client_id&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;`&lt;/script&gt;&lt;/html&gt; 在HTML代码中，跳转链接设置为https://github.com/login/oauth/authorize?client_id=f38d5d8c4b1bb8259159&amp;redirect_uri=http://localhost:8080/oauth/redirect 其中https://github.com/login/oauth/authorize就是Github用来获取授权码的地址，具体参考它的文档。 在index.js中使用koa-static来托管访问静态资源，监听8080端口： 123456789const Koa = require('koa');const app = new Koa();// Koa静态文件服务的目录app.use(staticServer(path.resolve('public')));app.listen(8080, () =&gt; &#123; console.log('Koa is listening in 8080');&#125;); （3）当点击链接，页面会跳转到Github授权的页面 （4）点击授权后，页面跳转到之前指定的Callback URI，也就是http://localhost:8080/oauth/redirect，所以需要在服务端代码对这个路由进行处理： 1234567const KoaRouter = require('koa-router');const router = new KoaRouter();router.get('/oauth/redirect', oauthController);// 加载路由中间件app.use(router.routes()); 当访问/oauth/redirect会执行oauthController的逻辑： 12345678910111213141516171819202122232425262728293031323334const oauthController = async ctx =&gt; &#123; // 获取授权码 const &#123; code &#125; = ctx.request.query; console.log('authorization code: ', code); try &#123; // 使用授权码 + clientID + clientSecret 获取 token const tokenRes = await axios(&#123; method: 'post', url: `https://github.com/login/oauth/access_token?client_id=$&#123;config.clientID&#125;&amp;client_secret=$&#123;config.clientSecret&#125;&amp;code=$&#123;code&#125;`, headers: &#123; accept: 'application/json' &#125; &#125;); const token = tokenRes.data.access_token; console.log('access token: ', token); // 使用令牌获取数据 const res = await axios.get('https://api.github.com/user', &#123; headers: &#123; accept: 'application/json', 'Authorization': `token $&#123;token&#125;` &#125; &#125;); console.log('result: ', res); // 拿到用户名，渲染到页面 const &#123; name &#125; = res.data; ctx.response.redirect(`/welcome.html?name=$&#123;encodeURIComponent(name)&#125;`); &#125; catch (e) &#123; console.log('There is something wrong when getting token: '); &#125;&#125;; 在oauthController中，首先我们从request的查询参数中获取授权码，然后使用授权码 + clientID + clientSecret从Github获取 token，获取token之后再使用相应的API获取用户名，这时需要将上面获得的token作为Authoriztion字段，加到HTTP请求的头信息里面。 拿到用户名，将页面重定向到welcome.html，在这个页面会将URL中的用户名取出来并显示在页面。注意由于用户名可能是中文，需要在redirect中进行安全编码，否则会发生问题。 关于OAuth的安全性问题回调域名在做微信登陆时，到了获取授权码code这一步，如果给微信服务器传的redirect_uri不是申请appid时输入的域名，微信会立刻返回redirect_uri错误的提示。 为什么会这样？因为如果微信不校验redirect_uri，会导致中间人攻击，攻击者伪造受害者的身份，使用受害者的微信账号，登陆目标网站。 假设在申请appid时的域名是a.com，申请的appid是123，假设微信获取code地址是https://wx.om/code，这样获取code的完整URL是： 12345https://wx.com/code? redirect_uri=http://a.com&amp; appid=11111&amp; response_type=code&amp; scope=userinfo 把这个地址发送给任何一个微信联系人，他们都可以通过自己的微信账号获取code，微信会带着code参数回调到http://a.com?code=455，然后a.com再通过code换取access token，用户就可以使用微信账户登录a.com。 但是如果微信不验证redirect_uri是否是a.com，攻击者将redirect_uri换为他的网站（假设为hack.com），受害人访问此链接，确认登录，微信生成code之后通过回调的方式将code传给了攻击者的网站http://hack.com?code=151，拿到code之后，攻击者再将域名切换为http://a.com?code=151，而这时a.com是无法分辨这是微信直接回调还是有人从中动了手脚的地址，无差别的获取code对应的access token，攻击者以受害者身份登陆成功。 对于Implicit方式，更需要校验redirect_uri，因为是一步到位的获取access token。 所以作为OAuth2.0 Server，redirect_uri的域名限制是一定要做的。而作为调用者，到不必这么担心，目前大部分遵循OAuth2.0的服务都不会犯这个错误。 对于调用者开发过程中，微信后台对于redirect_uri域名设置的限制，对于本地地址是无法正常登陆了。解决方法就是更改Host文件，将redirect_uri的域名直接指向内网就行了： 12# /etc/hosts127.0.0.1 a.com code与secret前面提到了，在使用OAuth之前，需要到提供的服务的服务商进行注册，获取appid（clientID）和secert（client Secret），appid的目的是为了告诉身份认证服务器我是a.com，而secret是为了告诉任务服务器，我真的是a.com。这个secert相当于客户端与认证服务器之间的信物，这个信物是不能暴露给用户的，所以它的传递只能通过服务器进行传递。能够被暴露的只有appid。 如果没有secert，当出现DNS污染，本该发往a.com的code被发往了hack.com，这时候攻击者就会直接使用code换取token了。 OAuth 2.0设计时的一个目标是，让不支持HTTPS的网站也能够安全使用。所以code才是必须的。如果没有code，直接获取access token，流程如下： 用户浏览器访问a.com，跳转到微信OAuth服务器获取access token 用户在微信的网页上登陆成功，并确认授权a.com使用微信账号登陆，微信服务器跳转到redirect_uri并且带上access_token参数 用户浏览器访问带access token的连接，完成登陆。 如果a.com不支持HTTPS，那么在最后一步，access token就完全暴露在浏览器和a.com服务器之间的线路中。 如果a.com支持HTTPS，那么理论上来说，可以省略获取code这一步的。 但是如果a.com不支持HTTPS，那么使用了code，code被暴露的后果是好于access token被暴露的。这是因为OAuth 2.0协议对此规定： code只能使用一次 如果攻击者比正常用户先用了code，当用户第二次使用code时，之前通过此code获取的access token将被撤回。 所以当code被泄露时，攻击最多让正常用户有点困扰，可能登陆意外失败，或者明明看起来登陆成功但还是获取不到用户信息的情况（access token已失效），攻击者拿不到数据。 state参数在获取code时，一般服务器会返回一个state参数，一般来说没什么用，也可以为空，但是OAuth2.0文档标注的是Recommended，在什么时候使用呢？ 它在防御CSRF时是非常有用的。进行CSRF攻击，攻击者： 申请一个的专门用于攻击的账号 走正常流程，跳转到微信上登陆此账号 登陆成功后，微信带着code跳转回a.com，这个时候，攻击者拦截自己的请求不再继续进行，而是将code的链接发送给受害者，棋牌受害者点击 受害人点击后，继续攻击者登陆流程，不知不觉登陆了攻击者的账号 而state参数如果利用起来，作为CSRF Token，就能避免此时的发生： 攻击者依旧获取code并打算骗受害者点击 受害者点击链接，但是服务器（a.com）分配给受害者的设备的state值和链接里面的state值不一样，服务器（a.com）直接返回验证state失败 state或者CSRF Token这种与设备绑定的随机字符串，复杂一点，攻击者就无计可施。 设置一个让攻击者猜不到的、跟设备（或者浏览器）绑定的state或者CSRF Token值，就是解决CSRF的关键。 Implicit授权模式Implicit授权模式一步到位，直接返回了access token，它的最重要也是最巧妙的设计是，登陆成功后身份认证服务器跳转回来带的参数都是放在#后面的，而不是查询参数。 这是因为，如果在没有使用HTTPS的线路上通信时，access token很容易被偷走，但是如果access token放在#后面，浏览器发起请求时，#后面的内容不会碎请求发送到服务器。这一样就可以防止中间人共计而只让设备用用access token。 同样，access token是一定不能存放在cookie这种可能被中间人发现的地方（除非使用HTTPS）。为了做到粳稻的安全性，access token最好连local/session storage都别放。这样理解，Implicit也就只适合SPA了，SPA不刷新页面可以让access token一直在内存里，直到关掉页面。 参考 理解OAuth 2.0@阮一峰的网络日志 OAuth 2.0 的一个简单解释@阮一峰的网络日志 OAuth 2.0 的四种方式@阮一峰的网络日志 GitHub OAuth 示例教程@阮一峰的网络日志 关于 OAuth2.0 安全性你应该要知道的一些事@Chrisyue’s Blog]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>OAuth</tag>
        <tag>第三方登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题28 BFF调研2]]></title>
    <url>%2F2019%2F04%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9828%20BFF%E8%B0%83%E7%A0%942%2F</url>
    <content type="text"><![CDATA[BFF调研报告第二部分 为什么说Node作为中间层带来了真正的前后端分离前后端未分离时是怎么做的？典型的MVC框架，使用一门后端语言、框架，这里以Egg.js为例子，定义路由： 1234module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/', controller.home.index);&#125;; 当访问/时，会到Controller层从处理业务逻辑的Service层（或者叫Modal层）拿到数据，渲染一个模板（View）并且将数据嵌入进去 1234567891011class HomeController extends Controller &#123; async index() &#123; const &#123; ctx &#125; = this; // 从Service层获取数据 const &#123; title &#125; = await ctx.service.news.list(); // 渲染模版 await ctx.render('index.tpl', &#123; title &#125;); &#125;&#125;module.exports = HomeController; 模板使用了nunjucks引擎，在index.tpl中 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hi Egg&lt;/h1&gt;&lt;a href="news"&gt;Movie&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 这种前后端没有分离的开发方式，主要指的是前后端传递数据的方式是通过后端渲染模板时将数据传递给模板，前端开发的只是模板的样式，被动的从模板拿到数据。也就是说大部分的逻辑、数据获取、处理都是在后端完成的。 前后端开始分离为了脱离前端强依赖后端的关系，将数据层的接口分离出来，以Ajax的形式进行交互，服务端只负责渲染逻辑、提供数据和接口，不负责数据填充。 页面的数据以JSON格式由前端通过Ajax获取，填充到页面中。具体的做法是，在路由中添加一个接口： 1router.get('/getTitle', controller.home.getTitle); 在Controller中添加对应的处理逻辑，返回JSON数据格式 1234567async getTitle() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; title: 'OK', &#125;; ctx.status = 200;&#125; 在模板中通过&lt;script&gt;脚本访问接口，获得数据后填充到DOM中 这个时候前后端的界限是按照浏览器和服务器的划分，但是也有一些问题 环境：本地开发需要起后端环境，影响开发效率（当然可以通过Mock数据解决） 联调：前后端关注点不同，联调时效率低下 接口：接口不好维护，接口变更、新加时需要沟通成本 前后端分离新阶段：SPA为了提高效率和用户体验，前端在前端开始了MVVM的单页面开发，后端不再负责渲染模板，只单纯的提供数据接口，后端的模板成为了前端SPA的容器。 前端也有了自己的路由、Model、View。 在SPA之前，浏览器接受的是服务器渲染好的HTML字符串和少许的JS/CSS脚本，路由由后端控制；到了SPA之后，服务器渲染好的只是一个空壳子，浏览器接受这个空壳子和大量的JS/CSS脚本，由浏览器渲染为HTML字符串，页面跳转由前端路由控制 前端路由一般是通过Hash模式实现，只只要后台服务器配合一个根路由对应基础模板，其他的跳转都是通过前端路由改变#后面的内容实现，#值的改变并不会想浏览器发送请求，所以SPA的url一般是http://demo.com/#index。 Vue-router也提供了History模式，利用了HTML5的history.pushState来实现URL跳转而无需重新加载页面，这样的URL就像正常的URL，例如http://demo.com/index，但是这需要后台配置支持，增加一个覆盖所有情况的候选资源，当URL匹配不到任何资源，应该返回同一个index.html页面，也就是app依赖的页面。这个时候服务端不再返回404，需要通过前端路由对不匹配的资源返回404 前面提到的Mock数据的问题，本地Mock是一种解决方案，但添加、维护、同步都非常麻烦。现在比较成熟的解决方案可以使用easy-mock，它可以很好地支持Swagger，在开发时在前端不再通过后台服务器获取数据，也不在本地Mock，而是添加一个Mock服务器，直接通同步服务端的接口，产出Mock数据。 Swagger是一款API文档工具，官网在这里。 真正的前后端分离：Node.js中间层服务现在的架构下，前后端的职能更加清晰： 后端 前端 提供数据 接收数据 处理业务逻辑 处理渲染逻辑 Server-side MVC Client-side MVVM 代码跑在服务器上 代码跑在浏览器上 但是服务端和客户端的部分职责重叠，很难统一具体要做的事。在SPA应用上也暴露了一些性能的问题 渲染、取值都在客户端执行，有性能的隐患 首屏渲染有白屏、闪烁的问题 无法SEO 对移动设备网速较低时体验较差 为了解决这个问题，可以引入Node作为中间层，从工作职能的角度上重新定义前后端的范畴 引入了之后前后端的职能重新划分为： Node中间层，也就是BFF，常见的业务场景 接口数据二次处理，在中间层做接口转发 页面性能，将首屏渲染交给中间层去做，次屏渲染依然走之前的浏览器渲染 使用Bigpiper技术，合并请求，降低负担，分批输出，提高体验。 淘宝前端基于Node.js的前后端分离的思考与实践PPT在这里。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端就是前端，服务器端就是后端），这种分法已经无法满足前后端分离的需求，从职责上划分更加满足使用场景： 前端：负责 View 和 Controller 层。 后端：只负责 Model 层，业务处理/数据等。 为什么要前后端分离？ 现有开发模式的适用场景:后端为主的MVC，做一些同步展现的业务效率很高，但是遇到同步异步结合的页面，沟通成本高，Ajax为主的SPA型开发模式，比较适合开发APP类型的场景，但是有SEO的问题 分清前后端职责，代码分别为虎 开发效率 前端发挥的局限 前后端分离，需要Web服务实现Controller层的功能，就是Node.js中间层 这样的架构会引出一些问题： （1）SPA中，后端已经提供了所需的数据接口，View前端也可以控制，为什么多加Node.js这一层？ 让前端控制Controller层，Node对于前端来说是很高效率的选择 （2）多加一层性能怎么样？ 分层就涉及每层之间的通讯，肯定有一定的性能损耗，但是合理的分层能让职责清晰，也方便协作，会大大提高开发效率。分层的损失可以在其他方面弥补回来。 另外，如果决定分层，可以通过优化通讯方式、通信协议，把性能损耗降到最低。 例如可以在Node层合并请求，利用Bigpipe优化数据传输。淘宝这方面的实践已经很多。 （3）多加一层，前端的工作量是不是增加了？ 增加是肯定的，但是可以减少联调、沟通的时间，效率会提升 （4）多加一层的风险怎么解决？ 随着Node.js大规模使用，系统/运维/安全部门的同学也一定会加入到基础建设中，共同晚上各个环节出现的问题，保证系统稳定属性 淘宝基于Node.js的前后端分离架构如下所示： 最上端是服务端，提供各种接口，因为有了Node，所以也不局限是什么形式的服务。对于后端来说，只需要关心业务代码的接口实现 服务端下面是Node.js中间层，中间层有一层Model Proxy与服务端进行通讯，这一层主要是抹平对不同接口的调用方式，封装一些View层需要的model。Node层使用的框架有开发者自己决定，输出方式也是完全由场景决定的 浏览器层在架构中没有变化 淘宝前端团队基于前后端分离的模版探索在传统的开发模式中，模板是前、后端中间的模糊地带，最容易与后端开发纠缠不清 浏览器端渲染的好处 摆脱业务逻辑与呈现逻辑在Java模版引擎中的耦合与混乱。 针对多终端应用，更容易以接口化的形式。在浏览器端搭配不同的模版，呈现不同的应用。 脱离对于后端开发、发佈流程的依赖。 方便联调。 浏览器端渲染造成的坏处： 模版分离在不同的库。有的模版放在服务端（JAVA），而有的放在浏览器端（JS）。前后端模版语言不相通。 需要等待所有模版与组件在浏览器端载入完成后才能开始渲染，无法即开即看。 首次进入会有白屏等待渲染的时间，不利于用户体验 开发单页面应用时，前端Route与服务器端Route不匹配，处理起来很麻烦。 重要内容都在前端组装，不利于SEO 引入了Node中间层后，前端可以自由选择模板是在服务端（Node）还是在浏览器端做渲染 淘宝的模板共享实践经验： （1）复杂交互应用（如购物车、下单页面） 状况：全部的HTML都是在前端渲染完成，服务端仅提供接口。 问题：进入页面时，会有短暂白屏。 解答：首次进入页面，在Node层进行全页渲染，并下载相关的模版。后续交互操作，在浏览器端完成局部刷新 （2）SPA页面 状况：使用Client-side MVC框架，在浏览器换页。 问题：渲染与换页都在浏览器端完成，直接输入网址进入或F5刷新时，无法直接呈现同样的内容。 解答：在浏览器端与Node层共享同样的Route设定，浏览器端换页时，在浏览器端进行Route变更与页面内容渲染，直接输入同样的网址时，在Node.js端进行“页面框架 + 页面内容”渲染（如何做？） 各种开发框架的对比Middelway淘宝前端团队推出的Web全栈应用开发框架，文档在这里。 使用了Egg.js作为Web层容器，可以使用Egg.js的插件，它的特点是 使用IoC机制将应用依赖管理起来，最大程度帮助应用在Web开发中提升可维护行和可扩展性（IoC模块可独立使用） 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。更多的看维基百科和这篇文章。 使用TypeScript进行应用开发 兼容Koa社区和Egg.js插件 一些细节也可以通过这篇文章了解。 Egg.js：蚂蚁金服死马：企业级Node.js Web框架研发与落地这是视频，这是PPT。 Chair BFF是基于Egg.js的研发框架，在Egg.js基础上，添加了很多定制话的插件，内部集成了很多蚂蚁内部的服务，即便开源也无法使用 但是包括Egg.js在内，与业务无关的插件，蚂蚁都已经开源了。正确的做法是基于Egg.js进行BFF的引入，充分利用Egg的社区生态、插件，随着业务开发编写定制化的插件和维护。当积累到一定程度后，可以形成适合于自己公司的BFF研发框架（Mi BFF），当上下游研发流程打通后，形成属于自己的解决方案（Mi-TWA） Egg.js有如下的优点： 蚂蚁金服的最佳实践的封装（通过插件的形式，已开源） 文档友好 更适合企业级开发：灵活定制，遵循约定 npm上插件众多，配套完善 可以使用Koa的中间件 有配套的研发平台的支持 社区模式VS企业模式：个人项目使用Koa和Egg区别不大，但是对企业内部，使用Egg的正确姿势是基于Egg封装自己的东西。 蚂蚁金服有了很多年的积累，才形成了Chair BFF和TWA这样的一站式研发平台和配套设施，对于新引入BFF的团队而言，可以做到渐进增强的研发体验： （1）首先实现，使用Node.js实现功能，保证代码质量 （2）在使用Node实现功能之后，很容易被人挑战，那么就需要一步步优化，比如统一编码规范，让团队可以更好的写代码 （3）提升稳定性、可维护性，对接企业内部服务 （4）通过完善的研发流程平台，提供更好的变成体验 （5）让产品工程师可以专注于产品 Egg的缺点：为了保证框架利用的最大化、代码的可维护性，需要学习、遵守框架的大量的约定 egg-vue-webpack-boilerplate 基于Egg + Vue + Webpack多页面和单页面服务端渲染同构工程骨架项目。需要配套使用基于Webpack封装的easywebpack-cli创建项目，可以创建各种项目的模板： 1234567Create Vue Application Create React Application Create Egg + Vue Application Create Egg + React Application Create Weex Application Create HTML Application Create NPM package Application 选择Egg + Vue项目，可以选择多种渲染方式： 123456Create Egg + Element Admin Application Create Egg + Vue Single Page SSR Application Create Egg + Vue Multil Page SSR Application Create Egg + Vue Single And Multil Page SSR Application Create Egg + Vue + TypeScript SSR Application Create Ves Framework - Node Vue TypeScript Isomorphic Framework Application 对于使用Egg+Vue/React实现服务端渲染，可以使用这个解决方案 nodejs-backend-for-frontendIBM的BFF解决方案，配合使用Express，内置了IMB的云开发工具，针对IBM的云服务进行了一些特殊化定制，Github的star数16，提供了对Swagger的支持，自动生成Mock数据 使用Koa或者Express自行搭建中间层使用Koa或者Express，自行搭建一个中间层，实现接口的转发、数据处理等比较基础的功能。 作为BFF引入时，可以将前端工程代码和BFF层代码分为两个仓库管理，也可以在一个仓库管理。 小米笔记本BFF项目部署 这个部分只是BFF项目使用Docker的部署过程，不作为引入方案，只作为部署经验进行介绍。 Node做中间层，做接口的转发服务，功能比较浅，重业务的逻辑也放到了后端。 接口转发、数据处理、Mock服务（Swagger） 好处： 更好的前后端分离 不需要考虑跨域 接口的聚合不再需要服务端的支持（减少沟通成本） 能自主完成一些小的功能开发 缺点 需要独立完成一套功能的实现 增加维护成本 基于Ocean平台使用Docker容器技术进行部署，具体代码参考Wiki。 总结 框架 维护团队 Star 优点 缺点 Egg.js 阿里 12404 1. 蚂蚁金服的最佳实践；2. 文档友好；3. 适合企业级开发；4. 插件众多，配套完善；5. 且可以使用Koa的中间件；6. 有配套的研发平台的支持 1. 需要学习、遵守框架的大量的约定 Middleway 淘宝 713 1. 淘宝的最佳实践；2. 使用IoC机制管理应用依赖；3. 使用TypeScript进行应用开发；4. 兼容Koa社区和Egg.js插件 1. 使用不广泛；2. 有些概念比较复杂，暂无引入必要； egg-vue-webpack-boilerplate easy-team 881 1. 有Vue和React等一系列工程解决方案；2. 可以扩展多页面和单页面服务端渲染 1. 使用不广泛； 2. 可定制性比较差 nodejs-backend-for-frontend IBM 16 1. 支持Swagger，自动生成Mock数据 1. 使用不广泛； 2. 内置了IBM云服务相关的功能 Express Express 43507 1. 应用广泛；2. 社区繁荣；3. 使用灵活； 1. 需要自搭建项目；2. 需要自行选择中间件； 3. 灵活性过高，导致后期可能维护困难 Koa Koa 25884 1. 异步流程控制优于Express；2. 社区繁荣；3. 使用灵活； 1. 需要自搭建项目；2. 需要自行选择中间件； 3. 灵活性过高，导致后期可能维护困难 落地方案总体建议一开始引入Node作为BFF层，在一些小的项目上进行改造，通过HTTP请求从后端服务获取数据，实现一些接口转发、数据处理之类比较简单的功能，将项目中所有接口都改造为接入BFF Server。 通过简单的项目，把代码管理、开发、Review，测试、部署、维护全流程（或大部分流程）走通后，逐渐扩展边界和功能（接口文档和接口的对应、自动生成Mock数据、性能监控等） 待确定的规范和方案主要流程中要确定的一些代码管理规范和方案： 1 代码管理（1）前端后端代码放到一个代码仓库里面统一管理。（可能需要处理依赖混在一起的问题） 前后端代码分离两个目录 以前端代码目录为主，添加服务端代码文件夹 以前端代码目录为主，添加前端代码文件夹 （2）前端后端代码放到两个代码仓库里面分别管理。 2 框架选择 自行搭建（前端项目+Koa/Express/Egg），demo地址在这里。 Egg.js（完全使用） Esay-Team egg-vue-webpack-boilerplate IBM的方案IBM/nodejs-backend-for-frontend 3 本地开发 前端在一个端口，起一个服务，负责渲染页面，Node服务在另外一个端口，其一个服务，负责提供接口和数据；二者处于开发模式热更新都是各自的构建工具实现的 前端、后端在同一个端口开发（使用egg-view-assets或者Esay-Team egg-vue-webpack-boilerplate） 4 构建流程 多页面/单页面服务端渲染 前端渲染 静态页面 前两种方式需要结合Vue-SSR或者React-SSR，最后一种方式只需要配置对应的构建目录，通过静态资源的方式构建 如果当前阶段只是实现接口转发的功能可以涉及不到第一步骤。 5 部署 前端打包后，手动上传到CDN，后端服务打包后为tar，手动上传至服务器，开启服务 前端打包后，手动上传到CDN，后端服务构建一个Docker镜像，推到服务器（或者结合平台）开启服务 参考 蚂蚁金服死马：企业级Node.js Web框架研发与落地-视频@ArchSummit 蚂蚁金服死马：企业级Node.js Web框架研发与落地-PPT@分享幻灯片 浅谈前后端分离与实践（一）@知乎 浅谈前后端分离与实践 之 nodejs 中间层服务（二）@知乎 前后端分离的思考与实践（一）@淘宝前端团队 前后端分离的思考与实践（二）@淘宝前端团队 前后端分离的思考与实践（三）@淘宝前端团队 淘宝前后端分离实践@2014JS中国技术大会 从NodeJS搭建中间层再谈前后端分离@掘金]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>BFF</tag>
        <tag>Egg.js</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题27 BFF调研1]]></title>
    <url>%2F2019%2F04%2F16%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9827%20BFF%E8%B0%83%E7%A0%941%2F</url>
    <content type="text"><![CDATA[BFF调研报告。 前端开发中存在的难问题 多端应用，不同类型客户端对数据、API有个性化的需求 服务聚合，单一后端为多个前端团队提供接口，导致跨团队协作低效，资源协调困难 问题：服务端设计的接口究竟是面向UI，还是面向通用服务？ BFF解决方案： Backends For Frontends， 简称BFF。 BFF最适合的场景，为第三方提供定制API等差异化场景，每个用户体验（客户端）对应一个后端， BFF作为用户体验适配层，对后端接口进行组合、处理，对数据进行：裁剪、格式化、聚合、编排。 BFF理念中，最重要的一点是：服务自治，谁使用谁开发，所以一般由前端维护。 BFF实现不限制具体技术，可以自由选型：Java/Node/PHP/Python，但大部分前端团队都会选择Node.js。 BFF的演化历程BFF和网关（API Gateway）是微服务架构中两个重要概念，可以通过下面的例子讲解BFF的出现过程 服务化架构V1实现单块应用的解构拆分，微服务初步完成，前端用户体验层主要是传统的服务端Web应用，服务化架构如下所示： 服务化架构V2随着无线应用的流行，除了Web应用外，服务还需要为新的无线原生App来提供接口和数据，先采用下面的服务架构： 这样的架构的问题是： 无线App与内部为微服务强耦合 无线App需要知道内部服务的地址等细节 无线App需要对接口数据进行大量的聚合剪裁和适配逻辑 服务化架构V2.1为了解决这个问题，在用户体验层和内部微服务层之间引入了BFF层，将后端的微服务进行适配，想用户体验层暴露有号和统一的API，方便无线设备接入访问后端服务 这种架构解决了上面的问题： 无线App与内部为微服务解耦，两边可以独立变化 无线App只需要知道BFF的地址，并且服务接口统一，不需要关心内部复杂的微服务的地址和细节 无线App需要不再需要聚合剪裁和适配逻辑，这些步骤都在BFF完成 但是随着接入设备的增加，也会有一些问题： BFF只有一个，接入设备增加后导致要考虑匹配问题，团队之间沟通协调成本高 BFF中不仅包括了各个业务线的聚合剪裁、适配和业务逻辑，还需要引入很多跨横切面逻辑，比如安全认证、日志监控、限流熔断等，这些代码混在一起，导致代码复杂度提高 BFF如果出现错误，会导致所有应用都不可用 微服务架构V3为了解决这个问题，引入API Gateway 在这种架构下： BFF按团队和业务线进行解耦拆分，拆分成若干个BFF微服务，每个业务线并行开发和交付各自负责的BFF微服务 网关，一般由独立的团队负责运维，专注跨横切面的功能，包括 路由，将来自无线设备的请求路由到后端的某个微服务BFF集群 认证，对涉及敏感数据的API访问进行集中认证鉴权 监控，对API调用进行性能监控 限流熔断，网关能够进行限流熔断，保护后端服务 安全防爬，收集访问日志，通过后台分析恶意行为，阻断恶意请求 网关在客户端与BFF之间又引入了一层，让两边可以独立变化 微服务架构V4可以对V3架构进行优化，将传统的服务端Web应用模式改为前后分离架构，前端采用H5单页技术提供给用户更好体验。 同时增加了下手是哪个第三方应用开放API的能力 拓展新的接入渠道，形成了一个完成的现代微服务架构，从外到内依次为：端用户体验层-&gt;网关层-&gt;BFF层-&gt;微服务层 具体实现细分力度要求把一个大后端拆分为多个小后端，有三种方式 用户体验级（UI） 端级 团队级 一般建议按照用户体验级来拆分 对接下游服务（微服务）（1）如何对接多个技术栈不同的下游服务 RPC协议调用 （2）如何管理、组合调用 借助RXJava、Finagle等事件机制来简化这些异步流程控制 （3）某个调用失败时，如何保障可用性 在BFF层容错，同时前端保证可接受不完整相应内容 复用问题拆分后，多个BFF间会产生冗余代码，这是不可避免的。 可以添加API网关层，将通用的后端逻辑（授权、认证、限流）放进去 想消除冗余，又不想因为抽离可复用代码而导致BFF间紧耦合，所以就有了一种折衷的态度：容忍BFF间冗余、消除单BFF内冗余。也就是允许一定程度的BFF间冗余 蚂蚁财富的BFF实践2016年时，汤尧对BFF在蚂蚁财富项目中的落地实践进行了介绍。 在引入BFF之前，蚂蚁财富的业务也遇到了上面提到的问题，主要是体验层API经常变化，导致开发效率低下。 于是引入了BFF，主要的目的是对数据进行：裁剪、格式化、聚合、编排。 一个理想的模型如下： 在实际落地过程中，形成了如下的架构： 他们在实战过程中，主要解决了一下几个问题： （1）Node.js与Java通信 数据：跨语言序列化协议hessian 服务：Node弱类型，Java强类型，如何调用 这个调用过程一般是通过RPC协议完成的，而非通过HTTP协议。 由于我对Java没有接触，而且资料只是他当时的PPT，没有详细的讲解，没有办法理解具体是如何实现的。而且恐怕对于大多数前端开发工程师来说，与Java的通信也是BFF落地过程中一个比较严峻的挑战，而且这是在前端开发人员有比较好的Node开发能力的基础上。 （2）多App适配 在API网关层处理多个App的通用的逻辑，比如错误码管理、数据一致性、免登、业务日志等。 （3）聚合 传给客户端需要的数据，简化客户端逻辑，减少网络开销 避免无意义的透传 敏感信息过滤 （4）接口设计准则 基础服务接口：（微服务？） 细粒度 通用的功能，可能会被多个BFF用到 提供含各种状态的mock真实数据，易于同步开发（如何实现？） BFF API设计 合理设计接口数量，太多不易维护 提供含各种状态的mock真实数据，页面不依赖server开发（如何实现？） 多协议发布（如何实现？） 规范数据格式 在落地BFF过程中，从技术角度来看： 前端和BFF由同一人完成 前端需要具备服务端技能 快速的应用发布能力（docker？） TWA的理念与实践在2018年的SEE Conf，蚂蚁金服的不四（知乎ID：死马)对在BFF基础上发展出来的TWA（Techless Web Application）开发体系进行了介绍（视频和PPT）。 传统的分层： BFF负责聚合底层业务数据，给客户端提供接口，秉承谁使用谁维护的理念，一般由前端团队维护。 业务实际上分为三层：前端（HTML/CSS/JS）+ BFF（Node.js接口聚合层）+ 后端服务（Java） BFF on Chari是蚂蚁自研的，基于Egg.js的BFF框架，打通了Node到Java的RPC通信链路 Egg.js已经开源（Egg.js是以Koa作为基础框架），需要基于Egg.js去打造属于自己的BFF框架 RPC的意思是不在一个内存空间的两个应用，借助网络来实现，像调用本地的函数一样去调用远程函数 BFF不是银弹，有着自己的问题： 研发成本上升：前端团队既要开发客户端，又要开发BFF，人手不够 流程繁琐：BFF引入后，要同时走前端、服务端的研发流程，多端发布、互相依赖，导致流程繁琐 运维经验不足：主要是前端工程师运维经验不足（给业务团队带来了很大困扰） 尽管职责划分越来越清晰，但是由于前后端发布系统不一致，前端团队仍需要在基于不同的代码仓库进行研发，走不同的发布流程 理想的开发流程： 蚂蚁金服推出的解决方案TWA（Techless Web Application），是一个全栈的研发框架 TWA是为了提升开发者研发体验而推出的渐进式解决方案，开发者在一个代码仓库下，基于TWA的框架，完成客户端和BFF层的研发，通过Basement研发平台提供的流程支持，不用再关注应用、构建、部署、流程等细节，可以一键将应用部署到各个运行终端，同时在研发平台上完成应用的自主运维和监控 将TWA拆解开来，分为了三个大的方向：框架、研发平台、运行时 框架：提供了前后端合一的框架，通过定制化网关，抹平多个终端和接入形式的差异，让一套代码可以运行在不同的终端下（？) 研发平台：Basement，提供TWA的研发迭代、自主运维和监控，精简规范了H5 APP的研发流程 运行时：通过基础服务和Docker，给客户端代码和服务端代码提供稳定可靠的运行环境 框架是一个渐进式框架，可以选择部分能力使用 客户端、服务端目录、依赖都是相互独立的。 复杂的终端环境，有不同的接入链路（可能通过网关走TCP长连接通信）、不同的鉴权方案。如果每个业务的BFF系统要对接到每个系统完成接入、鉴权是非常复杂的。 解决方案是：TWA网关层 + 客户端RPC Client， TWA网关层统一完成所有终端的接入、鉴权，BFF不需要对接到每个终端，只需要对接到网关，让BFF接口统一 客户端的RPC Clinet是一个请求库，对接到网关，将客户端的鉴权、接入的细节隐藏，并且可以自动选择接入链路 这就可以在client目录下，像调用本地方法一样，调用server中目录下的服务 研发平台 Basement，一站式运维平台，基于Docker，支撑整个应用的研发流程，完成自动化的测试和部署 Node与Java的通信与使用的微服务框架有关，可以采用HTTP的方式，也可以通过RPC调用。 蚂蚁金服的实践 数据：跨语言序列化协议hessian 服务：Node PRC 开源框架： sofa-bolt-node：蚂蚁通讯协议Bolt的Nodejs实现 sofa-rpc-node：一个通用的Nodejs RPC模块 有赞的实践 – HTTP可以采用服务注册中心： 首先，Java应用服务启动的时候，会往服务注册中心注册服务，这里的服务注册中心可能是ETCD或者Zookeeper，然后，Node应用在启动的时候，会先从服务注册中心拉取服务列表，接着Node会跟Java服务建立一条TCP长链接，除此之外，Node还需要负责Hession协议解析以及负载均衡等。 上面的方式Node职责比较重，对Node开发的要求高，有赞在此基础上做了改进： 在Node和Java之间添加了一层中间代理层Tether，Tether是用Go语言写的一个本地代理，Tether会对外暴露一个HTTP的服务，对Node来说，只需要通过HTTP方式调用本地的服务即可，其他服务化相关的服务发现、协议解析、负载均衡、长链建立维护都交由Tether来处理。这样，Node这一层就非常轻量了，Node是调用Java服务时： 1234567891011121314151617const Service = require('../base/BaseService');class GoodsService extends Service &#123; /** * 根据商品 alias 获取商品详情 * @param &#123;String&#125; alias 商品 alias */ async getGoodsDetailByAlias(alias) &#123; const result = this.invoke( 'com.youzan.ic.service.GoodsService', 'getGoodsDetailByAlias', [alias] ); return result; &#125;&#125;module.exports = GoodsService; 这种方式的优点： 使用简单，对前端开发非常友好，只需要通过HTTP方式调用本地的Tether服务即可； 多语言接入成本低，后期如果有其他语言（Python、Ruby）也需要接入整个服务化体系，也像Node一样，它们都只需要调用本地Tether暴露的HTTP服务即可，没有额外的开发成本了。 后期更方便做协议层的优化，因为这种方式Tether其实就是一个代理，后期如果需要做协议层性能上的优化，那只需要优化Tether的性能就可以了。 总结关于TWATWA是蚂蚁金服自研的，整合了BFF的一整套渐进式的前端+Node聚合层的开发体系，它不仅包括了BFF的引入，还包括了前后端代码管理、部署、运维等功能框架。 但是很遗憾的是，TWA没有开源，对于想要从0开始引入BFF，想实现TWA的功能，还有一个努力的过程。 实际上我们引入BFF，不是要完整的开发TWA，而是首先实现Chari BFF的功能。 接入BFF的好处对于团队来说： 业务支持变多 沟通协作变少 解决问题变快 对于个人来说： 更合理分工 做BFF可以拓展知识面 接入BFF的坏处： 组织决定了架构的复杂度 前期学习成本高，短期成为资源瓶颈 可能遇到的问题和可能的解决方法 Node与Java通信 – Hessian（数据），RPC（服务）（sofa-rpc-node）/ （grpc-node） 前端代码和BFF段代码管理 – Egg.js（同一个仓库，不同目录，不同依赖，分别打包、分别配置） 前端的应用发布、运维能力 – Docker 服务端的配合 – 服务：微服务（？），人员： （？） 前端能力提高 – 前端能力（JavaScript + HTML + CSS) + Node（服务端技能）+ Java（如何与Java通信）+ 运维能力（Docker） 参考 Pattern: Backends For Frontends@samnewman 为什么互联网公司开始用node.js做web服务的中间件？有什么好处吗？@知乎 Backend For Frontend@黯羽轻扬 蚂蚁财富的BFF实践.pdf@alipayobjects 微服务架构：BFF和网关是如何演化出来的@10条 Developer Experience First —— TWA 的理念与实践@知乎专栏 Techless Web Application 的理念与实践 — 不四@优酷 02_SEEConf_TWA的理念与实践_不四.pdf@语雀 Node 在有赞的实践@掘金 聊聊 Node.js RPC（一）— 协议@语雀 聊聊 Node.js RPC（二）— 服务发现@语雀]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>BFF</tag>
        <tag>TWA</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg01 入门]]></title>
    <url>%2F2019%2F04%2F15%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F03%20Egg%2FEgg01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在调研BFF的过程中，看到蚂蚁金服自研的BFF的开发框架BFF Chair是基于Egg.js开发的。BFF Chair没有开源，但是Egg.js已经开源了，如果需要引入BFF，需要基于Egg.js的基础上开发自己的BFF开发框架。 在调研BFF的过程中，看到蚂蚁金服自研的BFF的开发框架BFF Chair是基于Egg.js开发的。BFF Chair没有开源，但是Egg.js已经开源了，如果需要引入BFF，需要基于Egg.js的基础上开发自己的BFF开发框架。 1 Egg.js是什么Egg是一个为了开发企业级应用的框架，没有集成太多功能，值专注于提供Web开发的核心功能，并且提供了一套灵活可扩展的插件机制，来满足定制需求。 Egg奉行『约定优于配置』，在团队内应当按照一套统一的约定进行应用开发，降低沟通成本和学习成本。但约定不等于扩展性差，可以按照团队的约定制定框架。 2 Egg与其他Web框架的比较2.1 与Express的差异Express应用很广泛，简单且扩展性强，适合做个人项目，但框架本身缺少约定，标准的MVC模型会有各种千奇百怪的写法。而Egg按照约定进行开发，团队协作成本低。 2.2 与Koa的关系Koa和Express的设计风格类似，底层都是公用的同一套HTTP基础库，但是二者有一些区别： （1）异步解决方案 Express的异步编程模型是callback形式的，而Koa使用了async/await的形式 （2）Middleware中间件 Koa的中间件模型是洋葱圈模型 当中间件在执行时： 所有的请求经过一个中间件的时候都会执行两次，可以很方便的话实现后置处理逻辑。 （3）Context Express只有Request和Response两个对象，Koa增加了Context对象，作为当次请求的上下文对象（Koa1中为中间件的this，Koa2中作为中间件的第一个参数传入），可以将以此请求相关的上下文都挂载到这个对象，同时Context也挂在了Request和Response两个对象，这两个对象提供了大量的便捷方法辅助开发，例如： 1234request.queryrequest.hostnameresponse.bodyresponse.status （4）异常处理 通过同步方式编写异步代码带来的另一个非常大的好处就是异常处理非常自然，使用try/catch就可以将按照规范编写的代码中的所有错误捕获到。可以很方便的编写一个自定义的错误处理中间件： 123456789async function onerror(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit('error', err); ctx.body = 'server error'; ctx.status = err.status || 500; &#125;&#125; 只需要将这个中间件放在其他中间件之前，就可以捕获它们所有的同步或者异步代码中抛出的异常了。 2.3 Egg继承于KoaEgg选择了Koa作为基础框架，在它的模型基础上，做了一些增强。 2.3.1 扩展在基于Egg的框架或者应用中，可以通过定义app/extend/{application, context, request, response}.js中来扩展Koa中对应的四个对象的原型。通过这个功能，可以快速的增加更多的辅助方法。 例如，在app/extend/context.js中写入以下代码： 1234567// app/extend/context.jsmodule.exports = &#123; get isIOS() &#123; const iosReg = /iphone|ipad|ipod/i; return iosReg.test(this.get('user-agent')); &#125;,&#125;; 在Controller中，就可以使用刚才定义的便捷属性了： 123456// app/controller/home.jsexports.handler = ctx =&gt; &#123; ctx.body = ctx.isIOS ? 'Your operating system is iOS.' : 'Your operating system is not iOS.';&#125;; 2.3.2 插件Egg和Koa一样，可以通过中间件来提供各种功能，Egg的插件机制更加强大，让独立领域的功能模块可以更加容易编写。 一个插件可以包含： extend：扩展基础对象的上下文，提供各种工具类、属性 middleware：增加一个或多个中间件，提供请求的前置、后置处理逻辑 config：配置各个环境下插件自身的默认配置项 3 快速入门可以直接使用脚手架快速生成项目 123456789npm init egg --type=simple# 等同于 npx egg --type=simplenpm i# 启动项目npm run dev# open localhost:7001 生成项目后，可以编写Controller和对应的Router，可以在config文件夹下添加配置文件，此时目录结构如下： 12345678egg-example├── app│ ├── controller│ │ └── home.js│ └── router.js├── config│ └── config.default.js└── package.json Egg内置了static插件，默认映射/public/* -&gt; app/public/* Egg不强制使用某种模板引擎，只是约定了View插件开发规范，使用某种模板引擎需要在config目录下的plugin.js中开启： 12345// config/plugin.jsexports.nunjucks = &#123; enable: true, package: 'egg-view-nunjucks'&#125;; 在config/config.default.js中设置文件关联： 123456789// config/config.default.jsexports.keys = &lt;此处改为你自己的 Cookie 安全字符串&gt;;// 添加 view 配置exports.view = &#123; defaultViewEngine: 'nunjucks', mapping: &#123; '.tpl': 'nunjucks', &#125;,&#125;; 实际应用中，Controller一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层Service 可以使用中间件，完成一些独立的功能。 Egg提供了强大的配置合并管理功能： 支持按环境变量加载不同的配置文件，如config.local.js，config.prod.js等 应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载 在项目根目录下，以test.js为后缀名，即{app_root}/test/**/*.(test/app/middleware/robot.test.js) 4 渐进式开发在Egg里面的渐进式开发路径是： 插件（path） → 插件（package） → 框架 4.1 Step1 原始代码当我们编写了一段具有通用型逻辑的代码时，可以抽离成为插件，比如context.js中的内容： 12345678example-app├── app│ ├── extend│ │ └── context.js│ └── router.js├── test│ └── index.test.js└── package.json 4.2 Step2 插件（path）但是在一开始的时候，功能还没完善，直接独立成为插件，维护比较麻烦，这是可以把代码写成插件的形式，但不独立出去（即使用path来引用的插件形式的代码） 这个时候新的目录结构为： 123456789101112131415example-app├── app│ └── router.js├── config│ └── plugin.js├── lib│ └── plugin│ └── egg-ua│ ├── app│ │ └── extend│ │ └── context.js│ └── package.json├── test│ └── index.test.js└── package.json 核心代码： （1）app/extend/context.js移动到lib/plugin/egg-us/app/extend/context.js （2）lib/plugin/egg-ua/package.json声明插件 12345&#123; "eggPlugin": &#123; "name": "ua" &#125;&#125; （3）在config/plugin.js中通过path来挂载组件 123456// config/plugin.jsconst path = require('path');exports.ua = &#123; enable: true, path: path.join(__dirname, '../lib/plugin/egg-ua'),&#125;; 4.3 Step3 独立插件（package）经过一段时间开发后，该模块的功能成熟，此时可以抽离出来成为独立的插件 首先抽离出一个egg-ua插件，具体的方法的需要看插件文档学习。 代码在这里，目录结构： 123456789101112egg-ua├── app│ └── extend│ └── context.js├── test│ ├── fixtures│ │ └── test-app│ │ ├── app│ │ │ └── router.js│ │ └── package.json│ └── ua.test.js└── package.json 然后对原有应用改造，代码参见这里。 移除lib/plugin/egg-ua目录 package.json中声明对egg-ua的依赖 config/plugin.js中修改依赖声明为package方式 12345// config/plugin.jsexports.ua = &#123; enable: true, package: 'egg-ua',&#125;; 在插件没发布前，可以通过npm link的方式进行本地测试，具体参见npm-link 4.4 Step4 框架当积累了插件和配置后我们会发现，团队的大部分项目都会用到这些插件。此时就可以考虑抽象出一个适合团队业务场景的框架。 首先抽象出example-framework框架，具体的方法还是得看文档学习 代码在这里，目录结构： 1234567891011121314example-framework├── config│ ├── config.default.js│ └── plugin.js├── lib│ ├── agent.js│ └── application.js├── test│ ├── fixtures│ │ └── test-app│ └── framework.test.js├── README.md├── index.js└── package.json 把原来的egg-ua等插件的依赖从原来的应用中移除，配置到该框架的package.json和config/plugin.js中，然后改造原有的应用，对应的代码参考这里 移除config/plugin.js中对egg-ua的依赖 package.json中移除对egg-ua的依赖 package.json中声明对example-framework的以阿里，并配置egg.framework 1234567891011&#123; "name": "progressive", "version": "1.0.0", "private": true, "egg": &#123; "framework": "example-framework" &#125;, "dependencies": &#123; "example-framework": "*" &#125;&#125; 同样，在插件没发布前，可以通过npm link的方式进行本地测试 4.5 渐进式开发总结总的来说，Egg.js还是和适合一步步的渐进地去进行框架演进，具体流程如下： 当应用中有可能会复用到的通用逻辑，抽离出来放到lib/plugin中 当插件功能稳定后，独立出来作为一个node moudle 如此以往，应用中相对复用性较强的代码都会逐渐独立为单独的插件 当应用逐渐进化到针对某类业务场景的解决方案时，将其抽象为独立的framework进行发布 在新项目中抽象出的插件，下沉集成到框架后，其他项目只需要简单的重新npm install后就可以使用，可以提高团队效率 5 完整目录结构egg-project ├── package.json ├── app.js (可选) ------------------------- # 用于自定义自动时的初始化工作 ├── agent.js (可选) ----------------------- # 用于 Agent 机制的配置 ├── app | ├── router.js ------------------------ # 用于配置 URL 路由规则 │ ├── controller ------------------------ # 用于解析用户的输入 │ | └── home.js │ ├── service (可选) --------------------- # 用于编写业务逻辑层，建议使用 │ | └── user.js │ ├── middleware (可选) ------------------ # 用于编写中间件 │ | └── response_time.js │ ├── schedule (可选) -------------------- # 用于定时任务 │ | └── my_task.js │ ├── public (可选) ---------------------- # 用于放置静态资源 │ | └── reset.css │ ├── view (可选) ------------------------ # 用于放模板文件 │ | └── home.tpl │ ├── Modal (可选) ----------------------- # 用于放置领域模型，可选，由领域类相关插件约定 │ | └── mySQL.db │ └── extend (可选) ---------------------- # 用于框架的扩展 │ ├── helper.js (可选) │ ├── request.js (可选) │ ├── response.js (可选) │ ├── context.js (可选) │ ├── application.js (可选) │ └── agent.js (可选) ├── config | ├── plugin.js -------------------------- # 用于配置需要加载的插件 | ├── config.default.js │ ├── config.prod.js --------------------- # 配置文件，根据不同环境加载 | ├── config.test.js (可选) | ├── config.local.js (可选) | └── config.unittest.js (可选) └── test ----------------------------------- # 用于单元测屙屎 ├── middleware | └── response_time.test.js └── controller └── home.test.js 6 静态资源egg-view-assets提供了通用的静态资源管理和本地开发，文档在这里。 可以配合基于Webpack封装的roadhog、umi，通过自动的方式添加静态资源。 重要的是和构建工具整合，保证本地开发体验及自动部署，所以构建工具和框架有一层约定。 6.1 映射关系构建工具的Entry配置决定了映射关系，基于Webpack封装的roadhog、umi内置了映射关系，如果单独使用Webpack需要根据这层映射来选择使用哪种方式： 文件源码app/assets/index.js，对应的Entry为index.js 本地静态服务接受以此为Entry，如请求http://127.0.0.1:8000/index.js 构建生成的文件需要有这层映射关系，如生成index.{hash}.js并生成Mainfest文件描述关系如： 123&#123; &quot;index.js&quot;: &quot;index.&#123;hash&#125;.js&quot;&#125; roadhog完全满足这个映射关系，所以可以直接使用assets模板引擎，Umi不满足文件映射，所以选用其他模板引擎的方案。 6.2 开发、部署、CDN文档的介绍多是基于roadhog的基础上进行的配置，如果使用Webpack需要自己配置，还是比较繁琐的。 所以考虑使用Easy-Team提供的EGG + Vue工程化解决方案。 参考 Egg文档]]></content>
      <categories>
        <category>Egg</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高09 Hooks]]></title>
    <url>%2F2019%2F03%2F27%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9809%20Hooks%2F</url>
    <content type="text"><![CDATA[React Hooks学习笔记。 这篇文章真的写了好久，从1月多，Hooks还是实验特性时就开始看，中间断断续续，再加上一开始看英文的文档，拖到了现在。 总结的太磨叽了，又弄了一个精简版，那这个做分享吧。 心里也没底。 文中涉及到的代码在这里。 做了一个分享的PPT，如果有人需要的话可以拿走。 精简版React Hooks是V16.8的新特性，是一个向后兼容的新特性（不会引入破坏性的改变）。 引入的原因实现比现有方案（HOC/Render Props）更优雅的代码复用，为纯组件引入状态，能够将组件划分为更细的粒度。 内置Hooks1 useState Hook（1）用法内置的useState用来为纯组件添加状态变量和更新方法，可以认为是this.state和this.setState的简化版，以数组的形式获取状态变量，第一个变量是一个状态，第二个是更新方法，useState接受的参数是初始值 12import &#123; useState &#125; from 'react';const [count, setCount] = useState(0); （2）函数式更新在使用setState更新时，可以直接传递一个结果，这个结果将直接赋值给state，如果更新的结果与上一个状态有关系，那可以使用函数式更新，setState的参数是一个函数，函数的参数是之前的值，返回的是更新的值 （3）手动合并对象useState不会自动合并更新对象，所以需要手动进行合并，采取函数式赋值的方式：setState(prevState =&gt; ({ ...prevState, a: 100 })) （4）延迟初始化useState的参数initialState是首次渲染期间使用的状态，如果这个状态是一个高开销的计算结果，可以改为提供函数，这个函数仅在初始渲染时执行，可以避免性能浪费： 1const [state, setState] = useState(() =&gt; (&#123; a: initialize(), b: 2 &#125;)); 2 useEffect Hook（1）用法内置的useEffect会在每次渲染（DOM更新）后（包括首次）后执行才作为参数的方法，可以认为是componentDidMount和componentDidUpdate的合集，分为需要销毁的和不需要销毁的两种 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`&#125;); 上面是不需要销毁的useEffect，它会在每次渲染后执行内部的函数。 （2）清理effect如果需要销毁，那么只需要在这个函数内部返回一个另一个函数，在返回的函数中执行销毁操作即可。注意和执行一样，销毁也是在每次渲染后都会执行，可以防止内存泄漏。 123456useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; return () =&gt; &#123; document.title = `ok`; &#125;&#125;); （3）避免重复渲染useEffect默认的表现是在每次渲染后触发，当组件的任何一个状态发生改变时，更新函数都会执行，可以给useEffect传递第二个参数，这时只有当数组中的任一一项的值发生变化，useEffect的更新函数才会执行。 这个数组并不会作为参数传递给更新函数内部，但是从概念将，更新函数中引用的每个值都应该出现在输入数组中，这样才能避免更新函数依赖的某个值发生了变化，而函数没有重新执行。ESLint的插件会自动检测并插入这个数组，推荐使用。 如果参数一个空数组，那么任何变量的变化都不会引起useEffect的执行，这时候与只在componentDidMount和componentWillUnmount执行代码是类似的。 它的最大作用是就是减少因为没有在componentDidUpdate处理更新前的状态而导致的bug。 （4）useEffect的执行时机useEffect中的更新函数会延迟到layout和paint后触发，也就是说在浏览器更新屏幕之后才会触发，但是有一些事件不能推迟，对于这个类型的事件需要在useLayoutEffect中触发，它与useEffect的不同就是在触发时机上的不同。 虽然useEffect延迟到浏览器绘制完成之后执行，但是它保证在任何新渲染之前触发。 （5）useEffect中获取本次渲染更新后的值==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，==即便执行了setState之后仍是这样==。 可以认为每次渲染时通过useState声明的状态是不可变的（Immutable），每次渲染都会对它拍一个快照保存下来，当状态更而重新渲染时就会形成N个状态。不光是state和props通过快照的形式保存，组件的事件处理和useEffect都是同样的形式 如果要在useEffect中使用更新后的state，需要使用useRef 3 useRefuseRef返回一个可变的对象，其current属性被初始化为传递的参数，返回的这个对象就保留在组件的生命周期中。 useRef返回的ref对象在所有Render过程中保持着唯一引用，如果认为state是不可变的数据，那么ref对象就可以认为是可变对象，对ref.current的赋值和取值，拿到的额都是一个状态。 要注意，避免在渲染过重中（return中）设置直接饮用，可能会导致预料之外的结果，相反，应该只在事件处理程序和useEffect中修改、使用引用。 4 useContext用来创建context对象，当使用来传递数据时有用。 5 useReduceruseState的替代方案，当组件使用flux架构组织管理数据时有用。 用它配合useContext可以避免在多层组件中深度传递回调的需要。 6 useCallback主要是用来处理在useEffect之外的定义函数无法管理依赖，也无法成为useEffect的依赖，每次渲染都会生成新的快照的情况，使用之后只有在函数的依赖发生变化时才会生成新的函数，有利于提高性能，依赖也更清晰。 7 useMemo与useCallback类似，返回的是一个不生成快照的对象，而非函数。 useMemo只会在其中一个输入发生更改时重新计算，此优化有助于避免在每个渲染上进行高开销的计算。 8 useLayoutEffect前面介绍过，与useEffect的不同点仅仅在于执行时机不同，useLayoutEffect在绘制前同步触发，useEffect会推迟到绘制后触发 Hooks的使用规定（1）只在最顶层调用Hooks，不要再内部循环、条件语句或嵌套函数中调用Hooks（这是因为React是通过多个Hooks的调用顺序来确定多个useState中状态变量的对应关系），如果想要有条件的运行一个effect，可以将条件判断放在Hook内部 （2）只在React函数中调用Hooks，不在普通的JavaScript函数中调用 可以通过ESLint的eslint-plugin-react-hooks插件来检查、规范Hooks的使用，避免不规范的使用而导致的bug。 编写自定义Hook自定义Hook实际上就是一个函数，将公用的逻辑提取进去，可以调用其他的Hook，必须以use开头。 不同的组件使用同一个自定义的Hook，状态不会共享，只是将逻辑复用，Hook使用时内部状态和effect都是完全隔离的。 啰嗦版1 简介React Hooks是v16.8推出的一个新特性，它提供给开发者一种能力，让开发者不用class的形式就能够使用state和其他的特性 在进一步了解Hooks之前，有几点注意事项： 不是必选项，你可以现在现有的组件中添加代码来试用Hooks，但是如果你不想使用它也是完全可以的 100%向后兼容，Hooks不会引入任何破坏性的改变（breaking changes） 已经提供使用，在16.8版本正式引入 Hooks的引入并不意味着在React中要放弃使用class，后面会介绍渐进式使用Hooks的策略 Hooks也不会取代你已了解的React中的概念，相反，Hooks为props、state、context、refs和生命周期等等你所熟悉的概念提供了一个更加直接的API。Hooks提供了一个更好的方式来复合使用上述概念。 2 为什么要引入HooksHooks解决了React中一系列看似毫不相关的问题，这些问题在我们编写、维护大量组件时非常常见。 2.1 在组件间复用有状态的逻辑是非常困难的React并没有提供一种方式来为组件添加可复用的接口（例如将一个组件连接到store）。React中经常使用一些编程范式来解决这类问题，例如Render Props、高阶组件。但是使用这些范式需要对组件进行重构，这个过程非常的麻烦，并且将导致代码难以维护。当你在React DevTools中查看一个典型的React应用，你会发现充满了“包裹地狱”（wrapper hell），组件嵌套在多层的provider、consumer、高阶组件、Render和其他抽象结构中。虽然我们可以公国开发工具来进行梳理，但是这也表明了一个更底层的问题：React需要一个更好原生方法来实现状态逻辑的复用。 使用Hooks，你可以将状态逻辑从组件中抽离出来，这样就可以对它单独进行测试和复用。Hooks为开发者提供了在不改变组件层次的基础上进行状态逻辑复用的能力。这使得我们能够轻而易举的在组件之间或者社区间共享Hooks。 2.2 复杂的组件变的难以理解我们常常要维护这样的组件：开始很简单，慢慢就充满了大量难以维护的状态逻辑和副作用。每个生命周期方法常常包含了大量的不相关逻辑的组合。例如，组件常常在componentDidMoun和componentDidUpdate来获取数据，而在一个componentDidMount中常包含许多无关的逻辑，比如建立事件监听器，这些事件监听器需要在componentWillUnmount中销毁。这些相互关联、同时更改的代码被分隔开了，但是完全没有关系的却出现在同一个方法中。这将带来大量的bug和不一致性。 在大多数情况下，我们无法将这些组件分割成为更小的组件，因为状态逻辑贯穿了整个组件，我们也很难测试这些组件。这也是许多开发者更倾向于为React配套使用一个单独的状态管理框架的原因。但是这也常常带来太多的抽象，让你在不同的文件之间反复跳转，让组件的复用更加困难。 为了解决这个问题，Hooks可以根据依赖（例如建立订阅器或者获取数据）而非生命周期钩子，将一个组件分割为更小的函数。为了让组件更容易预测，你可以选择通过reducer来管理组件的内部状态。 2.3 Class让开发者和计算机都感到迷惑为了实现代码复用，代码组织难度加大了。我们发现Class成为了学习React的一大障碍。你必须搞清楚在JavaScript中this的工作原理，这与this在其他大多数语言中的原理都不相同。你必须记得为事件处理程序绑定this。在关于class的语法提案没有正式通过前，class的代码显得非常啰嗦。人们能够很好地理解props、state、自顶向下的数据流，但是仍很难理解class。React中函数和class组件自身以及应用场景的区别在充满经验的React开发者间都存在着分歧。 此外，React已经诞生5年了，我们希望在接下来的5年保持连贯性。像Sevlte、Angular、Glimmer等显示的，AOT编译（运行前编译）有着很大的潜力，尤其是不仅用于与模板时。我们最近在实验使用Prepack进行组件折叠（component folding）的尝试，并且初见成效。但是我们也发现class组件带来的某些无目的范式会降低这些优化效果。Cass在当前的工具中也存在着问题，比如Class的压缩效果并不好，热更新编的颗粒化且不可靠。我们希望能够提供新的API让代码得到最大程度的优化。 为了解决这些问题，Hooks提供了绕过class使用React更多的特性的能力。从概念上将，React组件更接近于函数。Hooks对函数更友好，但也不会未被React所提倡的理念。Hooks提供了一个非常迫切的“逃生舱口”，并且不需要您去学习复杂的函数式编程或者响应式编程的知识。 2.4 小结啰里吧嗦翻译了一堆，总结起来，Hooks出现的原因有三： 现有的React的状态组件复用方式（高阶组件、Render Props）有各自的问题， 而Hooks可以优雅的（不改变组件层次）实现代码复用 Hooks可以将组件根据功能，将组件划分为更小的粒度，便于调试、测试和维护 Hooks可以不使用Class来编写组件，提高代码性能，降低React的使用难度 3 渐进式策略 React并不准备移除class 我们都知道，Recat开发者都忙于搬砖而无暇关注新发布的API。Hooks非常新，可能在更多的实例和教程出现之后，再考虑学习或者使用Hooks，可能更加稳妥。 我们也知道，为React添加一个新的原语遇到的阻力会很大。我们为好奇的读者准备了一份详细的请求意见稿，它介绍了Hooks出现的更多细节，提供了额外的视角来审视具体的设计决定和相关技术。 最重要的是，Hooks与现有代码是共存的，所以可以渐进式的应用到代码中。我们分享了试验性的API，目的是得到社区中对亲自参与React未来发展的人们的早期的反馈，我们将不断更新Hooks。 最后，不必急于迁移到Hooks。我们建议避免任何的“大重构”，特别是针对现有的、复杂的class组件。Hooks的思维习惯还需要一定的思维转变。根据我们的经验，最好首先在全新的、不重要的组件中练习使用Hooks，并且确保你的团队中的每个人都欣然接受。 我们为Hooks准备了全部现有的针对class的用例，但是我们将在可预见的未来继续提供对class组件的支持。Facebook中有大量的用class写成的组件，我们绝没有移除它们的计划。相反，我们将会在新的代码中同时使用Hooks和class 4 State HookReact默认提供了两种Hooks，一种用来声明状态变量的State Hook，另外一种是用来执行副作用函数的Effect Hook。另外，用户可以自定义个性化的Hooks，进行灵活的应用。首先来了解State Hook。 4.1 例子下面的例子渲染了一个计数器，当点击按钮式，计算器的值会递加 先看传统的class组件怎么写： 123456789101112131415161718192021222324class Count extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; setCount() &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count + 1 &#125;) &#125;; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setCount()&#125;&gt;Click Me&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 用Hooks的实现： 12345678910111213141516// 引入useState，用来在函数组件中保存局部变量import &#123; useState &#125; from &apos;react&apos;;function Example() &#123; // Declare a new state variable, which we&apos;ll call &quot;count&quot; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 上面，useState就是一个Hook。我们在一个函数组件中调用Hook，来为函数组件添加一些内部状态。React在重复渲染时会保留这些状态。useState返回两个变量：当前状态值和更新此状态的函数。你可以在一个事件处理程序等任意位置调用这个方法。它和class中的this.setState也有点类似，除了Hook返回的函数并不会将新旧状态进行合并（后面会有一个例子来比较useState和this.setState的区别） useState的唯一一个参数是初始状态值。上面的例子中，这个值是0，因为我们的计数器是从0开始计数的。注意，与this.state不同，Hooks中的状态值类型可以不是对象，当时对象类型也是支持的。初始状态参数旨在第一次渲染时用到。 4.2 声明状态变量上面的class是一个有状态的组件，React中又有一种无状态的组件，也叫做函数组件（function component）长的像这样： 1234const Example = (props) =&gt; &#123; // You can use Hooks here! return &lt;div /&gt;;&#125; 如果想要用函数组件来实现计数器这个例子，在以前是行不通的，因为在函数组件中是没有this的，所以没有办法维护this.state这个状态变量。 这时候就是Hooks的用武之地了：当你想为一个函数组件添加一个状态变量（state），以前只能改写成为class的形式，现在就可以在函数组件中使用Hooks来达到你的目的。 在函数组件中可以使用useState： 123456import &#123; useState &#125; from 'react';function Example() &#123; // Declare a new state variable, which we'll call "count" const [count, setCount] = useState(0);&#125; useState到底做了什么？ useState声明了一个“状态变量”（例子中的count），这个变量名是可以随意定义的。这是在函数调用时保存变量值的方法–useState的作用就像class中的this.state一样。一般来说，当函数退出后变量会被清除，但是React会将状态变量保存起来。 useState的参数是什么？ useState只有一个参数，那就是Hook的初始值。与class不同，useState定义的状态变量可以不是object，number或者string都是可以的。在计数器的例子中我们需要一个数值来记录用户点击的次数，所以我们为变量传入了0作为初始值（如果想要在state中保存两个不同的值，需要调用useState()两次） useState的返回值是什么？ 返回两个变量：当前值和这个值的更新方法，上面的代码const [count, setCount] = useState()和class中的this.state.count和this.setState是类似的，不同点是Hook将它们作为一组数据同时返回 当再次渲染时，React会在函数组件中获取count的最新值，如果想要更新count可以调用setCount 4.3 读取状态变量在class中我们通过读取this.state.count来获取最新的count值： 1&lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; 在函数组组件中可以直接使用count值： 1&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; 4.4 更新状态变量在class中通过调用this.setState来更新count值 123&lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me&lt;/button&gt; 在函数组件中，我们已经声明了变量setCount和count，所以也就不需要this了 123&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; 4.5 声明多个状态变量在一个组件中可以多次使用状态Hook： 1234567function ExampleWithManyStates() &#123; // 声明了多个状态变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([&#123; text: 'Learn Hooks' &#125;]); // ...&#125; 通过数组的解构赋值，我们可以在调用useState声明多个不同名称的状态变量。变量名并不是useStateAPI的一部分，相反，React假设你会在每次渲染时，以相同的顺序多次调用useState。后面我们会回过头再来解释为什么可以这样做以及应用场景。 4.6 究竟什么是Hook？通过上面的例子，我们可以发现： Hook是一种能够“侵入”React的函数组件的状态和生命周期特性的函数。Hook不能用在class中–Hook让你能够抛弃class来使用React（我们并不建议立刻对现有代码进行重构，但是如果你愿意的话，可以在新代码中开始使用Hooks） React提供了一些内嵌的Hooks，例如useState。你也可以创建自己的Hook，达到在不同的组件间复用有状态的行为。后面会首先讲解内嵌的Hook。 5 Effect Hook我们将React组件中的某些操作称为具有副作用的effect（或者简称为effect），例如获取数据、订阅事件或者手动更改DOM，因为这些行为可能会影响其他的组件，并且无法在渲染期间完成。 useEffect就是一种Effect Hook，它可以为函数组件添加副作用行为。它提供的功能和class中的componentDidMount、 componentDidUpdate、componentWillUnmount是相同的，只是被合并为一个单独的API。 React组件中有两种常见的effect，一种是需要销毁的，另外一种是不需要销毁的。 5.1 不需要销毁的effect有些时候，我们希望在React更新DOM之后运行一些额外的代码。注入网络请求、手动更新DOM以及打印日志都是常见的不需要销毁的effect。这么认为的原因是我们可以运行它们，并且立刻忘记它们。下面看一下，用Class组件和Hook组件分别是如何实现effect的。 5.1.1 用Class组件实现在React的Class组件中，render方法并不会导致effect，因为在render中为时尚早–我们是在React更新DOM后才执行effect。 所以在React的Class组件中，我们将effect放在componentDidMount和componentDidUpdate生命周期函数中。下面的例子中，组件会在React更新DOM之后设置文档的标题。 123456789101112131415161718192021222324252627class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 我们必须在class的两个生命周期函数中编写相同的代码。 这是因为很多情况下，不管组件是刚刚渲染完成还是更新完成，我们想要执行相同的effect。也就是说，我们想要在每次渲染后都执行effect。但是React的Class组件并没有提供这样的生命周期。我们能够提取出一个单独的方法，但是仍需要在两个地方调用它。 而如果使用useEffectHook来完成同样的行为： 5.1.2 用Hook组件实现如果改成使用useEffect的形式： 1234567891011121314151617181920import &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 你可能会有这样的疑问： （1）useEffect究竟做了什么？ 通过使用这个Hook，你告诉React这个组件需要在每次渲染后执行一些操作。React会保存你传入的函数（这个函数就是上面提到的effect）并且在每次DOM更新后进行调用。在上面的Effect中，我们更改了文档的标题，当然也可以执行获取数据等其他必要的操作。 （2）为什么在组件中调用useEffect？ 将useEffect放在组件中让我们有能力从effect中获取count状态变量（以及任何prop）我们不需要特殊的API来读取它–因为它已经在函数的作用域中了。Hooks鼓励JavaScript闭包，并且尽量避免在JavaScript已经提供解决方案的情况下引入额外的React特有的API （3）useEffect在每次渲染后都会运行吗？ 是的。useEffect默认在首次渲染以及每次更新后都会运行（当然后办法修改这种行为）。这使得你函数无所谓是在mount还是update后被调用，因为他们会在每次渲染后都被统一调用。Reasct会保证在DOM更新完成后才会调用effect。 5.1.3 细节讲解123456function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); 我们声明了count状态变量，随后需要使用effect来完成某些行为。我们给useEffectHook传递了一个函数，这个函数就是effect，在其中我们设置文档的标题。我们在effect可以读取罪行的count因为它位于函数作用域内。当React渲染组件时会保存我们的effect，并且在每次更新DOM后运行–包括首次渲染。 有经验的卡开发者或者会注意到，传递给useEffect的函数在每次渲染后都是不同的。这是有意而为之。实际上，这让我们在effect中读取count的值而不必担心它的值没有刷新。每次渲染，我们都会使用新的effect代替之前的。折让effect看起来更像render的结果–每个effect都“属于”一次特定的render。这是很有用的，后面会提到。 与componentDidMount和componentDidUpdate，useEffect的effect不会阻塞浏览器更新显示信息。这会让你的app更加响应式。大部分的effect不需要同步完成，在少数情况下需要（例如测量布局），可以使用useLayoutEffectAPI。 5.2 需要销毁的effect有一些effect需要销毁，例如我们可能会针对默写外部数据源建立监听器。这种情况下就必须销毁effect，以避免内存泄漏。同样使用Class组件和Hook组件都可以时间。 5.2.1 使用Class组件在React的Class组件中，需要在componentDidMount生命周期中建立监听器，在componentWillUnmount销毁，例如，我们通过ChatAPI来订阅好友的上线状态，在React的Class组件中的实现如下： 12345678910111213141516171819202122232425262728293031323334class FriendStatus extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; render() &#123; if (this.state.isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return this.state.isOnline ? &apos;Online&apos; : &apos;Offline&apos;; &#125;&#125; 在componentDidMount和componentWillUnmount生命周期中需要执行相反的操作。生命周期方法让我们不得不将逻辑上相关联的操作分割开来。 5.2.2 使用Hooks组件你或许认为我们需要一个独立的effect来执行销毁。但是由于添加和移除订阅的关系如此紧密，所以useEffect在设计时就将而二者联系在了一起。在effect中返回一个函数，React就会在销毁时执行这个函数。 12345678910111213141516171819202122mport &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &apos;Loading...&apos;; &#125; return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;&#125; 在上面的例子中，React会在组件销毁时通过ChatAPI执行取消订阅，就如同在随后的渲染中再次运行Effect Hook一样（如果需要，当传递给ChatAPI的props.friend.id没有变化时，可以让React不再重复订阅） （1）为什么在effect中返回了一个函数？ 这是effect的可选的销毁机制。每一个effect都可以返回一个函数来进行销毁。这让我们能够统一维护保持添加和移除的逻辑。它们都是同一个effect的组成部分。 返回的函数可以使命名函数也可以是匿名函数、箭头函数。 （2）React究竟是何时销毁一个effect？ React在组件unmount时销毁effect。但是正如我们上面介绍过的，effect在每次渲染都会运行，而不只运行一次。所以React也会在上一次渲染结束后、运行下一次的effect之前来执行清理。后面会介绍为什么这有利于减少bug以及为了减少可能带来的性能问题如何退出这种机制。 5.3 为什么在每次更新后effect都会运行为什么effect的销毁在每次重新渲染后都会执行，而不是只在unmount时执行一次。下面的例子会展示这样设计的好处–编写bug更少的组件。 前面的订阅好友上线状态的组件会展示好友是否上线，组件从this.props中读取friend.id，在组件mount后订阅好友状态，在unmount后取消订阅 12345678910111213componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 但是，如果prop中的firend变化了，而组件仍然显示在界面上，这时会发生什么？我们的组件会继续展示之前的朋友（与当前不同）的上线状态。这就是一个bug。而且当我们在取消订阅时用了错误的好友ID是，会造成内存的泄露甚至崩溃。 在Class组件中，我们需要在componentDidUpdate中处理这种情况： 12345678910111213componentDidUpdate(prevProps) &#123; // Unsubscribe from the previous friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // Subscribe to the next friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 忘记正确的处理componentDidUpdate中的逻辑是React产生bug最多的原因之一。 如果使用Hooks的组件： 12345678function FriendStatus(props) &#123; // ... useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); 这种情况就能避免上面的bug。 没有代码专门处理更新的情况因为useEffect默认会自动处理。它会在应用下一个effect之前清理上一个effect。下面的订阅和取消订阅的顺序可以证明这一点： 12345678910111213// Mount with &#123; friend: &#123; id: 100 &#125; &#125; propsChatAPI.subscribeToFriendStatus(100, handleStatusChange); // Run first effect// Update with &#123; friend: &#123; id: 200 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(200, handleStatusChange); // Run next effect// Update with &#123; friend: &#123; id: 300 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(300, handleStatusChange); // Run next effect// UnmountChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect 这种行为默认保证了一致性，避免了Class组件中因为忽略更新逻辑而导致的bug 5.4 使用effect的注意事项5.4.1 使用多个effect来分离关注点在我们讨论为什么要引入Hooks的时候提到了一个问题，Class组件的生命周期方法常常包含无关的逻辑，而相关逻辑却常常被分散在不同的方法中。下面的组件包含了前面例子中的计数器和好友上线提示的逻辑： 1234567891011121314151617181920212223242526272829303132class FriendStatusWithCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; // ... 上面的代码中，设置文档标题的逻辑分散在componentDidMount和componentDidUpdate中，订阅逻辑分散在componentDidMount和componentWillUnmount中，而componentDidMount中包含了所有的逻辑代码。 使用Hooks如何解决这个问题？就像可以多次使用状态Hook一样，也可以使用多个effect。这让我们可以分离无关逻辑到不动的effect中。 12345678910111213141516171819function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; // ...&#125; ==Hooks让我们能够基于代码的行为来分割代码==，而不是基于生命周期。React会按照effect声明的顺序，运行组件中的每一个effect 5.4.2 跳过effect以改善性能某些情况下，每次渲染都销毁或者应用effect会造成性能问题。在Class组件中，我们可以通过在componentDidUpdate中对比prevProps和prevState来解决这个问题 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这种需求很常见，所以它被内置到了useEffectHook的API中。如果在重复渲染时某些特定值未发生改变，你可以让React不再运行effect。具体做法是将一个数组作为可选的第二个参数传递给useEffect 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // Only re-run the effect if count changes 上面的例子中，将[count]作为第二个参数传给了useEffect。当count值未发生变化时，React会跳过effect。如果数组中有多个值，React会在任何一个发生改变时再次执行effect。 注意，如果进行这种优化，确保数组中包含了被effect使用的、会随时间变化的外部变量。否则你的代码从上次渲染中获取的参考值不会改变。 如果想只执行、销毁effet一次（mount和unmount时），可以传递一个空数组作为第二个参数。这告诉了React你的effect不依赖任何从props和state中任何变量，所以不需要重复执行。这种情况与只在componentDidMount和componentWillUnmount执行代码是类似的，我们建议谨慎使用，因为容易导致bug 6 Hooks的使用规定Hooks是函数，在使用时需要注意两条规定，可以引入ESLint的一个插件来确保遵守 6.1 只在最顶层调用Hooks==不要在内部循环、条件语句或者嵌套函数中调用Hooks==。相反，要式中在React函数的最顶层使用Hooks。这样才能确保组件每次渲染时都以同样的顺序调用Hook。这是保证React在多个useState和useEffect中正确保存状态的前提。 6.2 只在React函数中调用Hooks不要在普通的JavaScript函数中调用Hooks。正确的做法是： 在React的函数组件中调用Hooks 在自定义的Hooks中调用Hooks 遵守这条规定，能够确保组件中的所有状态逻辑在源码中都是清晰可见的。 6.3 ESLint插件通过这个ESLint插件可以检测在使用Hooks时是否遵守了上面两条规定。安装： 1npm install eslint-plugin-react-hooks ESLint的配置文件： 12345678910&#123; "plugins": [ // ... "react-hooks" ], "rules": &#123; // ... "react-hooks/rules-of-hooks": "error" &#125;&#125; 将来这个插件会默认集成在Create React App和类似工具中。 6.4 为什么看这样一个例子： 12345678910111213141516171819function Form() &#123; // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() &#123; localStorage.setItem('formData', name); &#125;); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() &#123; document.title = name + ' ' + surname; &#125;); // ...&#125; React是通过Hooks的调用顺序来确定多个useState中状态变量的对应关系。上面的例子之所以能够正常运行是因为每次渲染时Hooks的执行顺序是相同的。 123456789101112131415// ------------// First render// ------------useState('Mary') // 1. 初始化状态变量name为'Mary'useEffect(persistForm) // 2. 添加effect来保存表单数据useState('Poppins') // 3. 初始化状态变量surname为Poppins'useEffect(updateTitle) // 4. 添加effect来更新标题// -------------// Second render// -------------useState('Mary') // 1. 读取状态变量name (忽略了参数)useEffect(persistForm) // 2. 更新effectuseState('Poppins') // 3. 读取状态变量surname(忽略了参数)useEffect(updateTitle) // 4. 更新effect 只要Hook的调用顺序不变，React就能正确辨别多个变量的关系。但是如果我们将一个Hook放到一个条件语句中呢？ 123456// 🔴 违反了第一条规定，在条件语句中使用了Hookif (name !== '') &#123; useEffect(function persistForm() &#123; localStorage.setItem('formData', name); &#125;);&#125; 条件语句第在第一次渲染时条件判断为true，Hooks的调用情况与上面相同。但是当第二次渲染时判断条件如果变为了false，这个Hook会被跳过，这是Hook的调用顺序发生了变化： 1234useState(&apos;Mary&apos;) // 1. 读取状态变量name (忽略了参数)// useEffect(persistForm) // 🔴 这个Hook被跳过了useState(&apos;Poppins&apos;) // 🔴 2 (原来是第3步). 无法读取状态变量surnameuseEffect(updateTitle) // 🔴 3 (原来是第4步). 无法更新effect React不会知道第二个useState返回值是什么，React认为这个组件的第二个Hook是persistForm这个effect，就如同上次渲染相同，但是实际情况并不是这样。从这之后的Hooks调用都会错位，导致了bug。 ==这就是必须在组件中的顶层中调用Hook的原因==。如果想要有条件的运行一个effect，可以将条件判断放在Hook内部： 123456useEffect(function persistForm() &#123; // 👍 We're not breaking the first rule anymore if (name !== '') &#123; localStorage.setItem('formData', name); &#125;&#125;); 编写个性化Hook例子编写个性化Hook可以将组件的逻辑提取为可复用的函数。 上面例子中一个订阅好友状态的组件我们命名为FriendStatus，现在假设我们的聊天程序有一个通讯录的功能，我们想要将在线好友的名字渲染为绿色。我们可以粘贴复制相同逻辑的代码到FriendListItem组件中，但是这很不优雅： 12345678910111213141516171819202122import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function FriendListItem(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 更优雅的做法是在FriendStatus和FriendListItem组件中共用相同的逻辑。 在以前，React中想要在组件中复用状态逻辑有两种方法：render props和HOC。使用这两种方法都需要添加一些包裹组件，现在使用Hooks可以不向组件树中添加新的组件来解决这个问题。 提取自定义Hook如果我们想在两个JavaScript函数中复用逻辑，可以将这部分提取到单独的函数中。React组件和Hooks都是函数，所以也可以使用这种方法。 自定义的Hook是这样的一种函数：函数名以use开头，可以调用其他的Hooks。在下面我们编写一个自定义的Hook：useFeinedStatus 123456789101112131415161718import React, &#123; useState, useEffect &#125; from 'react';function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 在useFeinedStatus中没有新的代码，逻辑都是从旧的组件中复制而来。和组件中调用一样，在我们自己编写的Hooks中，仍然需要遵守在顶层调用、不能在条件语句中调用的原则。 与React的组件不同，自定义的Hook不需要特殊标记。我们可以决定它的参数和返回值，就如果普通的函数一样。它的名字应该以use开头，这样就能一眼分辨出它遵守的Hook的规定。 我们的useFeinedStatusHook的目的是订阅好友的状态，所以参数是friendID，返回值是好友是否在线的状态值 1234567function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... return isOnline;&#125; 使用自定义Hook在一开始，我们的既定目标是从FriendStatus和FriendListItem组件中移除重复的逻辑代码。二者中都包含了好友上线通知的逻辑。 现在我们已经将这部分逻辑提取到了useFriendStatus这个Hook中，我们可以这样使用： 12345678function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return 'Loading...'; &#125; return isOnline ? 'Online' : 'Offline';&#125; 123456789function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 优化后的代码与原来的代码相同吗？ 是的。优化后的代码实现了一样的功能。但是我们将复用的部分提取到了单独的函数中。自定义的Hook的设计思路与Hooks相同，与React的特性不同。 自定义的Hook的名字一定要要以use开头吗？ 是的，这个习惯很重要。如果不这样做，我们就无法自动的侦测违反Hooks使用规定的行为，因为我们无法分别一个函数中是否调用了Hooks。 使用同一个Hook的两个组件的会共享状态码？ 并不是，自定义Hooks是一种复用状态逻辑的方式（就像建立一个监听器并且保存当前值），但是每次使用一个自定义Hook，所有其内部的状态和effect都是完全隔离的。 自定义Hook是如何隔离状态的？ Hook的每次调用都会隔离状态，因为对于React而言，我们直接调用useFriendStatus，与调用useState和useEffect是一样的。前面介绍过，同一个组件中useState和useEffect的多次调用完全是相互独立的。 提示：在Hooks之间传递参数既然Hooks是函数，那么我们就可以在它们中间传递参数。 为了说明这一点，我们为上面的聊天APP的例子再添加一个组件，它是一个聊天信息接受选择器，用来显示当前选择的好友是否在线。 1234567891011121314151617181920212223242526const friendList = [ &#123; id: 1, name: &apos;Phoebe&apos; &#125;, &#123; id: 2, name: &apos;Rachel&apos; &#125;, &#123; id: 3, name: &apos;Ross&apos; &#125;,];function ChatRecipientPicker() &#123; const [recipientID, setRecipientID] = useState(1); const isRecipientOnline = useFriendStatus(recipientID); return ( &lt;div&gt; &lt;Circle color=&#123;isRecipientOnline ? &apos;green&apos; : &apos;red&apos;&#125; /&gt; &lt;select value=&#123;recipientID&#125; onChange=&#123;e =&gt; setRecipientID(Number(e.target.value))&#125; &gt; &#123;friendList.map(friend =&gt; ( &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt; &#123;friend.name&#125; &lt;/option&gt; ))&#125; &lt;/select&gt; &lt;div/&gt; );&#125; 我们将当前选择的好友ID保存在变量recipientID中，如果用户在&lt;select&gt;中选择了另外的好友我们会更新这个变量 因为useStateHook调用时会提供recipientID的最新之，我们将它作为参数传给useFriendStatus这个Hook 12const [recipientID, setRecipientID] = useState(1);const isRecipientOnline = useFriendStatus(recipientID); 这就实现了通知我们当前选择的好友是否上线的目的。当我们选择了另外一个好友并且更新了recipientID后，我们自定义的HookuseFriendStatus就会取消对上一个朋友的订阅，订阅选择后的新朋友的状态 另一个例子：useYourImagination() 这部分的内容，由于我没有接触过Redux，所以不能很好的理解代码的功能。下一个任务就是学习Redux，需要回过头来再重新学习这部分 自定义Hook提供了React组件之前不具备的共享逻辑的灵活性。自定义Hook可以实现很多的功能，比如表单处理、动画、事件订阅、计时器等等。此外，Hooks使用起来就想使用React内置的特性一样轻松。 不要过早开始抽象逻辑。现在函数式组件功能更强大，你代码库中的函数式组件的平均长度会因此增长不少。这很正常，你没有必要立刻将它们分割为Hooks。但我们还是鼓励在有需要隐藏简单接口后的辅助逻辑时、或者分解复杂组件时开始使用自定义Hook 举个例子，下面是一个通过Hooks方式管理的复杂的组件，包含了许多局部变量。useState并没有将更新逻辑集中变得更容易，所以也许你更倾向于使用Redux的reducer的形式来实现： 123456789101112function todosReducer(state, action) &#123; switch (action.type) &#123; case 'add': return [...state, &#123; text: action.text, completed: false &#125;]; // ... other actions ... default: return state; &#125;&#125; reducer非常易于独立测试以及表达复杂的更新逻辑，如果需要还可以被分解为粒度更小的reducer。你也许习惯了使用React局部变量带来的优势，并不愿意再引入另外的库。 但如果编写一个useReducer的Hook帮助我们管理组件中的reducer中的局部变量呢？简单的实现如下： 12345678910function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; 可以在组件中使用这个Hook，使用reducer进行它的状态管理： 123456789function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: 'add', text &#125;); &#125; // ...&#125; 在复杂组件中利用reducer管理局部变量是非常常见的需求，所以React提供了的内置的useReducerHook。 Hooks APIReact提供了一系列内置Hooks，这里简单介绍一下吧，详细的参考文档。 分为两大类，基础Hook和附加Hook 基础Hook包括： useState useEffect useContext 附加Hook包括： useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useState1const [state, setState] = useState(initialState); 返回一个状态变量和更新函数。 要注意的是，在每次渲染期间，useState返回的第一个值将始终是应用更新后的最新的状态。 函数式更新在使用setState更新时，可以直接传递一个结果，这个结果将直接赋值给state，如果更新的结果与上一个状态有关系，那可以使用函数式更新，setState的参数是一个函数，函数的参数是之前的值，返回的是更新的值 1setState((prevState =&gt; prevState + 1) 手动合并对象注意，与class组件中的setState方法不同，useState不会自动合并更新对象： 比如，在class组件中： 123456789101112class Test extends React.Component &#123; state = &#123; a: 1, b: 2, &#125;; render() &#123; console.log(this.state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; a: 100 &#125;)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 点击按钮，setState会自动将对象合并，打印结果是： 1&#123;a: 100, b: 2&#125; 而在使用Hooks的组件中中： 123456789function Test() &#123; const [state, setState] = useState(&#123; a: 1, b: 2 &#125;); console.log(state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setState(&#123; a: 100 &#125;)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125; useState在更新时不会将对象合并，所以打印的结果是： 1&#123;a: 100&#125; 所以需要手动进行合并，采取函数式赋值的方式： 1setState(prevState =&gt; (&#123; ...prevState, a: 100 &#125;)) 这样才能保证更新后的对象是我们想要的对象。 延迟初始化useState的参数initialState是首次渲染期间使用的状态，在后续的更新渲染过程中，它会被忽略，因为state会采用上一次更新后最新的值，但是如果这个初始状态仍然会被计算一次： 1234567891011121314function initialize() &#123; console.log(&apos;initialize&apos;); return 1;&#125;function Test() &#123; const [state, setState] = useState(&#123; a: initialize(), b: 2 &#125;); console.log(state); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setState(prevState =&gt; (&#123; ...prevState, a: 100 &#125;))&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125; 在首次渲染时initialize会被调用，当点击按钮组件更新时，initialize仍然会被调用，但是结果却被遗弃了。如果这个状态是一个高开销的计算结果，可以改为提供函数，这个函数仅在初始渲染时执行，可以避免性能浪费： 1const [state, setState] = useState(() =&gt; (&#123; a: initialize(), b: 2 &#125;)); 将useState的参数改为函数，在后续渲染时，初始状态计算就会被跳过了。 useEffect1useEffect(didUpdate); 接受一个函数，默认在每次渲染后执行。 清理effect如果在effect中创建的一些事件需要在组件卸载时清理，比如定时器或者事件订阅等，可以为effect的更新函数返回一个新的函数，这个函数可以作为清理函数，在每次渲染时组件删除前执行，防止内存泄漏。 1234567useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // Clean up the subscription subscription.unsubscribe(); &#125;;&#125;); 如果组件渲染多次，在执行下一个effect之前都会先执行清理函数。 useEffect的执行时机useEffect中的更新函数会延迟到layout和paint后触发，也就是说在浏览器更新屏幕之后才会触发，因为它所针对的事件是订阅等事件处理程序不应该组织UI界面的更新。 但是有一些事件不能推迟，比如用户可见的DOM改变必须在下一次绘制之前同步触发，避免用户感觉到操作与视觉的不一致性。对于这个类型的事件需要在useLayoutEffect中触发，它与useEffect的不同就是在触发时机上的不同。 虽然useEffect延迟到浏览器绘制完成之后执行，但是它保证在任何新渲染之前触发。 避免重复渲染useEffect默认的表现是在每次渲染后触发，当组件的任何一个状态发生改变时，更新函数都会执行： 12345678910111213141516export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); useEffect(() =&gt; &#123; console.log(count2); &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count1&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count1 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 每更新count1的值时，useEffect都会执行，如果我们只希望打印count2的useEffect只在count2更新时执行，可以给useEffect传递第二个参数，它是更新时所依赖的值组成的数组 123useEffect(() =&gt; &#123; console.log(count2);&#125;, [count2]); 这样，这个更新函数只有在count2发生改变时才会执行。 如果传入一个空数组[]那就意味着告诉React这个更新函数不依赖于组件中的任何值，仅仅在首次渲染时执行，在组件销毁时执行清理，从不在更新时运行。 这个数组并不会作为参数传递给更新函数内部，但是从概念将，更新函数中引用的每个值都应该出现在输入数组中，这样才能避免更新函数依赖的某个值发生了变化，而函数没有重新执行。ESLint的插件会自动检测并插入这个数组，推荐使用。 useEffect中获取本次渲染更新后的值==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，牢记这一点很重要，例如： 12345678910111213141516171819202122export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); // useEffect1 useEffect(() =&gt; &#123; setCount1(100); console.log(count1, &apos;useEffect1&apos;); &#125;, [count1, count2]); // useEffect2 useEffect(() =&gt; &#123; console.log(count1, &apos;useEffect2&apos;); &#125;); return ( &lt;div&gt; &lt;p&gt;&#123;count1&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount2(count1 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 分析一下这个组件的执行结果： （1）首次渲染，useEffect1执行，setCount1(100)，这个时候打印的结果是多少？ （2）继续向下，useEffect2执行，打印的结果是多少？ （3）此时屏幕上显示的多少？ （4）是否会继续执行？ 再重复一遍，在==在useEffect的更新函数中，拿到的state和props总是当次渲染的初始值==，==即便执行了setState之后仍是这样==，所以： （1）首次渲染，useEffect1执行，setCount1(100)，这时count1的值仍然是初始值0，所以这个时候打印的结果是0 &quot;useEffect1&quot; （2）继续向下，useEffect2执行，同样获取的count1的值仍然是当次渲染的初始值，所以打印的结果是0 &quot;useEffect2&quot; （3）此时屏幕上显示的结果，在return时获取的count1的值才是经过了useEffect中更新后的值，所以屏幕上显示0 （4）由于在这轮渲染中，count1的值由0变为了100，而useEffect1依赖了count1的值，useEffect2默认每次更新后执行，所以会仍然执行。所以在下一轮次的渲染时会打印出100 &quot;useEffect1&quot;和100 &quot;useEffect2&quot;，屏幕上显示100。 所以完整的打印结果是： 12340 "useEffect1"0 "useEffect2"100 "useEffect1"100 "useEffect2" 实际上可以认为每次渲染时通过useState声明的状态是不可变的（Immutable），每次渲染都会对它拍一个快照保存下来，当状态更而重新渲染时就会形成N个状态。不光是state和props通过快照的形式保存，组件的事件处理和useEffect都是同样的形式，例如： 123456789101112131415161718192021export default function () &#123; const [count, setCount] = useState(1); const log = () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(count); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; log(); setCount(100); &#125;&#125;&gt; Set future count &lt;/button&gt; &lt;/div&gt; );&#125; 最终代码打印的结果是1，而不是100，屏幕上显示的100，这是因为在首次渲染时，log方法被执行，执行延时函数，这时候的count快照值是1，继续执行setCount(100)导致重新渲染，这一次渲染时count变为了100，显示在屏幕，3s后打印的count是首次渲染时保存的快照，所以结果是1 我犯过的一个错误就是，在useEffect1中通过setState更新了count1的值，而在useEffect2中要使用更新后的count1的值，这就会导致错误，因为在任何一个useEffect中拿到的count1的值是当次更新的count1的初始值，而不会是在useEffect1中更新后的值。 如何解决这个问题呢？我觉得有两个方法，一个是更好的组织useEffect，一个useEffect中不要完成过多的功能呢，更不要成为一个中间过程，为最终渲染的结果提供中间数据，而是让每个useEffect都提供渲染需要的最终数据。 如果确实有这种需要，那么就需要使用React提供了另外一种内置Hook了，useRef。 注意，在渲染结果中拿到的都是更新后的最新的props和state，如果在渲染结果中出现了旧的props和state，那么很可能是遗漏了一些依赖，导致对应的useEffect没有按照预期执行。还是推荐使用前面提到的ESLint的插件来帮助我们发现和解决问题。 useRef1const refContainer = useRef(initialValue); useRef返回一个可变的对象，其current属性被初始化为传递的参数，返回的这个对象就保留在组件的生命周期中。 useRef返回的ref对象在所有Render过程中保持着唯一引用，如果认为state是不可变的数据，那么ref对象就可以认为是可变对象，对ref.current的赋值和取值，拿到的额都是一个状态： 1234567891011121314151617181920export default function () &#123; const count = useRef(1); // useEffect1 useEffect(() =&gt; &#123; // 赋值 count.current = 100; console.log(count, &apos;useEffect1&apos;); &#125;); // useEffect2 useEffect(() =&gt; &#123; // 赋值 count.current = 200; console.log(count, &apos;useEffect2&apos;); &#125;); return ( &lt;div /&gt; );&#125; 使用useRef就可以再当次渲染获取到改变后的值，所以打印结果是： 12&#123;current: 100&#125; "useEffect1"&#123;current: 200&#125; "useEffect2" 要注意，避免在渲染过重中（return中）设置直接饮用，可能会导致预料之外的结果，相反，应该只在事件处理程序和useEffect中修改、使用引用。 其他内置的Hook目前还没用到，简单看下： useContext1const context = useContext(Context); 用来创建context对象，当使用Context API来传递数据时有用。 useReducer1const [state, dispatch] = useReducer(reducer, initialState，initialAction); useState的替代方案，接受类型为(state, action) =&gt; newState的Reducer，返回与dispatch方法匹配的当前状态。initialAction是可选的，提供初始的action 12345678910111213141516171819202122232425262728293031323334import React, &#123; useReducer &#125; from &apos;react&apos;;const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; const &#123; type &#125; = action; switch (type) &#123; case &apos;reset&apos;: &#123; return initialState; &#125; case &apos;increment&apos;: &#123; return &#123; count: state.count + 1 &#125;; &#125; case &apos;decrement&apos;: &#123; return &#123; count: state.count - 1 &#125;; &#125; default: &#123; return state; &#125; &#125;&#125;export default function () &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; &lt;p&gt;&#123;state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;reset&apos; &#125;)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;increment&apos; &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;decrement&apos; &#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125; 这个时候的state有reducer得来，更新方法dispatch是匹配reducer的dispatch({type: &#39;type&#39;})更新方法。 用它配合useContext可以避免在多层组件中深度传递回调的需要。 useCallback123456const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 主要的目的是，如果一个函数依赖了组件的state，并且由于复用的原因，不能放在useEffect中，就将这个函数用useCallback包装，返回的变量可以作为对应的useEffect的依赖，当其依赖发生变化时，返回新的函数引用，同时触发对应的useEffect重新执行。 我理解使用的原因主要出于性能优化和便于维护，例如： 1234567891011121314151617181920export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(100); function fetch() &#123; console.log(&apos;fetch&apos;); return count1 + 1000; &#125; useEffect(() =&gt; &#123; console.log(fetch()); &#125;); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 其中的useEffect无法添加fetch作为依赖，因为它是一个普通的函数，而且每次渲染fetch都会生成一个快照，如果使用了useCallback： 1234567891011121314151617181920export default function () &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(100); const fetch = useCallback(() =&gt; &#123; console.log(&apos;fetch&apos;); return count1 + 1000; &#125;, [count1]); useEffect(() =&gt; &#123; console.log(fetch()); &#125;, [fetch, count1, count2]); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount1(count1 + 1)&#125;&gt;Add Count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Add Count2&lt;/button&gt; &lt;/div&gt; );&#125; 使用了useCallback之后，依赖更清晰，并且在count1未发生变化时不会生成新的快照，有助于性能的提高。 useMemo1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 与useCallback类似，返回的是一个不生成快照的对象，而非函数。 useMemo只会在其中一个输入发生更改时重新计算，此优化有助于避免在每个渲染上进行高开销的计算。 useLayoutEffect前面介绍过，与useEffect的不同点仅仅在于执行时机不同，useLayoutEffect在绘制前同步触发，useEffect会推迟到绘制后触发 参考 Hooks API Reference@React Hooks API 参考@React中文文档 精读《useEffect 完全指南》@掘进 useEffect 完整指南@overreacted https://reactjs.org/docs/hooks-overview.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux03 React-Redux]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux03%20React-Redux%2F</url>
    <content type="text"><![CDATA[Redux一个为JavaScript应用而生的可预测的状态容器，可以有很多方式使用它，而React应用只是其中一种，所以它的API是高度抽象的，并非只针对React的。 为了使用方便，Redux的作者封装了一个React的专用的库React-Redux，这个库时可选的，是否选用应该权衡一下，因为React-Redux虽然提供了便利，但是需要掌握额外的API，并且要遵守它的组件拆分规范。 同步和异步流程先来复习一下Redux的基本流程： 12345671. 用户发出Action2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 在第1、2步之间有一个问题，之前考虑的情况都是在Action发出之后，Reducer立刻计算出State，这是一个同步的过程。如果在Action发出之后，过一段时间再执行Reducer，这是异步过程： 1234567891. 用户发出Action1.5 异步操作（等待一段时间）2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 现在我们希望的是在异步操作结束后，自动执行Reducer，这就要用到中间件（middleware） 中间件的概念什么是中间件？中间件（middleware）是一种很常见、也很强大的模式，被广泛应用在Express、Koa、Redux等类库和框架当中。 简单来说，中间件就是在调用目标函数之前，可以随意插入其他函数预先对数据进行处理、过滤，在这个过程里面你可以打印数据、或者停止往下执行中间件等。数据就像水流一样经过中间件的层层的处理、过滤，最终到达目标函数。 1234// 中间件可以把 A 发送数据到 B 的形式从// A -----&gt; B// 变成:// A ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; middleware 3 --&gt; ... ---&gt; B 具体到Redux来看，如果要实现中间件，最合适环节就是在发送Action的环节，即使用中间件包裹store.dispatch来添加功能，比如要增加打印功能，将Action和State打印出来，我们就可以编写这样一个中间件： 1234567const next = store.dispatch;store.dispatch = function (action) &#123; console.log('action: ', action); next(action); console.log('next state: ', store.getState())&#125;; 中间件对store.dispatch进行了改造，在发出Action和执行Reducer之间添加了其他功能。但是实际上中间件的写法不是这样的。 在Redux中，中间件是纯函数，有明确的使用方法，并且要严格的遵循以下格式： 1234567var anyMiddleware = function (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; // 你的中间件业务相关代码 &#125; &#125;&#125; 中间件由三个嵌套的函数构成（会依次调用）： （1）第一层向其余两层提供分发函数dispatch和getState函数 （2）第二层提供next函数，它允许你显示的将处理过的输入传递给下一个中间件或Redux（这样Redux才能调用所有reducer）。实际上next作为参数，就是通过componse传入的下一个要执行的函数，通过next(action)就将action传递给了下一中间件 （3）第三层提供从上一个中间件或者从dispatch传递过来的Action，这个Action可以调用下一个中间件（让Action继续流动）或者以想要的方式处理action 所以一个Log的中间件应该这样写： 12345678function logMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('logMiddleware action received:', action) return next(action) &#125; &#125;&#125; next(action)就是继续传递Action，如果不进行这一步，所有的Action都会被丢弃。 中间件的用法常用的中间件都有现成的，不用我们自行编写，只需要直接引用别人写好的模块即可，比如上面的打印日志的中间件，就可以使用现成的redux-logger模块： 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 使用的时候首先通过redux-logger提供的生成方法createLogger创建一个中间件实例logger，然后将它放在Redux提供的applyMiddleware方法中，放到createStore方法中（由于createStore方法可以接受应用的初始状态作为第二个参数，这个时候applyMiddleware方法就是第三个参数了） 有的中间件有次序要求，必须放在何时的位置才能正确输出，使用之前要查看文档。 applyMiddleware()applyMiddleware()是Redux的原生方法，会将所有中间件组成一个数组，依次执行，下面是它的源码： 12345678910111213141516export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; applyMiddleware可以接受多个中间件作为参数，全部放进了数组chain中，每个中间件接受Store的dispatch和getState函数作为命名参数，返回一个函数。该函数会被传入称为next的下一个中间件的dispatch方法，并返回一个接受Action的新函数，这个函数可以直接调用next(action)。这个过程是通过compose方法完成的。 多个中间件形成了一个调用链，调用链中的最后一个中间件会接受真实Store的dispatch作为next参数，并借此结束调用链。 12// 中间件函数的函数签名(&#123; getState, dispatch &#125;) =&gt; next =&gt; action compose()compose(...functions)的功能是从右到左来组合多个函数，这是函数式编程的方法，其中每个函数的返回值作为参数提供给左边的函数： 123compose(funcA, funcB, funcC); // 同等于funcA(funcB(funcC())) 关于compose方法，以前做过一道练习题《前端练习17 函数式编程的compose函数》，手写简易的compose方法。 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 异步操作的基本思路处理异步操作需要使用中间件。 同步操作只要发出一种Action即可，异步操作的差别是要发出三种Action 123- 操作发起时的Action- 操作成功时的Action- 操作失败时的Action 以向服务器取出数据为例，三种Action有两种不同的写法： 123456789// 写法一，名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', respose: &#123;&#125; &#125;// 写法二， 名称不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', respose: &#123;&#125; &#125; 除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态，例如： 123456const state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125; State中的属性isFetching表示是否正在抓取数据，didInvalidate表示是否正过期，lastUpdated表示上一次更新事件。 现在整个异步操作的思路就很清晰了： 121. 操作开始，发出一个Action，触发State更新为“正在操作”状态，View重新渲染2. 操作结束，再次发出一个Action，触发State更新为“操作结束”状态，View再次重新渲染 redux-thunk中间件异步操作至少要发出两个Action，用户操作触发第一个Action，这个和同步操作一样，标识着异步操作的开始，现在要做的是在异步操作结束时，自动发送第二个Action 奥妙就在Action Creator中，需要对其进行改造。我们有一个组件，点击按钮后会发出一个Ajax请求，将返回的结果填充在视图中，按钮的点击事件如下： 123456789101112131415161718192021sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = (answer) =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer &#125;); // Action Creator3 const actionCreator = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); return Request.demo2.getAnswer(&#123; question &#125;) .then(res =&gt; dispatch(receivePost(res))) &#125;; store.dispatch(actionCreator())&#125; 其中最关键的就是actionCreator，它的返回值是一个函数，这个函数执行时，会先发出一个ActionrequestPost（由Action Creator生成）并进行其他同步操作，然后进行异步操作Request.demo2.getAnswer({ question })，在异步操作的回调函数中发出第二个ActionactionCreator（由Action Creator2生成）。 上面的代码中，有几点要注意： （1）完成异步操作的Action CreatoractionCreator返回的是一个函数，普通的Action Creator返回的是Action对象 （2）返回的这个函数参数是dispatch和getState这两个Redux方法，普通的Action Creator参数是Action的内容。 （3）在返回的函数中，先发出的Actiondispatch(requestPost(question))表示操作开始 （4）异步操作结束后，在发出的Actiondispatch(receivePost(res))表示操作结束 第二点中，返回函数的两个Redux方法是执行时由函数的执行者传进去的，函数的执行者是谁呢？就是中间件redux-thunk 为什么要使用redux-thunk？因为Action是由store.dispatch发出的，这个方法接受的参数是一个对象，而我们的Action Creator返回的是一个函数，使用redux-thunk对store.dispatch进行改造，改造后在执行Action Creator返回的函数时就传入了dispatch和getState两个参数 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用thunk中间件，使dispatch可以接受函数作为参数（默认只能接受Action对象作为参数）import thunk from 'redux-thunk';// 创建Storeconst store = createStore(reducer, applyMiddleware(thunk));export default store; 因此，异步操作的第一种解决方案就是，==编写一个返回函数的Action Creator，然后使用redux-thunk中间件改造store.dispatch== redux-promise中间件在上面的Action Creator返回了一个函数，也可以返回其他值，另一种异步操作的解决方案，就是让Action Creator返回一个Promise对象 这需要使用redux-promise中间件 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用redux-promise中间件，使dispatch可以接受Promise作为参数import promiseMiddleware from 'redux-promise'// 创建Storeconst store = createStore(reducer, applyMiddleware(promiseMiddleware));export default store; 来看一下它的源码： 12345678910111213141516171819202122import isPromise from 'is-promise';import &#123; isFSA &#125; from 'flux-standard-action';export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 如果Action本身是一个Promise，它resolve后的值是一个Action对象，会被dispatch方法送出，reject后不会有任何动作，如果Action本身不是一个Promise对象，而Action对象的payload属性是一个Promise对象，那么无论其resolve或reject，dispatch都会发出Action 所以有两种写法，一种是让Action本身返回一个Promise对象： 12345678910111213141516171819202122sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = async () =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer: await Request.demo2.getAnswer(&#123; question &#125;) &#125;); store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); store.dispatch(receivePost());&#125; 更常见的是第二种写法，一般会配合redux-action中间件使用。 redux-action中createAction的用法： 12345678const a = createAction('test1', () =&gt; 10);a(); // &#123;type: "test1", payload: 10&#125;const b = createAction('test2');b(100); // &#123;type: "test2", payload: 100&#125; 使用redux-action将上面的写法改为： 1234567891011121314151617181920212223// 使用redux-promise中间件解决异步操作第二种写法sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123;type: 'SEND_QUESTION', status: 'sending...', question&#125;); // 发出同步Action store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); // 发出异步Action store.dispatch( createAction('RECEIVE_ANSWER')( // Promise的then函数返回值才是createAction的第二个参数 Request.demo2.getAnswer(&#123;question&#125;).then(v =&gt; (&#123; status: '', answer: v &#125;) ) ) );&#125; 注意，createAction的第二个参数实际上就是向要发送的Action的payload属性值，这里必须是一个Promise对象。（在reducer里面也必须从action.payload属性中获取对应的值） 明显，使用redux-promise的代码量更小一些，但是也因此失去了一定的灵活度，它的同步Action是脱离在异步操作之外单独存在的（即无法在一个Action Creator完成多个dispatch动作） 其他的比较热门的解决方案还有redux-promise-middleware（感觉像是前两者的一个集合）、redux-action-tools、redux-saga，可以学习这篇文章的讲解。 总结学习Redux的异步操作和中间件之后，最大的体会就是太繁琐了，各种解决方案太多了。如果是复杂的项目中，有着复杂的业务逻辑，使用Redux会是一个很麻烦的事情。 以前在做一个React项目时，项目组选型使用的Mobx，当时没觉得有好用（当然也有用的比较浅的原因），但是仅仅是学习Redux，就发现Mobx或者是Vuex真的比Redux好上手太多了，Redux的函数式编程的思想带来的难度不仅是阅读、学习的难度，更是过多的范式代码带来的苦恼。 我认为会经久流传的解决方案一定会在可阅读性、可维护性以及入手难度上取得一个比较好的平衡，除非它是为了解决一些别人无法解决的问题而提出的，是一个时间段内近乎唯一的解决方案，但我感觉Redux好像并不是这样。 参考 Redux 入门教程（二）：中间件与异步操作 compose@Redux中文文档 applyMiddleware@Redux中文文档 redux-tutorial-cn@github Redux异步方案选型@segmentfault]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习05 生成树形结构的方法]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A005%20%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由数组生成树形结构的方法。 问题接受了一个简单小任务，从后端获取一系列数据，以数组的形式存在，每一项都有着id和parentId，根据这两个属性，将这写数组重新组织成为一个树状菜单结构，传递给UI组件 这个问题有一点难度的事，后端传递的数据不是组织好的，是没有顺序的，就是说，有可能子项先出现，而父项后出现 1234567891011121314151617181920212223242526272829let originId = [ id: 2, name: 'b', parentId: 0&#125;, &#123; id: 4, name: 'a-2', parent_id: 1&#125;, &#123; id: 5, name: 'b-1', parentId: 2&#125;, &#123; id: 6, name: 'b-2', parentId: 2&#125;, &#123; id: 3, name: 'a-1', parentId: 1&#125;, &#123; id: 1, name: 'a', parentId: 0&#125;, &#123; id: 7, name: 'a-1-1', parentId: 3&#125;, ]; 所以在处理的时候，需要递归处理 递归实际上，直接用递归是可以实现的，但是我也是在网找了一阵子才发现这种方法，因为一来自己的算法实在是弱，也是因为着急的时候反而脑子更加不好用 1234567891011121314151617//递归方法 生成 json tree 数据const getJsonTree = function(data, parentIds) &#123; var itemArr = []; for (var i = 0; i &lt; data.length; i++) &#123; var node = data[i]; if (parentIds.includes(node.parentId)) &#123; var newNode = &#123;&#125;; newNode.id = node.id; newNode.name = node.name; newNode.children = getJsonTree(data, [node.id]); itemArr.push(newNode); &#125; &#125; return itemArr;&#125;;console.log(getJsonTree(originData, ['0', 'non'])) 这种方法能够实现，但是没有任何优化，对originData反复遍历查找，如果数据量很大的时候，恐怕性能上会出问题 利用JavaScript的引用类型这个纯属是学习了，首先对所有数据进行分组，也就是简历索引，将同一个parentId的数据都放到一个对象的同一个属性名对应的属性值中，也就是说生成这样的结构： 12345678const groupData = &#123; // parentId为'0'的数据都在这里 // 换句话说，id为'0'的所有子数据都在这里 '0': &#123; [1], [2] &#125;&#125; 这个还是比较好实现的，一个reduce搞定: 1234const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; return total;&#125;, &#123;&#125;); 现在，通过groupedData这个对象可以找到某个id对应的所有子数据，那么我就可以认为，对原始数据originData进行遍历，给数据增加一个chilren属性，把对应的groupedData的索引复制到这个children属性 我的脑子还是不太够用，说白了就是蠢，感觉绕在里面出不来，想了好一阵子才理清楚： 123456789101112131415161718const getJsonTree2 = function (data, id) &#123; // 按照parentId对所有数据分组 const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; return total; &#125;, &#123;&#125;); // 遍历原始数据， data.forEach(v =&gt; &#123; // 如果当前项的id存在于groupedData中，说明当前项就是groupedData对应的属性中所有元素的父元素 // 如果当前项的id不存在于groupedData中，说明当前项不是任何元素的父元素，就是个纯纯的子元素 // ID是不会重复的 if (groupedData[v.id]) &#123; v.children = groupedData[v.id] &#125; &#125;); return groupedData[id]&#125;; 最后取出的数据是从groupedData取出顶级元素，传入顶级元素的ID即可，因为这个需求比较特殊，顶级元素有两种ID，&#39;0&#39;或者&#39;non&#39;，所以需要额外处理一下： 123456return ids.reduce((total, current) =&gt; &#123; if (groupedData[current]) &#123; total = total.concat(groupedData[current]); &#125; return total;&#125;, []); 因为这个利用了JS的引用类型，所以不能采用下面的这种形式来改变最终的元素包含的属性： 123current = &#123; id: node.id&#125; 因为这会导致引用关系的丢失，所以如果需要改变最终树状元素的包含的属性有两种方法，一种是在分组获取groupedData时，采用下面这种形式直接修改元素属性： 123456789101112131415161718const dealObj = obj =&gt; &#123; obj.label = obj.chinese; delete obj.name; delete obj.chinese; delete obj.creator; delete obj.parentId; delete obj.status; delete obj.createTime; delete obj.updateTime;&#125;;// 按照parentId对所有数据分组const groupedData = data.reduce((total, current) =&gt; &#123; total[current['parentId']] ? total[current['parentId']].push(current) : total[current['parentId']] = [current]; // 处理元素包含的属性 dealObj(current); return total;&#125;, &#123;&#125;); 也可以在生成最终数据后统一处理，但是这样会增加时间复杂度： 1234567891011// 处理最终的数据const dealRes = res =&gt; &#123; res.forEach(v =&gt; &#123; dealObj(v); if(v.children &amp;&amp; v.children.length) &#123; dealRes(v.children) &#125; &#125;)&#125;;dealRes(result); 参考 JavaScript递归方法 生成 json tree 树形结构数据@腾讯云 更优更简洁的生成树和操作树算法@知乎 怎样效率高的生成树形结构的数据？@segmentfault]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习06 从数组中取出n个元素的所有组合]]></title>
    <url>%2F2019%2F03%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A006%20%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%96%E5%87%BAn%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[用递归实现从数组中取出n个元素的所有组合。 题目给定一个数组arr，从中选出n个元素，要求给出所有组合的情况（结果在一个数组中） 例子： 123456const arr = ['1', '2', '3'];const n = 2;const result = getCombine(arr, b);console.log(result);// ['12', '13', '23' ] 分析实际上就是一个求排列组合的问题。对上面的例子进行分析 （1）首先arr是[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],n是2，先取出数组中第一项1，然后需要从剩下的两个元素中取一个 （2）此时可以将arr看做[ &#39;2&#39;, &#39;3&#39;],n是1，在从中任取一项就行了 （3）此时结果为[&#39;12&#39;, &#39;13&#39;] （4）返回第一步，取出数组中第一项1改为取第二项2，然后从剩下的元素中取 （5）重复进行上面的步骤 很明显，分析后发现这是一个递归的过程，不过要注意的是需要控制取出第一个元素的序列，防止12和21作为两种情况出现。控制方法有两种，或者传入一个start作为开始的索引值，或者用slice来剪切数组，将数组已经取过的元素剪切掉 代码忽略了n大于数组长度的情况的处理。 123456789101112131415161718192021222324/** * 从数组中取出n个元素的所有排列组合 * @param arr 待处理数组 * @param n 要取出的元素个数 * @param result 返回的结果 * @param current 当前已经取出的元素 * @returns &#123;Array&#125; 返回数组，数组元素是各种排列组合的情况 */const getCombine = (arr, n, result = [], current = '') =&gt; &#123; // 如果只要取出一个元素，那么只需要将数组元素与已取出的元素一一组合即可 if (n === 1) &#123; result.push(...arr.map(v =&gt; `$&#123;current&#125;$&#123;v&#125;`)) ; return result; &#125; // 对当前数组进行遍历，剩余元素个数i等于要取出的元素个数时停止遍历 for (let i = 0; i &lt; arr.length - n + 1; i++) &#123; // 取出当前的元素与已取出的元素组合 const temp = `$&#123;current&#125;$&#123;arr[i]&#125;`; // 递归调用，数组剪切（相当于开始的索引前进），取出的个数减一 getCombine(arr.slice(i + 1), n - 1, result, temp); &#125; return result;&#125;; 参考 从数组中取出n个元素的所有组合（递归实现）@NULL]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高18 更换打包文件路径]]></title>
    <url>%2F2019%2F03%2F17%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E6%8F%90%E9%AB%9818%20%E6%9B%B4%E6%8D%A2%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一个由更改Vue打包后路径引发的一系列问题。 引入字体文件在Vue中，想要引入字体文件，需要，使用@font-face来引入本地的字体 12345h1 &#123; background: url('./assets/images/logo.png');&#125; 然后再App.vue中引入并使用 1234567891011&lt;style&gt; @font-face &#123; font-family: 'hello'; src: url('./assets/font/d.ttf'); font-weight: bold; font-style: italic; &#125; .hello-inner h1 &#123; font-family: hello; &#125;&lt;/style&gt; 这样就可以使用引入的字体了。 也可以单独建立一个CSS文件来统一管理引入的字体，然后通过import引入 123456&lt;style&gt; @import 'font.css'; .hello-inner h1 &#123; font-family: hello; &#125;&lt;/style&gt; url-loaderWebpack中的loader的目的是用来处理各种非JS之外的文件，可以使你在import或”加载”模块时预处理文件。 执行的顺序是从右至左，在Vue-cli2中，在webpack.base.conf.js中定义了一些基本的loader： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module: &#123; rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.pug$/, loader: 'pug', &#125;, &#123; test: /\.less$/, loader: "style-loader!css-loader!less-loader", &#125;, ]&#125;, 比较重要的是url-loader这个插件。我们在处理引入的各种资源文件时，Webpack最终会将各个模块打包成一个文件，因此我们样式中的URL路径是相对入口HTML页面的，而不是相对于原始CSS文件所在的路径的。这就会导致图片引入失败。这个问题可以使用file-loader解决。 url-loader中封装了file-loader，它不依赖于file-loader，它除了可以完成file-loader的作用，还可以将符合要求的图片进行编码生成DataURL，减少HTTP请求数目。url-loader选项中提供了limit参数，小于这个参数的文件才会转换为DataURL 路径明确一下关于路径的表示， 123./ 表示当前目录，相对地址../ 表示上层目录，绝对地址/ 表示根目录，绝对地址 __dirname表示当前文件在系统中的绝对路径，比如我在D:\projects\vue-cli-learning文件夹下新建了一个test.js文件： 1console.log(__dirname) 在Node环境下运行这个文件输出结果就是： 1D:\projects\vue-cli-learning path.resolve的目的是用来将相对路径转为绝对路径，接受多册参数，一次表示要进入的路径，直到最后一个参数为止。除了根目录，该方法的返回值都不带尾部的斜杠 12// 实例path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') 上面代码的实例，执行效果类似下面的命令。 12345$ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd 比如，在刚才的test.js中打印： 123const path = require('path');console.log(path.resolve(__dirname, 'a'));console.log(path.resolve(__dirname, '../a')); 输出的结果就是两个路径： 12D:\projects\vue-cli-learning\aD:\projects\a 打包路径的配置在处理字体文件的url-loader的配置选项中： 1name: utils.assetsPath('fonts/[name].[hash:7].[ext]') 规定了Webpack打包后生成的资源名称和路径，其中，utils.assetsPath规定了跨系统平台输出文件路径，并且和环境变量相关： 1234567exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125; 在生产环境下的config.build.assetsSubDirectory配置实在/config/index.js中： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ... 其他&#125; 其中， index是生成的index.html在本机的地址，现在的配置下，生成的index文件会位于D:\projects\vue-cli-learning\dist\中（由path.resolve转换而来） assetsRoot指明了构建后的资源的路径，Webpack会将所有打包后的资源（包括index.html在内都放到这个文件夹下 assetsSubDirectory是打包后的资源目录，除了index.html之外的所有模块都会放到这个文件夹中，当前配置后，所有的资源文件都会打包在D:\projects\vue-cli-learning\dist\static中 assetsPublicPath是static资源文件夹相对于HTTP服务器运行时的路径，比如我利用http模块构建了一个简单的静态服务器： 1npx http-server -a 127.0.0.1 -p 7070 这个时候服务器运行的URL是localhost:7070/ 当前目录的情况是这样： 如果我在App.vue中引入的字体文件路径是./assets/font/d.ttf)，在打包之后首先由对应的url-loader处理，生成的字体文件将位于/dist/static/fonts中，打包后静态服务器请求的字体地址是：http://127.0.0.1:7070/static/fonts/d.d30126a.ttf 明白这些选项都是干什么的后，就可以更改了 （1）更改打包后的文件路径，更改index选项assetsRoot选项，比如更改为： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/test/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/test/'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ... 其他&#125; 这时候打包后文件将是这样的结构： （2）更改打包后静态资源所在目录（同时对资源的请求也会更改，因为打包后内联的URL地址也由url-loader一并改变了 更改为： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static/hello/', assetsPublicPath: '/', // ... 其他&#125; 此时打包生成的目录： 发出的获取字体的网络请求的URL为http://127.0.0.1:7070/static/hello/fonts/d.d30126a.ttf （3） 更改HTTP服务器获取静态资源的路径 这个一直把我搞混了，在默认的配置情况下是去网站的根目录下去寻找assetsSubDirectory中规定的资源目录，比如http://127.0.0.1:7070/static/fonts/d.d30126a.ttf 但是如果资源不是在根目录下呢，比如需要通过http://127.0.0.1:7070/ok/static/fonts/d.d30126a.ttf来请求字体时，就需要改动assetsPublicPath了，此时的配置： 1234567891011build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist/'), assetsSubDirectory: 'static/', assetsPublicPath: '/ok/', // ... 其他&#125; 这个时候打包后的目录没有变化，但是请求字体的URL就变成了http://127.0.0.1:7070/ok/static/fonts/d.d30126a.ttf 如果要将assetsPublicPath改为./会发生什么呢？请求字体的URL发生了变化 这是因为./是相对地址，相对发出请求的文件所在的木而言的，这个请求是谁发出的呢？是打包后的CSS文件发出的 转换为绝对路径就是/static/css/，然后再这个目录下再去寻找资源目录，所以请求的URL是http://127.0.0.1:7070/static/css/static/fonts/d.d30126a.ttf，这肯定不是我们想要的 所以在更改assetsPublicPath时，尽量采用绝对地址，从服务器的根节点域名触发，定位资源文件，不容易发生错误。 总结回到初衷，本意只是简单的更改打包后的文件路径，想要打包在/dist/project中，只需要简单的更改index选项和assertsRoot即可 1234build: &#123; index: path.resolve(__dirname, '../dist/project/index.html'), assetsRoot: path.resolve(__dirname, '../dist/project/'),&#125; 这两项只会影响打包后在本地的路径，而assetsSubDirectory会影响请求和本地打包后路径，assetsPublicPath只会影响上线后发送请求的路径。 简单的一点改动，引出了一堆东西要学习。 参考 webpack学习笔记-2-file-loader和url-loader@CSDN Path模块@JavaScript标准参考教程 webpack再入门，说一下那些不入流的知识点@segmentfault webpack的3个路径配置项@博客园]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux02 异步操作和中间件]]></title>
    <url>%2F2019%2F03%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux02%20%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[学习Redux中间件的概念，以及使用Redux中间件完成异步操作的方法。 同步和异步流程先来复习一下Redux的基本流程： 12345671. 用户发出Action2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 在第1、2步之间有一个问题，之前考虑的情况都是在Action发出之后，Reducer立刻计算出State，这是一个同步的过程。如果在Action发出之后，过一段时间再执行Reducer，这是异步过程： 1234567891. 用户发出Action1.5 异步操作（等待一段时间）2. Store自动调用Reducer，计算返回一个新的State3. Store就会调用监听函数4. 监听函数listener中重新渲染View 现在我们希望的是在异步操作结束后，自动执行Reducer，这就要用到中间件（middleware） 中间件的概念什么是中间件？中间件（middleware）是一种很常见、也很强大的模式，被广泛应用在Express、Koa、Redux等类库和框架当中。 简单来说，中间件就是在调用目标函数之前，可以随意插入其他函数预先对数据进行处理、过滤，在这个过程里面你可以打印数据、或者停止往下执行中间件等。数据就像水流一样经过中间件的层层的处理、过滤，最终到达目标函数。 1234// 中间件可以把 A 发送数据到 B 的形式从// A -----&gt; B// 变成:// A ---&gt; middleware 1 ---&gt; middleware 2 ---&gt; middleware 3 --&gt; ... ---&gt; B 具体到Redux来看，如果要实现中间件，最合适环节就是在发送Action的环节，即使用中间件包裹store.dispatch来添加功能，比如要增加打印功能，将Action和State打印出来，我们就可以编写这样一个中间件： 1234567const next = store.dispatch;store.dispatch = function (action) &#123; console.log('action: ', action); next(action); console.log('next state: ', store.getState())&#125;; 中间件对store.dispatch进行了改造，在发出Action和执行Reducer之间添加了其他功能。但是实际上中间件的写法不是这样的。 在Redux中，中间件是纯函数，有明确的使用方法，并且要严格的遵循以下格式： 1234567var anyMiddleware = function (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; // 你的中间件业务相关代码 &#125; &#125;&#125; 中间件由三个嵌套的函数构成（会依次调用）： （1）第一层向其余两层提供分发函数dispatch和getState函数 （2）第二层提供next函数，它允许你显示的将处理过的输入传递给下一个中间件或Redux（这样Redux才能调用所有reducer）。实际上next作为参数，就是通过componse传入的下一个要执行的函数，通过next(action)就将action传递给了下一中间件 （3）第三层提供从上一个中间件或者从dispatch传递过来的Action，这个Action可以调用下一个中间件（让Action继续流动）或者以想要的方式处理action 所以一个Log的中间件应该这样写： 12345678function logMiddleware (&#123; dispatch, getState &#125;) &#123; return function(next) &#123; return function (action) &#123; console.log('logMiddleware action received:', action) return next(action) &#125; &#125;&#125; next(action)就是继续传递Action，如果不进行这一步，所有的Action都会被丢弃。 中间件的用法常用的中间件都有现成的，不用我们自行编写，只需要直接引用别人写好的模块即可，比如上面的打印日志的中间件，就可以使用现成的redux-logger模块： 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 使用的时候首先通过redux-logger提供的生成方法createLogger创建一个中间件实例logger，然后将它放在Redux提供的applyMiddleware方法中，放到createStore方法中（由于createStore方法可以接受应用的初始状态作为第二个参数，这个时候applyMiddleware方法就是第三个参数了） 有的中间件有次序要求，必须放在何时的位置才能正确输出，使用之前要查看文档。 applyMiddleware()applyMiddleware()是Redux的原生方法，会将所有中间件组成一个数组，依次执行，下面是它的源码： 12345678910111213141516export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; applyMiddleware可以接受多个中间件作为参数，全部放进了数组chain中，每个中间件接受Store的dispatch和getState函数作为命名参数，返回一个函数。该函数会被传入称为next的下一个中间件的dispatch方法，并返回一个接受Action的新函数，这个函数可以直接调用next(action)。这个过程是通过compose方法完成的。 多个中间件形成了一个调用链，调用链中的最后一个中间件会接受真实Store的dispatch作为next参数，并借此结束调用链。 12// 中间件函数的函数签名(&#123; getState, dispatch &#125;) =&gt; next =&gt; action compose()compose(...functions)的功能是从右到左来组合多个函数，这是函数式编程的方法，其中每个函数的返回值作为参数提供给左边的函数： 123compose(funcA, funcB, funcC); // 同等于funcA(funcB(funcC())) 关于compose方法，以前做过一道练习题《前端练习17 函数式编程的compose函数》，手写简易的compose方法。 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 异步操作的基本思路处理异步操作需要使用中间件。 同步操作只要发出一种Action即可，异步操作的差别是要发出三种Action 123- 操作发起时的Action- 操作成功时的Action- 操作失败时的Action 以向服务器取出数据为例，三种Action有两种不同的写法： 123456789// 写法一，名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', respose: &#123;&#125; &#125;// 写法二， 名称不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', respose: &#123;&#125; &#125; 除了Action种类不同，异步操作的State也要进行改造，反映不同的操作状态，例如： 123456const state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125; State中的属性isFetching表示是否正在抓取数据，didInvalidate表示是否正过期，lastUpdated表示上一次更新事件。 现在整个异步操作的思路就很清晰了： 121. 操作开始，发出一个Action，触发State更新为“正在操作”状态，View重新渲染2. 操作结束，再次发出一个Action，触发State更新为“操作结束”状态，View再次重新渲染 redux-thunk中间件异步操作至少要发出两个Action，用户操作触发第一个Action，这个和同步操作一样，标识着异步操作的开始，现在要做的是在异步操作结束时，自动发送第二个Action 奥妙就在Action Creator中，需要对其进行改造。我们有一个组件，点击按钮后会发出一个Ajax请求，将返回的结果填充在视图中，按钮的点击事件如下： 123456789101112131415161718192021sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = (answer) =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer &#125;); // Action Creator3 const actionCreator = () =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); return Request.demo2.getAnswer(&#123; question &#125;) .then(res =&gt; dispatch(receivePost(res))) &#125;; store.dispatch(actionCreator())&#125; 其中最关键的就是actionCreator，它的返回值是一个函数，这个函数执行时，会先发出一个ActionrequestPost（由Action Creator生成）并进行其他同步操作，然后进行异步操作Request.demo2.getAnswer({ question })，在异步操作的回调函数中发出第二个ActionactionCreator（由Action Creator2生成）。 上面的代码中，有几点要注意： （1）完成异步操作的Action CreatoractionCreator返回的是一个函数，普通的Action Creator返回的是Action对象 （2）返回的这个函数参数是dispatch和getState这两个Redux方法，普通的Action Creator参数是Action的内容。 （3）在返回的函数中，先发出的Actiondispatch(requestPost(question))表示操作开始 （4）异步操作结束后，在发出的Actiondispatch(receivePost(res))表示操作结束 第二点中，返回函数的两个Redux方法是执行时由函数的执行者传进去的，函数的执行者是谁呢？就是中间件redux-thunk 为什么要使用redux-thunk？因为Action是由store.dispatch发出的，这个方法接受的参数是一个对象，而我们的Action Creator返回的是一个函数，使用redux-thunk对store.dispatch进行改造，改造后在执行Action Creator返回的函数时就传入了dispatch和getState两个参数 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用thunk中间件，使dispatch可以接受函数作为参数（默认只能接受Action对象作为参数）import thunk from 'redux-thunk';// 创建Storeconst store = createStore(reducer, applyMiddleware(thunk));export default store; 因此，异步操作的第一种解决方案就是，==编写一个返回函数的Action Creator，然后使用redux-thunk中间件改造store.dispatch== redux-promise中间件在上面的Action Creator返回了一个函数，也可以返回其他值，另一种异步操作的解决方案，就是让Action Creator返回一个Promise对象 这需要使用redux-promise中间件 12345678910import &#123; createStore, applyMiddleware &#125; from "redux";import reducer from "./reducers/index";// 使用redux-promise中间件，使dispatch可以接受Promise作为参数import promiseMiddleware from 'redux-promise'// 创建Storeconst store = createStore(reducer, applyMiddleware(promiseMiddleware));export default store; 来看一下它的源码： 12345678910111213141516171819202122import isPromise from 'is-promise';import &#123; isFSA &#125; from 'flux-standard-action';export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 如果Action本身是一个Promise，它resolve后的值是一个Action对象，会被dispatch方法送出，reject后不会有任何动作，如果Action本身不是一个Promise对象，而Action对象的payload属性是一个Promise对象，那么无论其resolve或reject，dispatch都会发出Action 所以有两种写法，一种是让Action本身返回一个Promise对象： 12345678910111213141516171819202122sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123; type: 'SEND_QUESTION', status: 'sending...', question &#125;); // Action Creator2 const receivePost = async () =&gt; (&#123; type: 'RECEIVE_ANSWER', status: '', answer: await Request.demo2.getAnswer(&#123; question &#125;) &#125;); store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); store.dispatch(receivePost());&#125; 更常见的是第二种写法，一般会配合redux-action中间件使用。 redux-action中createAction的用法： 12345678const a = createAction('test1', () =&gt; 10);a(); // &#123;type: "test1", payload: 10&#125;const b = createAction('test2');b(100); // &#123;type: "test2", payload: 100&#125; 使用redux-action将上面的写法改为： 1234567891011121314151617181920212223// 使用redux-promise中间件解决异步操作第二种写法sendQuestion() &#123; const question = this.state.questionInput; // Action Creator1 const requestPost = (question) =&gt; (&#123;type: 'SEND_QUESTION', status: 'sending...', question&#125;); // 发出同步Action store.dispatch(requestPost(question)); // 重置输入框 this.setState(&#123; questionInput: '' &#125;); // 发出异步Action store.dispatch( createAction('RECEIVE_ANSWER')( // Promise的then函数返回值才是createAction的第二个参数 Request.demo2.getAnswer(&#123;question&#125;).then(v =&gt; (&#123; status: '', answer: v &#125;) ) ) );&#125; 注意，createAction的第二个参数实际上就是向要发送的Action的payload属性值，这里必须是一个Promise对象。（在reducer里面也必须从action.payload属性中获取对应的值） 明显，使用redux-promise的代码量更小一些，但是也因此失去了一定的灵活度，它的同步Action是脱离在异步操作之外单独存在的（即无法在一个Action Creator完成多个dispatch动作） 其他的比较热门的解决方案还有redux-promise-middleware（感觉像是前两者的一个集合）、redux-action-tools、redux-saga，可以学习这篇文章的讲解。 总结学习Redux的异步操作和中间件之后，最大的体会就是太繁琐了，各种解决方案太多了。如果是复杂的项目中，有着复杂的业务逻辑，使用Redux会是一个很麻烦的事情。 以前在做一个React项目时，项目组选型使用的Mobx，当时没觉得有好用（当然也有用的比较浅的原因），但是仅仅是学习Redux，就发现Mobx或者是Vuex真的比Redux好上手太多了，Redux的函数式编程的思想带来的难度不仅是阅读、学习的难度，更是过多的范式代码带来的苦恼。 我认为会经久流传的解决方案一定会在可阅读性、可维护性以及入手难度上取得一个比较好的平衡，除非它是为了解决一些别人无法解决的问题而提出的，是一个时间段内近乎唯一的解决方案，但我感觉Redux好像并不是这样。 参考 Redux 入门教程（二）：中间件与异步操作 compose@Redux中文文档 applyMiddleware@Redux中文文档 redux-tutorial-cn@github Redux异步方案选型@segmentfault]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>异步操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux01 入门]]></title>
    <url>%2F2019%2F03%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F06%20Redux%2FRedux01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redux入门学习。 Redux是一个可预测状态的JavaScript容器 是否需要使用ReduxRedux的出现是为了解决React的两个问题： 121. 代码结构2. 组件之间的通信 是否使用Redux，取决于React应用是否存在上面的问题需要解决，一般来说，如果UI层比较简单，没有很多的交互，那么Redux就不是必须的，但是如果你面临的是下面的某些场景，那么就有必要考虑使用Redux了： 123451. 用户的使用方式复杂2. 不同身份的用户有不同的使用方式（比如普通用户和管理员）3. 多个用户可以写作4. 与服务器大量交互，或者使用了Websocket5. view需要从多个来源获取数据 上面的情况才是Redux的适用场景：多交互、多数据源 从组件角度来看，如果组件有一下需求，可以考虑使用Redux： 12341. 某个组件的状态需要共享2. 某个状态需要在任何地方都能够拿到（全局状态）3. 一个组件需要改变全局状态4. 一个组件需要改变另一个组件的状态 Redux提供了一个统一的位置和机制来管理状态、组织代码结构，是Web架构的一种解决方案 设计思想Redux的设计思想： 121. Web应用是一个状态机，视图与状态是一一对应的2. 所有的状态保存在一个对象里面 这是flux单向数据流图： 1234567891011121314151617 _________ ____________ ___________ | | | | | | | Action |------------▶| Dispatcher |------------▶| callbacks | |_________| |____________| |___________| ▲ | | | | | _________ ____|_____ ____▼____| |◀----| Action | | || Web API | | Creators | | Store ||_________|----▶|__________| |_________| ▲ | | | ____|________ ____________ ____▼____ | User | | React | | Change | | interactions |◀--------| Views |◀-------------| events | |______________| |___________| |_________| 其中的每一个步骤和概念都是下面要介绍的一个部分，其实没有什么太多新的东西，更多是一种编程的范式和思想。 在flux的流程中，flux确保所有Action首先通过一个Dispatcher发送给Store，由Reducer计算后通知所有的监听器 概念首先创建一个React应用，然后安装Redux 1npm install redux --save StoreStore是保存数据的地方，可以把它看成一个容器。==整个应用应该只有一个Stroe==。 12import &#123; createStore &#125; from 'redux';const store = createStore(fn); Redux提供了createStore函数，来生成Stroe，这个函数接受另一个函数作为参数，这个函数就是下面要提到的reducer，返回新生成的Stroe对象。 往createStore传Reducer的过程就是给Redux绑定Action处理函数（也就是Reducer）的过程 StateStore对象包含所有数据，想要得到某一时刻（状态）下的数据，新需要对Store生成快照，生成的快照数据就是State 当前时刻的State，可以通过Store.getState获得： 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux中，一个State对应一个View，只要State相同，View就相同，反之亦然。 ActionState的变化就会导致View的变化，但用户接触不到State，用户通过View发出通知，告诉State要发生变化了，这个通知就是Action。 Action是一个对象，必须包含一个名为type的属性，用来标识Action的名称，其他属性可以自由设置，可以参考这个规范进行设置。 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125; 可以这样理解，Action描述当前发生的事情，它是唯一改变State的方法，将数据从View运送到Store。 Action CreatorView要发送多少种消息，就有多少种Action，如果都手写会很麻烦。可以定义一个函数来生成Action，这个函数就是Action Creator 12345678const ADD_TODO = '添加TODO';funciton addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Dispatch有了Action，还需要一种行为将Action由View传递到Store，这种行为就是dispatch，store.dispatch是View发出Action的唯一方法 123456789import &#123; createStore &#125; from 'redux';const store = createStore(fn);const action = &#123; type: '添加TODO', payload: 'Learn Redux'&#125;store.dispatch(action) store.dispatch接受一个Action对象作为参数，并将它发送给Store，结合上面的Action Creator，可以改写为 1store.dispatch(addTodo('Learn Redux')) ReducerStore收到Action后，需要对Action进行处理，返回一个新的State，这样View才会发生变化，这种State的计算过程就是Reducer Reducer是一个函数，它接受当前State和一个Action作为参数，返回一个新的State： 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; store.dispatch会自动触发Reducer的自动执行（因为在使用CreateStore时将Reducer作为参数传递给了Store） 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); ==Reducer函数最重要的特征是，它是一个纯函数==，也就是说只要是同样的输入，必定得到同样的输出。 纯函数必须遵守以下的约束： 123- 不得改写参数- 不得调用系统I/O的API- 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不同的结果 Reducer函数中不能改变State对象，必须返回一个==全新的对象==，参考下面的写法： 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 使用上面的ES7的对象展开进行拷贝时，只是浅拷贝，如果数据结构更复杂或者是嵌套的，那在处理State更新的时候可能要考虑一些不同的做法，可以考虑使用ImmutableJS，Redux对此是全无预设方式的，记住它只是一个状态的容器。 任何时候，与某个View对应的State总是一个不变的对象 这里有个常见模式：在Reducer里用switch来响应对应的Action ： 12345678910111213const reducer3 = function (state = &#123;&#125;, action) &#123; console.log('reducer_3 was called with state', state, 'and action', action) switch (action.type) &#123; case 'SAY_SOMETHING': return &#123; ...state, message: action.value &#125;; default: return state; &#125;&#125;; 用switch的时候， ==永远==不要忘记放个default来返回State，否则，你的Reducer可能会返回undefined（等于你的State就丢了） Subscribe现在，用户在View层，通过dispatch发出了一个Action到Stroe，触发了对应的Reducer返回了一个新的State，但是这个State和View之间还需要关联起来，才能让视图进行封信 通过store.subscribe可以设置监听函数，一旦State发生变化，设置的监听函数就会自动执行 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 所以需要吧View的更新函数（对于React就是组件的render方法或setState方法）放到listener，就可以实现View根据State对象的变化而自动更新渲染。 store.subscribe返回一个函数，调用这个函数可以解除监听 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); Store的实现Store设对象提供了三种基本方法： 123- store.getState()- store.dispatch()- store.subscribe() Store对象是由Redux提供的createStore方法创造的，这个方法除了接受一个Reducer作为第一个参数外，还接受第二个参数，表示State的初始状态，==这个状态会覆盖Reducer函数的默认参数== 下面是createStore的简单实现，利用了闭包的原理（也证明，如果声明两个Store对象，其中保存的State对象是相互独立的） 1234567891011121314151617181920212223242526const createStore = reducer =&gt; &#123; let state = reducer(undefined, &#123;&#125;); let listeners = []; const getState = () =&gt; state; const dispatch = action =&gt; &#123; reducer(state, action); listeners.forEach(fn =&gt; &#123; fn() &#125;) &#125;; const subscribe = listener =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners.filter(fn =&gt; fn !== listener) &#125; &#125;; return &#123; getState, dispatch, subscribe &#125;&#125;; Reducer的拆分Reducer函数负责生成State对象，但是由于整个应用只有一个State对象，包含所有数据，对于大型应用来说，这个State对象会很大 看这个例子： 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 三种Action分别改变State的三个属性： 123- ADD_CHAT：chatLog属性- CHANGE_STATUS：statusMessage属性- CHANGE_USERNAME：userName属性 三个属性之间没有联系，因此可以将Reducer函数拆分，不同的函数负责处理不同的属性（即部分state），然后再合并为一个大的Reducer即可 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 拆分后，每一个小的函数负责修改对应的属性，返回值都是完整的State对象 一开始我的理解有一点问题，以为返回一个对象，对象的内容是方法，根据传入的action.type的值来确定执行哪个方法。并不是这样，返回的对象的每一个内容都是State对象的一个属性，当一个Action发送到Stroe后，对象中的每一个子Reducer函数都会被执行一次，这样才能返回完整的State对象 这个时候，每个属性对应的子Reducer内部还是要根据action.type来判断具体逻辑的，否则会应用在所有属性上 这种拆分与React应用的结构相吻合，一个React根组件由很多子组件构成，子组件与Reducer完全可以对应。 Redux提供了combineReducers方法，用于Reducer的拆分，只要定义各个子Reducer函数，然后调用这个方法，将它们合成一个大的Reducer： 123456789mport &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default chatReducer; combineReducers产生一个整体的Reducer函数，根据State的key，分别执行子Reducer，并将返回的记过合并成为一个大的State对象 combineReducers的简单实现，注意返回的应该是一个函数（与常规的Reducer相同），给每个子Reducer传递的第一个参数不应该是整个State对象，而是对应的子对象State[key] 123456const combineReducer = reducers =&gt; (state = &#123;&#125;, action) =&gt; &#123; Object.keys(reducers).reduce((newState, key) =&gt; &#123; newState[key] = reducers[key](state[key], action); return newState &#125;, &#123;&#125;)&#125; 可以把所有子Reducer放在一个文件里面，然后统一引入 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 工作流程之前接触过Vuex，感觉里面一些概念是非常类似的，首先来看一下Redux的工作流程 1234567891011121314// 1. 用户发出Actionstore.dispatch(action)// 2. Store自动调用Reducer，并传入两个参数，当前State和收到的Action，返回一个新的Statelet newState = reducer(previousState, atcion)// 3. 如果返回的新的State发生了变化，Store就会调用监听函数store.subscribe(listener)// 4. 监听函数listener中可以通过getState获取最新的State，在这里可以触发重新渲染Viewfunction listener () &#123; const newState = store.getState(); component.setState(newState)&#125; 实例：计数器我将阮一峰老师的例子稍微改写了一下，只是形式上采用了Class组件的形式 首先在demo1.js组件中，引入Redux 1const store = createStore(reducer); reducer是从./reducers/index导出的一个经由combineReducers合成的Reducer（reducer2没什么用，只是为了练习而引入的） 123456789101112131415161718192021222324252627282930313233import &#123; combineReducers &#125; from 'redux'const reducer1 = (state = 0, action) =&gt; &#123; console.log('reducer1 was called with state', state, 'and action', action); switch (action.type) &#123; case 'INCREMENT': &#123; return +state + 1 &#125; case 'DECREMENT': &#123; return +state - 1 &#125; case 'CHANGE': &#123; return +action.payload &#125; default: &#123; return +state &#125; &#125;&#125;;const reducer2 = (state = &#123; test: 'go' &#125;, action) =&gt; &#123; if (action.type === 'INCREMENT') &#123; console.log('reducer2 was called with state', state, 'and action', action); &#125; return state&#125;;const reducer = combineReducers(&#123; val1: reducer1, val2: reducer2&#125;);export default reducer 在&lt;Demo1&gt;中，&lt;Count&gt;是一个函数式组件，只负责表现，具体的逻辑在&lt;Demo1&gt;中，通过store.getState来为this.state中的变量赋值，当用户点击按钮而使用dispatch(action)发出了Action，State变化，会触发监听函数变化，监听函数中再来调用setState来触发视图的更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Count = (&#123; value, onIncrement, onDecrement, onChange &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;button onClick=&#123; onIncrement &#125;&gt;+&lt;/button&gt; &lt;span&gt;Now, the count is &#123; value &#125;&lt;/span&gt; &lt;button onClick=&#123; onDecrement &#125;&gt;-&lt;/button&gt; &lt;input type=&quot;number&quot; onInput=&#123; onChange &#125; /&gt; &lt;/div&gt; )&#125;;export default class Demo1 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; val1: store.getState().val1, val2: store.getState().val2 &#125; &#125; render() &#123; const value = this.state.val1; const value2 = this.state.val2; const ACTIONS = &#123; INCREMENT: &apos;INCREMENT&apos;, DECREMENT: &apos;DECREMENT&apos;, CHANGE: &apos;CHANGE&apos; &#125;; store.subscribe(() =&gt; &#123; this.setState(&#123; val1: store.getState().val1 &#125;) &#125;); return ( &lt;Count value=&#123; value &#125; value2=&#123; value2 &#125; onIncrement=&#123; () =&gt; store.dispatch(&#123; type: ACTIONS.INCREMENT &#125;) &#125; onDecrement=&#123; () =&gt; store.dispatch(&#123; type: ACTIONS.DECREMENT &#125;) &#125; onChange=&#123; (e) =&gt; store.dispatch(&#123; type: ACTIONS.CHANGE, payload: e.target.value &#125;) &#125; /&gt; ) &#125;&#125;; 参考 Redux 入门教程（一）：基本用法@阮一峰的网络日志 redux-tutorial-cn@github]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>flux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高08 Create React App]]></title>
    <url>%2F2019%2F03%2F01%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9808%20Create%20React%20App%2F</url>
    <content type="text"><![CDATA[一个由Facebook官方出品的React脚手架工具，无需额外配置，迅速搭建React应用脚手架。 这里只对它进行简单的尝试和入门，如果需要进一步的学习，官网在这里，文档在这里，也可以参考这篇文章进行更高阶更深入的配置和学习。 使用Create React App开发React应用不必再安装Webpack或者Babel，它们已经被内置在脚手架中了 它提供的功能： 开箱即用的React支持 开发模式和生产模式的编译 开发模式的热更新 提供了单元测试测试的接口支持 其他配置工具的默认配置（亦可以个性化配置） 快速开始123npx create-react-app my-appcd my-appnpm start React应用会运行在http://localhost:3000/，开发完成后使用npm run build打包 安装安装需要Node的版本在8.10.0以上 12345678# 使用npxnpx create-react-app my-app# npm在5.1版本下不能使用npx# 需要使用npm，首先进行全局安装npm install -g create-react-app# 创建应用create-react-app my-app 运行1npm start 在http://localhost:3000以开发模式运行React应用，页面提供了热跟新功能，在控制台会显示错误和警告。 单元测试基本使用1npm test 使用Jest运行单元测试，默认情况下会运行从上次提交commit后有改动的文件的单元测试。 需要`react-scripts@0.3.0`及更高版本，老项目开启单元测试看这里。 Jest是基于Node的运行期，速度很快，并且动过jsdom提供了浏览器的全局变量，比如window，但Jest对于DOM的测试是不准确的，它的目的是对逻辑和组件进行单元测试，而非测试DOM 在运行时Jest会自动寻找以test.js/spec.js或者__tests__文件夹下以.js结尾的文件，==这些文件可以位于src目录下任意深度的文件夹内==。 建议将测试文件（或__test__文件夹）和北侧文件放在一起，有两个好处： 便于管理，一眼就能看到文件的单元测试文件 引入组件的时候更简洁, 例如import App from &#39;./App&#39; 命令行接口使用npm test时，Jest会以watch模式运行，每次更改文件都会重新运行测试文件 这个模式下的命令行接口提供了各种能力，可以一直开着这个窗口进行快速的重复测试 版本管理接口使用npm test默认情况下会运行从上次提交commit后有改动的文件的单元测试。可以在watch模式下按a来要求Jest执行全部的测试 如果当前的工程没有使用版本管理，那么Jest会默认运行全部的测试 测试组件关于Jest的使用，以前学习在Vue中使用Jest时总结过，Jest的基本用法是相同的，在测试组件时有所区别，Vue测试组件使用的将组件和Jest进行连接的工具是Vue-test-utils，而React则是Enzyme（更准确些，jest-enzyme更接近于Vue-test-utils，封装了很多方便的API） 内容比较多，这里不展开，文档在这里，慢慢单独学习。 构建生产文件1npm run build 打包出的文件是经过压缩的，文件名带有Hash值 个性化配置因为Create-React-App将Webpack、Babel、ESLit的配置隐藏起来，简化了用户的配置操作，可以快速开始开发。 但是这只适用于一些小型的、没有特殊需求的应用的开发，如果构建大型应用还需要对上面这些工具进行个性化的配置： 1npm run eject 运行后，Create-React-App会将上面工具的配置文件复制到项目中，以后对配置文件进行修改后，项目式中会采用项目中复制修改后的配置文件 要注意，这个操作是不可逆的。 CSS-Loader在新版本的Create React App中增加了对CSS Modules的支持，要求react-scripts版本高级2.0.0。 CSS文件的命名形式为[name].module.css，对应的类名会通过添加后缀的形式来实现局部作用域，类名的格式是[filename]\_[classname]\_\_[hash] 详情参考文档。 如果需要在老版本的Create React App中增加了对CSS Modules的支持，则首先需要先通过eject命令暴露配置文件，参考这篇文章。 ESLint由于Create React App将默认的构建配置封装了起来，而ESLint仅仅开启了最基本的规则，更重要的是默认情况下，ESLint仅仅会在IDE中对违反规则的情况进行提示，并不会在构建时在终端的输出进行终端和提示。 如果这种情况可以满足需要，而只需要开启更多的规则，那么就可以在根目录下新建一个文件.eslintrc.json，然后添加： 123&#123; "extends": "react-app"&#125; 但是如果要起到更强制性的提示作用（中断构建、终端提示），Create React App建议使用Prettier代替ESLint。如果要使用ESLint，那么就需要使用npm run eject，将配置文件吐出，按照AlloyTeam的提示进行配置即可，参考这篇笔记。 Ant Design按需引入安装antd： 1npm install antd -S 然后进行按需引入分为两种情况： （1）未eject出所有配置： 参考antd的文档， 安装react-app-rewired和customize-cra（CRA）。 1npm install react-app-rewired customize-cra -D 然后修改package.json文件的启动命令： 12345"scripts": &#123; "start": "react-app-rewired start", "build": "react-app-rewired build", "test": "react-app-rewired test",&#125; 然后安装babel-plugin-import 1npm install babel-plugin-import -D 然后在根目录下创建config-overrides.js，用来修改默认配置： 123456789const &#123; override, fixBabelImports &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: 'css', // true &#125;),); 然后按按照下面的格式按需引入模块： 1import &#123; Button &#125; from 'antd'; （2）已经eject出所有配置文件： 这个时候直接按照babel-plugin-import文档的说明配置即可。 安装babel-plugin-import： 1npm install babel-plugin-import -D 然后在package.json中找到babel选项，修改为： 1234567891011121314"babel": &#123; "presets": [ "react-app" ], "plugins": [ [ "import", &#123; "libraryName": "antd", "style": "css" &#125; ] ]&#125; 引入方式与上面相同： 1import &#123; Button &#125; from 'antd'; 配置Less首先安装less和less-loader： 1npm install less less-loader -D 然后同样分为是否eject配置两种情况： （1）未eject出所有配置，仍遵循上面的步骤，安装react-app-rewired和customize-cra,修改package.json中的启动脚本。 然后修改config-overrides.js文件： 12345678910111213const &#123; override, fixBabelImports, addLessLoader &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &#125;), addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123; '@primary-color': '#1DA57A' &#125;, &#125;),); 这里利用了less-loader的modifyVars来进行主题配置，变量和其他配置方式可以参考配置主题文档。 （2）已经eject出所有配置的情况，参考这篇文章： 在config目录下的webpack.config.js文件，找到// style files regexes注释位置，添加： 123// 添加 less 解析规则const lessRegex = /\.less$/;const lessModuleRegex = /\.module\.less$/; 然后找到rules属性，在其中添加less解析配置： 12345678910111213141516171819202122232425// Less 解析配置&#123; test: lessRegex, // exclude: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, 'less-loader' ), sideEffects: true,&#125;,&#123; test: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent &#125;, 'less-loader' ),&#125;, 要注意的是，新添加的less-loader必须在file-loader的前面才能生效，因为Webpack在解析Loader是从右至左进行的（从下到上），只有先经过file-loader对文件路径的处理，less文件才能够被正确引入。 配置Alias在Vue中习惯了使用@来代替一连串的..表示的相对地址，这个功能是webpack提供的，需要在webpack中进行配置 现在使用了React，也同样希望能够配置Alias来实现路径的更优雅的表示。如果已经eject处所有配置的情况下，直接在webpackd的配置文件下添加相关的代码即可： 12345678module.exports = &#123; //... resolve: &#123; alias: &#123; '@': path.resolve(__dirname, 'src/'), &#125; &#125;&#125;; 但是如果在未eject的情况下，同样需要借助上面使用的react-app-rewired实现，首先在根目录建立一个alias.js文件，在这个文件中编写Alias的配置代码：react-app-rewired 123456789const path = require('path');module.exports = &#123; resolve: &#123; alias: &#123; '@': path.join(__dirname, 'src'), &#125;, &#125;,&#125;; 然后在config-overrides.js文件中引入并进行配置： 123456const &#123; override, addWebpackAlias &#125; = require('customize-cra');const alias = require('./alias');module.exports = override( addWebpackAlias(alias.resolve.alias),); 重新编译后@就生效了。 这时有两个问题要解决 （1）IDE的点击跳转失效了 Webstorm是可以识别webpack的配置文件，对Alias进行相应的处理，但是这里并没有eject出Webpack的配置文件，但是我们的alias.js文件就是按照Webpack的配置模块的格式来编写的，所以可以将alias.js作为配置文件，传递给Webstorm，这样IDE的文件跳转就正常了 （2）ESLint的导入导出规则报错 这是因为ESLint不能识别我们的Alias，这需要安装eslint-import-resolver-webpack这个插件，让ESLint使用Webpack的解析规则。 首先安装 1yarn add eslint-import-resolver-webpack -D 然后在.eslintrc.js中添加如下的配置： 123456789module.exports = &#123; "settings": &#123; "import/resolver": &#123; "webpack": &#123; "config": "alias.js" &#125; &#125; &#125;,&#125; 同样使用alias.js来代替Webpack的配置文件，配置完之后ESLint也就能正常工作了。 配置webpack-bundle-analyzer首先需要安装： 1234# NPM npm install --save-dev webpack-bundle-analyzer# Yarn yarn add -D webpack-bundle-analyzer 在未eject的情况下，同样可以使用customize-cra来添加webpack-bundle-analyzer的配置，在cvonfig-overrides.js中，引入addBundleVisualizer，进行配置： 123456789const &#123; override, addBundleVisualizer &#125; = require('customize-cra');module.exports = override( // 添加 webpack-bundle-analyzer addBundleVisualizer(&#123; analyzerMode: 'static', reportFilename: 'report.html', &#125;, true),); addBundleVisualizer接受两个参数，第一个对象是webpack-bundle-analyzer的配置项，可以参考文档。第二个选项用来配置自动开启，设置为ture就不需要在每次build时传入--analyze来开启分析了 在已经eject了的情况下，在webpack.config.js做进行配置，将webpack-bundle-analyzer作为插件进行引入 1234567const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 环境变量环境变量在构建期间嵌入。 可以使用process.env.NODE_ENV来读取内置的环境变量，当运行npm start时，它等于development，当运行npm test时，它等于test，当运行npm run build时它等于production。不能手动覆盖NODE_ENV，这可以防止开发人员意外地将开发环境部署到生产环境中 除了process.env.NODE_ENV之外也可以使用自定义的环境变量，自定义的环境变量必须以REACT_APP_开头。 添加环境变量有两种方式： （1）在Shell中添加临时环境变量。 操作系统不同，在Shell中定义环境变量的方法也不相同: 12345# Windows (cmd.exe)set "REACT_APP_SECRET_CODE=abcdef" &amp;&amp; npm start# Linux, macOS (Bash)REACT_APP_SECRET_CODE=abcdef npm start 为了统一在不同的操作系统中的设置方法，可以使用cross-env这个库 安装： 1npm install cross-env --save-dev 使用时只需要在原来的脚本前面加上cross-env就可以了 1cross-env NODE_ENV=development nodemon ./index.js （2）在.env中添加开发环境变量 在项目根目录中创建名为.env的文件，在文件创建以REACT_APP_开头的自定义环境变量。除了NODE_ENV之外的任何其他变量都将被会略 ==实际上，NODE_ENV是不能被覆盖的，也就意味着在.env中定义NODE_ENV也是同样被忽略的，在默认配置条件下，脚手架中的NODE_ENV是无法更改的。== .env文件应该提交到git进行管理（除了.env&amp;.local之外） 除了.env之外，还可以使用特殊的.env文件 .env：默认。 .env.local：本地覆盖。除test之外的所有环境都加载此文件。 .env.development, .env.test, .env.production：设置特定环境。 .env.development.local, .env.test.local,.env.production.local：设置特定环境的本地覆盖。 如果使用一个新的自定义的.env文件，比如使用.env.stage的环境变量文件，需要在运行npm命令时使用env-cmd 安装： 1npm install env-cmd --save-dev 使用时直接将.env.stage的路径引入即可，在Package.json文件中： 12345&#123; "scripts": &#123; "test": "env-cmd ./.env.stage npm run build" &#125;&#125; 在命令行中： 1./node_modules/.bin/env-cmd ./.env.stage npm run build 这种情况下，process.env.NODE_ENV仍然是production，但加载的.env文件已经不再是.env.build，而是变为了env.stage 参考 Docs@Create React App 从React脚手架工具学习React项目的最佳实践（上）：前端基础配置@掘金 在create-react-app中使用@Ant Design ant-design/babel-plugin-import@github 在 Create React App 中启用 Sass 和 Less@掘进 eslint-import-resolver-webpack@npm 关于eslint-plugin-import无法识别webpack alias问题@JERMY’S BLOG aze3ma/react-app-rewire-aliases@github create-react-app 通过 react-app-rewired 添加 webpack 的 alias@OnlyLing Resolve@Webpack env-cmd@npm webpack-contrib/webpack-bundle-analyzer@github]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>脚手架</tag>
        <tag>Create React App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS60 ES10的新特性简介]]></title>
    <url>%2F2019%2F02%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS60%20ES10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[ES10/ES2019还只是一个草案，但是大多数功能在新版本的Chrome中已经实现了。 虽然ES6还没有掌握全，但是还是要紧跟时代，了解一下JavaScript的发展趋势吧 BigIntBigInt是第七种原始类型，用来标识超出JavaScript最大安全整数之外的数字 在之前，JavaScript的数字是使用的是双精度浮点数数据类型，可以表示的最大安全整数是2^53-1，也就是9007199254740991，可以使用Number.MAX_SAFE_INTEGER来表示，如果超出这个范围指挥所未定为Number.MAX_SAFE_INTEGER + 1 现在使用BigInt就可以表示这个范围之外的整数值，有两种方式创建： 123456let a = 10n;let b = BigInt(10n);let c = BigInt(10);typeof a; // "bigint"a === b; // true String.prototype.matchAll()使用这个方法对字符串进行匹配时，不必再为正则表达式添加g，直接进行全局查找，返回一个迭代器对象（可以使用for...of遍历） 但是目前Chrome(70.0.3538.77)的实现好像有一些问题，实现的效果与match是相同的，只是返回的不是一个数组，而是一个迭代器对象 1234567891011let a = 'a1a2';let b = a.matchAll(/a./);for(let match of b) &#123; console.log(match)&#125;// 实际结果// ["a1", index: 0, input: "a1a2", groups: undefined]// 预期结果["a1", index: 0, input: "a1a2", groups: undefined]["a2", index: 2, input: "a1a2", groups: undefined] 动态导入现在的import是静态加载，不能将import放在条件语句中，这就导致无法在运行时家在模块（Node的require是运行时加载模块） 现在的提案中使用import()方法完成动态加载，返回一个Promise对象，是一个异步加载的方法 1234btn.addEventListener('click', async () =&gt; &#123; const module = await import('./api/button-click.js'); module.clickEvent()&#125;) Array.prototype.flat(depth)对数组扁平化，可以传入参数指定递归的深度，默认深度为1 1234567let a = [[1], [2, [3]]]let b = a.flat()// [1, 2, Array(1)]let c = b.flat()// [1, 2, 3] 细节参考MDN Array.prototype.flatMap(callback)对数组每个元素使用映射函数callback进行处理，然后将结果扁平化为一个新数组，扁平化的效果与深度为1的flat方法相同。 1234567891011var arr1 = [1, 2, 3, 4];arr1.map(x =&gt; [x * 2]); // [[2], [4], [6], [8]]arr1.flatMap(x =&gt; [x * 2]);// [2, 4, 6, 8]// 只会将 flatMap 中的函数返回的数组 “压平” 一层arr1.flatMap(x =&gt; [[x * 2]]);// [[2], [4], [6], [8]] 细节参考MDN Object.fromEntries(iterable)将键值对列表iterable转换为一个对象，这个iterable列表需要是一个可迭代对象，返回一个新对象 实际上就是Object.entries()的逆向操作： 12345678910let obj = &#123; apple : 10, orange : 20, banana : 30 &#125;;let entries = Object.entries(obj);// [Array(2), Array(2), Array(2)]// 0: (2) ["apple", 10] // 1: (2) ["orange", 20] // 2: (2) ["banana", 30] let fromEntries = Object.fromEntries(entries);// &#123; apple: 10, orange: 20, banana: 30 &#125; 目前最新版本的Chorme浏览器还不支持（只有Firefox支持） 细节参考MDN String.prototype.trimStart()和String.prototype.trimEnd()`别名是String.prototype.trimLeft()和String.prototype.trimRight()`，分别删除开头/结尾的空格 1234567891011let str = ' hello 'str.trimStart()// "hello "str.trimLeft()// "hello "str.trimEnd()// " hello"str.trimRight()// " hello" 细节参考MDN globalThis对象在JavaScript中，不同的宿主环境提供了不同的全局对象，在Web中是window或者self，在Node中是global。 新的提案中规定的globalThis对象可以无视环境，直接获取当前的全局对象 123// 浏览器中globalThis// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window,…&#125; 提案详情在这里。 Symbol.prototype.description一个只读属性，用来返回声明Symbol对象时的描述符 12const symbol = Symbol('hello');// symbol.description; Hashbang语法制定了一个解释器，统一了JavaScript在服务器端的执行方式 1234$ ./index.js# 代替$ node index.js 这块我不太理解，我认为如果标准化之后，是不是以为着在服务器端执行时不再显示的需要Node环境，而是默认可以在系统中执行JS文件了？ 其他还有一些内部实现的优化和改进，比如JSON.stringify对特殊字符的处理、sort方法的稳定性等 还有实现#私有成员的提案，看原文吧。 参考 The Complete Guide to ES10 Features@freecodecamp ES10 特性的完整指南@segmentfault Number.MAX_SAFE_INTEGER@MDN Array.prototype.flat()@MDN Array.prototype.flatMap()@MDN Object.fromEntries()@MDN String.prototype.trimLeft()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES10</tag>
        <tag>ES2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎live10 如何修车养车才更省钱]]></title>
    <url>%2F2019%2F02%2F26%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F02%20%E7%9F%A5%E4%B9%8ELive%2F%E7%9F%A5%E4%B9%8Elive10%20%E5%A6%82%E4%BD%95%E4%BF%AE%E8%BD%A6%E5%85%BB%E8%BD%A6%E6%89%8D%E6%9B%B4%E7%9C%81%E9%92%B1%2F</url>
    <content type="text"><![CDATA[知乎Live的笔记，Live地址戳这里。 题目修车费的组成1修车费 = 材料费 + 工时费 材料费一级一级家家 工时由有工时单价乘以工时数而来 如何挑选一家性价比高的维修店看场面，才成本场面越大，非核心诉求成本越高 应该挑选地段偏僻、装修简单的维修点，成本低，运营成本压力小，水分少 把有钱人当傻子的喷漆厂 看热闹，猜口碑要判断修理厂的能力和口碑，根据运行特征来判断，口碑很好的修理厂肯定门庭若市 （1）维修车辆多不多 （2）维修车辆流转快不快 （3）技师忙不忙 （4）维修区的整洁程度 好的修理师： （1）聪明 （2）不善社交、甚至不善言辞 （3）问不倒 （4）工作习惯非常好，工作服干净 如何省钱 - 物料篇零件的分类（1）原厂件：质量最好，最贵 （2）OEM品牌件：例如博世、采埃孚、法雷欧、马勒等，给主机厂提供配件，但是没有主机厂的授权，这一点导致价格与原厂家有很大的差异。 （3）自主品牌件：一般有六个月质保，质量上、性能上也会有一定保证，但是价格上非常优惠 （4）副厂件（假冒、杂牌、无牌）：质量、性能没有保证，安装都有问题，不是车特老、人特穷不要用 （5）拆车件 （6）下线件 省钱Tips（1）淘宝：不靠谱 （2）奔驰、宝马、路虎等可用自主品牌配件，质量不比原厂差 （3）缸体相关的配件、密封件、内饰件、小部分外观件、电子电器、模块传感器，这些基本上都是只有原厂件的。如果上述的范畴内，某车型能找到OEM件，甚至还有自主品牌件，那就说明这里有通病。有需求才有供给。 （4）油水当中，除了部分变速箱油外，都可以用OEM件 辅料的钱可以省辅料（密封胶、发动机清洗剂、螺栓、卡扣、油水、冷媒）能凑合就凑合，用好东西上不了天。 大品牌三五十的和几百的效果没差别。 如何省钱 - 工时费篇哪些是可以同时做掉的项目？如果在修车的时候，可以打包更换一些东西，同时免去工时费，那么可以一起做 因为有一些东西（比如刹车片）接近更换日期可以同时换。 前提是工时费可以省下来。 可以省钱的诊断法则少走冤枉路：由小到大，由易到难： 先从便宜的零件开始诊断 先从简单、常见的故障点入手 哪些工时费可以砍价？有一些必要的工时费是应该包含在当前操作内的，比如拆油底壳必然会进行四轮定位，所以要求四轮定位工时费有一定优惠 零件毛利率30%，工时费毛利率100%，据此砍价 如何省钱-方案篇保养知识 机油：5000-8000km，一般不推荐超过1万km。（金美孚） 空滤：同机油，用的多的可以2倍于机油。不过关键还是要看脏污程度。（曼牌、马勒） 空调滤：根据经验，每年至少一次。不过关键还是要看脏污程度。 蓄电池：内阻6毫欧，一般2~3年挂掉。 制动液：实际考察的是沸点，但是沸点仪太贵了。我们就用含水量测试笔，一般超过3%就更换。根据经验，也是2~3年左右挂掉。 冷却液：2年左右更换一次，哪怕冰点合适，也不宜太长时间不换，会有水垢生锈。 变速箱油：不存在不需要更换的变速箱油。一般按6-8w公里为标准。我们的自营车标准会更严格一些。 刹车片：普通人6w km一次，牛人是不到6w就换了。 刹车盘：严格按照原厂标准，一般是同刹车片。但我们可以延后，2片换1盘。 火花塞：镍金2-3w，铂金8w左右，铱金10w以上。关键是看点火间隙。 皮带轮系：6-8w km更换一次，会有明显的异响。 燃油滤：3w公里左右，内置是6w公里。 动平衡、四轮定位：2-3万来一次，或者有抖动、跑偏或偏磨时再来。 4S店最爱项目：积碳清洗、喷油嘴清洁……：不出问题就不要做。 常用诊断技巧缺岗：火花塞老化 发动机高频抖动：发动机悬置机构老化，问题不大 发动机怠速抖动：发动机指针上下波动，进气系统出现问题，清洗节气门 哪些故障不用烦 底盘故障不用烦。 漏机油、渗机油不用烦。 空调、抖动、异响，根据自己耐受程度决定。 烧机油，如果不超过1000km/L，也都不用着急。 哪些故障必须修 漏冷却液必须修——高温故障必须立刻修； 机油缺了，必须立刻处理——加一点儿就行； 电路故障看情况，如果和动力相关，需要立刻修； 缺缸建议尽快修，尤其是一些老车：驰鹏的故事； 刹车系统故障，尽快修；]]></content>
      <categories>
        <category>知乎Live</category>
      </categories>
      <tags>
        <tag>笔记总结</tag>
        <tag>汽车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习54 实现strStr()]]></title>
    <url>%2F2019%2F02%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A054%20%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目 题目来自LeetCode 实现strStr()函数。 给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1。 例1: 12输入: haystack = "hello", needle = "ll"输出: 2 示例 2: 12输入: haystack = "aaaaa", needle = "bba"输出: -1 当needle是空字符串时我们应当返回0。这与C语言的strstr()以及Java的indexOf()定义相符。 实现其实就是实现JavaScript中的indexOf函数，对于空字符串indexOf返回的也是0 所以有些答案直接把indexOf方法摆在那里，就是在让人无语了，你来LeetCode的目的是什么呢？刷成绩吗，还是真心想要提高你的算法和逻辑思维的能力呢？ 我一开始想对haystack进行一次遍历，声明一个指针来标识内部的needle的遍历的位置，结果发现没有想象的简单 还是应该老老实实用两次遍历来实现，我一开始额外声明了变量来标识循环是否完成： 12345678910111213141516171819202122232425/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function (haystack, needle) &#123; if (needle === '') &#123; return 0; &#125; let end = true; for (let i = 0; i &lt; haystack.length; i++) &#123; let count = i; end = true; for (let j = 0; j &lt; needle.length; j++) &#123; if (haystack[count++] !== needle[j]) &#123; end = false; break; &#125; &#125; if (end) &#123; return i; &#125; &#125; return -1;&#125;; 执行用时竟然达到了骇人听闻的4912ms。 看了排名在前的答案，进行了优化，优化后执行用时只有100ms： 12345678910111213141516var strStr = function (haystack, needle) &#123; if (needle === '') &#123; return 0; &#125; for (let i = 0; i &lt;= haystack.length - needle.length; i++) &#123; for (let j = 0; j &lt; needle.length; j++) &#123; if (haystack[i + j] !== needle[j]) &#123; break; &#125; if (j === needle.length - 1) &#123; return i; &#125; &#125; &#125; return -1;&#125;; 看一下优化的点： 首先就是额外的两个变量根本没有必要，只需要在内层循环判断循环是否是最后一个字符串了即可，没有必要声明flag，而count的话，直接使用i+j代替就行 其次是外层循环没有必要完全循环，如果剩下的长度已经小于needle的长度，那么就没有必要再循环了，因为已经不能再产生结果了。 所以，还是智商的差距。 努力吧。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础19 Vue2.6更新]]></title>
    <url>%2F2019%2F02%2F21%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E5%9F%BA%E7%A1%8019%20Vue2.6%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[2019.2月，大年三十，Vue在时隔一段时间后发布了新的版本Vue2.6，版本号是Macross（超时空要塞） 真是，不让人过好年啊。学不动了。 吐槽归吐槽，该学还是得学习。相对来说Vue的文档和教程是最平易近人、最易理解的了，而且尤雨溪还亲自发表文章介绍了Vue2.6的更新情况，更没有不跟进的理由了。 Slots：新语法，性能优化，准备接轨3.0语法最重要的更新之一就是对Slots的语法的更新，Slots对于Vue的组件解耦和分发复用有很重要的意义。旧的语法在2.x版本将获得支持，但是在3.0版本后将被废弃。 这次更新引入了v-slot来代替原来的slot和slot-scope语法 有这样一个组件Comp： 1234567891011121314151617181920&lt;template&gt; &lt;div class="slot-inner"&gt; &lt;slot&gt;默认Slot&lt;/slot&gt; &lt;slot name="slot1"&gt;具名Slot&lt;/slot&gt; &lt;slot name="slot2" :innerUser="user"&gt;Hello &#123;&#123;user.firstName&#125;&#125;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; user: &#123; firstName: 'jay', lastName: 'chow' &#125;, &#125; &#125;&#125;&lt;/script&gt; 原来的语法： 1234567891011121314151617181920212223242526&lt;Comp&gt; &lt;!-- 默认插槽 --&gt; &lt;p&gt;向默认Slot插入的内容&lt;/p&gt; &lt;!-- 具名插槽 --&gt; &lt;p slot="slot1"&gt;向具名Slot插入的内容&lt;/p&gt; &lt;!-- 作用域插槽 --&gt; &lt;p slot="slot2" slot-scope="&#123;innerUser&#125;"&gt;Hi, &#123;&#123;innerUser.lastName&#125;&#125;&lt;/p&gt;&lt;/Comp&gt;&lt;!--默认插槽--&gt;&lt;foo&gt; &lt;div slot-scope="&#123; msg &#125;"&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/foo&gt;&lt;!--命名插槽--&gt;&lt;foo&gt; &lt;template slot="one" slot-scope="&#123; msg &#125;"&gt; text slot: &#123;&#123; msg &#125;&#125; &lt;/template&gt; &lt;div slot="two" slot-scope="&#123; msg &#125;"&gt; element slot: &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/foo&gt; 更新后的语法： 123456789101112131415161718192021222324252627&lt;Comp&gt; &lt;!-- 默认插槽 --&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;!-- 具名插槽 --&gt; &lt;template v-slot:slot1&gt;&lt;p&gt;向具名Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;!-- 作用域插槽 --&gt; &lt;template v-slot:slot2="&#123;innerUser&#125;"&gt;&lt;p&gt;Hi, &#123;&#123;innerUser.lastName&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt;&lt;!--默认插槽--&gt;&lt;foo v-slot="&#123; msg &#125;"&gt; &#123;&#123; msg &#125;&#125;&lt;/foo&gt;&lt;!--命名插槽--&gt;&lt;foo&gt; &lt;template v-slot:one="&#123; msg &#125;"&gt; text slot: &#123;&#123; msg &#125;&#125; &lt;/template&gt; &lt;template v-slot:two="&#123; msg &#125;"&gt; &lt;div&gt; element slot: &#123;&#123; msg &#125;&#125; &lt;/div&gt; &lt;/template&gt;&lt;/foo&gt; 要注意，v-slot只能用在&lt;template&gt;元素上，除了一种情况，那就是独占插槽的情况。 当被提供的内容只有默认插槽时，组件的标签才可以被当做插槽的模板来使用。 123&lt;Comp v-slot:slot1&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 也可用于作用域插槽：123&lt;Comp v-slot="&#123; msg &#125;"&gt; &lt;template&gt;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 注意，独占插槽下不能出现具名插槽，会导致作用域不明确 12345&lt;!-- 无效，会导致警告 --&gt;&lt;Comp v-slot:slot1&gt; &lt;template&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt; &lt;template v-slot:slot2&gt;&lt;p&gt;向默认Slot插入的内容&lt;/p&gt;&lt;/template&gt;&lt;/Comp&gt; 只要出现多个插槽，应该始终为所有的插槽使用完整的基于&lt;template&gt;语法 为什么使用新指令而不修改旧语法的语义？尤雨溪给出了三点原因： 会导致断裂性的变化，这个特性就不能在2.x版本发布了 即使在3.x版本中修改了slot-scope的语义，但是对于大量的学习者而言会在网络上搜索到大量的基于旧的语义的资料，让人困惑，而引入新的区别于slot-scope的新指令就可以避免这个问题。 在3.x版本后不同类型Slot的概念将会统一，所以也就没有必要去区分普通插槽和作用域插槽。插槽无论是否接受参数都是插槽。在统一插槽的概念后，在用slot和slot-scope代表两种特性就没必要了。 新语法嵌套更清晰原有的语法在多个组件嵌套时会有一个问题，就是不能清晰的判断变量分别是由哪个组件提供的： 123456789&lt;foo&gt; &lt;bar slot-scope="foo"&gt; &lt;baz slot-scope="bar"&gt; &lt;div slot-scope="baz"&gt; &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125; &lt;/div&gt; &lt;/baz&gt; &lt;/bar&gt;&lt;/foo&gt; 而且，有&lt;foor&gt;提供的foo却声明在了&lt;bar&gt;上，而是用了新的语法后： 1234567&lt;foo v-slot="foo"&gt; &lt;bar v-slot="bar"&gt; &lt;baz v-slot="baz"&gt; &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125; &lt;/baz&gt; &lt;/bar&gt;&lt;/foo&gt; 这是，作用域变量的提供者和声明者是同一个组件，新的语法能够清晰的显示多个作用域变量的关系及其提供者。 性能优化普通的slot是在父组件的渲染函数中生成的，因为此当一个普通的slot依赖的数据变化时，会首先触发父组件的更新，然后新的slot内容被传到子组件，触发子组件更新。 而scoped slot在编译时生成的一个函数，这个函数背传入子组件后会在子组件的渲染函数中被低啊用。这意味着scoped slot的依赖会被子组件手机，那么当依赖变动时就只会触发子组件的更新了。 在2.6中还引入了一个优化，如果子组件只是用了scoped slot，那么父组件自身依赖变动时，不会再强制子组件更新。这个优化是的父子组件之间的依赖意识在存在slot的情况下依然完全解耦。 此外，所有使用新的v-slot的语法的slot都会编译为scoped slot，这以为这所有使用新语法的slot代码都会获得上述的性能优化。 所有的非scoped slot现在也被以函数的形式暴露在this.$scopedSlots上。如果是直接用render函数的用户，现在可以完全抛弃this.$slots而全部使用this.$scopedSlots来处理所有的slot了 总结这次更新不仅用新的语法v-slot同一了普通的slot和scoped slot的语法，并且针对新的语法在编译性能上进行了优化提升。 虽然在3.0中才会废弃旧的语法，不再有普通的slot和scoped slot的区分，并且3.0中this.$slots将会直接暴露函数，取代 this.$scopedSlots，但是我认为从2.6起，就应该在项目中使用新的语法代替旧的语法，不仅能更好地迎接3.0的到来，还会获得性能上的提升。 异步错误处理Vue 的内置错误处理机制（组件中的errorCaptured钩子和全局的errorHandler配置项）现在也会处理v-on侦听函数中抛出的错误了。 另外，如果组件的生命周期钩子或者侦听函数中有异步操作现在也可以捕获了，只需要返回一个Promise，来让Vue处理可能存在的异步错误。 例如，在子组件中的button点击事件： 12345click() &#123; return new Promise(resolve =&gt; &#123; throw Error('click') &#125;)&#125; 父组件中的errorCaptured钩子函数和全局的errorHandler配置项中就可以捕获到这个错误： 123456789// 父组件errorCaptured(e, vm, msg) &#123; console.log(msg, 999);&#125;// 全局错误处理Vue.config.errorHandler = function(err, vm ,info) &#123; console.log(info, 'config')&#125;; 如果使用了async/await就更加简单，因为async函数默认返回Promise： 1234567export default &#123; async mounted() &#123; // 这里抛出的异步错误会被 errorCaptured 或是 // Vue.config.errorHandler 钩子捕获到 this.posts = await api.getPosts() &#125;&#125; 动态指令参数指令的参数现在可以接受动态的JavaScript表达式： 1234567891011&lt;div v-bind:[attr]="value"&gt;&lt;/div&gt;&lt;div :[attr]="value"&gt;&lt;/div&gt;&lt;button v-on:[event]="handler"&gt;&lt;/button&gt;&lt;button @[event]="handler"&gt;&lt;/button&gt;&lt;my-component&gt; &lt;template v-slot:[slotName]&gt; Dynamic slot name &lt;/template&gt;&lt;/my-component&gt; 通过这种语法，当表达式的值为null时，绑定/侦听器会被移除： 123456789101112131415161718&lt;button @[event]="click"&gt;click&lt;/button&gt;&lt;script&gt;export default &#123; name: 'demo30', data() &#123; return &#123; event: 'click' &#125; &#125;, methods: &#123; async click() &#123; console.log(123); this.event = null; &#125; &#125;&#125;&lt;/script&gt; 编译警告位置信息2.6开始，所有的编译器都包含了源码的位置信息： https://cn.vuejs.org/v2/guide/components-slots.html https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md 显示地创建响应式对象2.6引入了一个新的全局API，可以用来显示地创建响应式对象： 123const reactiveState = Vue.observable(&#123; count: 0&#125;) Vue内部就是使用这个方法来处理data函数返回的对象 返回的对象可以直接用于==渲染函数==和==计算属性==内，并且在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景： 123456789const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h('button', &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; 用在计算属性内： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class="slot-inner"&gt; &lt;button @click="click"&gt;click &#123;&#123;count&#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue';let count = &#123; count: 0 &#125;;const state = Vue.observable(count);export default &#123; methods: &#123; click() &#123; state.count++ &#125; &#125;, computed: &#123; count() &#123; return state.count &#125; &#125;&#125; 在Vue2.x中，被传入的对象会直接被Vue.observable改变，它和被返回的对象是同一个对象。在Vue3.x中，由于用Proxy代替了Object.defineProperty，所以会返回一个可响应的代理，而对原对象直接进行修改仍然是不可响应的。 因此为了向前兼容，推荐式中操作使用Vue.observable返回的对象，而不是传入源对象： 1234567click() &#123; // 推荐的做法 state.count++; // 虽然目前有效，但在Vue3.x中无效，所以不推荐 // count.count++;&#125; 重要的内部改动nextTick重新调整为全部使用Microtask在2.5中引入了一个改动，当一个v-on的DOM时间侦听器触发更新时，会使用Macrotask而不是Microtask类进行移步缓冲（具体的检测降级方案是setImmediate→MessageChannel→setTimeout）。 这原本是为了修正一类浏览器的特殊边际情况导致的bug才引入的（这种bug就是Edge浏览器处理Microtask的优先级比冒泡的优先级更高，会导致使用了Microtask的事件处理程序在冒泡之间就被触发），更多的细节看这里。 但这个改动本身却导致了更多其他的问题。在2.6里面对原本的边际情况找到了更简单的fix。 其他的改动（1）this.$scopedSlots函数统一返回数组，只影响render函数用户 （2）SSR数据预抓取，新增serverPrefetch钩子使得任意组件都可以在服务端渲染时请求异步的数据（不再限制于路由组件） （3）可直接在浏览器中引入的ES Modules构建文件，2.6包含了一个可以直接在浏览器导入的版本： 1234567&lt;script type="module"&gt;import Vue from 'https://unpkg.com/vue/dist/vue.esm.browser.js' new Vue(&#123; // ...&#125;)&lt;/script&gt; 参考 Vue 2.6 发布了@知乎 reverting-to-microtast@github 插槽@Vue]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>slot</tag>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习52 字符串中的第一个唯一字符]]></title>
    <url>%2F2019%2F02%2F20%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A052%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目 题目来自LeetCode 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1。 12345s = "leetcode"// 返回 0.s = "loveleetcode",// 返回 2. 注意事项：您可以假定该字符串只包含小写字母。 实现1首先想到的是用空间来换取时间，第一个循环用一个临时的数组来将所有的字符串都寸到对象中，并随时更改出现的次数，第二个循环在判断每一个字符串在对象中的值，如果只出现一次，返回当前的循环下标： 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function (s) &#123; let temp = &#123;&#125;; for (let i = 0; i &lt; s.length; i++) &#123; if (!temp[s[i]]) &#123; temp[s[i]] = 1; &#125; else &#123; temp[s[i]]++; &#125; &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (temp[s[i]] === 1) &#123; return i &#125; &#125; return -1&#125;; 这种方法的时间复杂度是O(2n)，执行结果不太理想，执行用时184mm 实现2想到可以同时从正反查找字符串出现的位置，如果是同一个位置，那么就返回改下标： 12345678910var firstUniqChar = function (s) &#123; const length = s.length; for (let i = 0; i &lt; length; i++) &#123; const str = s[i]; if (s.lastIndexOf(str) === s.indexOf(str)) &#123; return i &#125; &#125; return -1&#125;; 如果将indexOf和lastIndexOf的时间复杂度都认为是n，那么这种方法的时间复杂度是O(n^3)，但是执行用时反而会缩短一些，为144ms，可能是浏览器对indexOf和lastIndexOf有优化吧 实现3看了一下大神们100ms以内的实现方法，果然牛逼。 12345678910111213var firstUniqChar = function (s) &#123; const alpha = 'abcdefghijklmnopqrstuvwxyz'; let first = s.length; for (let i = 0; i &lt; alpha.length; ++i) &#123; let index = s.indexOf(alpha[i]); if (index !== -1 &amp;&amp; index === s.lastIndexOf(alpha[i])) &#123; if (index &lt; first) &#123; first = index; &#125; &#125; &#125; return first === s.length ? -1 : first;&#125;; 本来是遍历原先的字符串，结果变为遍历一个常量字符串。之所以这样可以行，是因为题目的备注中说明了“可以假定该字符串只包含小写字母” 所以这样的时间复杂度是O(n^2)，下降了一个数量级，实际执行用时为96ms 这道题的启发是什么呢。 那就是，智商真的很重要。 我只能勤能补一点点拙了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webstorm10 快速插入当前时间]]></title>
    <url>%2F2019%2F02%2F01%2F04%20IDE%E9%85%8D%E7%BD%AE%2FWebstorm10%20%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Webstorm快速插入当前时间的小技巧 在Webstorm中通过自定义Live Template可以快速插入当前时间 首先在设置中，Editor → Live Template，点击添加模板 填写如下信息： Abbreviation，在编辑器中输入的可以出发插入模板的缩写字符，这里填写datetime Description，对这个模板的介绍，可以不填写 Template，模版的样式，格式为$datetime，其中的datetime就是上面定义的模板字符，需要用$包裹 Expand with，出发插入模板的操作，默认点击Tab插入 No applicable context yet，定义这个模板应用的文件类型，这里选择全部 填写完成后： 然后点击EDIT VARIABLES，编写模板内容，选择datetime那一项，在Expression中输入date(&quot;yyyy-MM-dd HH:mm:ss&quot;) 现在在编辑器界面就可以快速插入当前时间了。 输入da时，编辑器就会提示，按下Tab补全，插入成功。]]></content>
      <categories>
        <category>IDEp配置</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue提高11 组件的自动化全局注册]]></title>
    <url>%2F2019%2F01%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F04%20Vue%2FVue%E6%8F%90%E9%AB%9811%20%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[如果使用了Webpack进行了文件的组织、编译，就可以使用require.context令组件实现自动化注册。 这个过程需要在创建Vue实例之前（new Vue({})）之前完成，例如src/main.js require.contextWebpack解析带有表达式的require语句时，会创建一个上下文(context)，因为在编译时(compile time)并不清楚具体是哪一个模块被导入。 上下文模块还包含一些运行时(runtime)逻辑来访问这个map对象。 这意味着Webpack能够支持动态require，但会导致所有可能用到的模块都包含在bundle中。 还可以使用require.context()方法来创建自己的（模块）上下文。 你可以给这个方法传3个参数：要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式。 语法如下： 1require.context(directory, useSubdirectories = false, regExp = /^\.\//); 实例： 12345require.context('./test', false, /\.test\.js$/);// （创建了）一个包含了 test 文件夹（不包含子目录）下面的、所有文件名以 `.test.js` 结尾的、能被 require 请求到的文件的上下文。require.context('../', true, /\.stories\.js$/);// （创建了）一个包含了父级文件夹（包含子目录）下面，所有文件名以 `.stories.js` 结尾的文件的上下文。 传递给 require.context 的参数必须是字面量(literal)！ 导出的上下文有是三个属性： resolve是一个函数，它返回请求被解析后得到的模块id。 keys也是一个函数，它返回一个数组，由所有可能被上下文模块处理的请求组成 id是上下文模块里面所包含的模块id ==用自己创建出的上下文，去引入要引入的文件，这是关键==： 12const context = require.context('.', false, /.*\.(jpg|png)$/);const images = context.keys().map(v =&gt; context(v)); 利用require.context注册组件在main.js中 12345678910111213141516171819202122232425262728293031const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\w+\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 剥去文件名开头的 `./` 和结尾的扩展名 fileName.replace(/^\.\/(.*)\.\w+$/, '$1') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) 动态注册路由实现组件的自动注册后就可以实现路由的自动注册，在router/index.js中 1234567891011121314151617181920212223242526272829303132import Vue from 'vue';import Router from 'vue-router';const requireComponent = require.context('../components/demos', true, /demo[1-9][0-9]?\.vue$/);const routes = requireComponent.keys().map(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName); // 剥去文件名开头的 `./` 和结尾的扩展名 const componentName = fileName.replace(/^\.\/(demo[1-9][0-9]?).*\.\w+$/, '$1'); // 全局注册组件 const component = Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig ); return &#123; path: `/$&#123;componentName&#125;` , name: componentName, component, &#125;&#125;);Vue.use(Router);export default new Router(&#123; routes,&#125;) 动态导出/引入文件脱离Vue，在使用Webpack的一般情况下也可以通过require来导出和引入组件。 1234567891011121314// 导出const context = require.context('./', false, /Demo\d+\.js$/);const Demos = context.keys().reduce((total, current) =&gt; &#123; const name = current.replace(/^\.\/(Demo\d+).*\.\w+$/, '$1'); total[name] = context(current).default; return total&#125;, &#123;&#125;);export default Demos;// 引入import DEMOS from './demos/'const &#123; Demo01, Demo02 &#125; = DEMOS; 注意，由于Demo是通过default导出的，所以需要使用.default来获取模块 其他应用还可以使用require.context实现一些其他目录的操作，例如读取目录下的图片： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;img v-for="img in images" :src="img" :key="img" class="insert"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const context = require.context('.', false, /.*\.(jpg|png)$/); const images = context.keys().map(v =&gt; context(v)); export default &#123; data() &#123; return &#123; images, &#125; &#125; &#125;&lt;/script&gt; 参考 Webpack Vue - 基础组件的自动化全局注册 掘金 - require.context]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习51 旋转数组]]></title>
    <url>%2F2019%2F01%2F28%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A051%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一个旋转问题的练习题。 题目 题目来自LeetCode 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 设计一个算法来计算你所能获取的最大利润。你可以==尽可能地完成更多的交易==（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 实现一开始觉得这是一个动态规划的问题，要拆成另两个部分，买的位置和卖的位置，想了半天，发现没有必要这么复杂 这里的关键是，==尽可能多的完成交易==，比如[1, 3, 2, 3, 4, 5]，肯定是两次交易3-1和5-2的利润比一次交易5-1的利润要高 其实计算的是差价，只要当前的利润小于已有利润，就卖出，已有利润计入当前利润中，并重置相关的数据 1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let buyIndex = 0; let currentProfit = 0; let totalProfit = 0; for (let i = 0; i &lt; prices.length; i++) &#123; let tempProfit = prices[i + 1] - prices[buyIndex]; if (tempProfit &gt; currentProfit) &#123; currentProfit = tempProfit &#125; else &#123; totalProfit += currentProfit; currentProfit = 0; buyIndex = i + 1 &#125; &#125; return totalProfit + currentProfit;&#125;; 再查看他人的答案，有更简单的，不像上面积攒到每次交易才算最后的利润值，还需要重置，可以直接每两次的股票差价进行比较，只要利润大于零就计入总利润，否则就抛弃 12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let totalProfit = 0; let tempProfit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; tempProfit = prices[i] - prices[i - 1]; if (prices[i] - prices[i - 1] &gt; 0) &#123; totalProfit += tempProfit &#125; &#125; return totalProfit;&#125;; 简单多了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高07 Context]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9807%20Context%2F</url>
    <content type="text"><![CDATA[跨组件数据传递和兄弟组件数据传递，一直是一个比较让人头痛的问题，Redux和Mobx都是很好的解决方法。 如果不使用第三方的框架，React提供了Context API来实现组件树传递数据。 简介React Context API提供了一种通过组件树传递数据的方法，而不必在每个级别通过props属性一层一层传递。 Context提供了一个在组件树内可被视为“全局”的数据，当一些数据需要在不同的嵌套级别上被许多组件访问时，可以考虑使用Context。 请谨慎使用Context，它使组件重用更加困难。 旧的API之前的使用方法是： 在上层组件（提供者）添加一个方法getChildContext，返回要传递的context对象 1234567891011121314class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: &quot;purple&quot;&#125;; &#125; render() &#123; return ( &lt;Button&gt;&lt;/Button&gt; ) &#125;&#125;// 还要提前声明传递的数据的类型：MessageList.childContextTypes = &#123; color: PropTypes.string&#125;; 在下层组件（使用者）中直接使用this.context获取属性 1234567891011121314class Button extends React.Component &#123; render() &#123; return ( &lt;button&gt; &#123;this.context.color&#125; &lt;/button&gt; ); &#125;&#125;// 同样要提前声明传递的数据的类型Button.contextTypes = &#123; color: PropTypes.string&#125;; 它的问题是，这样的写法不符合React的声明式的写法，并且在Context值更新后，顶层组件组件向目标组件props透传的过程中，如果中间某个组件的shouldComponentUpdate返回了false，因为无法在继续出发底层组件的render，新的Context将无法达到目标组件。 因此React提出了新的Context API 新的API新的API采用了声明式的写法，也解决了穿透shouldComponentUpdate的问题 看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;// 初始化一个Contextconst ThemeContext = React.createContext();// 父组件class FatherComponent extends React.Component &#123; state = &#123; color: &apos;blur&apos; &#125;; changeColor = color =&gt; &#123; this.setState(&#123; color &#125;) &#125;; render() &#123; return ( // XXXContext.Provider作为顶层组件接受名为value的Prop &lt;ThemeContext.Provider value=&#123;&#123; color: this.state.color, changeColor: this.changeColor &#125;&#125; &gt; ) &#125;&#125;// 后辈组件（目标组件）class App extends React.Component &#123; render() &#123; &lt;FatherComponent&gt; &lt;ThemeContext.Consumer&gt; // XXXContext.Consumer作为目标组件接受参数，必须是一个函数 &#123;context =&gt; ( &lt;ChildComponent color=&#123;context.color&#125; changeColor=&#123;context.changeColor&#125; &gt; )&#125; &lt;/ThemeContext.Consumer&gt; &lt;/FatherComponent&gt; &#125;&#125; 新的Context API由三个部分组成： （1）React.createContext用于初始化一个Context （2）xxxContext.Provider作为顶层组件，接受一个value的prop，可以接受任意需要被放入context中的数据和函数（注意，这个Prop的名字必须是value，这是React要求的，并且内部应该以对象的形式传入数据） （3）xxxContext.Consumer作为目标组件，可以出现在xxxContext.Provider之后的组件树的任意位置，接受Child组件，这里的Child组件必须是一个函数，参数就是context，用来接受从顶层组件传来的Context，返回值是后辈组件。 例子有这样三层组件： 父组件： 12345678910111213class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1&#125;)&#125;&gt; + &lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1&#125;)&#125;&gt; - &lt;/button&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125; 儿子组件： 12345678910class Child extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson /&gt; &lt;/div&gt; ) &#125;&#125; 孙子组件 12345const Grandson = () =&gt; ( &lt;div&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;/div&gt;); 现在，我们想让父组件的count属性能够被孙子组件获取到，按照原来的做法，需要一层一层传递进去： 1234567891011121314151617181920212223242526272829303132const Grandson = (&#123; count &#125;) =&gt; ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot;&#125;&#125;&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;p&gt;老子给的数：&#123;count&#125;&lt;/p&gt; &lt;/div&gt;);class Child extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot;&#125;&#125;&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson count=&#123;this.props.count&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;div style=&#123;&#123;&quot;border&quot;: &quot;1px solid #fff&quot;&#125;&#125;&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; +&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1 &#125;)&#125;&gt; -&lt;/button&gt; &lt;Child count=&#123;this.state.count&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 如果改为使用Context来实现呢？那么就需要在父组件增加一个Provider的架子，将后续的组件都装进去，在孙子组件使用Consumer的架子（是一个函数，返回值是原本的结构，但是通过函数的参数来获取要传递的跨级的数据） 123456789101112131415161718192021222324252627282930313233343536373839404142// 初始化一个Contextconst Context = React.createContext();const Grandson = () =&gt; ( &lt;Context.Consumer&gt; &#123;context =&gt; ( &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot; &#125;&#125;&gt; &lt;h3&gt;这是孙子&lt;/h3&gt; &lt;p&gt;老子给的数：&#123;context.count&#125;&lt;/p&gt; &lt;/div&gt; )&#125; &lt;/Context.Consumer&gt;);class Child extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot;, &quot;width&quot;: &quot;50%&quot;, &quot;margin&quot;: &quot;0 auto&quot; &#125;&#125;&gt; &lt;h2&gt;这是儿子&lt;/h2&gt; &lt;Grandson /&gt; &lt;/div&gt; ) &#125;&#125;export default class Demo7 extends Component &#123; state = &#123; count: 0 &#125;; render() &#123; return ( &lt;Context.Provider value=&#123;&#123;count: this.state.count&#125;&#125;&gt; &lt;div style=&#123;&#123; &quot;border&quot;: &quot;1px solid #fff&quot; &#125;&#125;&gt; &lt;h1&gt;这是老子&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; +&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count - 1 &#125;)&#125;&gt; -&lt;/button&gt; &lt;Child /&gt; &lt;/div&gt; &lt;/Context.Provider&gt; ) &#125;&#125; Demo地址在这里。 参考 上下文(Context)@React中文文档 如何解读 react 16.3 引入的新 context api？@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高06 Render Props]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9806%20Render%20Props%2F</url>
    <content type="text"><![CDATA[上一篇笔记学习了通过高阶组件实现React的代码复用，它也有着一些缺点。 除了HOC之外，还有没有别的方法呢？来，学习一下Render Props。 HOCHOC的出现是为了实现代码的复用，是一种React中的编程范式，基本的形式是： 1234567function HOCFactory(WrappedComponent, ...args) &#123; return class HOC extends React.Component &#123; render()&#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 代码通过一个类似装饰器技术（可以参考《16 ES6标准入门(Decorator)》这篇笔记）共享，接受一个基础组件作为参数，返回了一个新的组件 1const ResultComponent = HOC(BaseComponent) 一个HOC的例子Demo的Github地址在这里。 一个响应鼠标事件的HOC的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const withMouseHOC = Component =&gt; &#123; return class extends React.Component &#123; state = &#123; x: 0, y: 0 &#125; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; render() &#123; return ( &lt;div onMouseMove=&#123;this.handleMouseMove.bind(this)&#125; &lt;Component &#123;...this.props&#125; mouse=&#123;this.state&#125; /&gt; &lt;/div&gt; ) &#125; &#125;&#125;class App extends React.Component &#123; render() &#123; const &#123;x, y&#125; = this.props.mouse; return ( &lt;div&gt; &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;)&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;// 也可以写成纯函数式组件const App = props =&gt; &#123; const &#123; x, y &#125; = props.mouse; return ( &lt;div&gt; &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;) &lt;/h1&gt; &lt;/div&gt; )&#125;const AppWithMouse = withMouseHOC(App);ReactDOM.render(&lt;AppWithMouse /&gt;, document.getElementById(&apos;root&apos;) HOC的问题HOC存在着几个问题： （1）存在着多个HOC时，不知道props从何而来 （2）名字冲突，如果多个HOC使用了同名的prop，它们将发生冲突并彼此覆盖，React不会发出警告 （3）HOC使用的是静态组合而不是动态组合（结果组件被创建时发生的组合），不能再Render中调用HOC，不能使用React的生命周期 Render Props于是出现了另一门技术来实现代码复用，可以规避上面出现的问题 那什么是Render Prop呢？一个Render Prop是一个类型为函数的prop，将可复用组件的state作为参数传递给这个函数prop，返回对应的HTML模板（我理解，这也是“Render Prop”的意思吧，一个可以作为render函数返回HTML模板的prop） 将上面的例子改写成Render Prop的形式 123456789101112131415161718192021222324252627282930313233// 用一个普通组件来共享代码class Mouse extends React.Component &#123; state = &#123; x: 0, y: 0 &#125; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;) &#125; // 在render函数中，利用prop.render来进行渲染 render() &#123; return ( &lt;div onMouseMove=&#123;this.handleMouseMove.bind(this)&#125; &#123;this.prop.render(this.state)&#125; &lt;/div&gt; ) &#125;&#125;const AppWithMouse = () =&gt; &#123; // 给组件的render的prop传入了一个函数 return ( &lt;div&gt; &lt;Mouse render=&#123;(&#123;x, y&#125;) =&gt; ( &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;) &lt;/h1&gt; )&#125; &lt;/div&gt; )&#125;ReactDOM.render(&lt;AppWithMouse /&gt;, document.getElementById(&apos;root&apos;) 使用的窍门：将一个返回HTML函数作为名为render的prop，传给复用组件，复用组件中调用this.props.render(this.state)，渲染个性组件，最终返回最终组件。 有了Render Prop，我们可以使用一个prop去进行渲染，它解决了HOC的问题 （1）足够直接，可以通过Render Prop传入的函数的参数列表，有哪些state和prop可以使用 （2）不会有变量名的冲突，因为不会有任何的自动的属性合并 （3）组合模型是动态的，每次组合都是在render内部，可以利用React生命周期 此外，由于Render Prop仅仅是一个函数，所以不会带来过多的复杂的编程范式，更加简洁 用Render Prop代替HOC？技术实现上，可以使用Render Prop代替HOC，例如可以用一个一般的、具有Render Prop的&lt;Mouse&gt;组件实现的witchMouse的HOC： 1234567891011const withMouse = Component =&gt; &#123; return class extends React.Component &#123; render() &#123; return ( &lt;Mouse render=&#123;mouse =&gt; ( &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt; )&#125; /&gt; ) &#125; &#125;&#125; 但是我现在也没有具体的实践经验，是否在各种复杂的场下，Render Prop代替HOC都是更优的，还是需要实践慢慢总结证明。 与HOC的实现方式的区别假设包含能够复用的逻辑的公共组件是A，需要继承的个性组件是B，HOC的实现是将用一个函数的形式，B为参数，作为render的内容组合至A中，返回包含B的A，也就是最终的组件： 123456789const HOCFactory = B =&gt; &#123; return &lt;A /&gt;&#125;// B组合至A中返回class A extends from React.Component &#123; render() &#123; return &lt;B /&gt; &#125;&#125; 而Render Props方式的实现是，在A中渲染的是this.props.render函数的返回值，最终的组件形成是在使用A时，为A传入一个render参数，它的返回值就是B的内容（通过Prop传进A的内部进行渲染） 12345678910111213141516171819// A class A extends from React.Component &#123; render() &#123; return ( &lt;A&gt; &#123;this.props.render(this.state)&#125; &lt;/A&gt; ) &#125;&#125;// 最终组件class App extends from React.Component &#123; render() &#123; return ( &lt;A render=&#123;(state) =&gt; (&lt;B&gt;)&#125; /&gt; ) &#125;&#125; 参考 [译]使用Render props吧！@掘金 React中的Render Props@知乎]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高05 高阶组件]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9805%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[如何更好的实现代码复用，又能够保证一定的灵活性、可维护性和可读性，需要程序员自身的技巧和能力，也需要框架更好和合理的设计实现和编程范式。 高阶组件就是React实现代码复用的一种方法。 什么是高阶组件高阶组件（简称HOC）的目的就是实现代码的复用，它不是React的API，而是根据React的特性形成的一种开发范式。它接受一个组件作为参数并返回一个新的组件 1234567function HOCFactory(WrappedComponent, ...args) &#123; return class HOC extends React.Component &#123; render()&#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; HOC中并没有修改输入的组件，也没有通过继承来扩展组件，而是通过==组合的方式==来达到扩展的目的 即：传入HOCFactory中的WrappedComponent是一个有个性的组件，而HOC中返回的class是有公共特性的组件，通过传入args一些配置参数，返回的就是这个特性组件和公共组件的组合组件 HOC可以做什么 代码复用，代码模块化 增删改props 渲染劫持 （1）代码复用，代码模块化 看这样的一个例子： 加载数据、刷新数据的行为很常见，现在把这种逻辑抽离到高阶组件当中去。完成高阶组件loadAndRefresh，它具有以下功能： 123456789101112class Post extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.props.refresh()&#125;&gt;刷新&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Post = loadAndRefresh(&apos;/post&apos;)(Post) 高阶组件loadAndRefresh接受一个url作为参数，然后返回一个接受组件作为参数的函数，这个新函数返回一个新的组件。新的组件渲染的时候会给传入的组件设置content和refresh作为props。 getData(url)的返回Promise，它返回一个字符串的文本，你需要通过content的props把它传给被包裹的组件。组件在第一次加载还有refresh的时候会去服务器取数据。 另外，组件在加载数据的时候，content显示数据加载中...。而且，所有传给loadAndRefresh返回的组件的props要原封不动传给被包裹的组件。 最后一句话，loadAndRefresh返回的组件就是返回的新组件Post，被包裹的就是传入的原来的Post，原封不动就是指需要将this.props完全传递，利用了对象解构的语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const getData = url =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, 2000, Date.now())&#125;);class Post extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.props.content&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.props.refresh()&#125;&gt;刷新&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const loadAndRefresh = url =&gt; (Wrapper) =&gt; &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; content: &apos;&apos; &#125; &#125;; componentDidMount () &#123; this.refresh() &#125;; async refresh() &#123; this.setState(&#123; content: &apos;数据加载中...&apos;, &#125;); const content = await getData(url); this.setState(&#123; content, &#125;); &#125;; render () &#123; return ( &lt;Wrapper content=&#123;this.state.content&#125; refresh=&#123;this.refresh.bind(this)&#125; &#123;...this.props&#125;/&gt; ) &#125; &#125;&#125;;Post = loadAndRefresh(&apos;/post&apos;)(Post);export default class PCHeader extends Component &#123; render () &#123; return ( &lt;Post /&gt; ) &#125;&#125; 上面的高阶组件中，接受了Post作为个性组件，而HOC中的公共组件部分实现的就是抽离出来的获取、刷新数据的逻辑（它也是一个组件）。 props的传递是通过在组件上，利用对象的扩展，将所有prop传入 （2）增删改props HOC组件可以对传入的props进行修改或者添加 HOC组件会在原始组件的基础上增加一些扩展功能使用的props，这些props不应该传入到原始组件，一般会这样处理： 1234567891011function control(wrappedComponent) &#123; return class Control extends React.Component &#123; render()&#123; let props = &#123; ...this.props, message: &quot;You are under control&quot; &#125;; return &lt;wrappedComponent &#123;...props&#125; /&gt; &#125; &#125;&#125; （3）渲染劫持 可以在HOC中控制是否渲染（这里控制的组件整体是否被渲染，而非组建内部的细节），无法在HOC中控制渲染细节 比如，组件在data没有加载完的时候加载LOADING，可以在HOC中这样实现： 12345678910function loading(wrappedComponent) &#123; return class Loading extends React.Component &#123; render()&#123; if(!this.props.data) &#123; return &lt;div&gt;LOADING...&lt;/div&gt; &#125; return &lt;wrappedComponent &#123;...props&#125; /&gt; &#125; &#125;&#125; 注意事项不要在render方法里面调用HOC方法在render里面每次调用HOC都会返回一个新的class，重新渲染会让性能损耗加大。 拷贝静态方法有的时候在组件的class包装的静态方法，通过HOC返回的包装后的组件就没有这些静态方法。 为了保持组件使用的一致性，一般会把这些静态方法拷贝到包装后的组件上 123456function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 例子logger和debugger官网的例子，可以用来监控父级组件传入的props的改变： 123456789101112function logProps(WrappedComponent) &#123; return class extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; console.log(`WrappedComponent: $&#123;WrappedComponent.displayName&#125;, Current props: `, this.props); console.log(`WrappedComponent: $&#123;WrappedComponent.displayName&#125;, Next props: `, nextProps); &#125; render() &#123; // Wraps the input component in a container, without mutating it. Good! return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 页面权限管理可以使用HOC对组件进行包裹，当组件加载的时候，首先检验用户是否有对应的权限，如果有的话就渲染页面，如果没有就跳走 参考 Higher-Order Components@React 深入React高阶组件(HOC)@掘金 React HOC高阶组件详解@掘金]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高04 对虚拟DOM和加载过程的理解]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9804%20%E5%AF%B9%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[也是面试时比较常遇到的React的问题之一。了解了之后还是能够加深对React的理解。 React虚拟DOM的理解（1）用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 （2）当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 （3）把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 虚拟DOM本质上就是在JS和DOM之间做了一个缓存。可以类比CPU和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然DOM这么慢，我们就在JS和DOM之间加个缓存。CPU（JS）只操作内存（虚拟DOM），最后的时候再把变更写入硬盘（DOM）。 虚拟DOM是用JS的对象结构模拟出HTML中DOM的结构，批量的增删改查，由于直接操作的是JS对象，所以速度要比操作真实DOM要快，最后更新到真正的DOM中 虚拟DOM构建的对象，除了DOM相关属性，还包括了React自身需要的属性，比如ref，key等，大概如下结构： 123456789101112131415161718192021&#123; type: 'div', props: &#123; className: 'xxx', children: [&#123; type: 'span', props: &#123; children: ['CLICK ME'] &#125;, ref: key: &#125;, &#123; type: Form, props: &#123; children: [] &#125;, ref: key: &#125;] | Element &#125; ref: 'xxx', key: 'xxx'&#125; React何时将虚拟DOM渲染为真实DOMrender这个步骤就是React组件挂载的步骤 React组件挂载：将组件渲染，并构建DOM元素然后插入页面的过程 render的步骤是创建虚拟DOM，挂载组件， 在render之后，将这个虚拟DOM树真正渲染成一个DOM树，插入了页面，可以认为是在componentDidMount这个步骤完成的，该方法被调用时，已经渲染出真实的DOM 在组件存在期，componentDidUpdate与componentDidMount类似，在组件被重新渲染后，此方法被调用，真实DOM已经渲染完成 React不能setState的步骤shouldComponentUpdate和componentWillUpdate就会造成循环调用，使得浏览器内存占满后崩溃 对于setState的理解setState是一个异步方法，一个生命周期内的所有setState方法会合并操作。 在各个生命周期中执行setState： （1）在componentWillMount执行setState是无意义的，应该将这里为state的赋值放到constructor中直接作为state的初始值。 这是因为，组件直挂再一次，在componentWillMount里面setState会但是仅仅会更新state一次，而且会和constructor中的初始化state合并执行。所以这是无意义的setState （2）在componentDidMount中执行setState会导致组件在初始化的时候就触发了更新，渲染了两遍，应该尽量避免。 有一些场景，比如在组件DOM渲染完成后获得DOM元素位置或者宽高等等设置为state，会不得在componentDidMount之后setState，但是除了这些必要的时候，都应该尽量避免在componentDidMount里setState。 （3）在componentWillUnmount中执行setState不会更新state，是不生效而且无意义的。 （4）禁止在shouldComponentUpdate和componentWillUpdate中调用 setState，这会造成循环调用，直至耗光浏览器内存后崩溃。 在shouldComponentUpdate和componentWillUpdate调用setState会再次触发这两个函数，然后在两个函数又触发了setState，然后再次触发这两个函数，这样就进入了一个不停setState然后不停触发组件更新的死循环里，会导致浏览器内存耗光然后崩溃。 （5）在componentDidUpdate中执行`setState同样会导致组件刚刚完成更新又要再更新，进入死循环。 但是在某些特殊情况下，比如说state或者props变化触发了DOM变化，需要重新获取DOM元素宽高时然后更新某个state的时候，就不得不在这个函数里使用setState了。此时一定要给setState设置一个前提条件，以避免出现循环渲染的问题。 1234567componentWillUpdate(nextProps, nextState, nextContext) &#123; if (this.state.count !== 3333) &#123; this.setState(&#123; count: 3333 &#125;); &#125;&#125; 因此，如非必须，应该尽量避免在本函数里setState。 （5）在componentWillReceiveProps中可以setState，不会造成二次渲染。由于只有props的变化才会触发componentWillReceiveProps事件，因为在这个事件里setState不会造成不停触发组件更新的死循环，可以放心在这个函数里setState。 为什么虚拟DOM比原生DOM性能更高React的基本思维模式是每次有变动就整个重新渲染整个应用，相当于设置 innerHTML，只不过它设置的是内存里面 Virtual-DOM，而不是真实的 DOM。 React厉害的地方并不是说它比DOM快(这句话本来就是错的)，而是说不管你数据怎么变化，我都可以以最小的代价来更新DOM。方法就是在内存里面用新的数据刷新一个虚拟的DOM数，然以后新旧DOM树进行比较，找出差异，再将差异更新到真正的DOM 树上。 原生DOM性能低，因为DOM的规范迫使浏览器在实现的时候为每一个DOM元素添加了非常多的属性，然而这其中很多我们都用不到 而React对虚拟DOM的属性进行了精简，非常轻量化，并且使用了diff的算法，比较前后差异，最后只把变化的部分一次性应用到真实的DOM树 React的变动检查由于是DOM结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。 更正确的说法应该是：虚拟DOM不一定比原生DOM性能高，但是让开发者更省心的更新数据。 首先, 虚拟DOM并没有比直接原生操作更快, 所谓”快”是有条件的比如点赞, 数字+1, 直接操作DOM会更快。 如果你能自己捋请规则, 每回手动操作DOM的时候, 都只改动应该改变的, 那DOM操作永远比虚拟DOM快。 但如果你的改动勾连的地方很多，而且要保持状态，那虚拟DOM的自动diff无疑会让你省更多心。 比如一个列表, 列表项有点赞等状态, 回复数量等信息, 有动态新增, 有动态加载, 这时候你要直接操作DOM会很繁琐。 虚拟DOM的核心在于diff，它自动帮你计算那些应该调整，然后只修改该修改的区域, 省下的不是运行速度这种小速度，而是开发速度/维护速度/逻辑简练程度等”总体速度” diff算法比较两棵DOM树的差异是Virtual DOM算法最核心的部分，这也是所谓的Virtual DOM 的diff算法。两个树的完全的diff算法是一个时间复杂度为O(n^3)的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以Virtual DOM只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到O(n)。 参考 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ - 尤雨溪的回答@知乎 react里面的virtual DOM的效率为什么比直接操作DOM更快呢@segmentfault 如何理解虚拟DOM? - 戴嘉华的回答@知乎 React组件生命周期函数里setState调用分析@Simona&amp;Peter]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高03 编写一个组件]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9803%20%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[以前总结的，简单的编写一个组件的过程 还是太简略了，以后慢慢丰富吧。 详解过程编写一个组件首先引入相关模块 React prop-types 然后声明一个继承自React.Component的类： 123export default class MyComponent extends from Reac.Component&#123; &#125; 然后对传入的Prop进行限定和验证： 123456static PropTypes = &#123; checkedText: PropTypes.string, uncheckedText: PropTypes.string, hideText: PropTypes.bool, onClickFunc: PropTypes.func&#125; 可以对Prop的默认值进行预定义： 12345static defaultProp = &#123; checkedText: &apos;开&apos;, uncheckedText: &apos;关&apos;, hideText: false&#125; 然后定义组件的constructor， 在其中可以定义state中的初始值 123456constructor(props) &#123; super(props); this.state = &#123; checked: false &#125;&#125;; 将数组传回父组件，是通过调用父组件的方法，父组件的方法是通过Prop传入子组件中进行调用的 123456789101112// 父组件中引用子组件&lt;MyInput onClickFunc=&#123;this.handleClick.bind(this)&#125;/&gt;// 子组件中引用父组件的方法并传值handleClick() &#123; const &#123;checked&#125; = this.state; const &#123;onClickFunc&#125; = this.props; this.setState(&#123; checked: !checked &#125;, () = &gt; &#123; onClickFunc(this.state.checked) &#125;); 注意，调用父组件的方法放在了setState方法的回调函数中 一个组件的例子定义子组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Created by zh on 2018/1/24. */import React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import ReactDOM from &apos;react-dom&apos;;import styles from &apos;./myInput.css&apos;;import classnames from &apos;classnames&apos;export default class MyInput extends React.Component &#123; static propTypes = &#123; checkedText: PropTypes.string, uncheckedText: PropTypes.string, hideText: PropTypes.bool, onClickFunc: PropTypes.func &#125;; static defaultProps = &#123; checkedText: &apos;开&apos;, uncheckedText: &apos;关&apos;, hideText: false &#125;; constructor(props) &#123; super(props); this.state = &#123; checked: false &#125; &#125;; handleClick() &#123; const &#123;checked&#125; = this.state; const &#123;onClickFunc&#125; = this.props; this.setState(&#123; checked: !checked &#125;, () =&gt;&#123; onClickFunc(this.state.checked) &#125;); &#125; render() &#123; const &#123;checkedText, uncheckedText, hideText&#125; = this.props; const &#123;checked&#125; = this.state; let checkStyle = checked ? styles[&apos;circleChecked&apos;] : styles[&apos;circleUnchecked&apos;]; let textEle = !hideText ? ( &lt;span className=&#123; checked ? styles.checkedText : styles.unCheckedText&#125;&gt; &#123;checked ? checkedText : uncheckedText&#125; &lt;/span&gt; ) : null; return ( &lt;div className=&#123;styles.container&#125; onClick=&#123;this.handleClick.bind(this)&#125;&gt; &lt;div className=&#123;classnames(styles[&apos;circle&apos;], checkStyle)&#125;/&gt; &#123;textEle&#125; &lt;/div&gt; ) &#125;&#125; 引用子组件 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by zhouhao on 2017/5/8. */import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;observable, computed, action&#125; from &apos;mobx&apos;;import &#123;observer&#125; from &apos;mobx-react&apos;import Store from &apos;./components/Store&apos;;import style from &apos;../css/root.css&apos;;import MyInput from &apos;./components/MyInput&apos;;@observerexport default class Root extends React.Component &#123; constructor() &#123; super(); this.state = &#123; childState: &apos;关&apos; &#125; &#125; handleClick(inputChecked)&#123; let state = inputChecked ? &apos;开&apos; : &apos;关&apos;; this.setState(&#123; childState: state &#125;); &#125;; render() &#123; let &#123;childState&#125; = this.state; return ( &lt;div&gt; &lt;MyInput onClickFunc=&#123;this.handleClick.bind(this)&#125;/&gt; &lt;p&gt;子组件状态:&#123;childState&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高02 React性能优化]]></title>
    <url>%2F2019%2F01%2F25%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9802%20React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以前面试的时候，遇到过如何进行React性能优化的问题。总结了一下。 但是在实际工作中，确实没有遇到过React性能的问题，还是业务场景不复杂。希望以后能有机会实践。 PureRenderMixin因为react的diff是在某一个根节点发生变化的时候，调用所有节点进行render，再对生成的虚拟DOM进行对比，如果不变则不对真实DOM进行更新。这就导致了性能的浪费。 所以优化针对两方面： 拆分组件，有利于组件复用和优化 避免不必要的render 避免不要的render，主要基于componentShouldUpdate(nextProps, nextState)生命周期函数，该函数默认返回true，所以一旦prop或state有任何变化都会引起重新render React的官方解决方案是 PureRenderMixin ES5的写法： 12345678var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;);React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); pure-render-decoratorES7装饰器的写法： 12345678910111213141516171819import pureRender from &quot;pure-render-decorator&quot;...@pureRenderclass Person extends Component &#123; render() &#123; console.log(&quot;我re-render了&quot;); const &#123;name,age&#125; = this.props; return ( &lt;div&gt; &lt;span&gt;姓名:&lt;/span&gt; &lt;span&gt;&#123;name&#125;&lt;/span&gt; &lt;span&gt; age:&lt;/span&gt; &lt;span&gt;&#123;age&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; pureRender很简单，就是把传进来的component的shouldComponentUpdate给重写掉了，原来的shouldComponentUpdate，无论怎样都是return ture，现在不了，我要用shallowCompare比一比，shallowCompare代码及其简单 123function shallowCompare(instance, nextProps, nextState) &#123; return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);&#125; PureComponentReact在15.3.0里面加入了了React.PureComponent - 一个可继承的新的基础类, 用来替换react-addons-pure-render-mixin。用法： 12345678910111213141516class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; 要注意的是，这种比较只是浅比较，在多层嵌套的对象中比较会失败 immutable.jsImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。 Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画： Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的： 1234567891011121314151617181920212223import &#123; is &#125; from &apos;immutable&apos;;shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123; const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false;&#125; 无状态组件react官方还在0.14版本中加入了无状态组件 这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义： 123// es6const HelloMessage = (props) =&gt; &lt;div&gt; Hello &#123;props.name&#125;&lt;/div&gt;;render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode); 参考 https://segmentfault.com/a/1190000007811296 https://segmentfault.com/a/1190000010438089]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习50 买卖股票的最佳时机 II]]></title>
    <url>%2F2019%2F01%2F24%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A050%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II%2F</url>
    <content type="text"><![CDATA[贪心算法的练习题。 题目 题目来自LeetCode 给定一个数组，它的第i个元素是一支给定股票第i天的价格。 设计一个算法来计算你所能获取的最大利润。你可以==尽可能地完成更多的交易==（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 实现一开始觉得这是一个动态规划的问题，要拆成另两个部分，买的位置和卖的位置，想了半天，发现没有必要这么复杂 这里的关键是，==尽可能多的完成交易==，比如[1, 3, 2, 3, 4, 5]，肯定是两次交易3-1和5-2的利润比一次交易5-1的利润要高 其实计算的是差价，只要当前的利润小于已有利润，就卖出，已有利润计入当前利润中，并重置相关的数据 1234567891011121314151617181920/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let buyIndex = 0; let currentProfit = 0; let totalProfit = 0; for (let i = 0; i &lt; prices.length; i++) &#123; let tempProfit = prices[i + 1] - prices[buyIndex]; if (tempProfit &gt; currentProfit) &#123; currentProfit = tempProfit &#125; else &#123; totalProfit += currentProfit; currentProfit = 0; buyIndex = i + 1 &#125; &#125; return totalProfit + currentProfit;&#125;; 再查看他人的答案，有更简单的，不像上面积攒到每次交易才算最后的利润值，还需要重置，可以直接每两次的股票差价进行比较，只要利润大于零就计入总利润，否则就抛弃 12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; let totalProfit = 0; let tempProfit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; tempProfit = prices[i] - prices[i - 1]; if (prices[i] - prices[i - 1] &gt; 0) &#123; totalProfit += tempProfit &#125; &#125; return totalProfit;&#125;; 简单多了。]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React提高01 遇到的坑]]></title>
    <url>%2F2019%2F01%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact02%20%E6%8F%90%E9%AB%98%2FReact%E6%8F%90%E9%AB%9801%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[总结整理了一下一年前使用React开发测评平台时的经验。 总共使用React开发了一个项目，用了1个多月，学到的东西比这一年都多，值得好好总结。 定时任务中的setState如果定时任务触发时，组件已经被销毁，会给出警告 1setState(...): Can only update a mounted or mounting component. 虽然只是一个warning，但是还是证明写的代码不规范，不一定什么时候就埋坑了。 这个问题实质是：setState在异步的callback里执行，而这个时候由于返回上一页，组件已经被销毁了。 用isMounted方法做判断是官方不推荐的方法，而且我也不知道怎么实现。 真正的解决方法应该是在componentWillUnmount中将事件清除或者变量设置为null。 对于setInterval来说需要在componentWillUnmount中clear bind在addEventListener中的使用在组件中添加了scroll事件： 1window.addEventListener('scroll', this.windowScroll.bind(this)); 在componentWillUnmount中想要清除绑定的事件： 1window.removeEventListener('scroll', this.windowScroll.bind(this)); 这样做是不会生效的。 因为bind(this)方法总会返回一个新的函数，所以在removeEventListener时，移除的是一个不存在的、新的函数。 解决方法是在constructor里面对windowScroll一次性绑定this。（这样this.windowScroll变量指向的就是同一个bind之后的方法了。 1234567891011121314151617181920export default class Overview extends React.Component &#123; constructor(props) &#123; super(props); this.windowScroll = this.windowScroll.bind(this) &#125; windowScroll(e) &#123; // do something &#125; componentDidMount() &#123; window.addEventListener('scroll', this.windowScroll); &#125; componentWillUnmount() &#123; window.removeEventListener('scroll', this.windowScroll); &#125; // ... &#125; globalStore中的方法在组件中不能直接调用12345const &#123; globalStore &#125; = this.props;const &#123; setBtnStatus &#125; = globalStore;globalStore.setBtnStatus(); // OKsetBtnStatus(); // 报错 这是因为this指向调用者，前者的this指向globalStore，后者指向window checkbox值不能正确重置在不同题目之间跳转时checkbox值不会清除，原因是在跳转时即使input所在的组件被重新render，但是如果input本身的key没有变化，React就认为这个组件整体没有变化，不会重新渲染，只会对input局部渲染，所以input的value的值就不会重置。 ==只有key值变化，React才会认为组件整体变化，整体渲染== 解决方法是给input加上key的属性，根据页面变化，强制重新渲染，然后在componentWillReceiveProps里面对选中的答案状态进行重置 并且，不能在componentWillUpdate和componentShouldUpdate里面对state的值进行控制，会造成死循环 （2017.07.14更新） 当时查资料的时候对这里理解的不全面，原文的意思是如果key值太简单，例如只有数字序号作为key，当项目发生变化，key值可能不变，React可能会认为是同一个组件而不进行渲染。所以上面提到的： 只有key值变化，React才会认为组件整体变化，整体渲染 不够准确，应该==将key值独一无二化，例如用ID来标识key值==，这样key值不重复，就不会发生不渲染的情况。 （2019.01.22更新） 有两个问题： （1）React中的key并不要求全局唯一，因为key的作用域是==当前列表内==，同一个列表内唯一即可，不同列表、不同组件间都不需要考虑这个问题。 （2）第二个是，key值是加可以在包含input的组件的（由于当时的组件划分的不合理所以只能加在input上）。 当组件上没有key时，传入的Prop发生变化，React会寻求复用，保存组件状态，不会触发Mount系列事件，只会触发Update系列事件; 而如果增加了key，当传入的Prop发生变化也会导致组件重新渲染，所有状态重置 因此就有两个处理方法：一个就是不为组件增加key，而是在更新周期的componentWillReceiveProps中寻求状态重置，另一种就是为组件增加key，有React自动完成重置 前者在逻辑不复杂的情况下是可以使用的，但是如果逻辑比较复杂就会导致大量的逻辑和函数在componentWillReceiveProps中，而后者就一劳永逸了，直接销毁了组件并重建，在componentDidMount中处理重置好，可以参考这篇文章。 其实在Vue中也是相同的原理。 Prop的类型验证和默认值1234567891011export default class Question extends React.Component &#123; // 类型验证 static propTypes = &#123; finishBtnDisabled: PropTypes.bool &#125;; // Prop默认值 static defaultProps = &#123; finishBtnDisabled : false, &#125;;&#125; 对Mobx的Store中的变量赋值12let &#123; spendMinute &#125; = timeStore;spendMinute = 100; 这样是不行的，这是声明了新的变量，有了两种方法: （1）直接引用Store中的变量，这种方法在Mobx的严格模式下第一种方法是不允许的 1timeStore.spendMinute = 100 （2）引用Store中的方法，对变量赋值（推荐） 12345678910111213141516// Store中export default class Mark &#123; @observable spendMinute = 0; @action changeSpendMinute(minute) &#123; this.spendMinute = minute &#125;&#125;// 组件中@observerexport default class Overview extends React.Component &#123; changeMinute() &#123; const &#123; globalStore &#125; = this.props; globalStore.changeSpendMinute(100); &#125;&#125; &lt;div&gt;的blur事件会遇到这样的需求：当标签失去焦点时，将菜单隐藏并触发一些操作，直觉就想到使用focus和blur事件。 但是这两个事件只对form表单控件有效，但是对于&lt;span&gt;、&lt;div&gt;等普通元素并不生效 解决方法就是设置这些元素的tabindex属性，就可以触发焦点事件了。 12345&lt;div onBlur=&#123;this.blurHandler.bind(this)&#125; onFocus=&#123;this.focusHandler.bind(this)&#125; tabIndex="1"&gt; blur&lt;/div&gt; 此外，如果希望点击出现的菜单本身不会在点击自己时，因为blur事件消失，需要将菜单放入被点击事项的子元素中。 DOM事件传参DOM事件传参，事件对象作为最后一个参数并传入到事件处理程序中 1&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 与Vue中是不同的。 Vue中的点击事件传参时，需要手动将$event传入，否则事件处理程序无法访问事件对象。不传参时，事件处理程序默认的参数就是事件对象。 React中的thisReact组件中的this都指向了组件本身，但是为了接受客户端的响应而添加的回调函数，直接添加到了window对象上，再这个函数里面用到的this就指向了window而非React组件。 1234567891011121314151617export default class PCIndex extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; updateCounter: 0, &#125; &#125;; async markPhoto(index) &#123; // ... window.teacherMark = async function(result) &#123; // ... this.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;; &#125; 上面的setState会报错（可怕的是当时使用了Mobx，直接对组件内的属性赋值this.updateCounter++，没有报错而是直接无效） 解决方法有两个，一个是将组件的this缓存下来： 12345678910async markPhoto(index) &#123; const self = this; // ... window.teacherMark = async function(result) &#123; // ... self.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;;&#125; 第二种方法就是改用箭头函数：12345678910async markPhoto(index) &#123; const self = this; // ... window.teacherMark = result =&gt; &#123; // ... self.setState(&#123; updateCounter: (++this.state.updateCounter) &#125;); &#125;;&#125; 对于this的指向，一定要谨慎！ 循环的问题其实这个问题和React关系不大，还是自己太菜。 有这样的一段代码，要求根据数组成员的某些属性筛选数后，创建一个新的数组，当时的做法啊是：12345678910111213141516171819const questions = [ &#123; hasMarked: true&#125;, &#123; hasMarked: false&#125;, &#123; hasMarked: true&#125;];let markParamAnswer = [];questions.map((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer[index] = &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;; &#125;&#125;);console.log(markParamAnswer[1]); // undefinedconsole.log(markParamAnswer); // [&#123;...&#125;, empty, &#123;...&#125;] 但由于间隔着遍历导致数组，导致结果会形成带有空位的数组，在后面处理的时候出现了bug 当时的改进方案是： 1234567891011121314151617181920const questions = [ &#123; hasMarked: true&#125;, &#123; hasMarked: false&#125;, &#123; hasMarked: true&#125;];let markParamAnswer = [];let i = 0;questions.map((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer[index] = &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;; i++ &#125;&#125;);console.log(markParamAnswer); // [&#123;...&#125;, &#123;...&#125;] 但是现在来看，当时还是太菜，这就是没有code review的缘故，没人指出你的代码有多烂，只能靠自己回过头再看看，发现自己菜的一比。 可以直接用push就行了（2018-11-22）： 12345678910questions.forEach((question, index) =&gt; &#123; if (question.hasMarked) &#123; markParamAnswer.push(&#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;); &#125;&#125;); 如果数据量不大（因为会遍历两次）的时候可以写成函数式的，更清晰（2019-01-22）： 12345678let markParamAnswer = questions.filter(question =&gt; question.hasMarked).map(v =&gt; &#123; return &#123; "answerId": "123", "teacherName": "123", "score": -1, "comment": "111111" &#125;&#125;); 参考 React setState can only update a mounted or mounting component@stackoverflow react native Warning: setState(…): Can only update a mounted or mounting component.@QCSDN React Checkbox Stays Checked Even After Component is Unmounted@stackoverflow React 实践心得：key 属性的原理和用法]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS56 Generator 函数的异步应用]]></title>
    <url>%2F2019%2F01%2F22%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS56%20Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Generator函数实现异步编程，利用的是协程的思想。Generator函数可以将异步流程表示的很简洁，但是流程管理不方便，有两种方式进行Generator函数的自动流程化管理，一种是利用Thunk函数，另外一种是使用Promise对象，二者结合起来就是co模块。 传统方法所谓异步，简单说就是一个任务不是连续完成的，被分成了两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 在JavaScript中，ES6之前，实现的异步编程的方法有四种： 回调函数 事件监听 发布/订阅 Promise 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到回过头重新执行这个任务的时候，就直接调用这个函数。 第二段所需要信息和错误对象，都必须通过参数的形式传递给回调函数，这是因为程序分为两段执行，当第一段执行后，==任务所在的上下文环境就已经结束了==。在这之后的任务信息和抛出的错误，原来的上下文环境已经无法捕获，所以只能当做参数传入。 Promise回调函数本身没有问题，但是当多个回调函数存在的时候，会出现“回调地狱”，形成强耦合，只要有一个操作需要修改，它的上下层函数都要跟着修改 12345fs.readFile(fileA, 'utf-8', function (err, data) &#123; fs.readFile(fileB, 'utf-8', function (err, data) &#123; // ... &#125;);&#125;); Promise对象就是为了解决这个问题而提出的，它不是新的语法功能，而是一种新的写法，将回调函数的嵌套改为链式调用： 123456789101112var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).catch(function (err) &#123; console.log(err);&#125;); Promise的问题是代码冗余，很多的then导致语义不清楚 Generator函数协程的 Generator 函数实现Generator函数实现异步编程，利用的是协程的思想： 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 一段时间后，协程B交换执行权 协程A恢复恢复执行 协程A就是异步任务，分为了多段执行 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面的asyncJob就是一个协程，关键就在于yield命令，当程序执行到此处，asyncJob将执行权交给其他协程 整个Generator函数就是一个异步任务的容器，程序需要暂停的地方都需要使用yidld表达式 Generator之所以能够成为异步编程的旺盛解决方法，除了可以暂停执行和恢复执行之外，还因为Generator函数体内外的==数据交换和错误处理机制==。 上一篇笔记详细学习过Generator的基础知识了，看这里。 异步任务的封装看一个例子： 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); // fetch返回的是Promise对象 console.log(result.bio);&#125; 执行折断代码的方法： 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); Generator函数将异步流程表示的很简洁，但是流程管理不方便，即何时执行第一段、何时执行第二段 Thunk参数的求值策略求值策略关注的是函数的参数到底应该何时求值 有两种求值策略，一种是传值调用，即在进入函数体之前就进行计算，另一种是传名调用，即只将表达式传入函数体，旨在用到的时候求值。 传值调用有可能造成性能的浪费。 Thunk函数的含义编译器的传名调用，是将参数放到一个临时函数中，再将这个函数传入函数体，这个临时函数叫做Thunk函数 1234567var thunk = function () &#123; return x + 5;&#125;;function f(thunk) &#123; return thunk() * 2;&#125; Thunk函数是传名调用的一种实现，用来替换某个表达式 JavaScript中的Thunk的函数JavaScript中的Thunk函数替换的不是表达式，而是多参数函数，将多参数函数替换为只接受一个回调函数作为参数的==单参数函数==。 123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）const Thunk = fileName =&gt; &#123; return function(callback) &#123; fs.readFile(fileName, callback); &#125;&#125;const readFileThunk = Thunk(fileName);readFileThunk(callback) 任何函数，只要参数有回调函数，就能写成Thunk函数的形式，简单的Thunk函数转换器： 1234567const Thunk = function (fn) &#123; return function(...args) &#123; return fucntion(callback) &#123; return fn.call(this, ...args, callback) &#125; &#125;&#125; 使用： 12const readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback) Generator函数的流程管理Thunk函数可以用于Generator函数的自动流程管理，下面的Generator函数中封装了两个异步操作： 12345678910var fs = require('fs');var thunkify = require('thunkify');var readFileThunk = thunkify(fs.readFile);var gen = function* ()&#123; var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString());&#125;; 在使用Thunk函数管理之前，看一下如何手动执行上面这个函数： 123456789101112131415const g = gen();const r1 = g.next();r1.value(funciton(err, data) &#123; if (err) &#123; throw err; &#125; const r2 = g.next(data); r2.value(function(err, data) &#123; if (err) &#123; throw err; &#125; g.next(data) &#125;)&#125;) 为什么能够在r1.value里面传入一个函数呢？r1.value是第一个yield的结果，也就是readFileThunk(&#39;/etc/fstab&#39;)的结果，它是一个Thunk化的函数，返回值仍是一个函数，参数是回调函数： 123456// 相当于const thunk1 = r1.value;thunk1(function(err, data)&#123; // ...&#125;)) 通过上面的代码可以发现，Generator函数的执行过程，就是将同一个回调函数返回传入next方法返回值的value属性。 这使得我们可以通过递归来自动完成这个过程 Thunk函数的自动流程化管理Thunk函数的真正的威力，就在于可以==自动执行==Generator函数。下面是一个基于Thunk函数的Generator执行器 1234567891011function run(fn) &#123; const gen = fn(); function next(err, data) &#123; const result = gen.next(data); if (result.done) &#123; return; &#125; result.value(next) &#125;&#125; 有了这个执行器执行Generator函数的时候，不管内部有多少个异步操作，直接将Generator函数传入run函数即可（但是前提==每一个异步操作都要是Thunk函数==） 12345678var g = function* ()&#123; var f1 = yield readFileThunk('fileA'); var f2 = yield readFileThunk('fileB'); // ... var fn = yield readFileThunk('fileN');&#125;;run(g); Thunk函数并不是Generator函数自动执行的唯一方案，因为自动执行的关键是，必须==有一种机制，自动控制Generator函数的流程，接受和交换程序的执行权==。 Promise对象也可以代替回调函数做到这一点。 co模块co模块让你不用编写Generator函数的执行器： 12345678910const co = require('co');var gen = function* () &#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;co(gen).then(() =&gt; &#123;console.log('执行完成')&#125;) co函数返回一个Promise对象，当Generator函数执行完，可以用then方法添加回调函数。 co模块的原理co模块将两种自动执行器（Thunk函数和Promise对象）包装成一个模块，使用co模块的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或者Promise对象（或者数组或对象的成员全都是Promise对象） 基于Promise对象的自动执行同样的例子，将fs模块的readFile方法包装成为一个Promise对象： 12345678910111213141516171819const fs = require('fs');const readFile = function (fileName) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(fileName, (err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve(data) &#125;) &#125;)&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/filaA'); const f2 = yield readFile('/etc/filaB'); console.log(f1.toString()); console.log(f2.toString());&#125; 然后手动执行上面的函数： 1234567var g = gen();g.next().value.then(function(data)&#123; g.next(data).value.then(function(data)&#123; g.next(data); &#125;);&#125;); 实际上手动执行就是用then方法，层层添加回调函数（原理和前面的基于Thunk函数的自动执行器类似）： 123456789101112131415function run(gen)&#123; var g = gen(); function next(data)&#123; var result = g.next(data); if (result.done) return result.value; result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;run(gen); co模块的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function co(gen) &#123; var ctx = this; // 接受Generator函数作为参数，返回一个Promise对象 return new Promise(function(resolve, reject) &#123; // 检查参数gen是否为Generator函数。 // 如果是，就执行该函数，得到一个内部指针对象 // 如果不是就返回，并将Promise对象的状态改为resolved。 if (typeof gen === 'function') &#123; gen = gen.call(ctx); &#125; if (!gen || typeof gen.next !== 'function') &#123; return resolve(gen); &#125; // 将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。 // 这主要是为了能够捕捉抛出的错误。 onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; // next函数，它会反复调用自身 function next(ret) &#123; // 检查是否为Generator函数最后一步，是的话就返回最终结果 if (ret.done) &#123; return resolve(ret.value); &#125; // 将返回结果转换为Promise对象 var value = toPromise.call(ctx, ret.value); // 确保每一步的返回值，是 Promise 对象。 if (value &amp;&amp; isPromise(value)) &#123; // 使用then方法，为返回值加上回调函数 // 然后通过onFulfilled函数再次调用next函数 return value.then(onFulfilled, onRejected); &#125; // 在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象） // 将Promise对象的状态改为rejected，从而终止执行。 return onRejected( new TypeError( 'You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"' ) ); &#125; &#125;);&#125; 参考 Generator函数的异步应用@ECMAScript6 入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS55 Generator函数]]></title>
    <url>%2F2019%2F01%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS55%20Generator%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Generator函数的基本知识。 简介Generator函数有两个特征： function关键字后面有一个* 函数体内部使用yield表达式 123456function* helloWorldGenerator() &#123; yield 'hello'; yield 'word'; return 'ending'&#125;const hw = helloWorldGenerator() 调用函数后，函数并不执行，返回的也不是函数运行结果，而是指向内部状态的指针对象（即==遍历器对象==） 然后必须调用遍历器对象的next方法，让指针移向下一个状态，直到遇到yidld（或者return）为止。也就是说，yiled是暂停执行的标记，而next方法可以恢复执行： 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 每次调用nexd方法就会返回一个对象，对象有着value和done两个属性，value是yield后面的值，done是一个布尔值，表示便利是否结束。 yiled表达式yield是函数内部的暂停标志，执行逻辑： （1）遇到yiled暂停执行，将其后面的值作为next返回对象的value属性值 （2）下一次调用next方法，继续执行，直到遇到下一个yield （3）如果没有新的yield则运行到return或者函数运行结束 （4）将return的值作为返回对象的value属性值，如果没有return，返回对象的value属性值为undeinfed yield提供了==惰性求值==的功能。 ==yield表达式只能用在Generator函数里面，用在其他地方都会报错==。 与Iterator接口的关系可以将Generator函数赋值给对象的Symbol.iterator属性，从而使得对象具有Iterator接口 12345678910let obj = &#123;&#125;;[...obj]; // Uncaught TypeError: obj is not iterableobj[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...obj] // [1, 2, 3] next方法==yield表达式本身没有返回值==或者说总是返回undefined（这个指的是它在内部对于本身的传递，而非传递给next返回对象的value的属性值） 123456789101112function* f() &#123; let a = yield 100; console.log(a, 'a');&#125;let gen = f();gen.next();// &#123; value: 100, done: false &#125;gen.next();// undefined "a"// &#123; value: undefined, done: true &#125; a的值是undefined next方法可以带一个参数，这个参数会被当做==上一个==yield的表达式的返回值。 123456789101112function* f() &#123; let a = yield 100; console.log(a, 'a');&#125;let gen = f();gen.next();// &#123; value: 100, done: false &#125;gen.next('hello');// hello "a"// &#123; value: undefined, done: true &#125; 这个功能，可以在Generator函数开始运行后，==从外部向函数体内部注入值==，从而调整函数行为。 注意，==next注入的参数改变的是yield表达式的返回值==： 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // &#123; value:6, done:false &#125;a.next() // &#123; value:NaN, done:false &#125;a.next() // &#123; value:NaN, done:true &#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 当执行b.next(12)时，不是给y赋值12，而是yield (x + 1)为12，所以value是8 上面提到了，next的参数是赋值给==上一个==yield表达式返回值，所以在首次调用next传参是==无效==的。 ==第一次执行next方法，等同于启动执行Generator函数的内部代码== for...of循环for...of循环可以自动遍历Generator生成的Iterator对象，不需要再逐步调用next方法 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 要注意的是，==当nextd方法的返回值的done属性为true时，for...of循环就会终止，并且不包括return的值== 除了for...of之外，扩展运算符、解构赋值、Array.from内部都调用的遍历器接口，都可以将Generator函数返回的Iterator对象作为参数。 1234567891011121314151617function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2 Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获 123456789101112131415161718function* f() &#123; try &#123; yield 100; yield 200; &#125; catch(e) &#123; console.log('内部捕获', e) &#125;&#125;const gen = f();try &#123; console.log(gen.next()); // &#123; value: 100, done: false &#125; gen.throw('a'); // '内部捕获, a' console.log(gen.next()); // &#123; value: undefined, done: false &#125; gen.throw('a'); // '外部捕获, b'&#125; catch (e) &#123; console.log('外部捕获', e)&#125; 遍历器对象抛出的错误被Generator函数体内捕获后，Generator函数try语句内的其他语句就==不再继续运行==，并且遍历器对象抛出的其他错误也==不会被Generator函数内捕获==，而是被全局的catch捕获 try语句中抛出错误，try中的其他语句不会在继续执行 ==不要混淆遍历器对象的throw方法和全局的throw命令== 如果函数内部没有部署try...catch代码，遍历器对象抛出的错误会被外部的额try...catch代码捕获 要注意的是，throw抛出的错误要被内部捕获，前提是==必须执行过一次next方法==，因为不执行一次next代码，意味着Generator函数没有启动执行，所以错误会被抛出在函数外部。 遍历器对象的throw方法被捕获后，自动执行了一次next方法，并且只要Generator函数内部部署了try...catch代码，throw方法也不会影响下一次遍历 123456789101112131415function* f() &#123; try &#123; yield 100; yield 200; &#125; catch(e) &#123; console.log('内部捕获', e) &#125; yield 300;&#125;const gen = f();console.log(gen.next()); // &#123; value: 100, done: false &#125;console.log(gen.throw('a')); // '内部捕获, a', &#123;value: 300, done: false&#125; 这种在==函数体内==捕获错误的机制，大大方便了错误的处理，多个yield表达式，可以在函数内部==使用一个try...catch代码块==来捕获错误就可以了。 Generator函数内部的错误，也可以被函数体外的catch捕获，但是==函数内部的代码就不会再继续执行了==，JavaScript认为这个Generator已经==结束运行==了，再调用next方法会返回一个value属性为undefined，done属性为true的对象 Generator.prototype.return()Generator函数返回的遍历器对象有return方法，可以返回给定的值，提前==结束==Generator函数。 12345678910111213141516function* f() &#123; yield 100; yield 200; return 300;&#125;const g = f();g.next()// &#123; value: 100, done: false &#125;g.return(800)// &#123; value: 800, done: true &#125;g.next()// &#123; value: undefined, done: true &#125; return不提供参数，返回值的value属性是undefined。 如果Generator内部有try...finally代码块，且正在执行try代码，return方法会推迟到finally代码块执行完再执行 next、throw、return的共同点三者都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式 next是将yield表达式替换为一个值，throw是将yield表达式替换成throw语句，return是将yield表达式替换为return语句 1234567const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123; value: 3, done: false &#125; next： 123gen.next(1); // Object &#123; value: 1, done: true &#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; throw： 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return： 123gen.return(2); // Object &#123; value: 2, done: true &#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; yield*表达式如果在Generator函数内部调用另外一个Generator函数，默认情况下是无效的 123456789101112131415function* foo() &#123; yield 100; yield 200;&#125;function* bar() &#123; yield 300; foo(); yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 400 ==在Generator函数内部调用另外一个Generator函数需要用到yield*表达式==： 12345678910111213141516171819202122232425function* foo() &#123; yield 100; yield 200;&#125;function* bar() &#123; yield 300; yield* foo(); // 相当于 // yield 100; // yield 200; // 等同于 // for(let v of foo()) &#123; // yield v // &#125; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 100 200 400 yield*后面的Generator函数（没有return语句时）等同于在Generator函数内部部署一个for...of循环 123456789101112131415function* concat(iter1, iter2) &#123; yield* iter1; yield* iter2;&#125;// 等同于function* concat(iter1, iter2) &#123; for (var value of iter1) &#123; yield value; &#125; for (var value of iter2) &#123; yield value; &#125;&#125; 有return语句时，可以通过赋值var value = yield* iterator获取return语句的值，==yield*后面表达式中的return语句作为一个遍历的结果，而不是作为yield*的的返回值== 123456789101112function* foo() &#123; return 1;&#125;function* bar() &#123; const x = yield* foo(); return x;&#125;const gen = bar();gen.next();// &#123; value: 1, done: true &#125; 如果yiled*后面跟着一个数组，会直接遍历这个数组： 123456789101112131415161718192021function* foo() &#123; yield 300; yield [1, 2, 3]; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 [1, 2, 3], 400function* bar() &#123; yield 300; yield* [1, 2, 3]; yield 400;&#125;for(let i of bar()) &#123; console.log(i)&#125;// 300 1, 2, 3, 400 实际上，==任何数据结构只要有Iterator接口，就可以被yield*遍历==。 123456const read = (function* () &#123; yield 'hello'; yield* 'hello'&#125;)();read.next().value; // 'hello'read.next().value; // 'h' 作为对象属性的Generator函数可以简写为下面的形式： 12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例： 123456789function* gen()&#123;&#125;gen.prototype.say = function() &#123; console.log('hello')&#125;let obj = gen();obj instanceof gen; // trueobj.say(); // 'hello' 但是==Generator不能作为构造函数使用==，因为它的返回值总是一个遍历器对象，而非this对象（即使显示声明return this也不可以） 1234567function* gen()&#123; this.test = 123;&#125;let obj = gen();gen.test; // undefined Generator函数也不能和new一起使用，会报错。 Generator与协程协程有多个线程（函数），可以并行执行，但是只有一个线程（函数）处在正在运行的状态，其他线程（函数）都处于暂停状态（suspended），线程（函数）之间可以交换控制权。 协程以多占用内存为代价，实现多任务的并行。 Generator函数是ES6对协程的==不完全==实现，成为“半协程”，只有Generator函数的调用者才有权将程序的执行权还给Generator函数（完全协程，任何函数都可以将暂停的协程继续执行） 如果将Generator函数当作协程，可以将多个需要相互协作的任务写作Generator函数，之间==使用yield表达式交换控制权==。 练习 &amp; 应用判断Generator函数输出结果11234567891011121314function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();console.log(genObj.next());console.log(genObj.next('a'))console.log(genObj.next('b')) 思路：next的参数是对上一次的yield表达式返回值赋值，所以拆开来看： 123456function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); // -- genObj.next() &#123;value: undefined, done: false &#125;，此时第二个console.log被暂停了 console.log(`2. $&#123;yield&#125;`); // -- genObj.next('a') &#123;value: undefined, done: false &#125; 第二个console.log执行，传入了a return 'result'; // -- genObj.next('b') &#123;value: 'result', done: true &#125;，最后一个console.log执行，传入了b&#125; 判断Generator函数输出结果2123456789101112131415161718192021222324252627282930313233function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g()); Generator函数内部的错误，如果没有被内部捕获，则会被外部捕获，这时候Generator函数执行完毕，不再继续执行 注意，在内部抛出错误后，next返回值仍为上一次的返回值，并非抛出的结果。 结果： 123456// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 判断Generator函数输出结果3123456789101112131415161718192021222324function* foo() &#123; yield 2; yield 3; return "foo";&#125;function* bar() &#123; yield 1; var v = yield* foo(); console.log("v: " + v); yield 4;&#125;var it = bar();console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next()); 要注意的是，被代理的Generator函数的return语句，不再作为next方法的输出结果，而是用来向代理它的Generator函数返回数据 12345678910// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 3, done: false &#125;// v: foo// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125; 判断Generator函数输出结果41234567891011function* genFuncWithReturn() &#123; yield 'a'; yield 'b'; return 'The result';&#125;function* logReturned(genObj) &#123; let result = yield* genObj; console.log(result);&#125;console.log([...logReturned(genFuncWithReturn())]) 需要好好判断顺序，首先genFuncWithReturn()返回了一个迭代器对象，然后传入了logReturned中，按顺序执行，执行了console.log(result)之后，才会执行解构操作，所以顺序是： 12// The result// ["a", "b"] 如果换一种形式输出结果就不同了：123456for (let i of logReturned(genFuncWithReturn())) &#123; console.log(i)&#125;// a// b// The result 关键点就是解构操作符是等到函数执行后再执行的。 让for...of可以遍历原生对象原生的JavaScript对象时候不能使用for...of进行遍历的，因为并没有部署遍历接口。 123456789let obj = &#123; name: 'jay', age: 31&#125;for(let i of obj) &#123; console.log(i)&#125;// Uncaught TypeError: obj is not iterable 使用Generator函数，for...of可以遍历原生对象。 思路：由于原生对象没有部署遍历器接口，所以需要为对象的遍历器接口部署一个Generator函数，返回一个遍历器对象 123456obj[Symbol.iterator] = function* () &#123; let keys = Object.getOwnPropertyNames(this); for(let key of keys) &#123; yield [key, this[key]] &#125;&#125;; 可以编写一个更通用的方法： 12345678function makeIterator (obj) &#123; let keys = Object.getOwnPropertyNames(obj); obj[Symbol.iterator] = function* () &#123; for(let key of keys) &#123; yield [key, obj[key]] &#125; &#125;&#125; 我们之所以能够使用上面的Generator函数，就是因为它的返回结果是一个Iterator对象，这个Iterator对象有next方法，每次遍历时都要调用这个方法，返回的记结果就是包含了value和done两个属性的值 所以，我们不使用Generator函数，自己都构造返回一个具有next方法的对象也是可以的，next方法返回对象也需要包括了value和done连个属性，value属性是for...of的返回值，done用来标识遍历何时结束。 123456789101112function makeIterator (obj) &#123; let keys = Object.getOwnPropertyNames(obj); obj[Symbol.iterator] = function () &#123; let index = 0; return &#123; next() &#123; const key = keys[index] return &#123; value: [key, obj[key]], done: index++ === keys.length &#125; &#125; &#125; &#125;&#125; 第一次调用next方法就能够传值next的参数是赋值给==上一个==yield表达式返回值，所以在首次调用next传参是==无效==的。 构造一个wrapper函数，返回一个Generator函数，实现在第一次调用next方法时就能够输入值。 1234567const wrapped = wrapper(function* () &#123; console.log(`First input: $&#123;yield&#125;`); return 'DONE';&#125;);wrapped().next('hello!')// First input: hello! 思路：既然Generator首个next不能传参，那么就在我们的包裹函数中，将首次next调用在包裹函数内执行 1234567const wrapper = function(fn) &#123; return function(...args) &#123; const gnObject = fn(...args); gnObject.next(); return gnObject &#125;&#125; 利用Generator函数和for...of循环，实现斐波那契数列1234567891011121314function* fibonacci() &#123; let [prev, curr] = [0, 1]; for(;;) &#123; yield curr; [prev, curr] = [curr, curr + prev] &#125;&#125;for(let v of fibonacci()) &#123; if(v &gt; 100) &#123; break &#125; console.log(v)&#125; 实现一个clock状态机如果不使用Generator函数： 1234567const clock = (function () &#123; let ticking = true; return function () &#123; console.log(ticking ? 'tick' : 'tock'); ticking = !ticking &#125;&#125;)() 使用Generator函数： 12345678const clock = (function* () &#123; for(;;) &#123; console.log('tick'); yield; console.log('tock'); yield &#125;&#125;)() 输出多维数组中的值123456const numbers = flatten2([1, [[2], 3, 4], 5])numbers.next().value // =&gt; 1numbers.next().value // =&gt; 2numbers.next().value // =&gt; 3numbers.next().value // =&gt; 4numbers.next().value // =&gt; 5 思路就是递归调用Generator函数： 123456789function* flatten(arr) &#123; for(let i of arr) &#123; if (Array.isArray(i) &#123; yield* flatten(i) &#125; else &#123; yield i &#125; &#125;&#125; 要注意的就是，在一个Generator函数里面调用另外一个Generator函数，默认是无效的，所以必须使用yield*表达式来调用 遍历二叉树 对二叉树这里有些迷糊，因为基础不牢固，回头好好不玩了数据结构和算法，再来重新看一下这里（2019.01.17） 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 控制流管理如果一个多步操作非常耗时，采用回调函数，可能会写成下面这样： 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 改写成Promise格式： 123456789Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(value4 =&gt; &#123; // Do something with value4 &#125;, error =&gt; &#123; // catch the error from step1 through step4 &#125;) 改写成Generator格式： 1234567891011function* gen(value1) &#123; try &#123; const value2 = yield step1(value1); const value3 = yield step2(value2); const value4 = yield step3(value3); const value5 = yield step4(value4); // Do something with value4 &#125; catch(e) &#123; // catch the error from step1 through step4 &#125;&#125; 需要一个函数按次序调用： 12345678910scheduler(longRunningTask(initialValue));function scheduler (task) &#123; const taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if(!taskObj.done) &#123; task.value = taskObj.value; scheduler(task) &#125;&#125; 上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。 让Generator函数能够使用newGenerator函数不能和new命令一起用，会报错： 1234567function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 如何让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 12345678910111213141516171819function* gen () &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F ()&#123; // do something here&#125;let f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 实现： 123function F ()&#123; return gen.call(gen.prototype)&#125; 实际上这是一个有欺骗性的做法，实际上new关键字无效的，我们要的只是执行F即可。 1let f = new F(); 而gen.call(gen.prototype)相当于在gen原型上添加了属性，当访问f.a时实际上访问的就是原型链上的属性。 参考 Generator 函数的语法@ECMAScript6入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS54 无法使用Map遍历Array创建的数组的原因]]></title>
    <url>%2F2019%2F01%2F18%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS54%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Map%E9%81%8D%E5%8E%86Array%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[介绍了使用Map遍历Array创建的数组失效的原因 原文：Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work作者：shawn.webdev 示例为了便于说明，假设现在需要你生成一个数组，数组由数字 0~99 组成。你会怎么做？下面是一种方案： 1234const arr = [];for (let i = 0; i &lt; 100; i++) &#123; arr[i] = i;&#125; 也许你和我一样，不太喜欢在 JavaScript 中使用传统的 for 循环。实际上，由于像 forEach、map、filter、reduce 等高阶函数的出现，我已经很久没有使用传统的 for 循环了。声明性函数式编程太棒了！ 也许你还没有使用过函数式编程，认为上面的方法已经相当不错了。从技术层面上看没错，但是当你体会到函数式编程的魔力后，你可能就会思考是不是有更好的方法。 我对这个问题的第一反应是，“我可以创建一个长度为 100 的空数组，然后使用 map 遍历数组每个成员的索引！”在 JavaScript 中，我们可以使用 Array 构造函数去创建一个长度为 n 的空数组，就像下面这样： 1const arr = Array(100); 完美，对吧？我们创建了长度为 100 的数组，接下来我只需要 map 遍历每个元素的索引。 12const arr = Array(100).map((_, i) =&gt; i);console.log(arr[0] === undefined); // true 什么情况！数组的第一个元素应该是 0，但实际上是 undefined。 原理为了解释上面的现象，我必须介绍一个重要的技术特性。在 JavaScript 内部，数组就是用数字作为键名的对象。比如： 1['a', 'b', 'c'] 本质上它等于下面的对象： 123456&#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125; 当访问数组中索引 0 的元素时，实际上访问的是对象中键名为 0 的属性的键值。这很重要，因为当你把数组作为对象看待，再结合高阶函数的运行原理，上面的问题就很好理解了。 当你使用 Array 构造函数创建了一个新的数组时，实际上是创建了一个新的数组对象，它的 length 属性等于你传给 Array 的参数，除此以外，这个对象是一个空对象。对象中并没有数组对应的索引键（index key）。 1234&#123; //no index keys! length: 100&#125; 当你试图访问索引值为 0 的数组成员时，访问结果是 undefined，但这不是因为在索引键为 0 的位置存储的值是 undefined，而是因为 JavaScript 规定，当访问一个对象中并不存在的键名对应的键值时，会返回 undefined。 当 map、reduce、filter、forEach 等高阶函数沿着 0 到数组长度的索引键遍历数组对象时，就会发生上面的现象，但是只有当对象的键值存在时，回应的回调函数才会执行。所以，当我们使用 map 对数组遍历时没有执行回调函数–就是因为索引键并不存在。 解决方法正如你所了解的，我们需要的是这样的数组，它内部对应的对象形式包含着从 0 到数组长度的每一个键值。最好的办法就是将数组展开到另一个空数组中。 123const arr = [...Array(100)].map((_, i) =&gt; i);console.log(arr[0]);// 0 将数组展开到一个空数组后会生成一个新数组，它每个成员都是 undefined： 12345678&#123; 0: undefined, 1: undefined, 2: undefined, ... 99: undefined, length: 100&#125; 这是因为，扩展运算符比 map 方法更简单。它对数组（或者任何可遍历对象）进行从 0 到数组长度的简单循环，在当前的索引处，根据展开后的数组返回值，生成一个新的索引键。而 JavaScript 对展开数组的每一项都会返回 undefined （记住，这一些都是默认行为，因为访问的值对应的索引键并不存在），我们就得到了一个新的数组，数组成员都具备了索引键，因此是可以使用 map 进行遍历的了（同样也可以使用 reduce、filter、forEach 进行遍历） 结论我们发现了在 JavaScript 中数组的内部实质上就是对象，学习了创建任意长度、任意填充值的数组的最好的额办法。 同以往一样，在下面留下您的评论、疑问和反馈吧！ 编程愉快！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Array</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重学前端》的学习笔记]]></title>
    <url>%2F2019%2F01%2F18%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F01%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B402%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[极客时间的专栏《重学前端》的学习笔记，持续更新中。 开篇词 | 从今天起，重新理解前端前端开发之痛：散点自学 + 基础不牢，对于前端的知识体系和底层原理没有真正系统地理解 关于前端工程师成长需要两个视角： （1）立足标准，系统性总结和整理前端知识，建立自己的认知和方法论； （2）放眼团队，从业务和工程角度思考前端团队的价值和发展需要。 除此之外，前端工程师还需要了解程序员通用的编程能力和架构能力。 01 | 明确你的前端学习路线与方法两个前端学习方法： （1）建立知识架构 将零散的知识组织起来，也能帮助我们发现知识上的误区 （2）追本溯源 关注某个知识点背后的体系 03 | HTML语义：div和span不是够用了吗？语义类标签的特点是在视觉表现上都差不多，主要区别在于表示了不同的语义。 语义标签的好处：（1）增强网页结构可读性；（2）更适合SEO和读屏软件 语义标签用不好会造成大量的冗余标签，所以“用对”比“不用”好，“不用”比“用错”好 比较重要的语义标签适用场景： （1）作为自然语言延伸的语义类标签，例如&lt;ruby&gt;、&lt;rt&gt;、&lt;rp&gt; （2）作为消除歧义的标签，例如表示重音的&lt;em&gt; （3）作为标题摘要的标签，例如&lt;h1&gt;、&lt;hgroup&gt;、&lt;section&gt; （4）作为整体结构的语义类标签。例如&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;address&gt; 123456789101112131415&lt;body&gt; &lt;header&gt;……&lt;/header&gt; &lt;article&gt; &lt;header&gt;……&lt;/header&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; &lt;article&gt;……&lt;/article&gt; &lt;article&gt;……&lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; 04 | HTML语义：如何运用语义类标签来呈现Wiki网页？用Wiki的一个页面举例，学习了语义化标签的使用。 这一节介绍到的语义化标签有： aside，导航性质的工具内容 article，有明确独立性的主体部分 hgroup/h1/h2，一个标题组中的各级标题 abbr，缩写的词语都应该使用abbr标签 hr，横向分割线，但是表示故事走向或话题的转变，如果是单纯的视觉效果不应该使用这个标签 strong，强调的 blockquote，段逻辑的引述内容 q，行内的引述内容 cite，引述的作品名 time，日期，让机器阅读更方便 figure/figcaption，与著文章先骨干的、有一定自包含性的内容，都可以用figure包裹，可以是图片、表格、代码等，figcaption是这些内容的标题 dfn，包裹被定义的名字，例如：&lt;dfn&gt;程序员&lt;/dfn&gt;就是写程序的人 nav，目录导航 ol/ul，二者的区别是内容是否有顺序关系，不要因为视觉表现夏鸥改变语义 pre，表示其中的内容是预先经过排版的，不需要浏览器干预排版（保留了原来的缩进格式） samp：计算机程序的实例输出 code：代码，和samp一样，一般都是包裹在pre之中 还有一些其他的标签： date，类似于time，给及其阅读的内容 sub/sup，下标/上标，多用于数学、物理、化学领域 menu，ul的变体，用于功能菜单使用 main，整个页面出现一个，表示页面的主要内容，可以理解为特殊的div 语义化标签非常多，并且不像严谨的编程语言一样，有一条非此即彼的线。一些语义的引入会带来争议，所以应该尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签，保证语义不被滥用，不带来更多问题。 05 | JavaScript类型的细节类型JavaScript中定义了7种类型： Undefined Null String Number Boolean Symbol Object Undefined/NullJavaScript中的undefined是一个变量，而非一个关键字。任何变量在赋值之前都是Undefined类型，值为undefined，是一个全局变量，所以有： 12345undefined === undefined; // truelet a;let b;a === b; // true void运算的作用是将一个表达式变为undefined： 12345let a = void 0;a; // undefinedlet b = void &#123;&#125;;b; // undefined 一般不会将变量赋值为undefined，保证所有值为undefined的变量都是从未赋值的自然状态 Null类型也只有一个值null，所以有： 1null === null; // true Null语义是定义了，但是为空，这与Undefined是不同的 StringString的最大长度是2^53-1，这个长度指的不是字符数，而是字符串的编码长度 字符串操作charAt、charCodeAt、length针对的都是UTF16编码 UTF是Unicode的编码方式，一个Unicode码点表示一个字符，通常用U+????来表示，其中????是十六进制的码点值，0-65536（U+0000-U+FFFF的码点被称为基本字符区域 在JavaScript中的表示： 1'\u0031'; // 1 JavaScript字符串把每个UTF16单元当做一个字符串来处理，所以处理超出自己字符区域的字符时需要格外小心。 感觉阮一峰关于字符编码的知识讲的更加详细。 NumberNumber类型符合IEEE754-2008规定的双精度浮点数规则，但是为了表达几个额外的语言场景，规定了几个例外情况 NaN Infinity，无穷大 -Infinity，负无穷大 Infinity和-Infinity是为了不让除以0出错而引入的 JavaScript中有0和-0的区别，加法类运算没有区别，除法场合需要留意区分，区分的方式就是检测用作除数的结果，是Infinity还是-Infinity 121/-0 ===-Infinity; // true1/0 ===Infinity; // true 由于浮点数运算的精度问题，导致非整数得Number不能直接比较： 10.1 + 0.2 === 0.3 // false 正确的比较方法是使用JavaScript提供的最小精度之Number.EPSILION 1Math.abs(0.1 + 0.2 - 0.3) &lt; Number.EPSILION // ture ==检查等式左右两边的差是否小于最小精度==，才是正确的比较浮点数的方法。 SymbolSymbol是一切非字符串的类型key的集合，使用全局的Symbol函数创建Symbol 1var mySymbol = Symbol("my symbol"); 一些特殊的属性可以在全局的Symbol函数的属性中找到，比如可迭代对象的迭代器就定义在了Symbol.iterator属性上 12345678910111213let o = &#123;&#125;;o[Symbol.iterator] = function* () &#123; let index = 0; while(index &lt; 10) &#123; yield index++ &#125;&#125;;for(let i of o) &#123; console.log(i)&#125;// 0 1 2 3 ... 9 更多的内容需要专门学习。 Object提出了一个问题，为什么给对象添加的方法能够用在基本类型上？ 1234Number.prototype.say = function () &#123; console.log(123)&#125;;(123).say(); // 123 ==这是因为.运算符提供了封箱操作，它会根据基本类型构造一个临时对象，使得我们能够在基本类型上调用对应的对象的方法。== 类型转换封箱转换把基本类型转换为对应的对象，装箱独享都有私有的Class属性，可以用Object.prototype.toString来获取。 JavaScript中没有任何办法可以更改私有的class属性，因此Object.prototype.toString是可以准确识别对象对应的基本类型的方法 拆箱转换ToPrimitive函数是对象类型到基本类型的转换，对象到String和Number的转换都遵循“先拆箱再转换”的规则，拆箱转换会调用valueOf和toString类获得拆箱后的基本类型 转换为数字时首先调用valueOf，转换为字符串时首先调用toString ES6中可以通过显示指定Symbol.toPrimitive来覆盖原有行为 06 | JavaScript对象：面向对象还是基于对象JavaScript中的对象与其他语言的对象有一些不同之处，例如： JavaScript在ES6以前没有类的概念 JavaScript对象可以自由添加属性，其他语言不能 到底什么是面向对象？ 面向对象是顺着人类思维模式产生的一种抽象，从人类认知角度，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西 人的智力可以理解的东西 可以指导思考或行动（进行想象或施加动作）的东西 JavaScript没有采用C++、Java等流行的编程语言采用的“类”的方式来描述对象，而是采用了一个更为冷门的方式“原型”来描述对象 但是由于公司正值原因，JavaScript推出时在“原型运行时”的基础上增加了new、this的特性，使之看起来更像Java。 对象的特点对象有如下的特点： （1）对象具有唯一标识性：即使完全相同的两个对象，也并非一个同一个对象 对象的唯一标识性是用内存地址来体现的，对象具有唯一标识的内存地址 123var o1 = &#123; a: 1 &#125;;var o2 = &#123; a: 1 &#125;;console.log(o1 == o2); // false （2）对象有状态：对象具有状态，同一个对象可能处于不同状态之下 （3）对象具有行为：对象的状态，可能因为它的行为产生变迁 第二个和第三个特征“状态”和行为，在JavaScript中统一抽象为“属性”（因为JavaScript中函数也是一个特殊的对象） JavaScript在实现对象基本特征的基础上，JavaScript对象独有的特色是：==对象具有高度的动态性，这是因为JavaScript赋予了使用者在运行时为对象添改状态和行为的能力==。 JavaScript对象的两类属性JavaScript对象的属性并非只是简单的键值对，而是用一组特征来描述属性 第一类是数据属性（descriptor），有四个特征：value/writable/enumerable/configurable 第二类是访问器属性，也有四个特征（setter/getter/enumerable/configruable 访问器属性使得使用者在读和写属性时，可以执行代码得到不同的值，可以视为一种函数的语法糖 通常定义属性的代码会产生数据属性的value特征值，其他的数据属性的特征值默认为true，使用Object.getOwnPropertyDescripter可以查看数据属性特征值，使用Object.defineProperty可以改变数据属性特征值和访问器属性 在创建对象时，可以使用get和set关键字阿里创建访问器属性： 1234567var o = &#123; get a() &#123; return 1 &#125; &#125;;console.log(o.a); // 1 对象是一个属性的索引结构，key是属性名，属性值是一系列描述属性的集合 123456&#123; value: 1, writable: true, enumerable: true, configurable: true&#125; JavaScript提供了完全运行时的对象系统，可以模仿多数面向对象的编程范式，比如基于类和基于原型，但是由于它的对象系统是独特的、具有高度动态性的对象系统，这让它与其他面向对象的语言不通 07 | JavaScript对象：我们真的需要模拟类吗早期JavaScript的模拟面向对象，实际上是模拟基于类的面向对象 而JavaScript的面向对象本质上是基于原型的，而由于历史原因，不得不加入了new、this等语言特性来模拟类 JavaScript的原型复制操作采用了引用的思路：一个对象并不是真的去复制一个原型对象，而是使得新对象持有一个原型的引用 原型系统用两条概括原型系统 对象通过私有字段[[proto]]连接到其原型 读取一个属性，如果对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止 ES6提供了一些列内置函数，可以更方便的访问、操作原型，使用这三个方法，可以完全抛开类的模拟，直接利用原型来实现抽象、继承和复用。这三个方法是： Object.create(a, b)，根据指定的原型（a）创建新对象，原型可以是null，b是新对象的描述属性（数据属性） Object.getPrototypeOf获得一个对象的原型（等同于直接获取对象的__proto__属性） Object.setPrototypeOf设置一个对象的原型（等同于直接设置对象的__proto__属性） 用构造函数模拟类我们现在用来判断类型的最准确的方法Object.prototype.toString获得的结果[object xxxx]，实际上就是早期版本的“类”的概念，它原本是一个私有属性[[class]]，从ES5开始，[[class]]被Symbol.toStringTag定义，而Object.prototype.toString的结果可以使用Symbol.toStringTag定义： 12var o = &#123; [Symbol.toStringTag]: "MyObject" &#125;;console.log(Object.prototype.toString.call(o)); // [object MyObject] 用构造函数模拟类，关键就是使用new运算符，当我们对一个构造函数执行了new操作，实际上发生了一下几件事： 1234567let p = new Person();// 实际上let p = &#123;&#125;;p.__proto__ = Person.prototype;Person.call(p);return p new运算的返回值默认返回this，但显式的返回值时，如果返回值的是==基本类型==，则忽略返回值，仍然返回this，如果返回值是==引用类型==，则直接返回该返回值作为对象的结果 new的行为，视图让函数对象在语法上跟类变得相似，它客观上提供了两种范式，一种是在构造器中的this上添加实例属性，另外一种是在构造器的prototype原型对象上添加原型属性 在早期没有Object.create等方法的早期版本中，new是唯一一个可以指定[[proto]]的方法（直接访问__proto__是不被推荐在生产环境使用的） 下面是Object.create简单的Polpyfill： 12345function create (prototype) &#123; function F() &#123;&#125; F.prototype = prototype; return new F()&#125; ES6中的类classES6中的class用一种看起来更符合主流意义上的类的形式来模拟JS中的类，但本质上还是利用原型系统实现继承和复用，只不过用class代替了new和function的搭配，看起来更协调而已。 推荐使用ES6的语法来定义类，令function回归原本的函数语义。 ES6中引入的class关键字，意味着类的概念从属性升级为语言的基础设施，从此，基于类的编程方式成为了JavaScript的官方编程范式。 在类中通过get/set关键字创建getter/setter，类中定义的方法和属性会被写在原型对象上，数据型成员最好写在构造器里面： 1234567891011121314class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; // Getter get area() &#123; return this.calcArea(); &#125; // Method calcArea() &#123; return this.height * this.width; &#125;&#125; 类的写法实际上也是由原型运行时来承载的（我认为是原型系统的一种语法糖），逻辑上JavaScript认为每个类是有共同原型的一组对象。 类通过extends提供了继承能力： 12345678910111213141516171819202122class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); // call the super class constructor and pass in the name parameter &#125; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;let d = new Dog('Mitzie');d.speak(); // Mitzie barks. 比起早期的继承方式，extends关键字自动设置了constructor，并且会自动调用父类的构造函数，是一种更少坑的设计。 所以当我们使用类的思想来设计代码时，应该尽量使用class来声明类，而不是用旧语法，拿函数类模拟对象 （但是我认为，可以使用新的语法，但是如果不搞清楚本质还是不行的，需要弄清楚JavaScript实现继承和复用的根本原理，搞清楚JavaScript中原型链的原理，这是根本） （这一节的内容实际上信息量很大，讲述的是JavaScript中最基础、最精华的部分，设计能力的提高离不开这部分基础，之前自己总结过相关的笔记《Javascript面向对象编程2–构造函数的继承》，需要反复的思考和复习，打好基础） 08 | JavaScript对象：你知道全部的对象分类吗？ 这两天，offer的事情有了着落，又刚过完年回来，工作又闲的冒泡，自我驱动能力大幅下降，有点控制不住自己了 关于这一章的内容，实际上是比较复杂且深奥的，需要好多储备知识才能大概理解，而前几章我一直有一个不太满意的点，就是感觉作者的思路，或者说是语言组织，有一种故作高深的感觉，把简单的东西搞的很复杂的样子，把不好理解的知识用一些更不好理解的语言讲解，让人理解起来更加费劲，而且思路常常碎片化。 比较之下，更显得阮一峰的难得，举重若轻，平易近人，这才是我学习的榜样。 可以把对象分成几类： （1）==宿主对象==，有JavaScript宿主环境提供的对象，它们的行为完全由宿主环境决定 （2）==内置对象==，有JavaScript语言提供的对象，包括： 固有对象，有标准规定，随着JavaScript运行时创建而自动创建的对象实例 原生对象，可以由用户通过Array，RegExp等内置构造器或者特殊语法创建的对象 普通对象，由{}、Object构造器或者class关键字创建的对象，能够被原型继承 宿主对象JavaScript中常见的宿主对象就是浏览器提供的宿主对象，在这个宿主对象中，全局对象是window，window上有很多属性，比如document 实际上，window对象上的属性一部分来自浏览器环境，另外一部分来自JavaScript语言（JavaScript的标准中规定了全局对象属性） 宿主对象也分为固有的和用户可创建的两种，比如document.createElement就可以创建一些dom对象 宿主也会提供一些构造器，比如可以使用new Image创建&lt;img&gt;元素 内置对象·固有对象固有对象在任何JavaScript代码执行前就已经被创建出来了，它们通常扮演者饿类似基础库角色，ECMA中规定的固有对象有150+个 内置对象·原生对象我们将JavaScript中，能够通过语言本身的构造器创建的对象作为原生对象。JavaScript提供了30多个构造器，可以分成以下几类： 可以使用new运算符调用构造器创建新的对象，这些构造器的能力是原生的（即无法用纯JavaScript代码实现的），也无法用class/extend来继承的 这些构造器创建的对象多数使用了私有字段，例如Error: [[ErrorData]]、Boolean: [[BooleanData]]等，这些字段使得原型继承方法无法正常工作，所以可以认为，这些原生对象都是为了特定能力或性能，而设计出来的“特权对象” 用对象来模拟函数与构造器：函数对象和构造器对象JavaScript为用来模拟函数与构造器的对象预留了私有字段，并据此规定了抽象的函数对象和构造器对象的概念 函数对象的定义是，具有[[call]]私有字段的对象 构造器对象的定义是，具有[[construct]]私有字段的对象 JavaScript用对象模拟函数的设计代替了一般的编程语言中的函数，它们可以像其他语言的函数一样被调用、传参。任何宿主，只要提供了“具有[[call]]私有字段的对象”，就可以被JavaScript的函数调用的语法锁调用 [[call]]私有字段必须是一个引擎中定义的函数，需要接受this值和调用参数，并且会产生域的切换。 任何对象只需要实现[[call]]，它就是函数对象，可以作为函数被调用。如果它能够实现[[construct]]，它就是构造器对象，可以作为构造器被调用。 宿主对象和内置对象的表现对于宿主对象和内置对象来说，他们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器调用）也不总是一致。比如内置对象Date作为构造器调用时产生新的对象，作为函数时则返回字符串 12345typeof Date()// "string"typoeof new Date()// "object" 在浏览器宿主环境中提供的Image构造器，则根本不允许被作为函数调用： 12345new Image()// &lt;img&gt;Image()// Uncaught TypeError: Failed to construct 'Image': Please use the 'new' operator, this DOM object constructor cannot be called as a function. 基本类型（String、Number、Boolean）作为构造器时返回对象，作为函数调用时则产生类型转换的效果。 ==注意的是，ES6的箭头函数创建的仅仅是函数，而不能作为构造器使用。== 使用function创建的函数的行为当使用function关键字或者使用Function创建的函数必定同时是函数和构造器，它们执行同一段代码，但是表现出来的行为效果却不相同。 以前遇到过面试题，题目的中心思想就是如何判断一个函数是作为构造函数调用，还是作为普通函数被调用。两种行为的结果是不同的，进行判断的话就需要搞清楚new调用构造函数时发生了什么： 创建一个新的对象{} 实现原型链的继承 将构造函数的作用域赋给新对象（因此this对象就指向了新对象） 执行构造函数的代码 返回新对象（构造函数调用默认返回this，但显式的返回值时，如果返回值的是基本类型，则忽略返回值，仍然返回this，如果返回值是引用类型，则直接返回该返回值作为对象的结果） 所以要判断我认为只需要在函数内部判断this是否是该函数的实例即可。 对象的特殊行为在固有对象和原生对象中，有一些对象的默写行为与正常对象有很大区别，主要是下标运算（即使用中括号或者.来做属性访问）和设置原型继承 主要有： Array： Array的length属性根据最大的下标自动发生变化 String：String的正整数属性访问会去字符串里查找 arguments：arguments的非负整数型下标跟对其函数父对象的输入的变量联动 Object.prototype：作为所有正常对象的默认原型，不能在设置原型了（这就是语言的规定，Object.prototype.__proto__ === null，没有为什么） 模块的namespace对象：特殊的地方非常多，跟一般对象完全不用了 一个练习不使用new运算符，极可能找到获得对象的方法 1234567891011let o = &#123;&#125;;const o = function()&#123;&#125;;let o = Object.create(Object.prototype);let o = Object.assign(&#123;&#125;)class o &#123;&#125;let o = JSON.parse('&#123;&#125;')]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》的学习笔记]]></title>
    <url>%2F2019%2F01%2F18%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F01%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B401%20%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%2F</url>
    <content type="text"><![CDATA[极客时间的专栏《左耳听风》的学习笔记，持续更新中。 01 + 02 | 程序员如何用技术变现 程序员用手艺、技术养活自己，不依靠公司； 提高工作效率，去研究那些难的，公司内外的核心技术； 注重输出，输出技术、价值观，帮助更多的人，提高影响力。 如何做？ 积少成多，形成正向循环 关注有价值的东西，关注市场市场需求和技术趋势 在学习技术的过程一定要多问自己两个问题：“一，这个技术解决什么问题？为什么别的同类技术做不到？二，为什么是这样解决的？有没有更好的方式？” 找到最能体现价值的地方，技术人员在高速发展的公司价值可以最大化 加强动手能力，了解细节才能提出更好、更靠谱、可以落地的解决方案 关注技术付费点：①帮别人挣钱；②帮别人省钱 提升自己的能力和经历 找到有价值的信息源，提升英文能力，利用好Google 输出观点和价值观，这不容易，需要积累和经历，厚积薄发 真正伟大的公司和价产品都是要输出价值观的 朋友圈很重要 ==最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱不用还在那里，时间不用就浪费掉了。把时间投资在哪些地方，意味着未来会走什么样的路。== 03 - 04 | 从Equifax信息泄露看数据安全攻击的实现： 利用程序框架或者库的漏洞 暴力破解密码，撞库 代码注入，SQL注入，XSS攻击，CSRF攻击 利用程序日志意外泄露的信息 数据管理的问题： 一层防护 弱密码 内部系统暴露在公网 系统不及时打补丁 安全日志被暴露 保存不必保存的敏感信息 密码没有被合理地散列 安全最佳实践 了解使用了哪些框架和库，关注其安全性声明 建立能够快速部署安全补丁的发布流程 依赖的软件都有可能有安全性漏洞，建立安全策略时要考虑 建立多个安全层 建立对异常访问模式的监控机制 技术上的安全做法: 隔离关键数据到高安全级别的地方 敏感数据只进不出，提供对外服务接口操作数据 业务上需要返回的关键数据需要在传输层加密并且隐藏部分信息 用户加密算法需要非对称加密，密钥自动更换 被加密的数据和用于加密的密钥是由不同的人来管理，相互牵制 信息泄露需要做到通知，并限制外部系统的数据访问量 05 | 何为技术领导力何为技术领导力？ 尊重技术，追求核心基础技术 不断追求效率的提高： 工具自动化 组织架构的高效运转 人员的高效工作 开发可复用组件 坚持高于社会主流的技术标准和要求 如何拥有技术领导力？ 能够发现现有方案的问题 能够提供解决问题的思路和方案，并能比较这些方案的优缺点 能够做出正确的技术决定和技术选择，完成一个项目 能够更优雅、更简单、更容易的方式解决问题 能够提高代码的质量（扩展性、复用性、可维护性） 能够用正确的方式管理团队（人尽其用、提高效率） 有创新能力 ==总是在提供解决问题的思路和方案的人才是有技术领导力的人== 努力方向： 扎实的基础技术 非同一般的学习能力 坚持做正确的事 不断提高对自己的要求标准 06 | 如何才能拥有技术领导力（1）吃透基础技术 基础技术可以分为两部分：==编程和系统== 编程部分：C语言，编程范式，算法和数据结构； 系统部分：计算机系统原理，操作系统原理和基础，网络基础，==数据库原理==，分布式技术架构 （结合自身情况和职业，我认为加粗的几个部分可能是作为前端工程师的我来说是优先级更高的基础技术） （2）提高学习能力，能够很快的学习新技术，==又能在关键技术上深入==的能力 学习的信息源（英文搜索更接近最新的知识） 与高手交流 举一反三的思考 不怕困难的态度 开放的心态 （3）坚持做正确的事 提高效率的事 自动化的事 掌握前沿技术的事 知识密集型的事 技术驱动的事 （4）高标准要求自己，不断地反思、总结和审视自己 07 | 推荐阅读：每个程序员都该知道的知识每个程序员都应该要读的书： 《代码大全》，有点过时，但很经典 《程序员修练之道》，指路明灯 《计算机的构造和解释》，经典中的经典 《算法导论》，美国的本科生教材 《设计模式》，指路明灯 《重构》，代码重构最佳时间 《人月神话》，有点过时，但很经典 《代码整洁之道》，细节指出的效率，完美和简单 每个计算机专业的学生应该有的知识：（1）作品集（项目经历、开源软件的贡献、网址）比简历更重要 （2）与人交流的技巧（写演示文档、辩论能力） （3）硬技能（太多了，毫无目的的学习恐怕要耗费数年，必须有的放矢吧？） LinkedIn 高效的代码复查技巧提出做Code Review要求对提前的代码写说明文档，既可以方便做Code Review的人了解代码背景，又可以让写代码的人重新回头梳理代码 并且除了给出修改意见之外，也允许给出正面鼓励的评价 给出的Code Review写出有目的性的注释，比如“消除重复代码”、“增加测试覆盖率”等 不光要Review代码，还要Review对应的测试 还有给出的两篇文章，感觉不是我现在能吸收的，能把前边的书单完成，就是一个大的成就了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>极客时间</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点感想]]></title>
    <url>%2F2019%2F01%2F18%2F02%20%E5%81%B6%E5%B0%94%E8%AE%B0%E5%BD%95%2F2019%2F2019.01.18%20%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[突发而来的一点感想。 这一段时间的经历，让我对自己的现状和不足有了一个更清醒的认知，那就是： 学习能力不错，但是由于客观情况导致的前端乃至计算机基础薄弱； 前端知识点的深度有所加深，但还是没有能连成片； 过于依赖的强推动去提高自己，发现问题、发现痛点的主观能动性差 针对这些，我2019年的努力方向就是： 继续自我驱动，不断学习 继续之前定下的“基础扫盲三部曲”的第三步，体系化的学习算法和数据结构 有意识的去记录身边、开发过程中的难点、痛点，想办法解决问题，提高自己发现问题的能力，从解决自己的小问题开始，正确能够从更高层面，解决团队、公司的问题 对新技术保持好奇，对新技术的了解、学习、实践不拖延。 按照计划一步一步来吧，沉着一点，少点焦虑，多点坚定。 加油。]]></content>
      <categories>
        <category>偶尔记录</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习49 判断美元符号格式]]></title>
    <url>%2F2019%2F01%2F15%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A049%20%E5%88%A4%E6%96%AD%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用正则表达式判断美元符号格式的练习题，以及使用正则表达式为数字添加千分符 知识点正则表达式 题目完成一个函数isUSDFormat返回true/false来判断一个字符串是否符合美元格式： 以$开头 如果是小数，保留两位小数；如果不是小数则不显示小数部分 整数部分从小数点上一位开始每隔三位用,分割开来 如果整数部分从数字0开始，则只会显示一位0 例如： 1234567isUSDFormat('$1') // =&gt; trueisUSDFormat('$1.0') // =&gt; falseisUSDFormat('$100,000.00') // =&gt; trueisUSDFormat('$0,000.00') // =&gt; falseisUSDFormat('$0.00') // =&gt; trueisUSDFormat('$11,23,345.33') // =&gt; falseisUSDFormat('$1,123,345.33') // =&gt; true 实现这道题目和之前在面试中遇到过的为数字添加逗号的问题有一点点类似，先来看这道题目。 正则表达式是非常强大的，如果不用正则表达式，需要在函数里面进行拆分判断，所以还是需要多练习正则的使用 这道题，我又没有做出来，还是水平太低，看了讨论区的答案，好好分解一下： 实现，要判断的格式分为三个部分，就是$加上整数部分再加上（肯能存在的）小数部分： 1/^$(整数部分)(小数部分)?$/ 先看比较容易的小数部分，小数部分如果存在时，构成就是小数点加上两位数字，所以： 12// 小数部分/\.\d&#123;2&#125;/ 再来看整数部分，整数部分大体上可分为两种情况，情况1是以0开始，情况2就是不以0开始，那么两种情况可以用|来分割，两种情况都是满足要求的： 12// 整数部分((情况2)|0) 再来看情况2，它有两个要求，首位不能是0，并且从末尾（单词结束或者小数点位置）起每三位用,分割，所以情况2为： 1/[1-9]\d&#123;0,2&#125;(,\d&#123;3&#125;)*/ 上面表达的意思就是第一位是非0的整数，然后接着的数字可能是0，1，2三种，也就是说三面这一半匹配了x/xx/xxx三种形式的数字，后面如果再有数字的话就是后面括号中的内容，必须接着一个逗号和三位数字，当然这部分也可以没有，所以用*来限制数量 所以拼接到一起就是： 1const isUSDFormat = str =&gt; /^\$([1-9]\d&#123;0,2&#125;(,\d&#123;3&#125;)*|0)(\.\d&#123;2&#125;)?$/.test(str) 为数字添加逗号说说拿到面试题，很简单，就是使用正则为一个数字，从右向左每三位添加一个, 这道题目我当时没有用直接用正则做出来，因为我觉得正则是从左至右进行判断，而现在是从右至左添加，所以不知道怎么搞。 我当时的做法就是将字符串反转后进行添加，添加完了再反转回去。 如果不采用这种形式怎么实现呢？ 首先要了解一下在正则中的先行断言 先行断言是是用来判断位置的，比如x(?=y)，代表的是如果x后面跟的是y，那么就匹配x，在xyz中，匹配结果就是x，不包括y，因为y是作为先行断言进行判断位置的。 与先行断言对应的就是后行断言(?!)，比如x(?!y)表示后面不是y才会匹配x，所以xyz中的x就不会被匹配，而xzy中的x会被匹配 然后再来看一下我们要用到的\b和\B，它们是用来匹配位置的（注意是匹配，而不是判断），\b匹配的是单词边界，而\B正好相反，也就是匹配非单词边界的位置 我的理解是，比如123，\b匹配是1之前和3之后的位置，\B匹配的是1和2以及2和3之间的位置 1234 1 2 3 | | | | | | | | \b \B \B \b 那么如果用replace方法对\b和\B的匹配进行替换是什么效果呢？ 123let a = '123'.replace(/\b/g, '!')a // "!123!" 实现了添加的效果，因为被我们替换掉的是一个位置，而非一个字符。这就是我们能够使用replace实现需求的原因。 然后来看具体的正则表达式，以12345举例 我们首先要明确，要匹配的就是一个位置，这个位置将被替换为,，这个位置的特殊性是它后面应该跟着3个数字 到目前位置我们的正则表达式就是： 1/\B(?=(\d&#123;3&#125;))/ 上面，\B匹配非单词边界，匹配的结果将是12/23/34/45各自数字之间的位置 然后后面通过一个先行断言对\B进行了约束，那就是这个位置后面必须跟着3个数字，那现在匹配的结果就是12/23之间的位置了，都可以满足要求 实际上12之间后面跟着3个数字，3个数字后面又跟着一个数字，而我们要的不是这样，它后面需要是单词的结束（或者说是单词的边界），所以需要在后面增加另外的位置判定（$或者\b） 1/\B(?=(\d&#123;3&#125;)\b)/ 这样就能正确12345，而对于12345123456，可能有多个符合条件的先行断言位置要匹配，所以需要增加量词+ 1/\B(?=(\d&#123;3&#125;)+\b)/ 我之前理解错了，以为是有多个\B要匹配，+应该加在最外层的括号外边，其实不是，多个\B要匹配是replace的g完成的 所以最后的结果是： 1const reformat = str =&gt; str.replace(/\B(?=(\d&#123;3&#125;)+\b)/g, ',') 这只是对整数部分的处理，如果有小数部分，我没想到怎么直接用正则一次搞定，还是需要先判断是否有小数，然后将整数部分分割出出来单独处理，然后再把小数部分拼接上。 参考 #87 判断美元符号格式@ScriptOJ 正则表达式-数字每隔3位加入逗号@MDN 正则表达式/\B(?=(\d{3})+(?!\d))/怎样给数字添加千分符的@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习48 字体高亮函数]]></title>
    <url>%2F2019%2F01%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A048%20%E5%AD%97%E4%BD%93%E9%AB%98%E4%BA%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关于标签模板的练习题 知识点标签模板 题目完成highLight函数，可以把模板字符串中的插入内容替换掉，并且插入文档后显示红色，例如： 123const yourName = 'ScriptOJ'const myName = 'Jerry'document.body.innerHTML = highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` CSS样式： 123.red &#123; color: red&#125; 实现上面的关键是函数调用那一行： 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` 以我浅薄的学识，认为是题目出错了，哪有这样进行函数调用的，所以自作主张按照下面的调用方式实现： 1highlight('Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.') 按照这种形式，以前联系过类似的问题，使用new Function可以实现替换模板字符串变量的功能： 12345678910111213const highlight = (str) =&gt; &#123; let reg = /\$\&#123;(.+?)\&#125;/g; let match = reg.exec(str); let result = []; while(match) &#123; result.push(match[1]); match = reg.exec(str); &#125; return str.replace(reg, (match, p1) =&gt; &#123; const string = new Function(...result, `return $&#123;p1&#125;`)(...result.map(v =&gt; eval(v))); return `&lt;span class="red"&gt;$&#123;string&#125;&lt;/span&gt;` &#125;)&#125;; 但是实际上，题目根本没有出错，就是这样的调用形式： 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;.` 这种调用形式叫做==标签模板==功能。 标签模板功能模板字符串可以紧跟在一个函数后面，函数将被用来处理这个模板字符串，这就是标签模板功能： 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种形式，函数后面紧跟的字符串就是函数的参数。 当字符串中有变量时，会将模板字符串处理为多个参数，再调用函数，比如： 123456const a = 5;const b = 10;alert`hello $&#123;a + b&#125; world $&#123;a * b&#125;`// 等同于alert(['hello ', ' world', ''], 5, 10) alert的返回值就是函数处理模板字符串后的返回值，函数会接收到多个参数： 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; 函数的第一个参数是一个数组，数组的成员是模板字符串中没有变量替换的部分，也就是说，变量替换只发生在各个数组成员之间 函数的其他参数，都是模板字符各个变量被替换后的值 回到题目上来 1highlight`Hello, $&#123;yourName&#125;. I am $&#123;myName&#125;`. 实际上函数调用是： 1function highlight(['hello, ', '. I am ', ''], yourName, myName) &#123;&#125; 所以可以这样： 123const highlight = (strArray, ...rest) =&gt; &#123; return strArray.map((v, key) =&gt; v + `&lt;span class="red"&gt;$&#123;rest[key] || ''&#125;&lt;/span&gt;`).join('')&#125;; 另外，有一个String.raw方法，它可以获取一个模板字符串的原始字面量值的 比如： 123let name = "Bob";String.raw `Hi\n$&#123;name&#125;!`; // "Hi\\nBob!"，内插表达式还可以正常运行 以后用到的时候再看MDN的文档。 参考 #86 字体高亮函数@ScriptOJ 标签模板@ECMAScript6入门 String.raw()@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习47 自动绑定实例方法]]></title>
    <url>%2F2019%2F01%2F14%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A047%20%E8%87%AA%E5%8A%A8%E7%BB%91%E5%AE%9A%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[利用Proxy自动绑定实例方法 知识点 class内部默认是严格模式 class定义的原型方法的可枚举行 Proxy 题目首先看这样一个引子： 123456789101112const name = 'window';let obj = &#123; name: 'jay', say() &#123; console.log(this.name) &#125;&#125;;obj.say(); let say = obj.say;say(); 两次执行，分别会输出什么？ 显然，第一次会打印出jay，第二次是window(，如果在严格模式下会报错)，是因为this指向调用者，第二次的调用者是window 在构建类的时候，同样有这个问题： 123456789101112class Person &#123; constructor (name) &#123; this.name = name &#125; sayHi () &#123; console.log(`I am $&#123;this.name&#125;.`) &#125;&#125;const jerry = new Person('Jerry')const sayHi = jerry.sayHisayHi() // =&gt; 报错 注意，这里面是直接报错，因为this是指向了undefined而不是window，因为==在类和模块的内部，默认就是严格模式== 所以在类似于React.js的组件的事件监听当中我们总是需要手动地进行bind(this)操作。为了简化这样的操作，请你完成一个方法autoBind，它可以接受一个类作为参数，并且返回一个类。返回的类的实例和原来的类的实例功能上并无差别，只是新的类的实例所有方法都会自动 bind 到实例上。例如： 12345const BoundPerson = autoBind(Person)const lucy = new BoundPerson('Lucy')const sayHi = lucy.sayHisayHi() // =&gt; I am Lucy. 注意，如果autoBind以后给原来的类新增方法，也会自动反映在实例上，例如： 123456Person.prototype.sayGood = function () &#123; console.log(`I am $&#123;this.name&#125;. I am good!`)&#125;const sayGood = lucy.sayGoodsayGood() // =&gt; I am Lucy. I am good! 实现一上来我就想到了可以使用Proxy来拦截new的操作符，后来又试了试用extends方法，都可以实现一半，但是后一半，也就是“自动反映在实力上”这个要求没办法实现 先讲一下我用Proxy的实现，利用handler.construct方法，拦截了new的操作 1234567891011const autoBind = (ToBindClass) =&gt; new Proxy(ToBindClass, &#123; construct(targets, argus, newTarget) &#123; const self = new targets(...argus); Object.getOwnPropertyNames(targets.prototype).forEach(v =&gt; &#123; self[v] = targets.prototype[v].bind(new targets(...argus)) &#125;); return self &#125;&#125;) 在构造函数的方法中，使用了Object.getOwnPropertyNames(targets.prototype)对原型上的方法遍历进行绑定 要注意的是，==class里面定义的原型方法是不可枚举的==，这一点与直接定义在prototype是不同的，直接定义在prototype是可枚举的 所以遍历class的原型方法不能使用Objecet.keys方法，可以使用Object.getOwnPropertyNames 但是，这种方法没办法动对新增的方法进行处理。 看了看评论区，可以使用双层的Proxy实现，外层的Proxy不同，里面不直接返回实例，而是用Proxy再次进行处理的实例，对实例的get方法进行拦截，每次访问的时候再去原型链上找，然后进行绑定。 123456789101112131415const autoBind = (ToBindClass) =&gt; new Proxy(ToBindClass, &#123; construct(targets, argus, newTarget) &#123; const self = new targets(...argus); return new Proxy(self, &#123; get(target, key) &#123; if(typeof target[key] === 'function') &#123; target[key] = target[key].bind(self) &#125; return target[key] &#125; &#125;) &#125;&#125;) 外层的Proxy可以用函数自己去拦截构造器，所以上面也可以改写成： 12345678910111213const autoBind = (ToBindClass) =&gt; &#123; return function(...argus) &#123; const self = new ToBindClass(...argus); return new Proxy(self, &#123; get(target, key) &#123; if(typeof target[key] === 'function') &#123; target[key] = target[key].bind(self) &#125; return target[key] &#125; &#125;) &#125;&#125; 太笨了。 参考 #84 自动绑定实例方法@ScriptOJ Class 的基本语法@ECMAScript6入门 handler.construct()@MDN]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转行之路]]></title>
    <url>%2F2019%2F01%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[做出转行的决定，不知道是对是错 将自己的轨迹强行换到另外一条道路，到现在很矛盾，既有成就感，感觉自己掌握了很多东西，而且在学习的时候乐在其中，又很焦虑，因为前端的千变万化，新的框架层出不穷，版本升级绵延不绝。 痛并快乐着。 由于有了几年的工作经历，我知道学习和实际工作之间的差别。所以在自学过程中非常注意从实际项目的角度出发，在网上寻找、通过论坛发问，实际的工作过程是怎样的，将实际的工作能力提高。 转行最难的一是坚持，二是得不到认可。我坚持到了现在，下一步呢就是坚持下去，坚持到得到认可。（2016.12.05） 一年多了，在简单科技这一年我充满感激。能够转行成功有自己的努力，也有运气使然。明天就要去网易入职，不知道大公司会是什么样子，不知道未来是什么样子，可以预见的只有自己还有很多东西要学，很长的路要走。继续坚持下去吧。（2018.03.07） 这一年，尤其是最近几个月，焦虑更加严重了。互联网经济寒冬，公司业务的停滞，几次面试的失败，年龄的增大，让我的焦虑与日俱增。我总是觉得自己的时间宝贵，因为转行让我的前些年的时间全部白费，所以我渴望快速的成长。但是到现在，成长的速度赶不上年龄和外界对你的要求的增长速度。不知道未来会怎样，不知道下一站在哪里。（2019.01.11） 有了一点新的感想，按照计划一步一步来吧，沉着一点，少点焦虑，多点坚定。]]></content>
      <categories>
        <category>偶尔记录</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端练习09 同字母异序]]></title>
    <url>%2F2018%2F12%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0%2F%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A09%20%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Leetcode初级算法练习。 题目同字母异序指的是两个字符串字母种类和字母的数量相同，但是顺序可能不同。 完成isAnagram，接受两个字符串作为参数，返回true或者false表示这两个字符串是否同字母异序。例如： 12isAnagram("anagram", "nagaram") // =&gt; return true.isAnagram("rat", "car") // =&gt; return false. 实现1我实现的方案还是比较简单的，排序一下在比较就行了 1const isAnagram = (str1, str2) =&gt; [...str1].sort().join('') === [...str2].sort().join('') 还可以： 1const isAnagram = (str1, str2) =&gt; str1.length === str2.length &amp;&amp; ![...str1].find(v =&gt; !str2.includes(v)) &amp;&amp; ![...str2].find(v =&gt; !str1.includes(v)); 还可以使用for循环： 12345678910111213141516const isAnagram = (str1, str2) =&gt; &#123; if (str1.length !== str2.length) &#123; return false; &#125; let str2Copy = str2; for (let i = 0; i &lt; str1.length; i++) &#123; if (!str2Copy.includes(str1[i])) &#123; return false; &#125; else &#123; const str2CopyArr = [...str2Copy]; str2CopyArr.splice(str2Copy.indexOf(str1[i]), 1); str2Copy = str2CopyArr.join('') &#125; &#125; return str2Copy.length === 0&#125;; 实现2在LeetCode上又遇到了这道题，看了大神的代码，自愧不如。 想要执行用时短，要避免类型转换，所以直接使用了replace方法，这样就可以实现同样字母的替换 12345678var isAnagram = function (s, t) &#123; while (s !== t &amp;&amp; s.length === t.length) &#123; const reg = new RegExp(s[0], 'g'); s = s.replace(reg, ''); t = t.replace(reg, ''); &#125; return s === t&#125;; 执行用时116ms，而原先的方法最少都在150ms以上 实现3因为题目中注明了，可以假设字符串只包含小写字母，那收到另外一个题目的其他，也可以对一个常量字符串进行遍历： 1234567891011121314151617181920212223242526var isAnagram = function (s, t) &#123; if(s.length !== t.length) &#123; return false; &#125; const alpha = 'abcdefghijklmnopqrstuvwxyz'; let reg; for (let i = 0; i &lt; alpha.length; i++) &#123; const letter = alpha[i], sIndex = s.indexOf(letter), tIndex = t.indexOf(letter); if ((sIndex === -1 &amp;&amp; tIndex !== -1) || (sIndex !== -1 &amp;&amp; tIndex === -1)) &#123; return false; &#125; else &#123; reg = new RegExp(letter, 'g'); s = s.replace(reg, ''); t = t.replace(reg, ''); if (s === t) &#123; return true &#125; if(s.length !== t.length) &#123; return false &#125; &#125; &#125; return s === t;&#125;; 执行用时104ms。 参考 ScriptOJ - #44 同字母异序]]></content>
      <categories>
        <category>前端练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS53 判断变量类型]]></title>
    <url>%2F2018%2F12%2F03%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS53%20%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[总结了几种判断JavaScript中变量类型的方法。 学到了instanceof在iframe中的问题，去美团面试又被拒了吧。（2018.12.13） 知其然不知其所以然，只知道可以用intanceof和constructor，区别又不知道，去头条面试又被拒了吧（2018.12.3） 总结最常用的判断方法是Object.prototype.slice.call()，其他判断的方法都有着各种问题： Array.isArray判断数组，需要ES6的支持 typeof有各种特殊情况 instanceof对于字面量不适用，并且在iframe场景中有问题 constructor是可以手动改写的 Object.prototype.toString也有着风险：Object.prototype.toString的结果可以使用Symbol.toStringTag定义（2019.02.01） 方法1 typeof不太靠谱的方法，对于基本类型是可以的 1234567891011typeof 123// "number"typeof '123'// "string"typeof true// "boolean"typeof undefined// "undefined" 对于引用类型行不通，判断结果都是object 1234567891011121314151617typeof []// "object"typeof new Array()// "object"typeof &#123;&#125;// "object"typeof null// "object"typeof JSON// "object"typeof Math// "object" 方法2：instanceofinstanceof运算符用来验证原型对象与实例对象之间的关系。 ==当a.___proto___ === A.prototype成立时，instanceof返回true== 1234567var a = [], b = '21', c = &#123;&#125;;a instanceof Array; // trueb instanceof Array; // falsec instanceof Array; // false 但是注意： 1 instanceof只对引用类型有效，==对于基本类型字面量是无效的==，因为基本类型不是对象，不存在原型链的继承关系 1234567891011[] instanceof Array;// true123 instanceof Number;// falseNumber(123) instanceof Number// falsenew Number(123) instanceof Number// true 2 instanceof存在继承关系，==对于引用类型都是Object的实例== 12345[] instanceof Array;// true[] instanceof Object;// true 3 instanceof在iframe的场景中有可能出现误判 123456const a = [1, 2, 3];const iframe = document.querySelector('#iframe');console.log(a instanceof Array); // tureconsole.log(a instanceof iframe.contentWindow.Array); // falseconsole.log(iframe.contentWindow.Array === Array); // false 可以认为宿主和iframe是两套JS的执行环境，环境中的Array是不同的，所以判断会出现问题。 方法3：constructor实质上实例是没有constructor属性的，其constructor属性是继承自原型的： 1234567function Person()&#123;&#125;;let p = new Person();p.constructor === p.__proto__.constructor;// turep.constructor === Person.prototype.constructor// true 应用时： 1234567var a = [], b = '21', c = &#123;&#125;;console.log(a.constructor === Array); // trueconsole.log(b.constructor === Array); // falseconsole.log(c.constructor === Array); // false 它的主要问题是：constructor是可以手动更改的，当通过原型继承时，constructor会被改写 12345678910function Person() &#123;&#125;;function Man() &#123;&#125;;Man.prototype.constructor === Man;// trueMan.prototype = new Person();Man.prototype.constructor === Person;// true instacnceof和constructor的区别 instanceof是操作符，而constructor是继承构造函数的原型的一个属性 instanceof对于基本类型的字面量是无效的（返回false），基本类型的字面量的constructro不存在 instancoeof存在继承性，引用类型都是Object的实例，而constructor是可以认为改写的 1234567undefined instanceof Object;null instanceof Object;null.constructorundefined.constructo 方法4 Array.isArray()ES6的Array.isArray()方法可以来判断数组的类型 123456var a = [], b = '21', c = &#123;&#125;;console.log(Array.isArray(a)); // trueconsole.log(Array.isArray(b)); // falseconsole.log(Array.isArray(c)); // false 方法5 toString方法首先要知道，调用Object.prototype.toString返回结果都是[object xxx]的格式，例如： 1234567891011121314151617Object.prototype.toString.call(&#123;&#125;)"[object Object]"Object.prototype.toString.call('')"[object String]"Object.prototype.toString.call([])"[object Array]"Object.prototype.toString.call(function ()&#123;&#125;)"[object Function]"Object.prototype.toString.call(new Date())"[object Date]"Object.prototype.toString.call(true)"[object Boolean]" 构造一个函数，isType，传入要验证的类型，返回值是一个新的函数： 1234567891011function isType(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]` &#125;&#125;const isArray = isType('Array')const isString = isType('String')console.log(isArray[1, 2, [3]]); // trueconsole.log(isString(&#123;&#125;)); // false 这是一个比较稳妥的判断方法。 Object.prototype.toString也有着风险：Object.prototype.toString的结果可以使用Symbol.toStringTag定义： 12var o = &#123; [Symbol.toStringTag]: "MyObject" &#125;;console.log(Object.prototype.toString.call(o)); // [object MyObject] 参考 JavaScript高级程序设计（第3版） 掘金 - 高阶函数，你怎么那么漂亮呢！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node13 文件路径]]></title>
    <url>%2F2018%2F07%2F11%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode13%20%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。文件路径的笔记。 路径表示Node.js中的文件路径主要有以下几种： __dirname __filename proces.cwd() ./ ../ 其中前三个是绝对路径，后两个是相对路径 ，可以通过path.resolve转换为绝对路径 我现在的目录结构是这样的： 1234D:/ -projects/ path-test/ path.js path.js： 12345const path = require('path')console.log('__dirname：', __dirname)console.log('__filename：', __filename)console.log('process.cwd()：', process.cwd())console.log('./：', path.resolve('./')) 在path-test文件夹下用Node执行path.js，输出结果： 1234__dirname： D:\projects\path-test__filename： D:\projects\path-test\path.jsprocess.cwd()： D:\projects\path-test./： D:\projects\path-test 在projectst文件夹下用Node执行path.js： 1234__dirname： D:\projects\path-test__filename： D:\projects\path-test\path.jsprocess.cwd()： D:\projects./： D:\projects 关于他们的区别： process.cwd()是程序的执行路径，./相同 __dirname是被执行的JS文件所在文件夹的绝对路径 __filename是被执行的JS文件的绝对路径，与__dirname一样，都是JS文件本身的属性 path模块path.join()用于连接路径，主要用于针对不同系统（windows/unix）使用当前系统的路径分隔符 12var path = require('path');path.join(mydir, "foo"); 上面代码在Unix系统下，会返回路径mydir/foo。 path.join()用于将相对路径转为绝对路径 它可以接受多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。 12// 实例path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') 上面代码的实例，执行效果类似下面的命令。 12345$ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd 更多例子： 123456789path.resolve('/foo/bar', './baz')// '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/')// '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')// 如果当前目录是/home/myself/node，返回// /home/myself/node/wwwroot/static_files/gif/image.gif 参考 Node.js的dirname，filename，process.cwd()，./的一些坑@github Path模块@JavaScript标准参考教程 process对象@JavaScript标准参考教程]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>process.cwd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node12 AMD、CMD、UMD]]></title>
    <url>%2F2018%2F07%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode12%20AMD%E3%80%81CMD%E3%80%81UMD%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。AMD/CMD/UMD学习笔记。 AMDAMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”，也是由RequireJS定义的模块形式。 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 定义模块12345678// 文件名: foo.jsdefine(['jquery'], function ($) &#123; // 方法 function myFunc()&#123;&#125;; // 暴露公共方法 return myFunc;&#125;); 定义的第一个部分是一个依赖数组，第二部分是回调函数，只有当依赖的组件可用时回调函数才会执行。 加载模块123require(['foo'], function(foo) &#123; console.log(foo)&#125;) CommonJSNode.js的模块和包机制的实现参照了CommonJS的标准，但并未完全遵循。不过两者的区别不大。 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 定义模块在CMD规范中，一个模块就是一个文件。define是一个全局函数，用来定义模块。 define接受factory参数，factory可以是一个函数，也可以是一个对象或字符串。 比如可以定义一个JSON数据模块： 1define(&#123;&quot;foo&quot;: &quot;bar&quot;&#125;); factory是一个函数，有三个参数，function(require, exports, module) require是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id) exports是一个对象，用来向外提供模块接口 module是一个对象，上面存储了与当前模块相关联的一些属性和方法 1234567define(function(require, exports, module) &#123; var a = require('./a'); a.doSomething(); // 依赖就近书写，什么时候用到什么时候引入 var b = require('./b'); b.doSomething();&#125;); NodeJS中12345678// 文件名: foo.js// 依赖var $ = require('jquery');// 方法function myFunc()&#123;&#125;; // 暴露公共方法（一个）module.exports = myFunc; UMD通用模块规范UMD是AMD和CommonJS的糅合。 123456789101112131415((root, factory) =&gt; &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(['jquery'], factory); &#125; else if (typeof exports === 'object') &#123; //CommonJS var $ = requie('jquery'); module.exports = factory($); &#125; else &#123; //都不是，浏览器全局定义 root.testModule = factory(root.jQuery); &#125;&#125;)(this, ($) =&gt; &#123; //do something... 这里是真正的函数体&#125;); 更详细的内容看这个教程。 参考 https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E8%AE%A4%E8%AF%86AMD%E3%80%81CMD%E3%80%81UMD%E3%80%81CommonJS.md http://web.jobbole.com/82238/ https://mp.weixin.qq.com/s/WG_n9t4E4q0kBWczkSEdEA https://neveryu.github.io/2017/03/20/amd-cmd/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>UMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node11 process.env对象]]></title>
    <url>%2F2018%2F07%2F05%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode11%20process.env%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。process.env对象的学习笔记。 process对象process对象是Node的一个全局独享，提供当前Node进程的信息。他可以在脚本的任意位置使用，不必通过require命令加载 属性process对象提供了一系列的属性，用于返回系统信息 process.argv：返回一个数组，成员是当前进程的所有命令行参数 process.env：返回一个对象，成员为当前Shell的环境变量 process.pid：返回一个数字，表示当前进程的进程号 process.platform：返回一个字符串，表示当前的操作系统，比如Linux process.version：返回一个字符串，表示当前使用的 Node 版本，比如v7.10.0 process.envprocess.env返回一个对象，包含了当前Shell的所有环境变量 通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设定为production，开发阶段设定为development，然后在脚本中读取process.env.NODE_ENV 运行脚本时改变环境变量可以采用下面的写法： 1NODE_ENV=production node app.js ross-env如果按照上面的写法，在windows系统下是会报错的： 1'NODE_ENV' 不是内部或外部命令，也不是可运行的程序或批处理文件。 因为windows下不支持这种设置环境变量的方式，正确的方法是： 1set NODE_ENV=production &amp;&amp; node app.js 但是这样需要维护两个脚本命令，使用cross-env就可以解决这个问题 cross-env提供了一个设置环境变量的脚本，让我们能够以Linux的方式设置环境变量，在Windows下可以兼容运行 安装： 1npm install cross-env --save-dev 使用时只需要在原来的脚本前面加上cross-env就可以了 1cross-env NODE_ENV=development nodemon ./index.js 使用.env文件在Vue-cli3.0和Create-react-app两款脚手架中，都支持使用.env文件来引入环境变量 Vue中Vue-cli3.0在Vue-cli3.0的项目中，可以直接传递--mode参数复写环境变量，例如想要使用.env.staging，可以这样： 1vue-cli-service build --mode staging 这个时候NODE_ENV被改写为staging，同时会加载.env.staging文件 在.env中定义的变量除了NODE_ENV之外，都需要以VUE_APP_开头，同样可以在.env文件制定NODE_ENV，同样可以生效，例如上面的.env.staging文件中可以： 1NODE_ENV=production 这样NODE_ENV又被重新改写为了production Vue-cli2.0在以前的项目中，是不能直接使用.env文件的，一般都是直接使用process.env.NODE_ENV来区分环境。除了内置的development/production/test环境变量外，想要增加新的环境有两个做法 一个是在build的文件夹中，复制为build-staging.js，同时中为process.env.NODE_ENV重新赋值，在运行npm run build:staging命令时，运行build-staging文件 另外一个就是使用上面提到的corss-env，在运行npm命令时赋值 React中如果是使用Create-react-app脚手架的项目，在未eject之前，是不能覆写NODE_ENV的， 也没有提供--mode的选项来指定新的.env文件，可以使用cmd-env来指定.env文件，但是这个时候的NODE_ENV是不变的。 具体的可以参考《React提高08 Create React App》这篇笔记。 参考 process对象@JavaScript标准参考教程 使用cross-env解决跨平台设置NODE_ENV的问题@segmentfault 环境变量和模式@Vue CLI]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09 ES6标准入门(Promise对象)]]></title>
    <url>%2F2018%2F04%2F17%2F03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F03%20ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%2F09%20ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8(Promise%E5%AF%B9%E8%B1%A1)%2F</url>
    <content type="text"><![CDATA[学习Promise的笔记。 含义Promise是异步编程的一种解决方案，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。==只有异步操作的结果，可以决定当前是哪一种状态==，任何其他操作都无法改变这个状态。 （2）==一旦状态改变，就不会再变，任何时候都可以得到这个结果==。 Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就==凝固==了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。 Promise也有一些缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法Promise对象是一个构造函数，用来生成Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数 第一个回调函数是Promise对象的状态变为resolved时调用 第二个回调函数是Promise对象的状态变为rejected时调用（第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数）。 一个简单的例子： 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，比如像下面这样 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 1234567891011const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2.then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面的p2的状态在1秒之后改变，resolve方法返回的是p1，所以p2的状态决定于p1，在p1状态确定后p2的then和catch才会被执行 注意，==调用resolve或reject并不会终结Promise的参数函数的执行==。 一般来说，调用resolve或reject以后，Promise的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。 then方法返回的是一个==新的==Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log("resolved: ", comments);&#125;, function funcB(err)&#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为 rejected，就调用funcB。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。 另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 如果Promise 状态已经变成resolved，再抛出错误是无效的。 Promise对象的错误具有“冒泡”性质，==会一直向后传递==，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); ==一般来说，不要在then方法里面定义Reject状态的回调函数（即 then 的第二个参数），总是使用catch方法。== 12345678910111213// badpromise.then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise.then(function(data) &#123; //cb // success &#125;).catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是==第二种写法可以捕获前面then方法执行中的错误==，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 1234567891011121314const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123 上面代码中，someAsyncThing函数产生的Promise对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。 这就是说，Promise内部的错误不会影响到Promise外部的代码，通俗的说法就是Promise 会吃掉错误。 一般总是建议，Promise对象后面要跟catch方法，这样可以处理Promise内部发生的错误。catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。 另外，==注意catch和then一样，也会返回一个可链式操作的新的Promise对象== Promise.prototype.finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是ES2018引入标准的。 123promise.then(result =&gt; &#123;···&#125;) .catch(error =&gt; &#123;···&#125;) .finally(() =&gt; &#123;···&#125;); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的Promise状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于Promise的执行结果。 可以手写一个简单的finally方法（美团点评面试）： 12345678Promise.prototype.finally = Promise.prototype.finally || function (callback) &#123; if (Object.prototype.toString.call(this) !== '[object Promise]') &#123; return &#125; return Promise.resolve( this.then(() =&gt; callback()).catch(() =&gt; callback()) )&#125; Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1const p = Promise.all([p1, p2, p3]); Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise实例，如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise 实例。） 数组中的各个Promise实例同时开始 p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值==按顺序==组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 注意，如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并==不会触发==Promise.all()的catch方法。 1234567891011const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e));// ["hello", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的Promise实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 注意，这样每个promise实例都要有自己的then方法，并且有返回值，才能被 all 方法的then接住 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 同样可以手写一个Promise.all方法（滴滴面试）： 123456789101112131415161718192021Promise.all = Promise.all || function (promiseAll) &#123; let total = promiseAll.length; // 需要提前将结果数组的长度预定好，因为需要按顺序存入Promise结果 let result = new Array(total); let doneCount = 0; return new Promise((resolve, reject) =&gt; &#123; promiseAll.forEach(promise =&gt; &#123; promise.then((value, index) =&gt; &#123; result[index] = value; doneCount++; if(doneCount === total) &#123; resolve(result) &#125; &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。其余的Promise就不再改变了 数组中的各个Promise实例同时开始 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 手写一个Promise.race的实现： 1234567Promise.race2 = Promise.race2 || function (promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(promise =&gt; &#123; promise.then(v =&gt; resolve(v)).catch(err =&gt; reject(err)) &#125;) &#125;)&#125; Promise.resolve()Promise.resolve方法可以将现有对象转为Promise对象 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve等价于下面的写法 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况 （1）参数是一个Promise实例 Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行改对象的then方法。 123456789let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 123456const p = Promise.resolve('Hello'); p.then(function (s)&#123; console.log(s)&#125;);// Hello （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。所以，==如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法== 1234const p = Promise.resolve();p.then(function () &#123; // ...&#125;); Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise的错误处理最好使用catch代替then里面的第二个参数来捕获错误，因为这样就可以==捕获then的第一个参数中发生的错误== 同时，catch会检测的区域是==整个==promise链上之前每个地方的（then和其他异步操作），如果它前面还有另一个catch，则从那个catch后面开始 还有就是，catch也会返回一个可链式操作的新Promise对象，所以如果在一个catch中抛出一个错误，也会被下一个catch捕获 如果多层嵌套时，如果内层的错误在内层有catch捕获，那么就不会被外层的catch捕获到，如果内层没有被捕获，则会“冒泡”到外层的catch 如果Promise的错误没有被处理，那么可以通过unhandledrejection来统一捕获未==处理的Promise错误==（美团面试） 注意，有两个关键词： （1）一个是==未处理==的，如果被catch处理了，则不会被unhandledrejection捕获 （2）另一个是Pormise错误，必须是在Promise链路上发生的错误，否则也不会被捕获 使用： 123window.addEventListener('unhandledrejection', e =&gt;&#123; console.log(e)&#125;) 事件对象e是PromiseRejectionEvent事件，有两个属性: promise：被rejected的Promise reason：被rejected的原因 12345678910111213141516const p1 = new Promise((resolve) = &gt; &#123; a(); setTimeout((a) = &gt; &#123; resolve(a) &#125;, 1000, 'ok1')&#125;);p1.then(v = &gt; &#123; console.log(v)&#125;);window.addEventListener('unhandledrejection', e = &gt; &#123; console.log(e.reason) e.preventDefault()&#125;)// ReferenceError: a is not defined 可以通过e.preventDefault()来将错误拦截到此为止。 还可以监听rejectionhandled事件，当一个Promise发生错误，最初未被处理，稍后被处理的情况 12345678910111213141516171819202122232425262728const p1 = new Promise((resolve) =&gt; &#123; a(); setTimeout((a) =&gt; &#123; resolve(a) &#125;, 1000, 'ok1')&#125;);p1.then(v = &gt; &#123; console.log(v)&#125;);setTimeout(() =&gt; &#123; p1.catch (v =&gt; &#123; console.log(v, 'rejection') &#125;)&#125;, 1000);window.addEventListener('unhandledrejection', e =&gt; &#123; console.log(e.reason, 'unhandledrejection'); e.preventDefault()&#125;);window.addEventListener('rejectionhandled', e =&gt; &#123; console.log(e.reason, 'unhandledrejection')&#125;);// ReferenceError: a is not defined "unhandledrejection"// ReferenceError: a is not defined "rejection" 实例：图片加载一个例子，根据图片加载状态执行异步操作 123456789101112131415const preLoadImage = (path) = &gt; &#123; return new Promise(((resolve, reject) = &gt; &#123; let img = new Image(); img.src = path; img.className = 'image'; img.onload = () = &gt; resolve(img); img.onerror = () = &gt; reject(new Error('出错了')); &#125;))&#125;;preLoadImage('../demo03-上传图片预览/default.png') .then((img) = &gt; &#123; document.querySelector('#div').appendChild(img); &#125;).catch ((err) = &gt; &#123; console.log(err) &#125;) 手动实现Promise看了一些参考文章，还是迷迷糊糊，有机会要重新看（2019-04-11） 首先建立一个构造函数 123456789101112131415161718192021222324252627282930function MyPromise(fn) &#123; // 省略非 new 实例化方式处理 // 省略 fn 非函数异常处理 // promise 状态变量 // 0 - pending // 1 - resolved // 2 - rejected this._state = 0; // promise 执行结果 this._value = null; // then 方法注册的回调函数 this._deferreds = []; // 立即执行 fn 函数，调用私有方法 resolve 和 reject try &#123; fn( value =&gt; &#123; resolve(this, value) &#125;, reason =&gt; &#123; reject(this, reason) &#125; ) &#125; catch (e) &#123; reject(this, e) &#125;&#125; 然后来看resolve函数，它的目的主要是用来将promise实例的状态由pending改为resolved，它接受了两个参数，第一个参数是当前的promise实例，第二个参数是promise的执行结果 resolve函数中要处理的情况还是比较复杂的，主要是根据value的类型，这里只处理了value为promise和普通对象的情况，为thanable对象和函数的情况省略没有处理。 1234567891011121314151617181920212223242526272829303132333435/** * 用来改变 promise 状态。 * @param promise promise实例 * @param value promise的执行结果 * @returns &#123;*&#125; */function resolve(promise, value) &#123; // 非 pending 状态不可改变 if (promise._state !== 0) &#123; return; &#125; // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if (value === promise) &#123; return reject(promise, new TypeError('A Promise cannot be resolved with itself')) &#125; // 如果 value 为 Promise，则使 promise 接受 value 的状态 if (isPromise(value)) &#123; const deferreds = promise._deferreds; if (value._state === 0) &#123; // value 为 pending 状态 // 将 promise._deferreds 传递给 value.deferreds // 这样，当 value 不为 pending 状态后，可以抛弃之前的 promise，以 value 作为当前的 promise 执行 then 注册函数 value._deferreds.push(...deferreds) &#125; else if (deferreds.length &gt; 0) &#123; // value 为非 pending 状态 // 使用 value 作为当前的 promise ，执行 then 注册回调处理 for (let i = 0; i &lt; deferreds.length; i++) &#123; // handleResolved 是实际处理 handleResolved(value, deferreds[i]) &#125; // 清空回调函数队列 value._deferreds = [] &#125; return; &#125; 其中用到一个工具函数isPromise用来判断对象是否是一个Promise对象： 123function isPromise(value) &#123; return value &amp;&amp; Object.prototype.toString.call(value) === '[object Promise]' &amp;&amp; value.then&#125; 最后实际执行调用的是handleResolved函数，它不光在resolve函数中调用，在其他地方也被调用，它的主要目的有两个，一个是实现了当then注册函数为空时的透传功能，另外就是根据promise的状态来判断调用onResolved或onRejected 要注意的是需要保证异步调用，防止调用顺序错乱，使用了asyncFn函数来模拟异步执行。 123456789101112131415161718192021222324252627282930313233343536// 根据 promise 当前状态判断调用 onResolved 或 onRejected// 处理 then 注册回调为空的情形// 维护 then 链式调用function handleResolved(promise, deferred) &#123; asyncFn(function () &#123; const cb = promise._state === 1 ? deferred.onResolved : deferred.onRejected; let res; // 使用 deferred.promise 作为当前 promise 结合 value 调用后续处理函数继续往后执行，实现值穿透空处理函数往后传递。 if (!cb) &#123; if (promise._state === 1) &#123; resolve(deferred.promise, promise._value) &#125; else &#123; reject(deferred.promise, promise._value) &#125; return; &#125; try &#123; // 根据状态调用 then 中注册的 onResolved 或 onRejected 函数 res = cb(promise._value); &#125; catch (e) &#123; reject(deferred.promise, e) &#125; resolve(deferred.promise, res) &#125; )&#125;// 模拟异步执行函数function asyncFn() &#123; if (process &amp;&amp; typeof process === 'object' &amp;&amp; typeof (process.nextTick) === 'function') &#123; return process.nextTick &#125; else if (typeof setImmediate === 'function') &#123; return setImmediate &#125; return setTimeout&#125; 上面的函数中，之所以deferred对象之所以有onResolved和onRejected对应的方法，是因为我们在then函数的处理中进行了封装，下面看一下在原型上定义的then方法： 1234567891011121314151617181920212223242526272829MyPromise.prototype.then = function (onResolved, onRejected) &#123; // 实例化空 promise 对象用来返回（保持then链式调用) const res = new Promise(function () &#123; &#125;); // 使用 onResolved，onRejected 实例化处理对象 Handler const deferred = new Handler(onResolved, onRejected, res); // 当前状态为 pendding，存储延迟处理对象 if (this._state === 0) &#123; this._deferreds.push(deferred); // 返回新 promise 对象，维持链式调用 return res; &#125; // 当前 promise 状态不为 pending // 调用 handleResolved 执行 onResolved 或 onRejected 回调 handleResolved(this, deferred); // 返回新 promise 对象，维持链式调用 return res;&#125;// 封装存储 onResolved、onRejected 函数和新生成 promise 对象function Handler(onResolved, onRejected, promise) &#123; this.onResolved = typeof onResolved === 'function' ? onResolved : null; this.onRejected = typeof onRejected === 'function' ? onRejected : null; this.promise = promise;&#125; 之所以没有直接返回this，而是返回了一个新的Promise对象来实现链式调用，看下面的代码 123var promise2 = promise1.then(function (value) &#123; return Promise.reject(3)&#125;) 假如then函数执行返回this调用对象本身，那么promise2 === promise1，promise2状态也应该等于promise1同为resolved。而onResolved回调中返回状态为rejected对象。考虑到Promise状态一旦resolved或rejected就不能再迁移，所以这里promise2也没办法转为回调函数返回的rejected状态，产生矛盾。 剩下的就是reject函数，简单得多： 12345678910111213141516function reject(promise, reason) &#123; // 非 pending 状态不可变 if (promise._state !== 0) &#123; return &#125; // 改变 promise 内部状态为 rejected promise._state = 2; promise._value = reason; // 判断是否存在 then 注册回调函数，如果存在则依次执行 if (promise._deferreds.length &gt; 0) &#123; for (let i = 0; i &lt; promise._deferreds.length; i++) &#123; handleResolved(promise, promise._deferreds) &#125; promise._deferreds = [] &#125;&#125; 感觉现在大概能够明白这个意思了，但是要是自己实现可能还是要费点劲，考虑不了太多的情况，还是能力差。 有时间还是要来回顾，不断整理自己的笔记。 参考 then or catch@Promise迷你书 PromiseRejectionEvent@MDN unhandledrejection@MDN 解读Promise内部实现原理@掘金]]></content>
      <categories>
        <category>ES6标准入门</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础16 携带Cookie跨域]]></title>
    <url>%2F2018%2F01%2F06%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8016%20%E6%90%BA%E5%B8%A6Cookie%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[普通的AJAX请求（非跨域的情况）是默认携带cookie的，但是在跨域时则是不携带cookie的。跨域时携带cookie的方法有三种： Nginx反向代理 JSONP CORS 对Cookie跨域的理解假设服务端的域名是a.com，发送跨域请求的前端的域名是b.com，那么在b.com想a.com发送跨域请求时，是可以携带cookie的，但是这个cookie必须是域名为a.com下的cookie 也就是说，b.com的前端发送的跨域请求携带的cookie，是目标页面所在域的cookie。 所以带cookie跨域的前提是目标页面的cookie在本机存在，跨域要携带的cookie必须是目标页面所在域的cookie 之前的理解有两个误区： b.com向a.com发送跨域请求，可以把b.com域名下的cookie带上。如上面所说的，这是行不通的 b.com通过JS在本机生成一个域名a.com的Cookie，或者a.com的服务端在发送响应时setCookie的domain为b.com。这两种做法都是行不通的，因为设置cookie的domain可以设置为父域名和自身，但是不能设置其他域名和子域名，否则cookie设置不会成功。 domain假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。 服务端是无法跨域设置cookie的（set-cookie），只能设置自身域名或者父域名的Cookie 前端是可以带cookie跨域的，前提是cookie是目标服务器所在域的cookie Nginx反向代理通过Nginx反向代理来解决cookie跨域问题可以携带cookie。 JOSNP使用JSONP跨域可以携带cookie，但是只能是GET请求，需要在请求的选项中添加xhrFiles对象： 12345678910111213141516$.ajax(&#123; url: 'http://b.fdipzone.com/server.php', // 跨域 xhrFields: &#123; withCredentials: true // 发送凭据 &#125;, dataType: 'json', type: 'post', data: &#123; 'name': 'fdipzone' &#125;, success: function(ret) &#123; if (ret['success'] == true) &#123; alert('cookie:' + ret['cookie']); &#125; &#125;&#125;); CORSCORS的全称是“跨域资源共享“（Cross-Origin Resource Sharing） 它允许浏览器向跨源服务器发出XMLHttpRequest请求，解决跨域问题。 CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段： 12header(&quot;Access-Control-Allow-Origin: http://www.xxx.com&quot;); header(&quot;Access-Control-Allow-Credentials: true&quot;); 另一方面，开发者必须在AJAX请求中打开withCredentials属性： 123456789101112131415// 原生var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;xx.com&apos;);xhr.withCredentials = truelxhr.send()// jQuery$.ajax(&#123; type: &apos;GET&apos;, url: &apos;xx.com&apos;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true&#125;) 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。 同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 参考 HTTP cookies@MDN Set-Cookie@MDN 解决cookie跨域访问@博客园 跨域资源共享 CORS 详解@阮一峰的网络日志 跨域请求带cookie的解决方案@CSDN]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>HTTP</tag>
        <tag>cookie</tag>
        <tag>set-cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础01 Cookie]]></title>
    <url>%2F2018%2F01%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8001%20Cookie%2F</url>
    <content type="text"><![CDATA[Cookie学习笔记 什么是cookiecookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。==由于服务器指定cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销==（尤其是在移动环境下）。 新的浏览器API已经允许开发者直接将数据存储到本地，如使用Webstorage（本地存储和会话存储）或IndexedDB 。 cookie的分类cookie分为会话期cookie和持久性cookie。 会话期cookie在浏览器关闭后会自动删除，没有指定Expires和Max-age的cookie为会话期cookie 持久性cookie可以指定一个特定的过期时间（Expires）和有效期（Max-age），设定的日期和时间只与客户端相关，而不是服务端。 很多Web浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie也会恢复，就跟从来没有关闭浏览器一样。 cookie创建时包含的字段&lt;cookie-name&gt;=&lt;cookie-value&gt;设置name和value, 是必选字段，其他字段皆为可选 Expires=&lt;date&gt;规定cookie的过期日期，是一个绝对时间的日期值，如果没设置，cookie将在session结束后（即浏览器关闭后）失效（即会话期cookie）。HTTP/1.0的特性。 Max-Age=&lt;seconds&gt;规定了cookie的有效期（经过seconds秒后失效），是一个相对值。它是HTTP/1.1的特性，假如Expires和Max-Age均存在，那么Max-Age优先级更高。 Path=&lt;path-value&gt;指定一个URL路径，控制请求哪些路径下的页面能够读取cookie，/表示根路径下的文件有权限读取该cookie，path 权限有继承性，此目录的下级目录也满足匹配的条件 例如，如果path=/docs，那么/docs、/docs/Web/或者/docs/Web/HTTP都满足匹配的条件 Cookie的路径是在服务器创建Cookie时设置的，它的作用是决定浏览器访问服务器的某个资源时，需要将浏览器端保存的那些Cookie归还给服务器。 Domain=&lt;domain-value&gt;指定cookie生效的域名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。 假如指定了域名，那么相当于各个子域名也包含在内了。例如，.baidu.com的设置表明在baidu.com的所有域名中生效，如果设置为www.baidu.com，则仅仅在www.baidu.com域名中生效 SecureSecure设置为true时，cookie只应通过被HTTPS协议加密过的请求发送给服务器。默认为false 但即便设置了Secure，敏感信息也不应该通过cookie传输，因为Cookie有其固有的不安全性，Secure标记也无法提供确实的安全保障。 HttOnly设置了HttpOnly属性的cookie不能使用JavaScript进行访问，仅仅用于网络请求发送给服务端，目的是为了防范跨站脚本攻击（XSS）。 XSS（Cross-site scripting）：跨站脚本攻击是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。 对Cookie跨域的理解假设服务端的域名是a.com，发送跨域请求的前端的域名是b.com，那么在b.com想a.com发送跨域请求时，是可以携带cookie的，但是这个cookie必须是域名为a.com下的cookie 也就是说，b.com的前端发送的跨域请求携带的cookie，是目标页面所在域的cookie。 所以带cookie跨域的前提是目标页面的cookie在本机存在，跨域要携带的cookie必须是目标页面所在域的cookie 之前的理解有两个误区： b.com向a.com发送跨域请求，可以把b.com域名下的cookie带上。如上面所说的，这是行不通的 b.com通过JS在本机生成一个域名a.com的Cookie，或者a.com的服务端在发送响应时setCookie的domain为b.com。这两种做法都是行不通的，因为设置cookie的domain可以设置为父域名和自身，但是不能设置其他域名和子域名，否则cookie设置不会成功。 domain假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。 也就是说： 服务端是无法跨域设置cookie的（set-cookie），只能设置自身域名或者父域名的Cookie 前端是可以带cookie跨域的，前提是cookie是目标服务器所在域的cookie cookie在网络请求中的传递网络请求过程中cookie的传递有两个部分： Set-Cookie服务器可以通过==响应头==中的Set-Cookie字段，请求浏览器保存==一个==cookie信息 多个字段用;分割 123Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnlySet-Cookie: id=123; Domain=.toutiao.com; expires=Wed, 04-Apr-2018 09:59:25 GMT; Max-Age=7804800; Path=/ 注意，不能将多个cookie放在一个Set-Cookie中，要设置多个cookie，需要添加同样多的set-Cookie字段 Cookie浏览器会在发送HTPP请求时，通过==请求头==中的Cookie字段，携带上当前页面保存的所有cookie 可以在Cookie字段中设置多个cookie: JavaScript操作本地cookieJavaScript可以通过document.cookie创建cookie，也可以访问非HttpOnly标记的cookie 创建cookiedocument.cookie每次只能写入一条cookie，需要写入多条cookie时，需要重复调用 后写入的重名的cookie会覆盖旧的cookie 123document.cookie = "userId=828";document.cookie = "username=ok";document.cookie = "userId=919"; 在Cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格，所以在创建Cookie时需要用encodeURIComponent函数对要存入的值进行安全编码，读取时进行相应的解码 1document.cookie = "userId=" + encodeURIComponent("string"); 读取cookie获取cookie值可以直接取值 12var strCookie = document.cookie; // "name=123; ok=999; ok2=0; ok3=999; ok4=123" 只能够一次获取所有的Cookie值，而不能指定cookie名称来获得指定的值 要获取userId的值，可以这样实现（==要注意的是分号;后面是有一个空格的，需要在分割为数组的时候处理==）： 123456789101112131415var strCookie = document.cookie;//将多cookie切割为多个名/值对 var arrCookie = strCookie.split(";");var userId;//遍历cookie数组，处理每个cookie对 for (var i = 0; i &lt; arrCookie.length; i++) &#123; var arr = arrCookie[i].split("="); //找到名称为userId的cookie，并返回它的值 if ("userId" == arr[0]) &#123; userId = arr[1]; break; &#125;&#125; 删除cookie因为cookie是存储在客户端，所以服务器端是没法删除的，必须通知客户端去删除。==客户端通过设置cookie的max-age或者expires为-1将其删除== 为了考虑兼容性，二者应该同时使用。 封装对cookie的操作比较复杂，所以可以进行封装： 1234567891011121314151617181920const cookieJar = &#123; set(name, value, days = 1) &#123; const seconds = days * 24 * 60 * 60; document.cookie = `$&#123;name&#125;=$&#123;value&#125;; expires=$&#123;new Date(Date.now() + seconds * 1000)&#125;; max-age=$&#123;seconds&#125;` &#125;, get(name) &#123; const &#123;cookie&#125; = document; if (!cookie) &#123; return &#125; const cookieObj = cookie.split('; ').reduce((total, current) =&gt; &#123; const [ key, value ] = current.split('='); return Object.assign(total, &#123; [key]: value&#125; ); &#125;, &#123;&#125;); return cookieObj[name] &#125;, remove(name) &#123; document.cookie = `$&#123;name&#125;=''; expires=-1; max-age=-1` &#125;&#125; cookie的安全性问题cookie的安全性存在着很大的不确定性，所以一个重要的原则是，不能通过cookie存储、传输敏感信息 所以通过cookie维护用户的登陆状态时，应该是通过cookie保存、传输经过加密后的一份登陆状态，而==不是直接保存用户的密码信息==。 常见的窃取cookie的攻击有：跨站脚本攻击（XSS）和跨站伪造请求。 一些可以用来提高安全性的手段： 防止XSS攻击，对用于输入进行过滤 使用HTTPS传输cookie 用于明敏感信息的cookie只能拥有较短的生命周期 cookie加密 cookie里面加入IP信息，判断cookie中的IP信息和发送请求的IP是否相等，不相等采取措施，比如重新登录。 物理机窃取是防止不了的，就是到你电脑上，拷走cookie，是防止不了的。 追踪和隐私欧盟已经在2009/136/EC指令中提了相关要求，该指令已于2011年5月25日生效。虽然指令并不属于法律，但它要求欧盟各成员国通过制定相关的法律来满足该指令所提的要求。当然，各国实际制定法律会有所差别。 该欧盟指令的大意：在征得用户的同意之前，网站不允许通过计算机、手机或其他设备存储、检索任何信息。自从那以后，很多网站都在网站声明中添加了相关说明，告诉用户他们的cookie将用于何处。 参考 HTTP cookies@MDN Set-Cookie@MDN JavaScript Cookies@W3school 如何防止cookie被盗用？？@segmentfault]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>cookie</tag>
        <tag>set-cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题21 字符编码笔记]]></title>
    <url>%2F2018%2F01%2F02%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9821%20%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符编码笔记学习笔记。 ASCII码字节：八个二进制位，可以组合出256种状态，这称为一个字节（byte）。一个字节一共可以表示256种状态。 ASCII码是美国制定的，英语字符与二进制位之间的关系，一个规定了128个字符，比如空格SPACE是32（0010 0000），大写字母A是65（0100 0001）。这128个字符只占据了一个字节的后七位，最前面的一位统一规定为0 非ASCII码英语用128个字符编码就够了，但是非英语字符却远远不够。一些语言使用了ASCII中闲置的第一位来编入新的符号，这样一些欧洲国家的编码体系可以最多表示256个字符。 但是对于汉语，还是不够的，需要使用多个字节表达一个符号，简体中文最常见的编码方式是GB2312，用两个字节表示一个汉字，所以理论上最多可以表示256 x 256 = 63356个字符。 Unicode由于世界上存在多个编码方式，同一个二进制字符在不同编码方式下可以被解释成不同的符号。因此想要打开一个文件，就必须知道它的编码方式，否则使用错误的编码方式就会出现乱码。 Unicode是一种所有字符的编码方式，将世界上所有的符号纳入其中，每个字符都给予一个独一无二的编码。 Unicode现在可容纳100多个万个符号，每个符号编码都不一样。符号对应表可以查询unicode.org。 Unicode的符号不是一次性定义的，而是分区定义的，每个区可以放65536（$2^{16}$）字符，成为一个平面（plane），目前一个有17（$2^{5}$）平面，也就是说，整个Uniocde字符集的大小是（$2^{21}$）。 最前面的65536个字符，称为基本平面（BMP），码点范围是从0到$2^{16}-1$，写成16进制就是从0000到FFFF，所有常见字符都放在这个平面。剩下的字符都放在辅助平面（SMP）。 Unicode的问题Unicode只是一个符号集，之规定了符号的二进制代码，却没有规定到底用什么样的字节序表示这个码点。 比如汉字严的Unicode是十六进制数4E25，二进制是100111000100101，这个符号表示至少需要2个字节。 这样引出了两个问题： 如何让计算机区分Unicode和ASCII？计算机如何知道三个字节是Unicode中表示一个符号，而不是ASCII中的三个字符？ 英文字节只用一个字节表示就够了，那如果统一长度字节表示，会造成很大的浪费 UTF-32UTF-32是最直观的编码方法，每个码点用四个字节表示，字节内容一一对应码点。前位用0补齐。 它的优点是查找效率高，时间复杂度$O(1)$ 它的缺点是浪费空间。同样的英语文本，比ASCII码大了4倍。 UTF-8为了节省空间，UTF-8出现了。 UTF-8是在互联网使用最广泛的Unicode实现方式之一，其他实现方式还有UTF-16（字符用两个字节或四个字节表示）、UTF-32（字符用四个字节表示），不过在互联网环境基本不用。 UTF-8是Unicode的实现方式之一。 UTF-8的最大特点，就是它是一种变长的编码方式。他可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。 UTF-8的编码规则： 对于单字节的字符，字节的第一位设为0，后面7位是这个符号的Unicode码。因此对于英语字符，Unicode编码和ASCII码是相同的。 对于n字节（n &gt; 1），第一个字节的前n位都设为1，第n+1为设为0，后面字节的前两位一律设为10，其余的二进制位，全部为这个符号的Unicode码 1234567unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+---------------------------------------------0x0000 - 0x007F | 0xxxxxxx0x0080 - 0x07FF | 110xxxxx 10xxxxxx0x0800 - 0xFFFF | 1110xxxx 10xxxxxx 10xxxxxx0x010000 - 0x10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 解读UTF-8编码时，如果一个字节的第一位是0，那么这个字节单独就是一个字符，如果第一位是1，则连续有多少个1，就表示当前字符占据多少个字节 例如，严的Unicode编码是4E25（16进制），根据上表（实际自己尝试也会发现），它的UTF-8表示需要三个字节，即格式为1110xxxx 10xxxxxx 10xxxxxx，然后将严的最后一个二进制位开始，从后向前依次填入格式中的x，多位补0，就得到了严的UTF-8编码11100100 10111000 10100101，转换为十六进制是E4B8A5 1parseInt('111001001011100010100101', 2).toString(16).toUpperCase() UTF-16UTF-16介于UTF-8和UTF-32之间，结合了定长和变长两种编码方法的特点。 它的编码规则是，基本平面的字符占用两个字节，辅助平面字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。 UCS-2编码JavaScript采用Unicode字符集，但是只支持UCS-2这一种编码方法。 UCS-2的出现是由于历史上两只开发统一字符集的团队，在互相妥协、融合后的产物。UCS-2使用两个字节来表示基本平面的字符，没有对辅助平面字符处理。UTF-16的基本平面沿用UCS-2的编码，辅助平明字符使用4个自己表示。 UCS-2和UTF-16的关系是：UTF-16取代了UCS-2（UTF-16是UCS-2的超集），或者说UCS-2整合进了UTF-16。 由于JavaScript诞生时UTF-16还没有出现，所以只能采取UCS-2 JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字符。如果是4个字节的字符（即辅助平面上的字符），会当做两个双字节的字符处理。JavaScript的字符函数都收到这一点的影响，无法返回正确结果。 为了解决这个问题，必须对码点进行判断，然后手动调整。在遍历字符串时判断码点，如果落在0xD800和0xDBFF的区间，就要连同后面2个字节一起读取： 12345678while (++index &lt; length) &#123; // ... if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125;&#125; 类似的问题存在于所有的JavaScript字符操作函数，例如replace/substring/slice，这些函数都只对2字节的码点有效。要正确处理4字节的码点，就必须判断当前字符的码点范围。 ECMAScript 6ES6大幅增强了对Unicode的支持，基本解决了上述问题。 （1）正确识别字符ES6可以自动识别4字节的码点，因此遍历字符串就简单多了： 123for (let s of string ) &#123; // ...&#125; 但是为了保证兼容性，length属性还是原来的行为方式。为了得到正确的字符串的长度，可以用下面的方式： 1Array.from(string).length 比如，𝌆的码点为U+1D306,转换为UTF-16的编码是0xD834 DF06,长度是4个字节。length属性保持了以前的行为表现，认为2个字节是一个字符，所以认为𝌆的长度是2： 1'𝌆`.length; // 2 正确的做法是： 1Array.from('𝌆').length; // 1 （2）码点表示法JavaScript允许直接使用码点表示Unicode字符，写法是：反斜杠 + u + 码点 1'好' === '\u597D' // true 但是这样只能表示两个字节的码点，ES6修复了这个问题，只要将码点放在大括号内，就能识别4个字节的码点： 12'\u&#123;1d306&#125;'// "𝌆" （3）ES6新增了几个专门处理4字节码点的方法：12345String.fromCodePoint() // 从Unicode码点返回对应字符String.fromCodePoint('0x1d306') // "𝌆"String.prototype.codePointAt // 从字符返回对应的码点"𝌆".codePointAt(0).toString(16) // "1d306" （4）正则表达式ES6提供了u修饰符，对正则表达式提供4字节码点的支持 12345/^.$/.test('𝌆')// false/^.$/u.test('𝌆')// true 参考 Unicode与JavaScript详解@阮一峰的网络日志 字符编码笔记：ASCII，Unicode 和 UTF-8@阮一峰的网络日志]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
        <tag>UCS-2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习01 将一个JS数组彻底打乱顺序]]></title>
    <url>%2F2017%2F12%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A001%20%E5%B0%86%E4%B8%80%E4%B8%AAJS%E6%95%B0%E7%BB%84%E5%BD%BB%E5%BA%95%E6%89%93%E4%B9%B1%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[JS常用排序算法的总结。 所有算法的动画演示 冒泡排序（Bubble Sort）对相邻的两个对象进行比较，如果后者小于前者，把小的放前面 时间复杂度：O(n²) 123456789101112// 对比arr中的第j+1项和第j项，如果第j+1项小于第j项，就把第j+1项和第j项调换位置。// 如果没达到最终的顺序（从小到大），就继续找，继续换，直到达到最终效果function bubbleSort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; &#125; &#125; &#125; return arr;&#125; （2018.4.3补充）发现在内层循环时，可以改变内层循环的范围为 j&lt;arr.length-1-i, 原因是 当 i=0 的时候，里面的循环完整执行，第一遍排序，结果是将最大的数排到了最后 当 i=1 的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是 j&lt;arr.length-1-i 的巧妙之处 优化冒泡排序算法对冒泡排序进行优化，设定一个变量flag，用于表明是否进行了位置交换，如果没有交换位置，则说明当前排序完成，结束循环 时间复杂度：O(n²) 1234567891011121314151617function bubbleSort(arr) &#123; let isOver = false; for (var i = 0; i &lt; arr.length - 1; i++) &#123; isOver = true; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; isOver = false; &#125; &#125; // 内部循环一轮都不需要调换位置，说明全部排序已完成，没有必要再继续外部循环 if (isOver) &#123; return arr; &#125; &#125; return arr;&#125; 选择排序（Selection Sort）首先在乱序的数组中选择出最小的值，然后和每次循环后的数组第一位进行交换 时间复杂度：O(n²) 1234567891011121314151617const x = [0, 5, 3, 2, 4, 1, 10];function chooseSort (arr) &#123; let tempArr = [...arr]; for (let i = 0; i &lt; tempArr.length; i++) &#123; let maxIndex = i; for (let j = i; j &lt; tempArr.length; j++) &#123; if (tempArr[j] &gt; tempArr[maxIndex]) &#123; maxIndex = j &#125; &#125; if (maxIndex !== i) &#123; [tempArr[i], tempArr[maxIndex]] = [tempArr[maxIndex], tempArr[i]]; &#125; &#125; return tempArr;&#125;console.log(chooseSort(x)) 插入排序（Insert Sort）对数组进行循环，当循环到i时，认为i之前的项目都已经排好序了，对i+1进行处理，将i+1项插入到已经排好序的队列中，插入的方法就是从i+1开始，向回循环，两两比较，根据比较结果进行换位 时间复杂度：O(n²) 123456789101112const x = [0, 5, 3, 2, 4, 1, 10];function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &gt; 0; j--) &#123; if (arr[j - 1] &lt; arr[j]) &#123; [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(insertSort(x)) 归并排序（Merge Sort）把一个数组分为两个数组，左边排好序，右边排好序，然后合并到一起排序。 归并排序是分治法的典型实例，指的是将两个已经排序的序列合并成一个序列的操作 时间复杂度：O(nlogn) 排序过程： 1234567891011121314151617181920212223242526272829303132var arr = [-11, 17, 12, 19, 0, -222];function mergeSort(arr, s, e) &#123; if (s &gt; e) &#123; //起始位置大于终点位置，返回空数组 return []; &#125; else if (s == e) &#123; return [arr[s]]; //起始位置等于终点位置，说明数组里只有一个数字，返回只含一个数字的数组 &#125; var mIndex = Math.floor((s + e) / 2); //中间位置的Index var arrL = mergeSort(arr, s, mIndex); //将左边的数组排序 var arrR = mergeSort(arr, mIndex + 1, e); //将右边的数组排序 var resultArr = []; //结果数组 while (arrL.length &gt; 0 &amp;&amp; arrR.length &gt; 0) &#123; //当左右两个数组都不为空时 if (arrL[0] &lt; arrR[0]) &#123; resultArr.push(arrL.shift()); &#125; else &#123; resultArr.push(arrR.shift()); &#125; if (arrL.length == 0) &#123; //当左边的数组为空时 resultArr = resultArr.concat(arrR); break; &#125; else if (arrR.length == 0) &#123; resultArr = resultArr.concat(arrL); break; &#125; &#125; return resultArr;&#125;document.write(mergeSort(arr, 0, arr.length - 1)); 快速排序（quickSort） 在数据集之中，选择一个元素作为”基准”（pivot） 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 1234567891011121314151617181920212223var arr = [77, -33, 22, 32, 0, 2, 11];function quickSort(arr) &#123; // 递归结束条件 if (arr.length &lt;= 1) &#123; return arr; &#125; // 选择基准元素，并且从原数组中暂时剔除 const index = Math.floor(arr.length / 2); const base = arr.splice(index, 1)[0]; // 将数组分为左右组 let left = []; let right = []; // 对所有元素进行遍历，将大于基准值的放在左边，小于基准值的放在右边 for (let i = 0; i &lt; arr.length; i++) &#123; (arr[i] &lt; base ? right : left).push(arr[i]) &#125; // quickSort(left)对左边的合集进行递归 // quickSort(right)对右边的合集进行递归 // 连接起来，再加上基准元素就是完整合集 return quickSort(left).concat([base], quickSort(right))&#125;document.write(quickSort(arr)); 计数排序时间复杂度为O(N) 用空间换时间的算法，适用于提前知道数字范围，并且相差范围不大的情况 将数字放到对应的数组对象中，然后进行排序 这种方法不能对应数组中有负数的情况 1234567891011121314151617181920212223242526let arr = [100, 2, 3, 1, 5, 22, 33, 11, 22, 33];function sort(arr) &#123; let temp = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!temp[arr[i]]) &#123; temp[arr[i]] = 1; &#125; else &#123; temp[arr[i]]++; &#125; &#125; let result = []; for (let j = 0; j &lt; temp.length; j++) &#123; if (temp[j]) &#123; for (let k = 0; k &lt; temp[j]; k++) &#123; result.push(j) &#125; &#125; &#125; return result;&#125;console.log(sort(arr)) 参考 js算法之最常用的排序@博客园 JS-排序详解-冒泡排序@博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础01 常用排序算法]]></title>
    <url>%2F2017%2F12%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F05%20%E7%AE%97%E6%B3%95%2F01%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%8001%20%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JS常用排序算法的总结。 所有算法的动画演示 冒泡排序（Bubble Sort）对相邻的两个对象进行比较，如果后者小于前者，把小的放前面 时间复杂度：O(n²) 123456789101112// 对比arr中的第j+1项和第j项，如果第j+1项小于第j项，就把第j+1项和第j项调换位置。// 如果没达到最终的顺序（从小到大），就继续找，继续换，直到达到最终效果function bubbleSort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; &#125; &#125; &#125; return arr;&#125; （2018.4.3补充）发现在内层循环时，可以改变内层循环的范围为 j&lt;arr.length-1-i, 原因是 当 i=0 的时候，里面的循环完整执行，第一遍排序，结果是将最大的数排到了最后 当 i=1 的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是 j&lt;arr.length-1-i 的巧妙之处 优化冒泡排序算法对冒泡排序进行优化，设定一个变量flag，用于表明是否进行了位置交换，如果没有交换位置，则说明当前排序完成，结束循环 时间复杂度：O(n²) 1234567891011121314151617function bubbleSort(arr) &#123; let isOver = false; for (var i = 0; i &lt; arr.length - 1; i++) &#123; isOver = true; for (var j = 0; j &lt; arr.length - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [tempArr[j], tempArr[j + 1]] = [tempArr[j + 1], tempArr[j]]; isOver = false; &#125; &#125; // 内部循环一轮都不需要调换位置，说明全部排序已完成，没有必要再继续外部循环 if (isOver) &#123; return arr; &#125; &#125; return arr;&#125; 选择排序（Selection Sort）首先在乱序的数组中选择出最小的值，然后和每次循环后的数组第一位进行交换 时间复杂度：O(n²) 1234567891011121314151617const x = [0, 5, 3, 2, 4, 1, 10];function chooseSort (arr) &#123; let tempArr = [...arr]; for (let i = 0; i &lt; tempArr.length; i++) &#123; let maxIndex = i; for (let j = i; j &lt; tempArr.length; j++) &#123; if (tempArr[j] &gt; tempArr[maxIndex]) &#123; maxIndex = j &#125; &#125; if (maxIndex !== i) &#123; [tempArr[i], tempArr[maxIndex]] = [tempArr[maxIndex], tempArr[i]]; &#125; &#125; return tempArr;&#125;console.log(chooseSort(x)) 插入排序（Insert Sort）对数组进行循环，当循环到i时，认为i之前的项目都已经排好序了，对i+1进行处理，将i+1项插入到已经排好序的队列中，插入的方法就是从i+1开始，向回循环，两两比较，根据比较结果进行换位 时间复杂度：O(n²) 123456789101112const x = [0, 5, 3, 2, 4, 1, 10];function insertSort(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &gt; 0; j--) &#123; if (arr[j - 1] &lt; arr[j]) &#123; [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; &#125; &#125; &#125; return arr;&#125;console.log(insertSort(x)) 归并排序（Merge Sort）把一个数组分为两个数组，左边排好序，右边排好序，然后合并到一起排序。 归并排序是分治法的典型实例，指的是将两个已经排序的序列合并成一个序列的操作 时间复杂度：O(nlogn) 排序过程： 1234567891011121314151617181920212223242526272829303132var arr = [-11, 17, 12, 19, 0, -222];function mergeSort(arr, s, e) &#123; if (s &gt; e) &#123; //起始位置大于终点位置，返回空数组 return []; &#125; else if (s == e) &#123; return [arr[s]]; //起始位置等于终点位置，说明数组里只有一个数字，返回只含一个数字的数组 &#125; var mIndex = Math.floor((s + e) / 2); //中间位置的Index var arrL = mergeSort(arr, s, mIndex); //将左边的数组排序 var arrR = mergeSort(arr, mIndex + 1, e); //将右边的数组排序 var resultArr = []; //结果数组 while (arrL.length &gt; 0 &amp;&amp; arrR.length &gt; 0) &#123; //当左右两个数组都不为空时 if (arrL[0] &lt; arrR[0]) &#123; resultArr.push(arrL.shift()); &#125; else &#123; resultArr.push(arrR.shift()); &#125; if (arrL.length == 0) &#123; //当左边的数组为空时 resultArr = resultArr.concat(arrR); break; &#125; else if (arrR.length == 0) &#123; resultArr = resultArr.concat(arrL); break; &#125; &#125; return resultArr;&#125;document.write(mergeSort(arr, 0, arr.length - 1)); 快速排序（quickSort） 在数据集之中，选择一个元素作为”基准”（pivot） 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 1234567891011121314151617181920212223var arr = [77, -33, 22, 32, 0, 2, 11];function quickSort(arr) &#123; // 递归结束条件 if (arr.length &lt;= 1) &#123; return arr; &#125; // 选择基准元素，并且从原数组中暂时剔除 const index = Math.floor(arr.length / 2); const base = arr.splice(index, 1)[0]; // 将数组分为左右组 let left = []; let right = []; // 对所有元素进行遍历，将大于基准值的放在左边，小于基准值的放在右边 for (let i = 0; i &lt; arr.length; i++) &#123; (arr[i] &lt; base ? right : left).push(arr[i]) &#125; // quickSort(left)对左边的合集进行递归 // quickSort(right)对右边的合集进行递归 // 连接起来，再加上基准元素就是完整合集 return quickSort(left).concat([base], quickSort(right))&#125;document.write(quickSort(arr)); 计数排序时间复杂度为O(N) 用空间换时间的算法，适用于提前知道数字范围，并且相差范围不大的情况 将数字放到对应的数组对象中，然后进行排序 这种方法不能对应数组中有负数的情况 1234567891011121314151617181920212223242526let arr = [100, 2, 3, 1, 5, 22, 33, 11, 22, 33];function sort(arr) &#123; let temp = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!temp[arr[i]]) &#123; temp[arr[i]] = 1; &#125; else &#123; temp[arr[i]]++; &#125; &#125; let result = []; for (let j = 0; j &lt; temp.length; j++) &#123; if (temp[j]) &#123; for (let k = 0; k &lt; temp[j]; k++) &#123; result.push(j) &#125; &#125; &#125; return result;&#125;console.log(sort(arr)) 参考 js算法之最常用的排序@博客园 JS-排序详解-冒泡排序@博客园]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题16 EditorConfig和ESLint]]></title>
    <url>%2F2017%2F12%2F05%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9816%20EditorConfig%E5%92%8CESLint%2F</url>
    <content type="text"><![CDATA[编程好帮手：EditorConfig + ESLint EditorConfig为了保持项目中代码缩进风格的一致，可以使用EditorConfig来定义和维护一致的编码风格，例如范缩进风格，缩进大小，Tab长度以及字符集等。 标准的.editorconfig文件中，第一行是EditorConfig的官网，第二行是用于指明.editorconfig文件的位置，*代表通配符，下面是对应的规则，现在项目中使用的配置文件是这样的： 1234567891011121314151617181920root = true[*]#缩进风格：空格indent_style = space#缩进大小2indent_size = 2#字符集utf-8charset = utf-8#行尾允许空格trim_trailing_whitespace = true#结尾总是插入新的一行insert_final_newline = true[*.md]trim_trailing_whitespace = false 没有加入的属性还有： 12#换行符lfend_of_line = lf ESLintEslint是一个用来识别ECMAScript并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，一般使用配置文件来配置ESLint，在项目的根目录下创建.eslintrc.js 可以被配置的信息主要分为3类： Environments：你的Javascript脚本将要运行在什么环境（如：Node，浏览器等）中。 Globals：执行代码时脚步需要访问的额外全局变量。 Rules：开启某些规则，也可以设置规则的等级。 安装安装推荐局部安装： 1npm i -D eslint 安装完毕后，接下来新建一个配置文件.eslintrc.js，或者使用如下的命令行来自动生成。 1234./node_modules/.bin/eslint --init# 如果是全局安装的话可以执行eslint --init 配置文件中的配置规则分为三种等级： off” 或者 0：关闭规则。 “warn” 或者 1：打开规则，并且作为一个警告（不影响exit code）。 “error” 或者 2：打开规则，并且作为一个错误（exit code将会是1）。 1234567// .eslintrc.jsmodule.exports = &#123; env: &#123; browser: true, node: true, &#125;,&#125;; 具体的配置规则非常多，具体见这里。 在Webstorm中使用在Webstorm中配置ESLint，需要在Language &amp; Frameworks → Javascript → Code Quality Tools → ESLint中进行配置，勾选Enable 一般情况下下面的对应的配置和地址都会自动填好。 AlloyTeam ESLint规则也可以使用腾讯的AlloyTeam的ESLint规则，有详细的规则描述和示例，可以在此基础上进行定制。 使用时需要首先安装eslint、babel-eslint、eslint-config-alloy，这是AlloyTeam的ESLint规则的最基础的所需要安装的依赖 1npm install --save-dev eslint babel-eslint eslint-config-alloy 然后在项目根目录下的eslintrc.js中复制以下内容： 12345678910111213141516171819202122232425module.exports = &#123; extends: [ 'eslint-config-alloy', ], globals: &#123; // 这里填入你的项目需要的全局变量 // 这里值为 false 表示这个全局变量不允许被重新赋值，比如： // // jQuery: false, // $: false &#125;, rules: &#123; // 这里填入你的项目需要的个性化配置，比如： // // // @fixable 一个缩进必须用两个空格替代 // 'indent': [ // 'error', // 2, // &#123; // SwitchCase: 1, // flatTernaryExpressions: true // &#125; // ] &#125;&#125;; 配合Vue使用可以在使用AlloyTeam预置的Vue的规则： 12345npm install eslint babel-eslint vue-eslint-parser@2.0.1-beta.2 eslint-plugin-vue@3 eslint-config-alloy --save-dev 然后将.eslintrc.js中的extends的值更改为[&#39;eslint-config-alloy/vue&#39;] 下面是在CRM系统中使用的，一份配合Vue使用的配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module.exports = &#123; "env": &#123; "browser": true, "amd": true, "jquery": true &#125;, "rules": &#123; // 禁止出现alert, prompt 和 confirm, 可以在发布的时候进行检测 "no-alert": 2, // 禁止出现console, 可以在发布的时候进行检测 "no-console": 2, // 禁止出现debugger, 可以在发布的时候进行检测 "no-debugger": 2, // 禁止不写分号 "semi": [2, "always"], // 禁止出现tab之外的缩进 "indent": [2, "tab"], // 允许定义前使用 "no-use-before-define": 0, // 允许if (!!foo) 这种形式 "no-extra-boolean-cast": 0, // 允许对函数声明进行覆盖赋值 "no-func-assign": 0, // 允许使用caller或callee "no-caller": 0, // 允许函数在不同的情况下返回不同类型的值 "consistent-return": 0, // 允许在switch的case中不加break "no-fallthrough": 0, // 允许使用__proto__ "no-proto": 0, // 允许覆盖外部变量 "no-shadow": 0, // 允许文件的最后一行不是空白行 "eol-last": 0, // 允许使用下划线开头命名变量 "no-underscore-dangle": 0, // 建议将操作符放到行尾, 而不是行首 "operator-linebreak": [1, "after"], // 建议使用已定义的变量 "no-undef": 1, // 建议return语句中不要包含赋值表达式 "no-return-assign": 1, // 建议代码列数不能超过120行 "max-len": [1, 120], // 建议启用严格模式 "global-strict": 0, "strict": 1, // 建议使用单引号 "quotes": [1, "single"], // 建议注释符要有空白隔开 "spaced-comment": [1, "always"] &#125;, // 如果使用vue单文件组件 "extends": [ "plugin:vue/essential" ],&#125; 配合React使用同样可以在使用AlloyTeam预置的React的规则： 1234npm install eslint babel-eslint eslint-plugin-react eslint-config-alloy --save-dev 然后将.eslintrc.js中的extends的值更改为[&#39;eslint-config-alloy/react&#39;]。 在Exam项目中使用的一份很简单的配置文件： 1234567891011121314151617181920212223module.exports = &#123; extends: [ 'plugin:react/recommended', ], "ecmaFeatures": &#123; "jsx": true, "modules": true &#125;, "env": &#123; "browser": true, "node": true &#125;, "parser": "babel-eslint", "rules": &#123; "quotes": [2, "single"], "react/jsx-uses-react": 2, "react/jsx-uses-vars": 2, "react/react-in-jsx-scope": 2 &#125;, "plugins": [ "react" ]&#125; 需要注意的是，如果使用的Create React App脚手架工具来搭建React项目，由于它将默认的构建配置封装了起来，而ESLint仅仅开启了最基本的规则，更重要的是默认情况下，ESLint仅仅会在IDE中对违反规则的情况进行提示，并不会在构建时在终端的输出进行终端和提示。 如果这种情况可以满足需要，而只需要开启更多的规则，那么就可以在根目录下新建一个文件.eslintrc.json，然后添加： 123&#123; "extends": "react-app"&#125; 但是如果要起到更强制性的提示作用（中断构建、终端提示），Create React App建议使用Prettier代替ESLint。如果要使用ESLint，那么就需要使用npm run eject，将配置文件吐出，按照AlloyTeam的提示进行配置即可。 ESlint对Async报错的解决方法在ESlint配置文件中增加 123parserOptions: &#123; "ecmaVersion": 8,&#125; 参考 rules@ESLint 在WebStorm中使用editorConfig插件@CSDN ESLint与EditorConfig@CSDN ESLint - 简介@简书 Displaying Lint Output in the Editor@Create React App AlloyTeam/eslint-config-alloy@github]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
        <tag>EditorConfig</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础10 Restful API设计规范]]></title>
    <url>%2F2017%2F11%2F13%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8010%20Restful%20API%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[REST 用来规范应用如何在 HTTP 层与 API 提供方进行数据交互 。 REST 描述了 HTTP 层里客户端和服务器端的数据交互规则；客户端通过向服务器端发送 HTTP（s）请求，接收服务器的响应，完成一次 HTTP 交互。这个交互过程中，REST 架构约定两个重要方面就是 HTTP 请求的所采用方法，以及请求的链接。 REST 对请求的约定REST 用来规范应用如何在 HTTP 层与 API 提供方进行数据交互 。 REST 描述了 HTTP 层里客户端和服务器端的数据交互规则；客户端通过向服务器端发送 HTTP（s）请求，接收服务器的响应，完成一次 HTTP 交互。这个交互过程中，REST 架构约定两个重要方面就是 HTTP 请求的所采用方法，以及请求的链接。 在请求层面，REST 规范可以简单粗暴抽象成以下两个规则： 请求 API 的 URL 表示用来定位资源； 请求的 METHOD 表示对这个资源进行的操作； API 的 URLURL 用来定位资源，跟要进行的操作区分开，这就意味这 URL 不该有任何动词； 下面示例中的get、create、search等动词，都不应该出现在 REST 架构的后端接口路径中。在以前，这些接口中的动名词通常对应后台的某个函数。比如： 1234/api/getUser/api/createApp/api/searchResult/api/deleteAllUsers 当我们需要对单个用户进行操作时，根据操作的方式不同可能需要下面的这些接口： 1234/api/getUser （用来获取某个用户的信息，还需要以参数方式传入用户 id 信息）/api/updateUser （用来更新用户信息）/api/deleteUser （用来删除单个用户）/api/resetUser （重置用户的信息） 更有甚者，可能在更新用户不同信息时，提供不同的接口，比如： 123/api/updateUserName/api/updateUserEmail/api/updateUser 这样的弊端在于：首先加上了动词，肯定是使 URL 更长了；其次对一个资源实体进行不同的操作就是一个不同的 URL，造成 URL 过多难以管理。 其实当你回过头看「URL」 这个术语的定义时，更能理解这一点。URL 的意思是统一资源定位符，这个术语已经清晰的表明，一个 URL 应该用来定位资源，而不应该掺入对操作行为的描述。 在 REST 架构的链接应该是这个样子： URL 中不应该出现任何表示操作的动词，链接只用于对应资源； URL 中应该单复数区分，推荐的实践是永远只用复数；比如GET /api/users表示获取用户的列表；如果获取单个资源，传入 ID，比如/api/users/123表示获取单个用户的信息； 按照资源的逻辑层级，对 URL 进行嵌套，比如一个用户属于某个团队，而这个团队也是众多团队之一；那么获取这个用户的接口可能是这样： 1GET /api/teams/123/members/234 表示获取 id 为 123 的小组下，id 为234 的成员信息 按照类似的规则，可以写出如下的接口: 1234/api/teams （对应团队列表）/api/teams/123 （对应 ID 为 123 的团队）/api/teams/123/members （对应 ID 为 123 的团队下的成员列表）/api/teams/123/members/456 （对应 ID 为 123 的团队下 ID 为 456 的成员） 特殊情况：有的时候一个资源变化难以使用标准的 Restful API 来命名，可以考虑使用一些特殊的 actions 命名。比如，“密码修改”这个接口的命名很难完全使用名词来构建路径，此时可以引入 action： 1【PUT】 /v1/users/&#123;user_id&#125;/password/actions/modify // 密码修改 API的请求方法在很多系统中，几乎只用 GET 和 POST 方法来完成了所有的接口操作；这个行为类似于全用 DIV 来布局。实际上，我们不只有GET 和 POST 可用，在 REST 架构中，有以下几个重要的请求方法：GET，POST，PUT，PATCH，DELETE。这几个方法都可以与对数据的 CRUD 操作对应起来。 CRUD 是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。即增删改查 简单来说，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。 123456【GET】 /users # 查询用户信息列表【GET】 /users/1001 # 查看某个用户信息【POST】 /users # 新建用户信息【PUT】 /users/1001 # 更新用户信息(全部字段)【PATCH】 /users/1001 # 更新用户信息(部分字段)【DELETE】 /users/1001 # 删除用户信息 1【Read】资源的读取，用 GET 请求，比如： 1GET /api/users （ 表示读取用户列表） GET 应当实现为一个安全方法。用于获取数据而不应该产生副作用。 2【Created】资源的创建，用 POST 方法； POST 是一个非幂等的方法，多次调用会造成不同效果； 幂等（Idempotent）：如果对服务器资源的多次请求与一次请求造成的副作用是一样的的话，那这个请求方法可以被认为是幂等。 比如下面的请求会在服务器上创建一个name属性为&#39;John Snow&#39;的用户；多次请求就会创建多个这样的用户。 12345POST /api/users&#123; &quot;name&quot;: &quot;John Snow&quot;&#125; 3【Update】资源的更新。用于更新的 HTTP 方法有两个，PUT 和 PATCH。 他们都应当被实现为幂等方法，即多次同样的更新请求应当对服务器产生同样的副作用。 PUT 和 PATCH 有各自不同的使用场景： PUT 用于更新资源的全部信息，在请求的body中需要传入修改后的全部资源主体； PATCH 用于局部更新，在body中只需要传入需要改动的资源字段。 设想服务器中有以下用户资源/api/users/123 12345&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;Original&quot;, &quot;age&quot;: 20&#125; 当我们往后台发送更新请求时，PATCH 和 PUT 造成的效果是不一样。 12345PUT /api/users/123&#123; &quot;name&quot;: &quot;PUT Update&quot;&#125; 上述 PUT 请求操作后的内容是： 1234&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;PUT Update&quot;&#125; 可以观察到，资源原有的 age 字段被清除掉了。 而如果改用 PATCH 的话， 12345PATCH /api/users/123&#123; &quot;name&quot;: &quot;PATCH Update&quot;&#125; 更新后的内容是： 12345&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;PATCH Update&quot;, &quot;age&quot;: 20&#125; 请求中指定的name属性被更新了，而原有的age属性则保持不变。 PATCH 的作用在于如果一个资源有很多字段，在进行局部更新时，只需要传入需要修改的字段即可。否则在用 PUT 的情况下，你不得不将整个资源模型全都发送回服务器，造成网络资源的极大浪费。 4【Delete】资源的删除，相应的请求 HTTP 方法就是 DELETE。这个也应当被实现为一个幂等的方法。如: 1DELETE /api/users/123 用于删除服务器上ID为123的资源，多次请求产生副作用都是，是服务器上ID为123的资源不存在。 5 两个不常用的HTTP动词 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。针对非简单请求的CORS请求，会在正式通信之前增加一次HTTP查询请求，称为“预检”请求，对应的请求方法就是OPTION 查询参数REST 风格的接口地址，表示的可能是单个资源，也可能是资源的集合；当我们需要访问资源集合时，设计良好的接口应当接受参数，允许只返回满足某些特定条件的资源列表。 公共参数常规的公共查询参数有： 参数名 作用 offset 返回记录的开始位置 limit 返回记录的数量 keyword 提供关键词进行搜索 sort 指定排序的字段 orderby 指定排序方式 具体来看： （1）以offset和limit参数来进行分页： 1GET /api/users?offset=0&amp;limit=20 （2）使用keyword提供关键词进行搜索： 1GET /api/users?keyword=john （3）使用sort参数和orderby参数进行排序 12GET /api/users?sort=age&amp;orderby=asc // 按年龄升序GET /api/users?sort=age&amp;orderby=desc // 按年龄降序 有的时候也可以只用orderby来进行排序： 12GET /api/users?se&amp;orderby=age_asc // 按年龄升序GET /api/users?se&amp;orderby=age_desc // 按年龄降序 个性参数上面介绍的offset、limit、 orderby 是一些公共参数。此外，业务场景中还存在许多个性化的参数： 1【GET】 /v1/categorys/&#123;category_id&#125;/enable=[1|0]&amp;os_type=&#123;field&#125;&amp;device_ids=&#123;field,field,…&#125; 注意不要过度设计，只返回用户需要的查询参数，此外，需要考虑是否对查询参数创建数据库索引以提高查询性能。 语义化设计合适的 API URL，以及选择合适的请求方法，可以语义化的描述一个 HTTP 请求的操作。 当我们都熟悉且遵循这样的规范后，基本可以看到一个 REST 风格的接口就知道如何使用这个接口进行 CRUD 操作了。比如下面这面这个接口就表示搜索ID为123的图书馆的书，并且书的信息里包含关键字game，返回前十条满足条件的结果。 1GET /api/libraries/123/books?keyword=game&amp;sort=price&amp;limit=10&amp;offset=0 同样，下面这个请求的意思也就很明显了吧。 12345PATCH /api/companies/123/employees/234&#123; &quot;salary&quot;: 2300&#125; 状态码服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 状态码 状态信息 说明 200 OK 请求成功 201 CREATED 创建成功 204 NO CONTENT 删除数据成功 400 INVALID REQUEST 错误的请求 401 Unauthorized 未授权 403 Forbidden 有授权（与401相对），但是被拒绝 404 NOT FOUND 无法找到 406 Not Acceptable 用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式） 500 INTERNAL SERVER ERROR 服务器发生错误 错误处理当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。 一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: "Invalid API key"&#125; 也可以采取下面的结构： 1234567891011HTTP/1.1 400 Bad RequestContent-Type: application/json&#123; &quot;code&quot;: &quot;INVALID_ARGUMENT&quot;, &quot;message&quot;: &quot;&#123;error message&#125;&quot;, &quot;cause&quot;: &quot;&#123;cause message&#125;&quot;, &quot;request_id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;, &quot;host_id&quot;: &quot;&#123;server identity&#125;&quot;, &quot;server_time&quot;: &quot;2014-01-01T12:00:00Z&quot;&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 1234567【GET】 /&#123;version&#125;/&#123;resources&#125; // 返回资源对象的列表（数组）【GET】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回单个资源对象【POST】 /&#123;version&#125;/&#123;resources&#125; // 返回新生成的资源对象【PUT】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回完整的资源对象【PATCH】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 返回完整的资源对象【DELETE】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 状态码 200，返回完整的资源对象。【DELETE】 /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125; // 状态码 204，返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 12345678&#123; "link": &#123; "rel": "collection https://www.example.com/zoos", "href": "https://api.example.com/zoos", "title": "List of zoos", "type": "application/vnd.yourformat+json" &#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; "current_user_url": "https://api.github.com/user", "authorizations_url": "https://api.github.com/authorizations", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user， 然后就得到了下面结果。 1234&#123; "message": "Requires authentication", "documentation_url": "https://developer.github.com/v3"&#125; 版本号在 Restful API 中，API应当尽量兼容之前的版本。Web端很容易为了适配服务端的新的 API 接口进行版本升级，而 Android 、IOS等客户端必须通过用户主动升级产品到新版本，才能适配新接。 为了解决这个问题，在设计 Restful API时一般情况下会在 URL 中半流版本号，并同时兼容多个版本： 12【GET】 /v1/users/&#123;user_id&#125; // 版本 v1 的查询用户列表的 API 接口【GET】 /v2/users/&#123;user_id&#125; // 版本 v2 的查询用户列表的 API 接口 现在可以再不改变 V1 版本的接口情况下，新增 V2 版本的接口满足新的业务需求。服务端会同时兼容多个版本，但是同时维护版本过多也会成为不小的负担。常见的做法是，不维护全部的兼容版本，而是只维护最新的几个兼容版本，例如维护最新的三个兼容版本。在一段时间后，大部分的用户升级到新的版本后，废弃一些使用量较少的服务端老版本的API接口，并要求使用产品老旧版本的用户墙纸升级。 其他 API的身份认证应该使用OAuth 2.0框架。 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 关于 REST 的更多详细规范，可以参考这个仓库。 参考 RESTful API 设计指南@阮一峰的网络日志 RESTful 接口实现简明指南@知乎 服务端指南 | 良好的 API 设计指南@掘金]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Restful</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS28 判断对象是空对象]]></title>
    <url>%2F2017%2F11%2F09%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F02%20JavaScript%2FJS28%20%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[如何判断对象是空对象，总结了一下。 概述一个空的对象{}在JS中进行判断，显示为真值： 12var a = &#123;&#125;;console.log(!!a) // true 所以要判断对象中是否含有属性，需要使用特殊的手段，不同情况下有不同的手段： Reflect.ownKeys() JSON.stringify Object.keys/Object.values/Object.entries Object.getOwnPropertyNames() for...in 其他方法 这里判断对象是否是空对象，应该刨除原型链继承的影响，只观察对象自身是否含有任意属性值。 基于这个前提下，我认为可能Reflect.ownKeys()是更恰当的方法。 遍历方法的区别先来看一下各种遍历方法的区别： 自身属性 原型属性 可枚举属性 不可枚举属性 Symbol属性 for...in √ √ √ × × Object.getOwnPropertyNames √ × √ √ × Object.keys √ × √ × × Relect.ownKeys √ × √ √ √ Reflect.ownKeys(target)Relfect对象是ES6为操作对象提供的新API，它提供了许多针对对象的操作方法，其中ownKeys用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 它与其他的遍历方法最大的不同就是，它会将对象中Symbol类型的属性名遍历出来，而其他的方法不会。 123function isEmpty(obj) &#123; return Reflect.ownKeys(obj).length === 0&#125; 其他的方法都有着自己的局限性。 Object.keys()Object.keys()方法返回的数组中只包括自身可枚举的属性，不可枚举属性和Symbol属性都包括在返回结果中 Object.getOwnPropertyNames()Object.getOwnPropertyNames()返回的结果中包含自身可枚举和不可枚举的属性，但是不包含Symbol属性 它与Object.keys()相比，返回结果增加了自身不可枚举的属性 for...in利用for...in对对象进行遍历时，会返回自身以及原型链上的可枚举属性，返回结果不包含Symbol属性 我们这里的前提是不考虑原型链继承而来的属性，所以即便不考虑Symbol属性，也需要通过hasOwnProperty判断遍历的结果是继承自原型链还是属于自身的属性 JSON.stringify()JSON.stringify()方法可以将对象序列化为字符串，但是在序列化过程中会忽略方法属性和Symbol属性 12345const a = &#123; [Symbol(123)]: 123, say() &#123;&#125;&#125;;console.log(JSON.stringify(a)) // '&#123;&#125;' Lodash的isEmpty方法使用Lodash的isEmpty判断对象是否是空对象时，对象如果被认为为空，那么他们没有自己的可枚举属性的对象。 它对字符串、数组、类数组对象也考虑在内了，如果这些对象长度为0，就认为是空对象 对于Map和Set对象，如果其size为0，就认为是空对象 看一下它的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Checks if `value` is an empty object, collection, map, or set. * * Objects are considered empty if they have no own enumerable string keyed * properties. * * Array-like values such as `arguments` objects, arrays, buffers, strings, or * jQuery-like collections are considered empty if they have a `length` of `0`. * Similarly, maps and sets are considered empty if they have a `size` of `0`. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param &#123;*&#125; value The value to check. * @returns &#123;boolean&#125; Returns `true` if `value` is empty, else `false`. * @example * * _.isEmpty(null); * // =&gt; true * * _.isEmpty(true); * // =&gt; true * * _.isEmpty(1); * // =&gt; true * * _.isEmpty([1, 2, 3]); * // =&gt; false * * _.isEmpty(&#123; 'a': 1 &#125;); * // =&gt; false */function isEmpty(value) &#123; // 对于null也认为是空对象，返回true if (value == null) &#123; return true; &#125; // 对数组/类数组对象/字符串/Buffer/arguments对象，根据length属性进行判断 if (isArrayLike(value) &amp;&amp; (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) &#123; return !value.length; &#125; // 主要是通过Object.prototype.toString.call返回类型 var tag = getTag(value); // 针对Map和Set对象，根据size属性进行判断 if (tag == mapTag || tag == setTag) &#123; return !value.size; &#125; // 针对原型对象，利用for...in遍历，返回自身除了constructor之外的属性 if (isPrototype(value)) &#123; return !baseKeys(value).length; &#125; // 针对普通对象，利用for...in循环 for (var key in value) &#123; if (hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; return true;&#125; 发现它使用的是for...in来进行主要的判断，对Symbol属性也没有进行判断 123const key = Symbol(123);const a= &#123;[key]: 33&#125;;console.log(_.isEmpty(a)); // true 参考 Reflect@ECMAScript6入门 isEmpty@Lodash Object.keys()@MDN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node10 同时使用不同版本的node]]></title>
    <url>%2F2017%2F11%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode10%20%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84node%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。管理Node版本的笔记。 方法1：利用n工具利用n工具可以创建不同版本的node并且在不同版本切换 12345678npm install -g n n ls //查看可用版本 n 5.8.0 //安装5.8.0版本n stable //安装最新稳定版n lastest //安装最新版n rm 0.10.1 //删除某个版本n use 0.10.21 some.js //以指定的版本来执行脚本 使用最后一条命令就可以使用指定版本的node来运行文件， 比如，etutorweb使用的node是5.8.0， 所以当前node全局版本是5.8.0，exam的使用的node版本是6.9.1，原本的前端服务的启动命令是： 1NODE_ENV=development node ./bin/devServer.js 想要使用6.9.1版本的node需要把启动命令改为： 1NODE_ENV=development n use 6.9.1 ./bin/devServer.js ok了！并且不需要更改项目中任何关于node版本的信息 n无效的解决方法有时候通过n来切换版本会出现不生效的情况，原因可能就是node的安装目录和n默认的路径和不同 查看node当前安装路径： 123which node/opt/node/bin/node #举个例子 而n的默认安装路径是/usr/local，若你的node不是在此路径下，n切换版本就不能把文件复制到改路径中，所以我们必须通过N_PREFIX变量来修改n的默认的node安装路径 编辑环境配置文件： 1vim ~/.bash_profile 将下面两行代码插入到文件末尾： 12export N_PREFIX=/opt/node #node实际安装位置export PATH=$N_PREFIX/bin:$PATH :wq保存退出 执行source使修改生效 1source ~/.bash_profile 确认一下环境变量是否生效： 12echo $N_PREFIX/opt/node 然后再重新执行切换版本的命令就ok了 123456$ n 4.4.4install : node-v4.4.4 mkdir : /opt/node/n/versions/node/4.4.4 fetch : https://nodejs.org/dist/v4.4.4/node-v4.4.4-linux-x64.tar.gz##############100.0% installed : v4.4.4 再查看当前 node 版本： 12$ node -vv4.4.4 方法2 使用ln -s命令ln -s是linux系统中一个非常重要的命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接，使用方法： 1ln -s 源文件 目标文件 这里有两点要注意： 第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接 和硬链接两种，软链接就是ln -s ,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 这里就是利用ln -s将项目中的node文件连接到指定版本的node文件 首先找到n创建的不同版本的node安装位置（也可以不使用n安装不同版本的node），找到要使用的版本的node的启动文件： 1/usr/local/n/versions/node/6.0.0/bin/node 然后将这个文件链接到全局，不过为了全局的node已经被node5.8.0版本占用，所以连接到node6，： 1ln -s /usr/local/n/versions/node/6.9.1/bin/node /usr/local/bin/node6 也可以将对应版本的npm链接过去1ln -s /usr/local/n/versions/node/6.9.1/bin/npm /usr/local/bin/npm6 这样执行node6就对应到6.9.1的node上了 1234ubuntu@et-zhouhao:~$ node -vv5.8.0ubuntu@et-zhouhao:~$ node6 -vv6.9.1 然后将项目的启动命令中的node改为node6即可： 1NODE_ENV=development node6 ./bin/devServer.js 但是要注意，这种方法，需要在项目中将对应的node命令都改为node6，否则会报错，比如nodemon.json中的execMap对应的node要改为node6，并且只能在本机更改，不能上传到代码仓库中： 12345678910111213141516171819202122232425&#123; &quot;restartable&quot;: &quot;rs&quot;, &quot;ignore&quot;: [ &quot;.git&quot;, &quot;node_modules/**/node_modules&quot;, &quot;test&quot;, &quot;view&quot; ], &quot;verbose&quot;: true, &quot;execMap&quot;: &#123; &quot;js&quot;: &quot;node6&quot; &#125;, &quot;events&quot;: &#123; &quot;restart&quot;: &quot;echo \&quot;App restarted\&quot;&quot; &#125;, &quot;watch&quot;: [ &quot;config&quot;, &quot;server&quot;, &quot;shared&quot; ], &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot; &#125;, &quot;ext&quot;: &quot;js json&quot;&#125; 参考 https://segmentfault.com/a/1190000007567870]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>n</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础02 HTTP缓存]]></title>
    <url>%2F2017%2F10%2F04%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F08%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%8002%20HTTP%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTTP缓存学习笔记。 WEB缓存分类Web缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN缓存）、浏览器缓存。 浏览器缓存也包含很多内容：HTTP缓存、indexDB、cookie、localstorage 等等。 强缓存和协商缓存强缓存：可以理解为无须验证的缓存策略。对强缓存来说，响应头中有两个字段Expires/Cache-Control来表明规则。 协商缓存：缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差异，实际上没有必要再次请求。客户端和服务器端通过某种验证机制验证当前请求资源是否可以使用缓存。 浏览器第一次请求数据之后会将数据和响应头部的缓存标识存储起来。再次请求时会带上存储的头部字段，服务器端验证是否可用。如果返回304 Not Modified，代表资源没有发生改变可以使用缓存的数据，获取新的过期时间。反之返回200就相当于重新请求了一遍资源并替换旧资源。 ==强制缓存的优先级高于协商缓存== 缓存机制 浏览器判定是否有缓存（Cache-Control） 浏览器根据expires或者max-age（max-age会覆盖expires）判定缓存是否过期，如果未过期，则使用缓存（即==强缓存==，不需要与服务器交互，返回码200 OK (from cache)） 如果已过期，则浏览器向服务器发送请求，如果上次缓存中有Last-modified和Etag字段，这次请求的请求头中会加入If-Modified-Since（对应于Last-modified）和If-None-Match（对应于Etag）。如果服务器确定内容未更改，则使用缓存（即==协商缓存==，返回码304 Not Modified），否则重新请求资源 服务器将Cache-control、Expires、Last-modified、Date、Etag等字段在响应头中返回，便于下次缓存。 缓存控制字段ExpiresExpires指缓存过期的时间，超过了这个时间点就代表资源过期。 取值是一个日期： 12Expires: new Date(&apos;2018/12/06&apos;)Expires: Wed, 21 Oct 2015 07:28:00 GMT 当设置为一个无效的日期，比如0或者-1，代表者此资源已经过期，相当于==禁止使用缓存== Expires是HTTP/1.0的标准，如果同时设置了Cache-Control中的max-age或者s-max-age，Expires会被忽略 Cache-ControlCache-Control主要有以下几个取值： max-age: 设置缓存的最大的有效时间，单位为秒，会覆盖掉expires s-maxage: 只用于共享缓存，比如CDN缓存，在私有缓存中被忽略，会覆盖max-age和expires public：响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存，并且在多用户间共享 private: 响应只作为私有的缓存，不能在用户间共享 no-cache: 表明资源不进行缓存。但是设置了no-cache之后==并不代表浏览器不缓存==，而是在使用缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间 no-store: 绝对禁止缓存，每次请求都要向服务器重新获取数据 must-revalidate: 如果页面过期，则去服务器进行获取。 这里面最后三个属性需要单独分析一下， no-store是拒绝禁止缓存，不再查看过期时间，每次都向服务器去请求新资源据 no-cache是拒接直接使用缓存，无论时间是否过期，都强制向服务器确认缓存的有效性 must-revalidate是拒绝使用过期缓存，只要时间过期，不再像服务器确认缓存有效性，而是直接请求新资源 Last-modified/If-Modified-Since==响应头部==的Last-modified，表示服务器端资源的最后修改时间 第一次请求之后，浏览器记录这个时间，再次请求时，==请求头部==带上 If-Modified-Since即为之前记录下的时间。 服务器端收到带If-Modified-Since的请求后会去和资源的最后修改时间对比。若修改过就返回最新资源，状态码200，若没有修改过则返回304。 Etag/If-None-MatchEtag是由服务端生成的一段hash字符串 第一次请求时服务器在响应头中带上ETag: abcd，之后客户端再次发送的请求中会带上If-None-Match: abcd，服务器比对ETag，返回304或200。 last-modified和Etag区别某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。 一些资源的最后修改时间改变了，但是内容没改变，使用Last-modified看不出内容没有改变。 Etag的精度比Last-modified高，属于强验证，要求资源字节级别的一致，==优先级高==。 计算ETag也是需要占用资源的，如果修改不是过于频繁，看自己的需求用Cache-Control是否可以满足。 考虑缓存的内容： CSS样式文件 JS文件 logo、图标 HTMLl文件 可以下载的内容 可缓存的内容又分为几种不同的情况： （1）不经常改变的文件 ==给max-age设置一个较大的值==，例如设置Cache-Control: max-age=31536000 标准中规定max-age的值最大不超过一年，所以设成31536000 引入的一些第三方文件、打包出来的带有hash后缀的CSS、JS文件。一般来说文件内容改变了，会更新版本号、hash值，相当于请求另一个文件。 （2）可能经常需要变动的文件 一般设置Cache-Control: no-cache max-age=0 比如入口index.html文件、文件内容改变但名称不变的资源。选择ETag或Last-Modified来做验证，在使用缓存资源之前一定会去服务器端做验证，命中缓存时会比第一种情况慢一点点，毕竟还要发请求进行通信。 不能被缓存的请求 HTTP信息头中包含Cache-Control:no-cache，Pragma:no-cache，或Cache-Control: max-age=0等告诉浏览器不用缓存的请求 Post请求无法被缓存 HTTP响应头中不包含缓存控制字段(Last-Modified/Etag/Cache-Control/Expires的请求无法被缓存 ==业务敏感的GET请求不应该被缓存== 禁止浏览器进行缓存的方法（1）在响应头中设置： Cache-control: no-store Cache-control: no-cache max-age=0 Cache-control: no-cache Expires: -1 Pragma: no-cache（与Cache-Control: no-cache效果一致，用来向后兼容只支持 HTTP/1.0 协议的缓存服务器） （2）针对HTML文件：可以在HTML文件的&lt;Meta&gt;标签中进行设置http-eqiv： 12345678&lt;meta http-equiv="Expires" content="Wed, 20 Jun 2007 22:33:00 GMT"&gt; &lt;!--设置每次访问都需要请求最新html代码--&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;meta http-equiv="Cache-Control" content="no-store"&gt;&lt;meta http-equiv="Pragma" content="no-store"&gt; http-eqiv规定了能改变服务器和用于引擎行为的编译，具体属性值参考文档。 （3）通过对文件命名增加时间戳或者Hash值，来强制浏览器重新获取新文件。 用户行为对缓存的影响（1）CTRL+F5强制刷新浏览器 浏览器不使用缓存，发送的请求头中带有Cache-Control: no-cache，明确告诉Web服务器，客户端不使用缓存。 （2）F5刷新浏览器； 如果是在地址栏输入网址然后回车，浏览器会查找内存缓存（Memory Cache）中是否有匹配。如有则使用（缓存命中）；如没有则发送网络请求 （3）在地址栏输入网址然后回车 同F5效果相同，区别是F5时在内存缓存（Memory Cache）中查找缓存是否匹配，而这里是在磁盘缓存（Disk Cache）中进行查找。 参考 浏览器缓存@掘金 Expires@MDN Pragma@MDN HTTP 缓存机制一二三@知乎]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node03 Package.json]]></title>
    <url>%2F2017%2F07%2F06%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode03%20Package.json%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Package.json的学习笔记。 1 概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 命令提示符执行npm install，则会根据package.json下载所有需要的包，npm install --production只下载dependencies节点的包 一个完整的package.json文件实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "name": "Hello World", "version": "0.0.1", "author": "张三", "description": "第一个node.js程序", "keywords": ["node.js", "javascript"], "repository": &#123; "type": "git", "url": "https://path/to/url" &#125;, "license": "MIT", "engines": &#123; "node": "0.10.x" &#125;, "bugs": &#123; "url": "http://path/to/bug", "email": "bug@example.com" &#125;, "contributors": [&#123; "name": "李四", "email": "lisi@example.com" &#125;], "scripts": &#123; "start": "node index.js" &#125;, "dependencies": &#123; "express": "latest", "mongoose": "~3.8.3", "handlebars-runtime": "~1.0.12", "express3-handlebars": "~0.5.0", "MD5": "~1.2.0" &#125;, "devDependencies": &#123; "bower": "~1.2.8", "grunt": "~0.4.1", "grunt-contrib-concat": "~0.3.0", "grunt-contrib-jshint": "~0.7.2", "grunt-contrib-uglify": "~0.2.7", "grunt-contrib-clean": "~0.5.0", "browserify": "2.36.1", "grunt-browserify": "~1.3.0", &#125;&#125; 在package.json中可以使用通配符： 12&quot;lint&quot;: &quot;jshint *.js&quot;&quot;lint&quot;: &quot;jshint **/*.js&quot; *表示任意文件名，**表示任意一层子目录 2 name字段name字段不能含有.和_，可以使用-，不能含有非URL安全的字符 3 scripts字段3.1 概述scripts字段指定了运行脚本命令时的npm命令缩写，比如start指定了运行npm run start时要执行的命令 注意的是当运行test、start、restart和stop命令时可以省略run npm脚本中需要执行多个任务时，如果是并行执行，使用&amp;符号： 1$ npm run script1.js &amp; npm run script2.js 如果是继发执行，使用&amp;&amp;符号： 1$ npm run script1.js &amp;&amp; npm run script2.js 更多的细节参考阮一峰的文章。 3.2 自定义脚本执行脚本时，npm会临时自动将目录的node_modules/.bin加入PATH变量。这意味着，可以使用node_modules中任何脚本，而无需添加node_modules/.bin前缀。比如，当前项目的依赖里面有Mocha，只要直接写mocha test就可以了。 例如执行tap命令，你可以直接写： 1"scripts": &#123;"test": "tap test/\*.js"&#125; 而不是12&quot;scripts&quot;: &#123;&quot;test&quot;: &quot;node_modules/.bin/tap test/\*.js&quot;&#125; 3.3 传递参数如果我们在执行npm run xxx操作的时候想给里面的脚本传参数可以使用-- --，如下所示： 1234"scripts": &#123; "test": "mocha test/", "test:xunit": "npm run test -- --reporter xunit" &#125; 这种设置对于组合一些高级配置的命令是非常有用的。 1234“scripts”: &#123; "lint": "jshint **.js", "lint:checkstyle": "npm run lint -- --reporter checkstyle &gt; checkstyle.xml"&#125; 3.4 生命周期钩子npm也在不同的生命周期提供了一些钩子，可以方便你在项目运行的不同时间点进行一些脚本的编写。 它的钩子分为两类：pre-和post-，前者是在脚本运行前，后者是在脚本运行后执行。所有的命令脚本都可以使用钩子（包括自定义的脚本）。 例如：运行npm run build，会按以下顺序执行： 1npm run prebuild --&gt; npm run build --&gt; npm run postbuild pre脚本和post脚本也是出口代码敏感(exit-code-sensitive)的，这意味着如果您的pre脚本以非零出口代码退出，那么NPM将立即停止，并且不运行后续脚本。 通常可以在pre脚本上执行一些准备工作，在post脚本上执行一些后续操作。 12345&#123; "clean": "rimraf ./dist &amp;&amp; mkdir dist", "prebuild": "npm run clean", "build": "cross-env NODE_ENV=production webpack" &#125; 另外，还有很多额外的生命周期钩子，可以方便使用，例如husky和pre-commit包提供了有关git的commit的生命周期钩子。 3.5 使用环境变量根据官网的介绍，在”scripts”中编写的脚本还可以方便使用一些内置变量，这些内置变量会在Node运行的时候放在process.env下，如果是shell脚本，就直接使用环境变量$…， 这对你编写一些脚本工具特别有用。 在package.json中所有的配置项都可以通过$npm_package_前缀拿到： 1"show": "echo $npm_package_name &amp;&amp; echo $npm_package_version" 如果是使用Node： 123const &#123; log &#125; = console;log(process.env.npm_package_name);log(process.env.npm_package_version); 配置参数放在npm_config_前缀的环境中（你可以通过npm config set设置一些配置变量，下面介绍config的时候会介绍)，例如： 3.6 一些常用的脚本配置引用阮老师的一些配置，可以看到配合一定的插件，npm可是实现一些很实用的功能 12345678910111213141516171819202122232425262728&#123; // 删除目录 "clean": "rimraf dist/*", // 本地搭建一个HTTP服务 "serve": "http-server -p 9090 dist/", // 打开浏览器 "open:dev": "opener http://localhost:9090", // 实时刷新 "livereload": "live-reload --port 9091 dist/", // 构建HTML文件 "build:html": "jade index.jade &gt; dist/index.html", // 只要CSS文件有变动，就重新执行构建 "watch:css": "watch 'npm run build:css' assets/styles/", // 只要HTML文件有变动，就重新执行构建 "watch:html": "watch 'npm run build:html' assets/html", // 部署到Amazon S3 "deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/", // 构建favicon "build:favicon": "node scripts/favicon.js",&#125; 3.7 内置脚本npm自带了数十个内置命令，这些命令都可以直接通过npm执行，除了instal，还有很多实用的 npm -l 列举所有npm自带的命令简介，然后通过npm help可以详细查看某个命令 npm search 快速查询npm中的相关包（和我们去npm官网查是一样的） npm root 查看全局的node_modules目录 npm audit fix 这个命令很实用，自动扫描您的项目漏洞，并自动安装任何兼容更新到脆弱的依赖 npm restart 重新启动模块 npm prune 移除当前不在package.json中但是存在node_modules中的依赖 npm repo 浏览器端打开项目地址（GitHub），省去打开浏览器查找的操作！ npm docs 查看项目文档，同上 npm home 在浏览器端查看项目（项目主页），同上 npm search 查找包含该字符串的依赖包 npm view [field][--json] 列出依赖信息，包括历史版本，可以指定field来查看某个具体信息，比如（versions) 可以添加–json参数输出全部结果 4 npxnpm v5.2.0之后还引入了npx，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。（在node_modules中，所有可执行文件，也就是package中带bin的，都会放在node_modules/.bin中） 举例：使用create-react-app创建一个react项目，老方法： 123npm install -g create-react-app // 实际就是把package.json中的bin命令连接到了/usr/local/bin中create-react-app my-app npx方式： 12npx create-react-app my-app // 执行本`node_modules/.bin`中的对应命令 这条命令会临时安装create-react-app包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。 npx会帮你执行依赖包里的二进制文件。 举例来说，之前我们可能会写这样的命令： 1npm i -D webpack./node_modules/.bin/webpack -v 如果你对bash比较熟，可能会写成这样： 12npm i -D webpack**npm bin**/webpack -v 有了npx，你只需要这样： 12npm i -D webpacknpx webpack -v npx会自动查找当前依赖包中的可执行文件，如果找不到，就会去PATH里找。如果依然找不到，就会帮你安装！ npx甚至支持运行远程仓库的可执行文件： 1npx github:piuccio/cowsay hello 再比如npx http-server可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些） 12345678910111213npx http-servernpx: 1 安装成功，用时 3.032 秒Path must be a string. Received undefinednpx: 25 安装成功，用时 5.241 秒C:\Users\zhouhao1\AppData\Roaming\npm-cache\_npx\45232\node_modules\http-server\bin\http-serverStarting up http-server, serving ./Available on: http://10.234.98.23:8080 http://192.168.56.1:8080 http://192.168.99.1:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server 指定node版本来运行npm scripts： 1npx -p node@8 npm run build npx的优点： 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 可以执行依赖包中的命令，安装完成自动运行。 自动加载node_modules中依赖包，不用指定$PATH。 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 5 dependencies字段和devDependencies字段5.1 使用dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 123456&#123; "devDependencies": &#123; "browserify": "~13.0.0", "karma-browserify": "~5.0.1" &#125;&#125; 在单独安装某个模块时： 使用--save表示将该模块写入dependencies属性。缩写为-S 使用--save-dve表示将该模块写入devDependencies属性。缩写为-D 从命令行参数字面上，我们就能看出dependencies、devDependencies的区别： dependencies表示我们要在生产环境下使用该依赖， devDependencies则表示我们仅在开发环境使用该依赖。 举个例子，我要用webpack构建代码，所以在开发环节，它是必需的，但对普通用户来说，它是不必要的，所以安装`webpack时，我要执行： 1npm install webpack --save-dev 5.2 版本号版本号 major.minor.patch ：其中： patch：修复bug，兼容老版本， minor：新增功能，兼容老版本 major：新的架构调整，不兼容老版本 常用的主要有以下几种： 指定版本：比如1.2.2 波浪号（~）：表示安装1.2.x的最新版本 插入号（^）：表示安装1.x.x的最新版本，注意如果大版本号是0，则与波浪号使用相同，例如^0.2.3只会安装0.2.x的版本，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本 推荐的做法：不锁版本，用 ^ 引入。 在package.json中确定版本号，只能锁定本身依赖的包，但是包自身所依赖的包没有办法锁定，解决方法就是npm shrinkwrap或者npm 5.0版本以后增加的lock功能： 如果你使用 lock 机制，则应该将 package-lock.json 提交到 repo 中。比如 Vue 采取了该策略。 如果你不使用 lock 机制，则应该加入 .npmrc 文件，内容为package-lock=false ，并提交到 repo 中。比如 ESLint 采取了该策略。 如果你需要在程序中做版本匹配，手写是不是很麻烦，其实npm提供了一个现成的匹配版本号的工具 5.3 区别在做项目的时候，两者可以认为没有实质的区别，但是在发布npm包的时候二者区别很大：dependencies下的模块会作为依赖，一起被下载；devDependencies下面的模块就不会自动下载了 一般来说，开发时依赖的东西需要安装在devDependencies字段中，比如转义用的babel，打包用的webpack等，如果发布后还需要使用的则要安装在dependencies，比如vue、vue-router等 6 其他字段6.1 main字段main字段指定了加载的入口文件，require(&#39;moduleName&#39;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js 6.2 cinfig字段用于添加命令行的环境变量，例如： 12345&#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 然后，在server.js脚本就可以引用config字段的值。 123http .createServer(...) .listen(process.env.npm_package_config_port) 用户可以改变这个值。 1$ npm config set foo:port 80 6.3 keywords和description字段description是字符串，keywords是字符串数组，简单地说，这两个东东是npm搜索系统中的搜索条件，所以。如果你试图发布的是一个开源插件，那么这两个字段你应该重视 6.4 license 字段指定的项目的许可证，它告诉他人他们是否有权利使用你的包，以及，在使用你的包的时候他们应该受到怎样的限制 6.5 author字段可以是一个字符串，也可以是一个对象。如果传入对象，要包含三个属性： name属性(必填) email属性（选填） URL属性（选填） 6.5 engines字段指明了该模块运行的平台，比如Node的某个版本或者浏览器 1&#123; "engines" : &#123; "node" : "&gt;=0.10.3 &lt;0.12" &#125; &#125; 也可以指定适用的npm版本。 1&#123; "engines" : &#123; "npm" : "~1.0.20" &#125; &#125; 6.6 os字段指明了用户执行的操作系统： 1&#123; "os": [ "darwin", "linux", "!win32" ] &#125; 7 安装非NPM上发布的包通常，我们安装的包都是在npm官网上，通过版本标明。但是，如果我想使用没上传到npm上的包怎么办？其实你可以直接加网址或git url。 git url可以是以下形式： 1234git://github.com/user/project.git#commit-ishgit+ssh://user@hostname:project.git#commit-ishgit+http://user@hostname/project/blah.git#commit-ishgit+https://user@hostname/project/blah.git#commit-ish 其中，commit-ish可以是任意的tag，branch，sha。 8 更新我们知道npm自带的npm update可以根据pacaage.json的版本号更新包，但是你==需要手动的更新版本号==，因此出现了升级插件npm-check-updates，可以自动搜索当前包的更新情况，并且修改pacage.json 1$ npm install -g npm-check-updates ncu是npm-check-updates的缩写命令 12345$ ncu -v # 查询版本号$ ncu # 直接输入ncu可以查看所有需要更新的包 12345678$ ncu -u # 更新所有的包，并修改package.json文件$ ncu -f regex # 只匹配特定的正则格式的包$ ncu -g # 更新全局包 参考 http://javascript.ruanyifeng.com/nodejs/packagejson.html http://www.cnblogs.com/penghuwan/p/7134046.html http://guxinyan.github.io/2017/11/02/%E5%8C%85%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8devDependencies%E8%BF%98%E6%98%AFdependencies/ https://blog.zfanw.com/difference-between-dependencies-and-devdependencies/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Package.json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题10 Fetch API]]></title>
    <url>%2F2017%2F05%2F08%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9810%20Fetch%20API%2F</url>
    <content type="text"><![CDATA[Fetch是基于Promise设计的，是属于window对象的方法，可以用来替代Ajax。旧浏览器不支持Promise，需要使用Polyfill进行处理 。 兼容性 目前浏览器对Fetch的原生的支持率并不高，幸运的是，引入下面这些polyfill后可以完美支持IE8+ ： 由于IE8是ES3，需要引入ES5的polyfill: es5-shim, es5-sham 引入Promise的polyfill: es6-promise 引入Fetch探测库：fetch-detector 引入Fetch的polyfill: fetch-ie8 可选：如果你还使用了Jsonp，引入fetch-jsonp 如果在Node使用，还需要安装node-fetch模块。 使用一个基本的Fetch请求如下： 1234567fetch('http://example.com/movies.json') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); &#125;); 也可以通过Request构造器函数创建一个新的请求对象，这也是建议标准的一部分。第一个参数是请求的URL，第二个参数是一个选项对象，用于配置请求。请求对象一旦创建了，便可以将所创建的对象传递给fetch()方法，用于替代默认的URL字符串。示例代码如下： 1234567const req = new Request(URL, &#123;method: 'GET', cache: 'reload'&#125;);fetch(req).then(function(response) &#123; return response.json();&#125;).then(function(json) &#123; insertPhotos(json);&#125;); 上面的代码中指明了请求使用的方法为GET，并且指定不缓存响应的结果。 参数fetch接受两个参数： 第一个参数是请求的目标URL 第二个参数是一个配置项对象，包括所有对请求的设置，可选参数有method、headers、mode、credentials、cache等 关于参数的详细说明可以参考MDN的文档。 返回值Fetch的返回值是一个Promise对象，当这个Promise对象resolve时，在then方法中获得的是一个Resopnse对象。 Response对象中包含了当次请求的相应数据，需要调用对应的方法将Response对象转换为相应格式的数据，最常用的就是json()方法，它将返回一个被解析为JSON格式的Promise对象，并将Response对象设置为已读。 Response对象常用属性包括headers、ok、redirected、status、statusText、type、url等，常用的方法包括clone()、error()、formData()、text()等，具体的说明参考MDN的文档。 与 Ajax 的区别Ajax是基于XMLHttpRequest对象来发送网络请求、获取数据的。 Fetch是基于Promise设计的，是属于window对象的方法，可以用来替代Ajax。 使用原生的Ajax发送一个JSON请求一般是这样： 12345678910111213141516var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.responseType = 'json';xhr.send(null);xhr.onredaystatechange = function() &#123; if (xhr.readystate === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.response) &#125; &#125;&#125;;xhr.onerror = function() &#123; console.log("Oops, error");&#125;; 使用Fetch来进行同样的操作： 123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e)) 可以使用Async/Await来实现“ 12345678try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125;// 注：这段代码如果想运行，外面需要包一个 async function 总结起来，Fetch与Ajax的主要的不同点在于： （1）Fetch基于Promise对象，Ajax基于XMLHttpRequest对象 （2）当收到代表错误的HTTP状态码时(4xx/5xx)，从fetch()返回的Promise不会被标记为reject，而是标记为resolve（但是会将resolve的返回值的ok属性标记为false），仅当网络故障时或请求被阻止，才会标记为reject； 来看下面的Fetch请求： 123456789101112fetch('http://127.0.0.1:7001/getTitle') .then(v =&gt; console.log('resolve, v.ok = ', v.ok)) .catch(e =&gt; console.log('reject', e)); // 当服务器返回结果正常（200）时，返回结果：// resolve, v.ok = true// 当服务器返回结果异常（500）时，返回结果：// resolve, v.ok = false// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// reject TypeError: Failed to fetch 当使用原生的Ajax时： 123456789101112131415161718192021222324252627const xhr = new XMLHttpRequest();xhr.open('GET', 'http://127.0.0.1:7001/getTitle');xhr.send();xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log('success', xhr.status); &#125; else &#123; console.log('error', xhr.status); &#125; &#125;&#125;;xhr.onerror = (e) =&gt; &#123; console.log('onerror', e.type);&#125;// 当服务器返回结果正常（200）时，返回结果：// success 200// 当服务器返回结果异常（500）时，返回结果：// error 500// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// error 0// nerror error 现在使用比较多的axios也是基于原生的XMLHttpRequest对象进行的封装，它可以在Node中使用（Fetch不行），它的行为比起Fetch更加合理，当收到代表错误的HTTP状态码时(4xx/5xx)，从axios()返回的Promise会被标记为reject， 1234567891011121314151617axios.get('http://127.0.0.1:7001/getTitle') .then(v =&gt; console.log('resolve', v.data)) .catch(e =&gt; console.log('reject', e));// 当服务器返回结果正常（200）时，返回结果：// resolve &#123;title: "OK"&#125;// 当服务器返回结果异常（500）时，返回结果：// reject Error: Request failed with status code 500// at createError (createError.js:17)// at settle (settle.js:19)// at XMLHttpRequest.handleLoad (xhr.js:78)// 当网络故障或请求被阻止时（设置跨域失败），返回结果：// reject Error: Network Error// at createError (createError.js:17)// at XMLHttpRequest.handleError (xhr.js:87) （3）默认情况下，Fetch不会从服务端发送或接受任何cookie，要发送cookie，必须设置credentials选项。而AJAX请求默认自动带上同源的cookie，不会带上不同源的cookie。可以通过前端设置withCredentials为true、后端设置Header的方式来让Ajax带上不同源的Cookie fetch发送Cookie为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: &#39;include&#39;添加到传递给fetch()方法的init对象。 123fetch('https://example.com', &#123; credentials: 'include' &#125;) 果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加credentials: &#39;same-origin&#39;。要改为确保浏览器不在请求中包含凭据，请使用credentials: &#39;omit&#39;。 例子上传JSON数据123456789101112const url = 'https://example.com/profile';const data = &#123; username: 'example' &#125;;fetch(url, &#123; method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or &#123;object&#125;! headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;)&#125;).then(res =&gt; res.json()) .catch(error =&gt; console.error('Error:', error)) .then(response =&gt; console.log('Success:', response)); 上传文件可以通过HTML&lt;input type=&quot;file&quot; /&gt;元素，FormData()和fetch()上传文件。 123456789101112var formData = new FormData();var fileField = document.querySelector("input[type='file']");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()) .catch(error =&gt; console.error('Error:', error)) .then(response =&gt; console.log('Success:', response)); 获取图片下面这个例子，是在React中，使用fetch获取图片，并将图片转换为Blob对象，赋给&lt;img&gt;的src，在页面上展示图片： 1234567891011121314151617import React, &#123; useState, useEffect, useRef &#125; from &apos;react&apos;;import fetch2 from &apos;./fetch2.png&apos;;export default function Statistics() &#123; const [src, setSrc] = useState(&apos;&apos;); useEffect(() =&gt; &#123; fetch(&apos;fetch2.png&apos;).then(v =&gt; v.blob()).then(v =&gt; &#123; setSrc(URL.createObjectURL(v)); &#125;); &#125;, [param]); return ( &lt;div className=&#123;styles.container&#125;&gt; &lt;img src=&#123;&#125; /&gt; &lt;/div&gt; );&#125; 使用Fetch需要注意的问题 考虑Fetch兼容性（IE浏览器不支持Fetch） 考虑环境对Promise的支持情况 如果在Node中使用需要安装node-fetch 服务端返回错误时（4xx/5xx），Fetch不会reject，可以通过返回的Response对象的OK属性判断 默认情况下Fetch不会接受或者发送Cookie，需要使用credentials选项开启 参考 使用Fetch@MDN fetch API@DWB 传统 Ajax 已死，Fetch 永生@segmentfault WorkerOrGlobalScope.fetch()@MDN Response@MDN 【误】Ajax不会自动带上cookie/利用withCreadentials带上cookie@知乎 XMLHttpRequest.withCredentials@MDN fetch和ajax的区别@segmentfault]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Fetch</tag>
        <tag>Axios</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router01 入门]]></title>
    <url>%2F2017%2F05%2F07%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F03%20React%2FReact03%20React-Router%2FReact-Router01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React-Router入门学习笔记。 React-RouterReact-Router是官方插件，文档在这里。 引入安装：(4.0版本后引入的是react-router-dom，而不是原本的react-router，使用方式也有了大的变化，和阮一峰的教程以及慕课网的视频教程都不同，这里按照新版本的API写代码） 1npm install --save react-router-dom 新建一个root.js，作为入口文件，渲染到文档中，原来的index.js作为其中一个组件嵌入，需要在webpack.config.js中入口文件的更改： 12345module.exports = &#123; context: __dirname + '/app', entry: "./js/root.js", // ... &#125; 如果使用了 引入需要的方法： 1import &#123; BrowserRouter, Route, Link &#125; from 'react-router-dom'; &lt;link&gt;连接不使用a标签，使用&lt;link&gt;标签 12345&lt;ul&gt; &lt;li&gt;&lt;Link to="/"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/details"&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/list"&gt;列表页&lt;/Link&gt;&lt;/li&gt;&lt;/ul&gt; &lt;BrowserRouter&gt;Hash history不支持location.key和location.state。另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用BrowserRouter，此API不再作多余介绍。 BrowserRouter，里面的元素是在此基础上跳转的页面 12345678910111213141516171819202122232425262728import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;BrowserRouter, Route, Link&#125; from &apos;react-router-dom&apos;;import Index from &apos;./index&apos;import ComponentDetails from &apos;./components/details&apos;;import ComponentList from &apos;./components/list&apos;;import ComponentHeader from &apos;./components/header&apos;;export default class Root extends React.Component&#123; render()&#123; return( &lt;BrowserRouter basename=&quot;/a/&quot;&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/details&quot;&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/home&quot; component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/details&quot; component=&#123;ComponentDetails&#125; /&gt; &lt;Route path=&quot;/list&quot; component=&#123;ComponentList&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ) &#125;&#125;ReactDOM.render(&lt;Root /&gt;, document.getElementById(&apos;example&apos;)); &lt;Switch&gt;当进行地址匹配的时候，如果有多个匹配项值匹配首个匹配的对象（需要增加exact属性） 123456789101112131415161718export default class Root extends React.Component&#123; render()&#123; return( &lt;BrowserRouter basename=&quot;/a/&quot;&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/details&quot;&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list&quot;&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/details&quot; component=&#123;ComponentDetails&#125; /&gt; &lt;Route path=&quot;/list&quot; component=&#123;ComponentList&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ) &#125;&#125; 此时点击首页，会将所有三个&lt;Route&gt;全部渲染，但是使用&lt;Switch&gt;只会渲染首个匹配对象 可以用这个组件实现前端页面404的功能： 123456789101112131415161718192021222324252627import &#123; BrowserRouter as Router, Route, Link, Switch &#125; from &apos;react-router-dom&apos;const NoMatch = () =&gt; (&lt;div&gt;&lt;h1&gt;Sorry, 404&lt;/h1&gt;&lt;/div&gt;);// 路由设置export default class RouterContainer extends React.Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div className=&quot;container&quot;&gt; &lt;nav&gt; &lt;div className=&quot;head&quot;&gt; &lt;Link to=&quot;/&quot; /&gt; &lt;/div&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;App&#125; /&gt; &lt;Route path=&quot;/demo1/&quot; component=&#123;Demo1&#125; /&gt; &lt;Route path=&quot;/demo2/&quot; component=&#123;Demo2&#125; /&gt; &lt;Route path=&quot;/demo3/&quot; component=&#123;Demo3&#125; /&gt; &lt;Route component=&#123;NoMatch&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125; 参数传递传递参数在&lt;Route&gt;中的path参数后面用:+paramName，在组件中使用this.props.match.params.paramName来获取传入的值 路由： 123456789101112&lt;BrowserRouter&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/home"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/details/123"&gt;详情页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/list"&gt;列表页&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path="/home" component=&#123;Index&#125; /&gt; &lt;Route path="/details/:id" component=&#123;ComponentDetails&#125; /&gt; &lt;Route path="/list" component=&#123;ComponentList&#125; /&gt; &lt;/div&gt;&lt;/BrowserRouter&gt; 页面： 1&lt;div&gt;这是详情页details idd &#123;this.props.match.params.id&#125;&lt;/div&gt; Koa-Router之前对二者的理解存在着偏差 React-Router是前端路由，而Koa-Router控制的是后端路由 React是单页面应用，也就是在单一一个页面上实现多个组件、布局的切换，React-Router实现的就是在前端页面上根据url的切换对应不同的组件 实现单页面应用的前提是服务器返回单页面应用的根地址对应的页面，也就是需要Koa-Router首先配置好url对应的地址 比如，我想要实现www.test.com这个单页面应用，并配置了前端路由： 123456&lt;Router history=&#123; browserHistory &#125; key=&#123; Date.now() &#125;&gt; &lt;Route path="/" components=&#123;keyPointPage&#125;&gt; &lt;IndexRoute component=&#123;home&#125; /&gt; &lt;Route path="page1" components=&#123;page1&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 当我访问www.test.com对应的是IndexRoute设置的home组件，当我访www.test.com/page1加载page1组件 但是前提是要服务器首先要对www.test.com这个地址的访问请求给出回应，也就是需要通过Koa-Router配置地址，并且对www.test.co后面的访问进行配置，都需要访问同一个view模版文件（单页面） 123456789// 对根地址配置router.get('/', async(ctx) =&gt; &#123; await dealPageRequest(ctx, 'keypoint_react');&#125;);// 对根地址对应的其他地址指向同一个viewrouter.get('/*', async(ctx) =&gt; &#123; await dealPageRequest(ctx, 'keypoint_react');&#125;); 坑 如果要在&lt;Link&gt;标签中使用target=&quot;_blank&quot;属性时只能使用HashRouter，不知道为什么BrowserRouter不行 根目录如果是/，一定要在&lt;Route&gt;加上exact属性，要不然都会进行匹配。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node02 NPM]]></title>
    <url>%2F2017%2F05%2F07%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode02%20NPM%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。 NPM（node package manager）是NodeJS的包管理器，用于Node插件管理（包括安装、卸载、管理依赖等），npm已经在NodeJS安装的时候顺带装好了 安装插件123npm install &lt;name&gt; [-g] [--save-dev]；npm install gulp-less --save-dev 说明： （1）通过-g来控制是否全局安装： 全局安装。将会安装在C:\Users\Administrator\AppData\Roaming\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录；全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； （2）通过--save-dev控制插件是记录到package.json，以及记录到什么位置 --save（-S）指明将插件信息记录到package.json的dependencies字段 --save-dev（-D）指明将插件信息记录到package.json的devDependencies字段， devDependencies里面的插件只用于开发环境，不用于生产环境，而dependencies是需要发布到生产环境的。 package.json为什么要保存至package.json？因为Node插件包相对来说非常庞大，将配置信息写入package.json并更新devDependencies值，以表明项目需要依赖该插件 dependencies的值可以向其他参与项目的人指明项目在开发环境和生产环境中的Bode模块依懒关，其他开发者对应下载即可 卸载插件1npm uninstall &lt;name&gt; [-g] [--save-dev] PS：不要直接删除本地插件包 删除指定插件： 1npm uninstall gulp-less gulp-uglify gulp-concat 删除全部插件需要借助rimraf： 12npm install rimraf -grimraf node_modules 更新插件12345# 更新指定插件npm update &lt;name&gt; [-g] [--save-dev]# 更新全部插件npm update [--save-dev] 当前目录已安装模块；12345# 查看所有弄快npm list# 查看一级模块npm list –depth 1 cnpm因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以淘宝团队提供了一个完整npmjs.org镜像，可以用此代替官方版本，同步频率目前为10分钟一次以保证尽量与官方服务同步。 安装： 1npm install cnpm -g --registry=https://registry.npm.taobao.org 注意：安装完后最好查看其版本号cnpm-v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm； 12# 使用cnpm install express 直接使用npm注册淘宝镜像12345678npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/mirrors/node# 配置后可通过下面方式来验证是否成功npm config get registry# 或npm info express 推荐使用npm安装插件，但是安装源改为淘宝 删除淘宝镜像1234567npm config delete registrynpm config delete disturl# 或者 npm config edit # 在打开的文件中找到淘宝那两行，删除 npm本身的升级用管理员权限打开PowerShell，然后执行以下命令： 123Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Forcenpm install -g npm-windows-upgradenpm-windows-upgrade npxnpm从5.2版开始，增加了npx命令 npx有三个作用： （1）Npx会到node_modules/.bin路径和环境变量$PATH里调用项目内部安装的模块，比如项目内安装了Mocha，如果想要在命令行中调用 12345# 在项目根目录下调用node-modules/.bin/mocha --version# 使用npxnpx mocha --version （2）避免安装全局模块，npx会将本地不存在的模块下载到临时目录，使用后再删除 12345678910npx create-react-app my-react-app# 可以指定版本npx uglify-js@3.1.0 main.js -o ./dist/main.js# 使用--no-install强制使用本地模块npx --no-install http-server# 使用--ignore-existing强制使用远程模块npx --ignore-existing create-react-app my-react-app （3）利用下载模块的特点还可以指定某个版本的Node运行脚本 1npx node@0.12.8 -v 更详细可以参考阮一峰的网络日志。 参考 国内优秀npm镜像推荐及使用]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散专题09 Moment.js和date-fns]]></title>
    <url>%2F2017%2F04%2F26%2F01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%2F%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9809%20Moment.js%E5%92%8Cdate-fns%2F</url>
    <content type="text"><![CDATA[介绍JavaScript的两个日期处理工具库Moment.js和date-fns。 Moment.jsMoment.js是一个（轻量级）的Javascript日期处理类库，使用它可以轻松解决前端开发中遇到的种种日期时间问题。 Moment.js不依赖任何第三方库，支持字符串、Date、时间戳以及数组等格式，可以格式化日期时间，计算相对时间，获取特定时间后的日期时间等等。 支持中文在内的多种语言。 格式化日期1234moment().format('MMMM Do YYYY, h:mm:ss a'); // 四月 26日 2017, 12:12:53 中午moment().format('dddd'); // 星期三moment().format("MMM Do YY"); // 4月 26日 17moment().format('YYYY [escaped] YYYY'); // 2017 escaped 2017 相对时间12345moment("20111031", "YYYYMMDD").fromNow(); // 5 年前moment("20120620", "YYYYMMDD").fromNow(); // 5 年前moment().startOf('day').fromNow(); // 12 小时前moment().endOf('day').fromNow(); // 12 小时内moment().startOf('hour').fromNow(); // 14 分钟前 日历时间12345678moment().subtract(10, 'days').calendar(); // 2017年4月16日moment().subtract(6, 'days').calendar(); // 上周四中午12点14moment().subtract(3, 'days').calendar(); // 上周日中午12点14moment().subtract(1, 'days').calendar(); // 昨天中午12点14分moment().calendar(); // 今天中午12点14分moment().add(1, 'days').calendar(); // 明天中午12点14分moment().add(3, 'days').calendar(); // 本周六中午12点14moment().add(10, 'days').calendar(); // 2017年5月6日 Moment.js提供了丰富的说明文档，使用它还可以创建日历项目等复杂的日期时间应用。日常开发中最常用的是格式化时间，下面是常用的格式： date-fnsdate-fns是另外一个比热门的JavaScript日期处理工具库，越来越多的人用它来替换Moment.js。它一样提供了大量的函数来操作日期。 安装： 1npm install date-fns --save date-fns是使用纯函数构建的，并且可以再不改变传递日期实例的情况下保持不变。并且由于date-fns里面每一个方法都是一个文件，所以可以非常方便的只引入需要的部分，这相比于Moment.js可以更方便的降低打包体积。 123const moment = require('moment');const format1 = moment.format;const format2 = require('date-fns/format'); 具体使用方法参考官方文档。 比较Moment.js存在一些问题，导致了date-fns越来越流行，Moment.js存在的一些问题时hi： Moment.js是可变的 具有复杂的面向对象的API 复杂的API带来大量性能开销 使用Webpack将其打包在构建结果中，会导致构建结果尺寸增加很多 那么date-fns是如何解决这些问题呢？一个一个来看： （1）Moment.js是可变的 Moment.js中的日期是可变的，这可能会导致不可预料的行为，什么意思呢： 12345678910111213const moment = require('moment');const now = moment(new Date());console.log('now: ', now.format());// now: 2019-05-09T18:08:40+08:00now.add(3, 'days');console.log('now: ', now.format());// now: 2019-05-12T18:08:40+08:00now.add(3, 'days');console.log('now: ', now.format());// now: 2019-05-15T18:08:40+08:00 Momment.js生成的moment对象是可变的，now在一开始代表5月9日，加3天后变为了5月12日，再加三天变为了5月15日。 这是因为Moment.js是面向对象的原因，它产生的是一个可变的对象。 而date-fns是纯函数式，它更加纯净简洁，它产生的对象是不可变的，每次调用都会返回新的对象： 12345678910111213141516const addDays = require('date-fns/add_days');const now = new Date();console.log('now: ', now);// now: 2019-05-09T10:10:30.079Zconst day1 = addDays(now, 3);console.log('day1: ', day1);// day1: 2019-05-12T10:10:30.079Zconsole.log('now: ', now);// now: 2019-05-09T10:10:30.079Zconst day2 = addDays(now, 3);console.log('day2: ', day2);// day2: 2019-05-12T10:10:30.079Zconsole.log('now: ', now);// now: 2019-05-09T10:10:30.079Z 在加3天后，产生新的日期，但是原来的now对象一直都是5月9日，是不变的。 （2）具有复杂的面向对象的API和复杂的API带来大量性能开销 相对来说，date-fns作为纯函数，API可能会稍微更简洁一下，这个还是看官网的文档吧。 （3）使用Webpack将其打包在构建结果中，会导致构建结果尺寸增加很多 Moment加载时默认会将所有方法和所有的语言locale文件打包，打包出体积Gzip压缩后可能也要60kb，如果需要按需加载需要Webpack的配合，在Webpack的配置文件中使用自带的IgnorePlugin插件来过滤掉所有的locale文件： 12345678const webpack = require('webpack');module.exports = &#123; //... plugins: [ // Ignore all locale files of moment.js new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/), ],&#125;; 当需要语言包时手动引入： 1234const moment = require('moment');require('moment/locale/ja'); moment.locale('ja'); 但是这样只能排除不必要的locale文件，但是没使用的方法还是会全部引入的。 而date-fns每个方法、每个locale都是一个单独的文件： 在使用的时候完全做到了按需引入： 1234567891011const addDays = require('date-fns/add_days');const format = require('date-fns/format');const eoLocale = require('date-fns/locale/eo');const result = format( addDays(new Date(2014, 6, 2), 3), 'Do [de] MMMM YYYY', &#123;locale: eoLocale&#125;);console.log(result);// 5-a de julio 2014 在Webpack构建的时候，自动就可以做到按需引入，非常方便。 参考 Moment.js 文档@Moment date-fns文档@date-fns date-fns —— 轻量级的 JavaScript 日期库@可译网 在webpack打包时精简moment.js@CSDN]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Moment</tag>
        <tag>date-fns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node05 常用模块]]></title>
    <url>%2F2017%2F04%2F19%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode05%20%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。常用模块的介绍（未完成） 1 http模块略 2 url模块用来生成和解析URL，使用前需要通过require加载 2.1 url.resolve(base, path)用来生成URL，第一个参数是基准URL，其余参数是根据基准URL，生成对应的位置 12url.resolve('/one/two/three', 'four')// '/one/two/four' 3 querystring模块用来解析查询字符串，将一个查询字符串解析为JavaScript对象 1234var str = 'foo=bar&amp;abc=xyz&amp;abc=123';querystring.parse(str)// &#123; foo: 'bar', abc: [ 'xyz', '123' ] &#125; 一共接受四个参数 1querystring.parse(str[, sep[, eq[, options]]]) str是需要解析的查询字符串 seq是多个键值对之间的分隔符，默认为&amp; eq是键名与键值之间的分隔符，默认为= options是配置对象，有两个属性，decodeURIComponent属性是一个函数，用来将编码后面的字符串还原，默认是querystring.unescape()，maxKeys属性指定最多解析多少个属性，默认是1000 完整调用形式如下： 123456querystring.parse( 'w=%D6%D0%CE%C4&amp;foo=bar', null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) 参考 url模块@JavaScript标准参考教程 querystring模块@JavaScript标准参考教程]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URL</tag>
        <tag>querystring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node09 swig模版引擎]]></title>
    <url>%2F2017%2F04%2F04%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode09%20swig%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Swig模版引擎学习笔记。 简介swig 是node端的一个优秀简洁的模板引擎，类似Python模板引擎Jinja，目前不仅在node端较为通用，相对于jade、ejs优秀，而且在浏览器端也可以很好地运行。 这是官方文档 。 语法swig的变量123&#123;&#123; foo.bar &#125;&#125;&#123;&#123; foo[&apos;bar&apos;] &#125;&#125;//如果变量未定义，输出空字符。 swig的标签extends使当前模板继承父模板，必须在文件最前 123&#123;% exdtends file %&#125;// 参数file：父模板相对模板root的相对路径 block定义一个块，使之可以被继承的模板重写，或者重写父模板的同名块 12&#123;% block blockName %&#125;something can be entended and modified...&#123;% endblcok %&#125;// 参数name：块的名字，必须以字母数字下划线开头 parent将父模板中同名块的内容注入当前块中 12345&#123;% extends &quot;./foo.html&quot; %&#125;&#123;% block content %&#125; My content. &#123;% parent %&#125;&#123;% endblock %&#125; include包含一个模板到当前位置，这个模板将使用当前上下文 参数file是包含模板相对模板 root 的相对路径 123&#123;% include &quot;a.html&quot; %&#125;&#123;% include &quot;template.js&quot; %&#125; //将引入的文件内容放到被引用的地方 raw停止解析swig标签，其中所有内容都将按照字面意思输出 参数file是包含模板相对模板 root 的相对路径 123// foobar = &apos;&lt;p&gt;&apos;&#123;% raw %&#125;&#123;&#123; foobar &#125;&#125;&#123;% endraw %&#125;// =&gt; &#123;&#123; foobar &#125;&#125; set设置一个变量，在当前上下文中复用，设置的值会覆盖已定义值 12345// foods = &#123;&#125;;// food = &apos;chili&apos;;&#123;% set foods[food] = &quot;con queso&quot; %&#125;&#123;&#123; foods.chili &#125;&#125;// =&gt; con queso 模版继承Swig 使用 extends 和 block 来实现模板继承 example: 12345678910111213141516//layout.html&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&#123;% block title %&#125;My Site&#123;% endblock %&#125;&lt;/title&gt; &#123;% block head %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819//index.html&#123;% extends &apos;./layout.html&apos; %&#125;&#123;% block title %&#125;My Page&#123;% endblock %&#125;&#123;% block head %&#125;&#123;% parent %&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;p&gt;This is just an awesome page.&lt;/p&gt; &lt;h1&gt;hello,lego.&lt;/h1&gt; &lt;script&gt; //require(&apos;pages/index/main&apos;); &lt;/script&gt;&#123;% endblock %&#125; swig模板经过编译后： 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; My Page&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is just an awesome page.&lt;/p&gt; &lt;h1&gt;hello,lego.&lt;/h1&gt; &lt;script src=&quot;pages/index/main&quot;&gt; //require(&apos;pages/index/main&apos;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在express中使用swig在express框架中，默认的模版是jade，可以更改为其他模版引擎。修改app.js 123456789101112var app = express(); app.set(&apos;view engine&apos;, &apos;jade&apos;);// 把上面的代码改为下面的// view engine setupvar app = express(),swig = require(&apos;swig&apos;),app.engine(&apos;html&apos;, swig.renderFile); //使用swig渲染html文件app.set(&apos;view engine&apos;, &apos;html&apos;); //设置默认页面扩展名app.set(&apos;view cache&apos;, false); //设置模板编译无缓存app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;)); //设置项目的页面文件，也就是html文件的位置swig.setDefaults(&#123;cache: false&#125;); //关闭swig模板缓存swig.setDefaults(&#123;loader: swig.loaders.fs(__dirname + &apos;/views&apos;)&#125;); //从文件载入模板，请写绝对路径，不要使用相对路径 然后把原来的views文件夹下得文件后缀都改为html 模板文件layout.html 123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% block head %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; index.html 1234567891011&#123;% extends &apos;layout.html&apos; %&#125;&#123;% block title %&#125;index &#123;&#123;title&#125;&#125; &#123;%endblock%&#125;&#123;% block head %&#125;&#123;&#123;title&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;p&gt;This is just an awesome page.&lt;/p&gt;&#123;% endblock %&#125; 然后再路由中设置即可使用： 123router.get(&apos;/&apos;, function(req, res) &#123; res.render(&apos;index&apos;, &#123; title: &apos;标题&apos; &#125;);&#125;); 参考 http://www.iqianduan.net/blog/how_to_use_swig http://node-swig.github.io/swig-templates/docs/ http://www.joryhe.com/2016-05-21-hexo-swig-advance-grammar.html http://www.ithao123.cn/content-10830341.html]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Swig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node08 Express]]></title>
    <url>%2F2017%2F04%2F04%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode08%20Express%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Express学习笔记。 简介express是基于nodejs平台的web框架，它可以让我们快速开发出==web应用==。Express主要解决了 请求路由 和 视图模板 的问题 安装express项目的命令如下 123express -e nodejs-product//-e, --ejs add ejs engine support //-J, --jshtml add jshtml engine support (defaults to jade) 验证版本如果是express 4.0之前版本，那么执行“express -V”就可以得到版本号了，可express 4.0之后还需要再安装express-generator包，如果没有安装还执行“express -V”命令会报错。 12$ npm install -g express-generatorexpress -V 项目目录 bin:真实的执行程序（在命令行输入express命令时，其实对应的其实是去执行bin目录下的express程序）。 app.js： 项目的启动文件(项目入口)，可以改成index.js或者main.js都成 node_modules： 存放项目的依赖库 package.json： 项目依赖配置及开发者信息 public： 静态文件如 css,js,img (PS:俺其实习惯叫static) routes： 路由文件 Views： 页面文件(Ejs或者jade的模板，默认是jade) express() 表示创建express应用程序。简单几行代码其实就可以创建一个应用，如下： express默认的模版是jade模版，想要更改模版需要在app.js中更改： 1234// 原本是“app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 修改为app.engine(&apos;.html&apos;, ejs.__express);app.set(&apos;view engine&apos;, &apos;html&apos;); app.engine方法用来重新设置模板文件的扩展名，上面的代码意思是用ejs模板引擎来处理“.html”后缀的文件 12app.engine(ext, callback) //注册模板引擎的 callback 用来处理ext扩展名的文件。 PS：__express不用去care，其实就是ejs模块的一个公共属性，表示要渲染的文件扩展名。 app.use用来指定中间件function：1app.use([path], function) 可选参数path默认为”/“。使用 app.use() “定义的”中间件的顺序非常重要，它们将会顺序执行，use的先后顺序决定了中间件的优先级; app.render用来渲染view同时传进对应的数据: 12app.render(view, [options], callback)// 渲染 view, callback 用来处理返回的渲染后的字符串。 app.jsapp.js是项目的主文件,为这个主文件里面有创建服务和监听端口的语句： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var express = require(&apos;express&apos;); //引入express框架var session = require(&apos;express-session&apos;); //设置session的中间件var redisStore = require(&apos;connect-redis&apos;)(session); //实现redis存储sessionvar glob = require(&apos;glob&apos;); //使用类似shell的模式语法匹配文件路径var path = require(&apos;path&apos;); //path模块用于处理和转换文件路径var bodyParser = require(&apos;body-parser&apos;); //解析请求的body的中间件var swig = require(&apos;swig&apos;); //swig模板引擎var staticTag = require(&apos;./swig/static&apos;); //swig模板相关设置var morgan = require(&quot;morgan&quot;); //控制台日志var app = express(); //创建一个express应用app.locals.ENV = NODE_ENV; //将环境变量NODE_ENV存在app.locals里app.locals.ENV_DEV = (NODE_ENV === &apos;dev&apos;); //是否是dev环境// view engine setupapp.engine(&apos;html&apos;, swig.renderFile); //使用swig渲染html文件app.set(&apos;view engine&apos;, &apos;html&apos;); //设置默认页面扩展名app.set(&apos;view cache&apos;, false); //设置模板编译无缓存app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;)); //设置项目的页面文件，也就是html文件的位置swig.setDefaults(&#123;cache: false&#125;); //关闭swig模板缓存swig.setDefaults(&#123;loader: swig.loaders.fs(__dirname + &apos;/views&apos;)&#125;); //从文件载入模板，请写绝对路径，不要使用相对路径staticTag.init(swig); //这个init函数是自定义的，对swig模板做了一些自定义设置app.use(session(&#123; //设置session中间件的写法，session会存在服务端 cookie: &#123; maxAge: 2502000 * 1000 //设置最大生命周期，过了这个时间后cookie会失效，单位毫秒 &#125;, name: &apos;lbn_sid&apos;, //用来保存session的cookie名称 secret: &apos;what are you thinking?&apos;, //用来对session数据进行加密的字符串.这个属性值为必须指定的属性 store: new redisStore(&#123; //设置session的存储仓库为redis数据库 ttl: 2502000, //redis session生命周期，单位秒 url: REDIS_URL //redis缓存服务地址 &#125;), saveUninitialized: false, //false选项不会强制存储未初始化的session到redis里，未初始化意味着新的还没有修改的 resave: false //如果是true选项，强制重新存储session到redis里，即使session没有被修改，false意味着如果没有变化就不用重新存&#125;));// app.use(morgan(&apos;combined&apos;)); //morgan控制台日志，会在控制台输出所有http请求日志，combined是标准Apache日志格式app.use(bodyParser.json()); //bodyParser.json是用来解析请求体的json数据格式app.use(bodyParser.urlencoded(&#123; extended: true, limit: &apos;10mb&apos;&#125;));/*bodyParser.urlencoded则是用来解析我们通常的form表单提交的数据， *也就是请求头中包含这样的信息： Content-Type: application/x-www-form-urlencoded *extended选项为true会使用qs library来解析数据，false会使用querystring来解析 *limit选项限制请求体的大小 */app.use(&apos;/&apos; + global.STATIC_URL, express.static(path.join(__dirname, STATIC_DIR)));//为静态资源的请求添加虚拟路径，只有请求静态资源的路径前加了global.STATIC_URL前缀后，才可请求成功var controllers = glob.sync(&apos;./controllers/*.js&apos;); //获取到controllers文件夹下的所有js文件，这些文件里都是路由controllers.forEach(function (controller) &#123; require(controller)(app);&#125;);//将所有路由循环到主文件中使其生效app.use(function (err, req, res, next) &#123; //当请求出现500错误，渲染500错误页面 res.locals = &#123;env: NODE_ENV&#125;; // treat as 404 if (err.message &amp;&amp; (~err.message.indexOf(&apos;not found&apos;) || (~err.message.indexOf(&apos;Cast to ObjectId failed&apos;)))) &#123; return next(); &#125; res.status(500).render(&apos;500&apos;, &#123; error: err.stack &#125;);&#125;);app.use(function (req, res, next) &#123; //当请求出现404错误，渲染404错误页面 res.status(404).render(&apos;404&apos;, &#123; url: req.originalUrl, error: &apos;Not found&apos; &#125;);&#125;);module.exports = app; //将app应用导出成模块 这其中session的设置值得注意，session的设置写在了app.use()中，也就是中间件中，中间件也是路由，只是所有的请求都会经过它的处理。这里设置session时有一个cookie的设置，这个cookie就是session的唯一标示，是sessionId，也就是说，第一次访问网站的时候，在请求通过session设置的中间件时，响应头里会设置一个set-cookie来强制浏览器存储一个cookie，也就是在浏览器存下sessionId，然后会在node端新建一个session，这里浏览器存的sessionId和node端的session是对应关系，之后的请求也会经过session设置的中间件，此时的请求头里会自动带上浏览器的所有cookie，当中间件发现已经有sessionId的时候，就不会新建了，只用更新对应的session就可以了。 binexpress4.0之后的版本，项目目录下会有bin/这个目录，这个目录专门用于自定义启动脚本，这样就把与启动服务的代码和主文件分离了，而且你可以定义多个启动脚本，而不用去修改app.js这个主文件。 文件内容： 123456789101112131415161718#!/usr/bin/env node/*这一句是写给类unix系统看的 *如果用户没有将nodejs装在默认的/usr/bin路径里 *当系统看到这一行的时候，首先会到env设置里查找nodejs的安装路径 *再调用对应路径下的解释器程序完成操作 */var app = require(&apos;../app&apos;);//引入app主应用app.set(&apos;port&apos;, PORT || 3000);//设置端口为环境变量.env文件里的PORT，如果.env里没有，就默认3000var server = app.listen(app.get(&apos;port&apos;), function() &#123; console.log(&apos;Express server listening on port &apos;, app.get(&apos;port&apos;), &quot; with pid &quot;, process.pid);&#125;);/*app.listen(path,[callback])的写法是启动一个socket连接，然后在给定的端口上监听连接 *app.get(name)的写法是获取app设置，设置的时候通过app.set(&apos;port&apos;, &apos;my port&apos;);来设置。 */ 路由Web需要通过不同uri区分功能，如：/user/profile 表示用户信息，/about 表示网站简介，路由可以实现这一功能。 我个人理解的就是当在地址栏输入一个地址，要对应的页面去往何处，完成这一功能的命令就是路由。 路由用get去设置，默认的路由/对应routes.index,/user对应应routes.user 12345678910111213141516171819202122var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.all(&quot;*&quot;, function(request, response, next) &#123; console.log(&quot;step1&quot;); next();&#125;);app.get(&quot;/&quot;, function(request, response) &#123; response.end(&quot;Home Page!&quot;);&#125;);app.get(&quot;/about&quot;, function(request, response) &#123; response.end(&quot;About Page!&quot;);&#125;);app.get(&quot;*&quot;, function(request, response) &#123; response.end(&quot;404!&quot;);&#125;);http.createServer(app).listen(1984); VIEW处理Express加入了View处理机制，一起看看： 1234567891011var express = require(&quot;express&quot;);var app = express();// 模板目录：./viewsapp.set(&quot;views&quot;, __dirname + &quot;/views&quot;);// 使用jade引擎app.set(&quot;view engine&quot;, &quot;jade&quot;); // 寻址views/index，提交jade渲染，并返回结果app.get(&quot;/&quot;, function(request, response) &#123; response.render(&quot;index&quot;, &#123; message: &quot;I&apos;m hyddd&quot; &#125;); &#125;); 参考 http://www.cnblogs.com/Darren_code/p/node_express.html http://www.cnblogs.com/hyddd/p/4237099.html http://www.cnblogs.com/hahazexia/p/6027787.html http://www.cnblogs.com/hahazexia/p/6213286.html]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node07 events事件模块]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode07%20events%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。 Nodejs的大部分核心API都是基于异步事件驱动设计的，所有可以分发事件的对象都是EventEmitter类的实例。 如何使用实例化events.EventEmitter这个类，然后就可以使用手册上的一些方法了。 12var event = require("events")//引入事件模块var emitter = new event.EventEmitter();//实例化事件触发器 实例化之后就可以添加EventEmitter的一些方法了。 12emitter.on("事件名称",监听函数)；emitter.emit("事件名称"，[参数1], [参数2]...) on和emit是最基本的方法，on用来建立普通的事件监听（也就是监听器），当事件触发则执行监听函数； emit用来触发某个事件，然后将参数按顺序传入监听函数。 下面是一个基本的例子，当emiiter的event1事件被触发后就执行了func1，如果定义了多个evnet1，则event1也会在触发后执行多次。 1234emitter.on("event1", function func1(msg1, msg2)&#123; console.log(msg1+"+"+msg2)&#125;);emitter.emit("event1","this is event1", "this is event2"); 其他监听方法12345678910111213141516171819emitter.addListener(event, listener) // 与on相同，都是建立监听器emitter.once(event, listener)// 建立一次性监听器，执行listener后删除本监听器emitter.removeListener(event, listener)// 从指定事件中除去某一个监听函数，也就是再触发这个事件，指定的监听函数不执行了emitter.removeAllListeners(event)// 删除所有对这个事件的监听函数，也就就是再触发这个事件，没函数执行了emitter.setMaxListeners(n) // 设置这个emitter实例的最大事件监听数，默认是10个，设置0为不限制// 如果设置了最大监听数量，则同一事件的监听最好不要超过该最大值，否则很可能发送内存泄漏。emitter.listeners(event) // 返回这个事件的监听函数的数组，例如返回：[function1, function2, function3]// 修改会改变此事件的监听函数，例如emitter.listeners(event).length = 2;就相当于执行了：emitter.removeListener(event, function3) ; 看一个例子： 12345678910111213141516171819202122232425262728293031var event = require("events"), emitter = new event.EventEmitter();var func1 = function(msg1, msg2)&#123; console.log(msg1+msg2)&#125;;var func2 = function()&#123;console.log("this is event2")&#125;;var func3 = function()&#123;console.log("this is event3")&#125;;emitter.on("event1",func1);emitter.addListener("event1", func2);emitter.on("event1",func3);console.log(emitter.listeners("event1"));// [ [Function], [Function], [Function] ]emitter.emit("event1","this is ", "event1");// this is event1// this is event2// this is event3emitter.removeListener("event1", func1);console.log(emitter.listeners("event1"));// [ [Function], [Function] ]emitter.emit("event1","this is event1", "this is event2");// this is event2// this is event3emitter.removeAllListeners("event1");console.log(emitter.listeners("event1"));// []emitter.emit("event1","this is event1", "this is event2");// nothing here 应用实例比如有一个秒杀活动，只有第一个点击按钮的人才有机会获取奖品，网站会记录本次活动有多少人点击这个按钮，同时又要根据用户ID记录此用户点过多少次这个按钮。 不使用事件监听代码可能这么写： 123456789101112131415var prize = false; //false表示奖品未被领取var isactive = true; //活动是否开启if(有人点击抽奖按钮)&#123; if(!isactive ) return false; //先判断活动是否已经关掉了 if(!prize)&#123; getprize(此人id, 按钮id); //getprize是领奖的方法 prize = true; &#125; addbutton(此人id, 按钮id); //此按钮点击统计+1 addclick(此人id, 按钮id); //此人点击此按钮统计+1&#125;setTimeout(function()&#123; isactive = false; &#125;, 1000*60*60*24); //活动时间1天，1天以后活动结束 上面这段代码对我自己也是有启发的： 奖品是否被领取、活动是否开启在这个代码的开始部分都用了布尔值作为标识符，这样在后面根据条件、状态的变化改变对应的标识符即可，然后将这些标识符作为if的判断条件。 如果用事件监听改写上面代码，看上去更清晰，而且可能效率更高一些。 1234567891011121314151617var events = require("events");var btclick = new events.EventEmitter();btclick.once('bt0click',getprize)//getprize是领奖的方法，触发一次后，自动删除本触发器btclick.on('bt0click', addbutton);//此按钮点击统计+1btclick.on('bt0click', addclick);//此人点击此按钮统计+1if(有人点击抽奖按钮)&#123; btclick.emit('bt0click', 此人ID, 按钮ID); //等于触发了bt0click事件的所有监听器&#125;setTimeout(function()&#123; btclick.removeAllListeners('bt0click'); //移除所有监听器&#125;, 1000*60*60*24); //活动时间1天，1天以后活动结束 参考 http://snoopyxdy.blog.163.com/blog/static/6011744020118212553691/]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Events</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node06 fs模块]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode06%20fs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。fs模块和fs-extra的学习笔记。 概述Node中的fs模块用来对本地文件系统进行操作。文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。 fs模块中提供的方法可以用来执行基本的文件操作，包括读、写、重命名、创建和删除目录以及获取文件元数据等。每个操作文件的方法都有同步和异步两个版本。 异步操作的版本都会使用一个回调方法作为最后一个参数。当操作完成的时候，该回调方法会被调用。而回调方法的第一个参数总是保留为操作时可能出现的异常。如果操作正确成功，则第一个参数的值是null或undefined。 同步操作的版本的方法名称则是在对应的异步方法之后加上一个Sync作为后缀。比如异步的rename() 方法的同步版本是renameSync()。 使用方法：fs.readFile属于fs模块，使用前需要首先引入fs模块 1const fs= require(“fs”) fs.readFile以异步的方式读取文件内容。 API读取文件readFile1fs.readFile(filename, [options], [callback(err,data)]) filename：必选参数，文件路径，可以是绝对路径，也可以是相对路径。如果是相对路径，是相对于当前进程（process.cwd）的路径，而不是相对于当前脚本的路径。 options：可选参数，可指定flag（文件操作选项，如r+ 读写；w+ 读写，文件不存在则创建）及encoding属性 callback：回调函数，传递2个参数，异常err和文件内容data 注意，文件编码可取值包括’ascii’/‘utf-8’/‘base64’，如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法将其转换为字符串。 12345678910111213const fs = require('fs');console.log('start');fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log(file);&#125;);// fs.readFile('./test.txt', (error, file) =&gt; &#123;// console.log('before:', file.toString());// &#125;);console.log('finish'); 输出结果： 123startfinishContent: 你好啊 写文件writeFile1fs.writeFile(filename, data, [options], callback(err)); filename：必选参数，文件路径 data：写入的数据，可以是字符或一个Buffer对象 options：flag, mode(权限)，encoding callback：回调函数，传递1个参数，异常err 12345678910111213const fs = require('fs');console.log('start');fs.writeFile('./test.txt', '难判谁人错与对', 'utf-8', (error, file) =&gt; &#123; console.log('write finish');&#125;);fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('Content:', file);&#125;);console.log('finish'); 输出结果： 1234startfinishwrite finishContent: 难判谁人错与对 注意，在同一个文件多次使用fs.writeFile且不等待回调是不安全的，对于这种情况应该使用fs.createWriteStrem 以追加方式写文件appendFile1fs.appendFile(filename, data, [options], callback(err)); 异步地将数据追加到文件，如果文件尚不存在则创建该文件。 data可以是字符串或Buffer。 1234567891011const fs = require('fs');fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('before:', file);&#125;);fs.appendFile('./test.txt', '你随河流而来', 'utf-8', (error) =&gt; &#123; fs.readFile('./test.txt', 'utf-8', (error, file) =&gt; &#123; console.log('after:', file); &#125;);&#125;); 结果： 1234before: 难判谁人错与对after: 难判谁人错与对你随河流而来 打开文件open1fs.open(filename, flags, [mode], callback(err,fd)); filename：必选参数，文件名 flags：操作标识，如r,读方式打开 [mode]：权限，如777，表示任何用户读写可执行 callback：打开文件后回调函数，参数默认第一个err，第二个fd为一个整数，表示打开文件返回的文件描述符，Window中又称文件句柄 监视文件watchFile1fs.watchFile(filename, [options], listener(curr, prev)); 对文件进行监视，并且在监视到文件被修改时执行处理 filename, 完整路径及文件名； [options], persistent为true表示持续监视，不退出程序；interval单位毫秒，表示每隔多少毫秒监视一次文件 listener, 文件发生变化时回调，有两个参数：curr为修改后的fs.Stat对象，prev为修改之前的fs.Sta对象 1234fs.watchFile('./test.txt', (curr, prev) =&gt; &#123; console.log('current', curr); console.log('previous', prev);&#125;); 改动文件后，输出结果： 1234567891011121314151617181920212223242526272829303132333435363738current Stats &#123; dev: 16777218, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 4636749, size: 46, blocks: 8, atimeMs: 1556524554000, mtimeMs: 1556524553000, ctimeMs: 1556524553000, birthtimeMs: 1556524553000, atime: 2019-04-29T07:55:54.000Z, mtime: 2019-04-29T07:55:53.000Z, ctime: 2019-04-29T07:55:53.000Z, birthtime: 2019-04-29T07:55:53.000Z &#125;previous Stats &#123; dev: 16777218, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 4636495, size: 42, blocks: 8, atimeMs: 1556524547000, mtimeMs: 1556524320000, ctimeMs: 1556524320000, birthtimeMs: 1556524319000, atime: 2019-04-29T07:55:47.000Z, mtime: 2019-04-29T07:52:00.000Z, ctime: 2019-04-29T07:52:00.000Z, birthtime: 2019-04-29T07:51:59.000Z &#125; fs.unwatfile方法用来接触对文件的监听。 判断路径是否存在原本判断路径是否存在的fs.exists已经在V1.0.0被废弃，改为使用fs.stat或者fs.access fa.stat用来查询文件信息 1234567fs.stat('./test.txt', (err, stat) =&gt; &#123; if (stat &amp;&amp; stat.isFile()) &#123; console.log(stat); &#125; else &#123; console.log('file does not exist'); &#125;&#125;); fs.access用来检查文件的访问权限 123456789// 检查文件是否存在fs.access('/etc/passwd', function(err) &#123; console.log(err ? '文件存在' : '文件不存在');&#125;);// 检查文件是否有读写权限fs.access('/etc/passwd', fs.R_OK | fs.W_OK, function(err) &#123; console.lo(err ? '不可操作!' : '可以读/写');&#125;); 新建目录fs.mkdir()1fs.mkdir(path[, options], callback) mkdir接受三个参数吗，第一个是目录名，第二个是权限制，第三个是回调函数 1fs.mkdir('./hello', '0777', err =&gt; console.log(err)); 读取目录readdir1fs.readdir(path[, options], callback) 用来读取目录，返回一个所包含的文件和子目录的数组，不会递归寻找内部目录，需要手动递归实现： 1234567891011121314const list = (path) =&gt; &#123; fs.readdir(path, (err, files) =&gt; &#123; console.log(files); files.forEach(file =&gt; &#123; fs.stat(file, (error, stat) =&gt; &#123; if(stat &amp;&amp; stat.isDirectory()) &#123; list(file) &#125; &#125;) &#125;) &#125;)&#125;;list(process.cwd()); 创建读/写操作的数据流createReadStream/createWriteStreamcreateReadStrem方法旺旺用来打开大型的文本文件，创建一个读取操作的数据流。大型文本文件体积很大，读取操作的缓存装不下，只能分成几次发送。每次发送会触发data时间，发送结束会触发end时间 12345678910111213141516171819202122232425262728293031const func = data =&gt; &#123; console.log('Line: ' + data);&#125;;const readLines = (input, func) =&gt; &#123; let remaining = ''; input.on('data', data =&gt; &#123; remaining += data; let index = remaining.indexOf('\n'); let last = 0; while(index &gt; -1) &#123; let line = remaining.substring(last, index); last = index + 1; func(line); index = remaining.indexOf('\n', last); &#125; remaining = remaining.substring(last); &#125;); input.on('end', () =&gt; &#123; if(remaining.length &gt; 0) &#123; func(remaining) &#125; &#125;)&#125;;const input = fs.createReadStream('./test.txt');readLines(input, func); createWriteStream用来创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作 12345const out = fs.createWriteStream(fileName, &#123; encoding: 'utf8'&#125;);out.write(str);out.end(); createReadStream和createWriteStream配合，可以实现拷贝大型文件。 1234567891011121314151617181920212223const fileCopy = (filename1, filename2, done) =&gt; &#123; const input = fs.createReadStream(filename1); const output = fs.createWriteStream(filename2); input.on('data', data =&gt; &#123; output.write(data); &#125;); input.on('error', err =&gt; &#123; console.log(err); &#125;); input.on('end', () =&gt; &#123; output.end(); if (done) &#123; done() &#125; &#125;)&#125;;fileCopy('./test.txt', './hello.text', () =&gt; &#123; console.log('copy finish');&#125;); 删除文件unlink和删除文件夹rmdir1234// 删除文件fs.unlink('./hello.text', (err) =&gt; &#123; console.log('deleted');&#125;); 1234// 删除文件夹只能删除空文件夹，如果里面有内容则不能直接删除，会报错fs.rmdir('./world', (err) =&gt; &#123; console.log(err, 'deleted');&#125;); 如果world文件夹不为空，无法删除： 12345&#123; [Error: ENOTEMPTY: directory not empty, rmdir &apos;./world&apos;] errno: -66, code: &apos;ENOTEMPTY&apos;, syscall: &apos;rmdir&apos;, path: &apos;./world&apos; &#125; 重命名rename1234// 重命名fs.rename('./hello', './world', err =&gt; &#123; console.log(err);&#125;); 同步方法上面提到的异步API都有着对应的同步方法，比如readFile对应的同步方法readFileSync(): 12345const fs = require("fs");const file = fs.readFileSync("./test.txt", "utf-8");console.log(file);console.log("finish"); 执行的顺序就是按照一条时间链由上至下执行： 12你好哇~finish fs-extra模块fs-extra模块是fs模块的一个扩展，文档在这里。 fs-extra集成了fs模块的所有方法，提供了很多遍历的API，并且添加了Promise的支持，可以使用它来代替fs模块。 安装使用它不是Node自带的模块，需要单独安装 1npm i -S fs-extra 使用时完全可以替代fs模块，如果希望明确表示在使用fs-exra，可以将fs标示改为fse 1const fse = require('fs-extra'); 异步方法fs-extra的异步方法可以使用回调函数的形式，更推荐的是使用Promise形式，也可以使用Async/Await的语法： 1234567891011121314151617181920212223242526// 回调函数fse.copy('./test.txt', './world/test.txt', err =&gt; &#123; if (err) &#123; console.error(err); return; &#125; console.log('success!');&#125;);// Promisefse.copy('./test.txt', './world/test.txt').then(() =&gt; &#123; console.log('success');&#125;).catch(e =&gt; &#123; console.error(e);&#125;);// Async/Awaitconst copyFile = async () =&gt; &#123; try &#123; await fse.copy('./test.txt', './world/test.txt'); console.log('success'); &#125; catch (e) &#123; console.error(e); &#125;&#125;;copyFile() APIfs-extra提供了很多遍历的API，这些API都有异步和同步的两个版本，简单列举一部分异步的API，详细的API文档看这里。 1234567891011121314151617181920212223242526272829303132333435fse.copy(src: string, dest: string, [options: object, callback: func])// 复制文件或目录，目录可以包含内容fse.emptyDir(dir: string, [callback: function])// 确保目录为空，如果目录不为空，则删除目录下内容，如果目录不存在，则创建该目录fse.ensureFile(file: string, [callback: func])// 确保文件存在。如果请求创建的文件位于不存在的目录中，则会创建这些目录。如果该文件已存在，则不进行修改。（别名：createFile）fse.ensureDir(dir: string, [callback: func])// 确保目录存在，如果目录结构不存在，则创建它，如果目录存在则不进行操作fse.ensureLink(srcpath: string, dstpath: string, [callback: func])// 确保链接存在。如果目录结构不存在，则创建它。fse.move(src: string, dest: string, [options: object, callback: func])// 移动文件或目录fse.outputFile(file: stirng, data: string|Buffer|Uint8Array, [options: string|object, callback: func])// 几乎与writeFile相同，除了如果父目录不存在则创建它，file必须是文件路径（不允许使用缓存区或文件描述符）fse.outputJson(file: string, object: object, [options: object, callback: func])// 将对象写入JSON文件，几乎与writeJSON相同，除了如果目录不存在，则创建它fse.writeJson(file, object, [options, callback])// 将对象写入JSON文件，几乎与outputJSON相同，除了必须保证目录存在之外fse.pathExists(file: string [, callback: func]);// 检查文件系统来测试给定路径是否存在fse.readJson(file: string, [options: object, callback: func])// 读取JSON文件，并将其解析为对象fse.remove(path: string, [callback: func])// 删除文件或者目录，该目录可以包含内容，类似rm -rf 参考 fs 模块@JavaScript标准参考教程（alpha） Node.js v10.15.3 文档@nodejs.cn 使用Node.js的fs模块操作文件之检查文件是否存在 node-“fs-extra”模块代替fs使用@掘金]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>fs</tag>
        <tag>fs-extra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node04 模块化]]></title>
    <url>%2F2017%2F04%2F03%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode04%20%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。Node中模块化的学习笔记。 几种形式模块导入和导出有几种形式： require：Node和ES6都支持的引入 export/import：只有ES6支持的导出/引入格式 module.exports/exports：只有Node支持的导出格式 NodeNode的模块系统遵循的是CommonJS规范，CommonJS定义的模块分为模块标识（module）、模块定义（exports）、模块引用（require） exports和module.exportsNode在执行一个文件时，会给这个文件内生成一个exports和module对象，module又有一个exports属性，他们的关系如下，都指向一个内存区域： 1exports = module.exports = &#123;&#125;; 如果人为将二者指向不同的内存区域，最终导出的内容是module.exports的内容，而不是exports的内容，所以尽量都使用module.exports导出，用require导入 requireNode.js提供了exports和require两个对象，其中exports是模块公开的接口，require用来从外部获取一个模块接口，即获取模块的exports对象。 Node.js可以加载的文件模块分为三种： .js，通过fs模块同步读取JS文件并编译执行 .node，通过C/C++进行编写的Addon。通过dlopen方法进行加载 .json，读取文件，调用JSON.parse解析加载 require可以接受以下几种参数的传递： lodash、jQuery等原生模块 相对路径的文件模块 绝对路径的文件模块 非原生模块的文件模块 在引用文件模块的时候后要加上文件的路径： /.../.../xxx.js表示绝对路径、 ./xxx.js表示相对路径(同一文件夹下的xxx.js) ../表示上一级目录 如果既不加/.../、../又不加./的话，则该模块要么是核心模块，要么是从一个node_modules文件夹加载 小例子test1.js文件： 12345678910const tt1 = function (a, b) &#123; return a + b;&#125;;function tt2(a, b) &#123; return a * b;&#125;module.exports.tt1 = tt1;module.exports.tt2 = tt2; test2.js文件 1234const test1 = require("./test1.js");console.log(test1.tt1(1, 2));//3console.log(test1.tt2(1, 2));//2 在命令行执行 1node test2.js 上面代码要注意： 被引用的test1.js需要将要导出的对象存入module.exports（或者是exports）中 在test2.js文件中引入test1.js的结果，引入的就是module.exports对象，该对象对应的方法就是在test1.js中定义的函数 在使用require时要表明路径，否则会找不到对应的文件。 ES6的模块化ES6中的规范是使用export和import来导出和导入模块 导出的时候有的时候会增加一个default关键字，它其实就是一个语法糖： 123456// test.jsconst a = 123;export default a// 等同于 export &#123; a as default &#125; 引入的时候就可以直接使用任意变量名引入： 123import x from './test.js'// 等同于 impor &#123; default as x &#125; from './test.js' 要注意的是一个模块里面只能有一个export default。 还要注意，ES6导出的模块是静态的，我是这样理解的：导出的只是一段代码，并没有实际运行，导出的如果是函数也没有执行 参考 exports、module.exports 和 export、export default 到底是咋回事@掘金]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Exports</tag>
        <tag>Module</tag>
        <tag>Require</tag>
        <tag>Import</tag>
        <tag>Export</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node01 入门]]></title>
    <url>%2F2017%2F03%2F31%2F05%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%2F01%20Node%2FNode01%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[重新学习Node，整理以前的日志。一篇Node入门的笔记。 什么是Node.jsNode是一个服务器端JavaScript解释器。Node的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个物理机的连接代码。处理高并发和异步I/O是Node受到开发人员的关注的原因之一。 Node本身运行Google V8 JavaScript引擎，所以速度和性能非常好，而且Node对其封装的同时还改进了其处理二进制数据的能力。因此，Node不仅仅简单的使用了V8，还对其进行了优化，使其在各种环境下更加给力。 第三方的扩展和模块在Node的使用中起到重要的作用，npm就是模块的管理工具，用它安装各种Node的软件包并发布自己为Node写的软件包。 安装Node在macOs下安装可以通过homebrew来安装，可以通过brew -v来查看是否安装了homebrew，如果没有安装，则通过终端命令安装 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装成功后，来安装node： 123brew link nodebrew uninstall nodebrew install node 也可以直接在官网下载Node的安装包，为pkg格式，双击安装包安装即可。 在Windows下安装直接在官网下载Node的安装包，为msi格式，双击安装包安装即可。 在centos下安装进入要存放下载资源的目录，比如/usr/local/src/目录，然后执行安装命令 1wget http://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x64.tar.gz 上述命令是下载6.9.4的64位nodejs版本，如果你想下载其他版本，可以将命令中的两处v6.9.4替换成其他版本号； 如果系统是32位(一般是64位)，也可以将x64改成x32 下载完成后，执行解压命令 1tar -zxvf node-v6.9.4-linux-x64.tar.gz 解压完成，可以看到当前目录解压后的文件夹node-v6.9.4-linux-x64，重命名一下 1mv node-v6.9.4-linux-x64 node 现在，node文件夹就是程序目录，但是还不能够全局使用，需要添加变量 首先在root目录下找到.bash_profile文件，编辑 1vim ~/.bash_profile 找到PATH=$PATH:$HOME/bin，在后面添加路径为： 1PATH=$PATH:$HOME/bin:/usr/local/src/node/bin 保存修改:wq，然后重载一下 1source ~/.bash_profile OK！大功告成！现在可以在任何目录下执行node和npm命令了！ Hello Node12345678910var http = require('http'); http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); // text/plain是无格式正文 res.end('Hello World\n'); &#125;).listen(1337, "127.0.0.1"); console.log('Server running at http://127.0.0.1:1337/'); 代码逻辑： 全局方法require()是用来导入模块的，一般直接把require()方法的返回值赋值给一个变量，在JavaScript代码中直接使用此变量即可。require(&quot;http&quot;)就是加载系统预置的http模块； http.createServer是模块的方法，目的就是创建并返回一个新的web server对象，并且给服务绑定一个回调，用以处理请求； 通过http.listen()方法就可以让该HTTP服务器在特定端口监听 Node实现了console.log方法，执行hello.js代码，相关信息会显示在命令行中， 在命令行，成功启动会看见console.log()中的文本。 Node Moudle在Node中，不同的功能组件被划分成不同的模块。应用可以根据自己的需要来选择使用合适的模块。每个模块都会暴露一些公共的方法或属性。模块的使用者直接使用这些方法或属性即可，对于内部的实现细节就可以不用了解。除了Node本身提供的API外，开发人员也可以利用这个机制来将应用拆分成多个模块，以提高代码的可复用性。 如何使用模块在Node中使用模块是非常方便的，在代码中可以直接使用全局函数require()来加载一个模块。 自己如何开发模块？使用require()导入模块的时候，模块名称以&quot;./&quot;开始的这种，就是自己开发的模块文件。 代码中封装了模块的内部处理逻辑，一个模块一般都会暴露一些公开的方法或属性给其他的人使用。模块的内部代码需要把这些方法或属性给暴露出来。 hello.js的内容： 12345678var method = &#123; number: 50, add: function(a, b) &#123; return a + b; &#125;&#125;;exports.method = method; 在另外一个文件myNode.js中引用hello.js： 12345var hello = require("./hello.js");var sum = hello.method.add(5, 10);console.log(sum);console.log(hello.method.number) 运行后结果： 123$ node myNode.js1550 Node的优势Node核心思想： 非阻塞 单线程 事件驱动 在目前的web应用中，客户端和服务器端之间有些交互可以认为是基于事件的，那么Ajax就是页面及时响应的关键。每次发送一个请求时（不管请求的数据多么小），都会在网络里走一个来回。服务器必须针对这个请求作出响应，通常是开辟一个新的进程。那么越多用户访问这个页面，所发起的请求个数就会越来越多，就会出现内存溢出、逻辑交错带来的冲突、网络瘫痪、系统崩溃这些问题。 Node的目标是提供一种构建可伸缩的网络应用的方案，服务器可以同时处理很多客户端连接。 Node和操作系统有一种约定，如果创建了新的链接，操作系统通知Node后进入休眠。如果有人创建了新的链接，那么它（Node）执行一个回调，每一个链接只占用了非常小的（内存）堆栈开销。 Node异步执行的例子： hello.js的内容： 12345678var method = &#123; number: 50, add: function(a, b) &#123; return a + b; &#125;&#125;;exports.method = method; 在另外一个JS文件myNode.js中引用hello.js： 12345678910var fs = require("fs");fs.readFile("./hello.js", function(err, data) &#123; if (err) &#123; throw err &#125; console.log("successful")&#125;);console.log("async") 文件执行结果首先执行打印async，然后打印异步执行的successful，运行后结果： 123$ node myNode.jsasyncsuccessful Node是无阻塞的，新请求到达服务器时，不需要为这个请求单独作什么事情。Node仅仅是在那里等待请求的发生，有请求就处理请求。 因此，Node更擅长处理体积小的请求以及基于事件的I/O。Node不仅仅是做一个Web服务的框架，它可以做更多，比如它可以做Socket服务，可以做比方说基于文件的，然后基于像一些比方说可以有子进程，然后内部的，它是一个很完整的事件机制，包括一些异步非注射的解决方案，而不仅仅局限在网络一层。同时它可能，即使作为一个Web服务来说，它也提供了更多可以深入这个服务内核、核心的一些功能，比方说Node使用的Http Agent，这块就是它可以更深入这个服务内核来去做一些功能。 Node的事件流因为Node采用的是事件驱动的模式，其中的很多模块都会产生各种不同的事件，可由模块来添加事件处理方法，所有能够产生事件的对象都是事件模块中的EventEmitter类的实例。 12345678var event = require("events");var emitter = new event.EventEmitter();emitter.on("myEvent",function(msg)&#123; console.log(msg)&#125;);emitter.emit("myEvent","this is my event") 上面的代码中： 使用require()方法添加了events模块并把返回值赋给了一个变量 new events.EventEmitter()这句创建了一个事件触发器，也就是所谓的事件模块中的EventEmitter类的实例 on(event, listener)用来为某个事件event添加事件处理方法监听器 emit(event, [arg1], [arg2], [...])方法用来产生事件。以提供的参数作为监听器函数的参数，顺序执行监听器列表中的每个监听器函数。 在Node中，存在各式各样不同的数据流，Stream（流）是一个由不同对象实现的抽象接口。 例如请求HTTP服务器的request是一个流，类似于stdout（标准输出）；包括文件系统、HTTP 请求和响应、以及 TCP/UDP 连接等。流可以是可读的，可写的，或者既可读又可写。所有流都是EventEmitter的实例，因此可以产生各种不同的事件。 可读流主要会产生以下事件： data： 当读取到流中的数据时，此事件被触发 end： 当流中没有数据可读时，此事件被触发 error： 当读取数据出现错误时，此事件被触发 close： 当流被关闭时，此事件被触发，可是并不是所有流都会触发这个事件。（例如，一个连接进入的HTTP request流就不会触发close事件） fd事件 ： 当在流中接收到一个文件描述符时触发此事件。只有UNIX流支持这个功能，其他类型的流均不会触发此事件。 强大的File System文件系统模块Node中的fs模块用来对本地文件系统进行操作。文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。所有的方法都提供了异步和同步两种方式。 fs模块中提供的方法可以用来执行基本的文件操作，包括读、写、重命名、创建和删除目录以及获取文件元数据等。每个操作文件的方法都有同步和异步两个版本。 异步操作的版本都会使用一个回调方法作为最后一个参数。当操作完成的时候，该回调方法会被调用。而回调方法的第一个参数err总是保留为操作时可能出现的异常。如果操作正确成功，则第一个参数的值是null或undefined。 同步操作的版本的方法名称则是在对应的异步方法之后加上一个Sync作为后缀。比如异步的rename()方法的同步版本是renameSync()。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
</search>
