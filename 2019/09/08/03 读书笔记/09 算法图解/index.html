<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.7.0">


  <link rel="mask-icon" href="/images/logo-new.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="《算法图解》读书笔记。">
<meta name="keywords" content="算法,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="算法图解">
<meta property="og:url" content="http://oldzhou.cn/2019/09/08/03 读书笔记/09 算法图解/index.html">
<meta property="og:site_name" content="不负好时光">
<meta property="og:description" content="《算法图解》读书笔记。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://image.oldzhou.cn/1v.PNG">
<meta property="og:image" content="http://image.oldzhou.cn/zf12.PNG">
<meta property="og:image" content="http://image.oldzhou.cn/FiQoRiT8tz138jzvkeQZWRGEFw93">
<meta property="og:image" content="http://image.oldzhou.cn/Fl3iEnO5FYCdyYiMXiOkCuql1uUB">
<meta property="og:image" content="http://image.oldzhou.cn/Fj5dynDALXWgM5DB-qCJtK18Mo2T">
<meta property="og:image" content="http://image.oldzhou.cn/Fjx9eekL9ZyKlS4dZPQ7YUXbFg91">
<meta property="og:image" content="http://image.oldzhou.cn/FrfzqyPU7e18nxxgP9cvJMS8-lMX">
<meta property="og:image" content="http://image.oldzhou.cn/Fmr34MFG0USbDmNqmNeNu45ywTW4">
<meta property="og:image" content="http://image.oldzhou.cn/FmOxsuyNafgyhDN69YCLJ8YC1Msi">
<meta property="og:image" content="http://image.oldzhou.cn/FvFXMVoXNM9W8GcvZsU1Avfj7a79">
<meta property="og:image" content="http://image.oldzhou.cn/FvvBFCu23aMo0xK9UVTAsMvc_Xby">
<meta property="og:image" content="http://image.oldzhou.cn/FiYMEKJtqo2zeAaW1G5q6k44cnSk">
<meta property="og:image" content="http://image.oldzhou.cn/Fhi7juYF5NjIkAhkjGLRyRJmjXEW">
<meta property="og:image" content="http://image.oldzhou.cn/Fr0lFaLA3xhe7OYIv4ryvWPnq4dc">
<meta property="og:image" content="http://image.oldzhou.cn/FlF6aYs9sjSCCiJCpvBzZJ9C-WN-">
<meta property="og:image" content="http://image.oldzhou.cn/FiWlG9ksWIX1G_3GvJoiB8Ktmkxc">
<meta property="og:image" content="http://image.oldzhou.cn/Fn_k5y9H71yf44EpwYgcjm95SYIp">
<meta property="og:image" content="http://image.oldzhou.cn/Fqtw8x2bLAZf3bInFWPOy-ZLZwd6">
<meta property="og:updated_time" content="2019-09-08T18:25:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法图解">
<meta name="twitter:description" content="《算法图解》读书笔记。">
<meta name="twitter:image" content="http://image.oldzhou.cn/1v.PNG">






  <link rel="canonical" href="http://oldzhou.cn/2019/09/08/03 读书笔记/09 算法图解/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>算法图解 | 不负好时光</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不负好时光</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">没什么才华，就剩一点坚持</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="http://www.oldzhou.cn/pages/page1.html" rel="noopener" target="_blank"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oldzhou.cn/2019/09/08/03 读书笔记/09 算法图解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="哆啦斯基周">
      <meta itemprop="description" content="一个大龄前端程序员的技术博客">
      <meta itemprop="image" content="/images/avatar3.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不负好时光">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">算法图解

              
            
          </h2>
        

        <div class="post-meta">
         
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-08 18:25:40 / 修改时间：18:25:45" itemprop="dateCreated datePublished" datetime="2019-09-08T18:25:40+00:00">2019-09-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/08/03 读书笔记/09 算法图解/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2019/09/08/03 读书笔记/09 算法图解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>读书笔记。</p>
<a id="more"></a>
<h2 id="第一章-算法简介"><a href="#第一章-算法简介" class="headerlink" title="第一章 算法简介"></a>第一章 算法简介</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找是一种算法，其输入必须是<strong>有序</strong>的元素列表。</p>
<p>对于包含<code>n</code>个元素的列表，使用二分查找最多需要<code>$\log_2^n$</code>步</p>
<p>对数运算是幂运算的逆运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_2^n = a  →  2^a=n</span><br></pre></td></tr></table></figure>
<p>在使用大O表示法讨论运行时间时，<code>$\log$</code>指的都是<code>$\log_2$</code>（以<code>2</code>为底）</p>
<p>二分法的JS实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法查找</span></span><br><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">list, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = list.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor((min + max) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (list[middle] &gt; target) &#123;</span><br><span class="line">      max = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list[middle] &lt; target) &#123;</span><br><span class="line">      min = middle + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>对于Python，如果取非整数索引，会自动向下取整，但是JS中不会，因为JS中的数组本质上是一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'x'</span>, <span class="string">'y'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'x'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'y'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果为JS数组的非整数索引赋值，结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">a[<span class="number">2.5</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="comment">// [1, 2, 2.5: 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>线性时间：最多需要查找的次数与列表长度相同<code>$O(n)$</code></p>
<p>对数时间：最多需要查找的次数要<code>$\log_2^n$</code>, <code>$O(\log n)$</code></p>
<p><code>$O(\log n)$</code>比<code>$O(n)$</code>快，当需要搜索的元素越多，前者比后者快得就越多</p>
<h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>仅仅知道算法需要多长时间能运行完还不够，还需要知道运行时间如何随列表增长而增加。大O表示法表示的是算法运行时间的<strong>增速</strong>。</p>
<p>大O表示法指出的是<strong>最糟糕</strong>的情况下的运行时间。</p>
<p>一些常见的大O运行时间有：</p>
<ul>
<li><code>$O(\log n)$</code>，对数时间，例如二分查找</li>
<li><code>$O(n)$</code>，线性时间，例如简单查找</li>
<li><code>$O(n * \log n)$</code>，例如快速排序，一种比较快的排序算法</li>
<li><code>$O(n^2)$</code>，例如选择排序，一种比较慢的排序算法</li>
<li><code>$O(n!)$</code>，例如旅行商问题的解决方案，一种非常慢的算法</li>
</ul>
<p><img src="http://image.oldzhou.cn/1v.PNG" alt="image"></p>
<p>算法的速度指的并非时间，而是操作数的增速（随着输入的增加，运行时间将以什么样的速度增加）。</p>
<h2 id="第二章-选择排序"><a href="#第二章-选择排序" class="headerlink" title="第二章 选择排序"></a>第二章 选择排序</h2><h3 id="内存的工作原理"><a href="#内存的工作原理" class="headerlink" title="内存的工作原理"></a>内存的工作原理</h3><p>需要将数据存储到内存是，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式：数组和链表</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组所分配的内存空间都是紧紧相连的。如果为数组添加新元素时，当前数组占用的内存满了，则需要将数组元素转移到其他地方。可以预留内存，但是都会带来两个缺点：</p>
<ol>
<li>浪费内存</li>
<li>预留的内存用完后，还需要转移元素</li>
</ol>
<p>数组的优点：需要随机的读取元素时，数组效率很高。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表中的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在了一起。</p>
<p>链表的优势在与插入元素方面，而且如果需要同时读取所有元素时，链表的效率很高。</p>
<h3 id="在中间插入元素"><a href="#在中间插入元素" class="headerlink" title="在中间插入元素"></a>在中间插入元素</h3><p>使用链表插入元素很简单，只需要修改它前面的额按个元素指向的地址。使用数组插入元素时，则必须将后面的所有元素都后移。</p>
<p>在中间插入元素，链表是更好的选择。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>需要删除元素，链表也是更好的选择。</p>
<h3 id="数组和链表的比较"><a href="#数组和链表的比较" class="headerlink" title="数组和链表的比较"></a>数组和链表的比较</h3><p>数组用的更多，因为它支持<strong>随机访问</strong>，所以数组的读取速度更快。而链表只能<strong>顺序访问</strong>。</p>
<p>数组和链表常见的操作的运行时间：</p>
<table>
<thead>
<tr>
<th>–</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>$O(n)$</code></td>
<td><code>$O(1)$</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>$O(n)$</code></td>
<td><code>$O(1)$</code></td>
</tr>
</tbody>
</table>
<h3 id="Facebook存储用户信息的方法"><a href="#Facebook存储用户信息的方法" class="headerlink" title="Facebook存储用户信息的方法"></a>Facebook存储用户信息的方法</h3><p>Facebook存储用户信息时用的是<strong>链表数组</strong>，数组包含26个元素，每个元素指向一个链表。</p>
<p><img src="http://image.oldzhou.cn/zf12.PNG" alt="image"></p>
<p>插入元素时，对数组的移动最多26次，然后再从它指向的链表中进行插入。</p>
<p>读取元素时，可以直接找到数组中的对应元素，然后在链表中查找。</p>
<blockquote>
<p>那么查找元素时，会不会效率太低？</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的原理就是每一轮在<code>n</code>个元素中进行查找，找出最小元素，放到结果当中。</p>
<p>每一轮的操作时间复杂度为<code>$O(n)$</code>，这样的操作需要执行<code>n</code>次，所以时间复杂度为<code>$O(n^2)$</code></p>
<p>有一个问题，每一轮进行后，下一轮要检查的元素会逐渐减少，实际随后检查的元素格式是一个公差为<code>1</code>的等差数列<code>n-1</code>、<code>n-2</code>…<code>2</code>、<code>1</code>，平均每次检查的元素是<code>n/2</code>，因此运行时间为<code>$O(n * n/2)$</code>，但是大O表示法会忽略诸如<code>1/2</code>这样的常数，所以为<code>$O(n^2)$</code></p>
<p>选择排序的JS实现：（从小到大排序）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chooseSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序的速度不是很快，快速排序的速度更快，时间复杂度为<code>$O(n * \log n)$</code></p>
<h2 id="第三章-递归"><a href="#第三章-递归" class="headerlink" title="第三章 递归"></a>第三章 递归</h2><p>递归是一种很多算法都使用的一种编程方法。</p>
<p>递归只是让解决方案更加清晰，并没有性能上的优势。实际上在有些情况下使用循环的性能更好。</p>
<h3 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h3><p>编写递归函数时，必须告诉它何时停止。每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件值得是函数不再调用自己，避免造成无限循环。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种简单的数据结构，有两种操作：压入和弹出。</p>
<p>计算机内部使用被称为调用栈的栈。在调用过程中，调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都保留在内存中。</p>
<p>在递归调用栈中，包含着未完成的函数调用，自己无需跟踪哪些函数还没有被执行，栈会完成这个步骤。</p>
<p>使用栈很方便，但是也有性能代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，那么以为这计算机储存了大量函数调用的信息。</p>
<p>解决方法：</p>
<ol>
<li>改用循环</li>
<li>使用尾递归（尾递归的实现需要确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数）</li>
</ol>
<h2 id="第四章-快速排序"><a href="#第四章-快速排序" class="headerlink" title="第四章 快速排序"></a>第四章 快速排序</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治法是解决问题的一种思路，一种递归式问题解决方法。</p>
<p>用分治法解决问题有包括两个步骤：</p>
<ol>
<li>找出基线条件（即递归终止的条件），这种条件必须尽可能简单</li>
<li>不断将问题分解（或者说缩小规模），直到符合基线条件</li>
</ol>
<p>一道题目：将一个长度为<code>length</code>、宽度为<code>width</code>的矩形均匀地分成方块，并确保分出的方块是最大的</p>
<p>分析这道题，首先要找出递归条件，最容易处理的情况是<strong>一条边的长度是另一条边的整数倍</strong>。这个时候就可以将矩形均匀地分成方块。</p>
<p>然后找出递归条件，每次递归都需要缩小问题规模。首先找出这块地可容纳的最大方块<code>A</code>，剩余的土地为<code>B</code>，根据欧几里得算法，适用于这小块地的最大方块，也是适用于整块地的最大的方块（就这个算法我就不知道，真做的时候就做出不来）。据此就可以不断的缩小规模，直到满足基线条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到一个矩形可以均匀的划分的最大的小方块的尺寸</span></span><br><span class="line"><span class="keyword">const</span> getMaxSquare = <span class="function">(<span class="params">length, width</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (width &gt; length) &#123;</span><br><span class="line">    [width, length] = [length, width]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length % width === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length === width) &#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getMaxSquare(width, length - width)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 编写设计数组的递归函数时，基线条件通常是数组为空或者只包含一个元素。</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想就是<strong>分治法</strong>，首先从最简单情况开始分析，找出基线条件，那就是数组为空或者只包含一个元素，然后逐渐增加到两个元素，三个元素。</p>
<p>到了三个元素的时候，首先选出基准值，然后分别找出比基准值小和比基准值大的元素（即分区），这样就得到了三个部分：</p>
<ol>
<li>小于基准值的数字组成的数组（无序）</li>
<li>基准值</li>
<li>大于基准值组成的数组（无序）</li>
</ol>
<p>然后对1和3再次进行快速排序，直到满足基线条件（即数组的长度为<code>0</code>或者<code>1</code>）为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> middleIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> middle = arr.splice(middleIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">    (middle &gt; arr[i] ? left : right).push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(middle, quickSort(right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>快速排序的时间复杂度是<code>$O(n * \log n)$</code></p>
<h3 id="再谈大-O-表示法"><a href="#再谈大-O-表示法" class="headerlink" title="再谈大$O$表示法"></a>再谈大<code>$O$</code>表示法</h3><p><code>c</code>是算法所需要的固定时间量，被称为常量。通常不考虑这个常量，因为如果算法的大<code>$O$</code>运行时间不同，这种常量将无关紧要。</p>
<p>但有时候，常量的影响可能很大，如果运行时间都是<code>$O(n * \log n)$</code>，那么常量就会影响很大。这也是快速排序比合并排序快的原因。</p>
<p>下面要分析一下，快速排序的时间复杂度为什么是<code>$O(n * \log n)$</code></p>
<p>快速排序的性能高度依赖于选择基准值，如果总是将第一个元素用作基准值，栈长为<code>n</code>（即总共要调用<code>n</code>次），每一轮要比较<code>n</code>个数字，每轮完成时间为<code>$O(n)$</code>，这就是最糟情况，这时候快速排序的运行时间是<code>$O(n^2)$</code></p>
<p>如果总是将中间的元素用作基准值，栈长变成了<code>$O(\log n)$</code>，每一轮仍然要比较<code>n</code>个数字，每轮完成时间为<code>$O(n)$</code>，这就是最佳情况，这时候快速排序的运行时间是<code>$O(n * \log n)$</code></p>
<p>要注意的是，最佳情况也是平均情况。只要每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间也就是<code>$O(n * \log n)$</code>。</p>
<p>快速排序是最快的排序算法之一，也是分治法的典范。</p>
<h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数是这样的函数，无论输入什么数据，都还给一个数字，即将输入映射到数字，散列函数必须满足：</p>
<ol>
<li>每次输出的一致性</li>
<li>将不同的输入映射到不同的数字</li>
</ol>
<p>可以使用散列函数来确定元素的存储位置。</p>
<p>散列函数对于散列表的性能至关终于，良好的散列函数让数组中的值呈均匀分布，SHA函数可以用作散列函数。</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>使用散列函数和数组，就可以创建一种被称为散列表（hash table）的数据结构。</p>
<p>散列表也被称为散列映射、映射、字典和关联数组。适合用于：</p>
<ul>
<li>模拟映射关系</li>
<li>防止重复</li>
<li>缓存、记住数据</li>
</ul>
<p>JavaScript中的对象结构就是语言实现了的散列表结构。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>散列表的性能：</p>
<table>
<thead>
<tr>
<th>–</th>
<th>平均情况</th>
<th>最糟情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
</tbody>
</table>
<p>在平均情况下下，散列表执行各种操作的时间都是<code>$O(1)$</code>。<code>$O(1)$</code>被称为常量时间，它并不意味着马上，而是说不管散列表大多，所需的时间与长度无关，都是相同的数值。</p>
<p>所以在JavaScript中，使用对象存储数据并进行查找的性能大于使用数组存储，可以认为是<code>$O(1)$</code></p>
<h2 id="第六章-广度优先搜索（BFS"><a href="#第六章-广度优先搜索（BFS" class="headerlink" title="第六章 广度优先搜索（BFS)"></a>第六章 广度优先搜索（BFS)</h2><h3 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h3><p>广度优先搜索算法（breadth-first search，BFS）是一种图算法，可以找出两样东西之间最短的距离，即解决<strong>最短路径问题</strong>。</p>
<p>解决最短路径问题有两个步骤：</p>
<ol>
<li>使用图来建立问题模型</li>
<li>使用广度优先搜索解决问题</li>
</ol>
<p>图用来模拟不同的东西是如何连接的，由节点和边构成</p>
<p><img src="http://image.oldzhou.cn/FiQoRiT8tz138jzvkeQZWRGEFw93" alt=""></p>
<p>有向图的关系是单向的，边是箭头，箭头指定了关系的方向；无向图没有剪头，关系是双向的。</p>
<p><img src="http://image.oldzhou.cn/Fl3iEnO5FYCdyYiMXiOkCuql1uUB" alt=""></p>
<p>如果任务A依赖于任务B，在列表中任务A就必须在任务B后面，这被称为拓扑排序。</p>
<p><img src="http://image.oldzhou.cn/Fj5dynDALXWgM5DB-qCJtK18Mo2T" alt=""></p>
<p>树是一种特殊的图，其中没有往后指的边。</p>
<p><img src="http://image.oldzhou.cn/Fjx9eekL9ZyKlS4dZPQ7YUXbFg91" alt=""></p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索是一种用于图的查找算法，可以解决两类问题：</p>
<ol>
<li>从节点A出发，有前往节点B的路径吗</li>
<li>从节点A出发，前往节点B的哪条路径最短</li>
</ol>
<p>在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径，但是一定要<strong>按添加顺序检查</strong>，队列（queue）是一种可以实现这种目的的数据结构。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列只支持两种操作：入队和出队。队列是一种<strong>先进先出</strong>（First In First Out）的数据结构，而栈是一种后进先出（Last In Frist Out）的数据结构。</p>
<h3 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h3><p>实现广度优先搜索的关键是，要使用队列来存放要搜索的结果，这个队列是在搜索的过程中不断变增加的。在遍历一层时，如果不是目标，则将这个元素的后代加入到待搜索队列中。同时使用一个对象标记对象是否已经遍历过（针对无向图，防止无限循环出现，对于树结构来说则不需要）</p>
<p>如果是实现最短路径，在将后代元素加入到待搜索队列中时，应该以对象的形式加入，因为要补充一个队列，用来存放当前遍历的路径。</p>
<h3 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h3><p>在整个关系网中进行搜索，以图算法来看，运行时间至少为<code>$O(边数)$</code>，此外还使用了一个队列来存放待搜索元素，将一个元素添加到队列的时间是固定的为<code>$O(1)$</code>，对每个元素都这样做的总时间为<code>$O(n)$</code>。</p>
<p>所以广度优先搜索的运行时间为<code>$O(边数+顶点数)$</code>，通常写作<code>$O(V+E)$</code>，<code>V</code>是顶点数，<code>E</code>是边数。</p>
<h2 id="第七章-迪克斯特拉算法"><a href="#第七章-迪克斯特拉算法" class="headerlink" title="第七章 迪克斯特拉算法"></a>第七章 迪克斯特拉算法</h2><p>广度优先搜索找出的是段数最少的路径，如果每段路径有着不同的权重，要找出最快的路径，可以使用迪克斯特拉算法</p>
<h3 id="使用迪克斯特拉算法"><a href="#使用迪克斯特拉算法" class="headerlink" title="使用迪克斯特拉算法"></a>使用迪克斯特拉算法</h3><p>迪克斯特拉算法包含四个步骤</p>
<ol>
<li>找出“最便宜”的节点，即可在最短时间内到达的节点</li>
<li>更新该节点的邻居的开销</li>
<li>重复这个过程，直到对图中每个节点都这样做了</li>
<li>计算最终路径</li>
</ol>
<p>迪克斯特拉算法背后的关键理念：<strong>找出图中最便宜的节点，确保没有到该节点的更便宜的路径</strong></p>
<h3 id="负权边"><a href="#负权边" class="headerlink" title="负权边"></a>负权边</h3><p><strong>如果有负权边，就不能使用迪克斯特拉算法</strong>。</p>
<p>因为节点一旦被处理，就以为这没有前往该节点的更便宜的路径，但是如果有负权边，那么就会在最片的路径被发现后，在负权边的路径上发现更便宜的节点。</p>
<p>在有负权边的图中，要找出最短路径，可以使用贝尔曼-福德算法。</p>
<h3 id="迪克斯特拉算法的实现"><a href="#迪克斯特拉算法的实现" class="headerlink" title="迪克斯特拉算法的实现"></a>迪克斯特拉算法的实现</h3><p>迪克斯特拉算法的实现需要四个散列表：</p>
<ol>
<li>用于存储节点、节点的邻居以及前往节点邻居的开销<code>graph</code></li>
<li>用于存储每个节点的最短开销<code>costs</code></li>
<li>用于存储每个节点最短开销情况下的父节点<code>parents</code></li>
<li>用于存储已经遍历过的节点<code>processed</code></li>
</ol>
<p>实际上上面这四个散列表就是迪克斯特拉算法需要的数据结构，需要将图转换为对应的数据结构后，对这种特定的数据结构使用算法，达到目的。</p>
<p>以下面的图距离：</p>
<p><img src="http://image.oldzhou.cn/FrfzqyPU7e18nxxgP9cvJMS8-lMX" alt=""></p>
<p>首先实现第一个散列表（也就是JS中的对象）<code>graph</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储节点、节点的邻居以及前往节点邻居的开销</span></span><br><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  start: &#123;<span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  a: &#123;<span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  b: &#123;<span class="attr">a</span>: <span class="number">8</span>, <span class="attr">d</span>: <span class="number">7</span>&#125;,</span><br><span class="line">  c: &#123;<span class="attr">d</span>: <span class="number">6</span>, <span class="attr">end</span>: <span class="number">3</span>&#125;,</span><br><span class="line">  d: &#123;<span class="attr">end</span>: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后实现第二个对象<code>costs</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储每个节点的最短开销</span></span><br><span class="line"><span class="keyword">const</span> costs =  &#123;</span><br><span class="line">  a: <span class="number">5</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">Infinity</span>,</span><br><span class="line">  d: <span class="literal">Infinity</span>,</span><br><span class="line">  end: <span class="literal">Infinity</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，没有计算的节点的开销用了<code>Infinity</code>无穷大来表示。</p>
<p>然后实现第三个对象<code>parents</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储每个节点最短开销情况下的父节点</span></span><br><span class="line"><span class="keyword">const</span> parents = &#123;</span><br><span class="line">  a: <span class="string">'start'</span>,</span><br><span class="line">  b: <span class="string">'start'</span>,</span><br><span class="line">  c: <span class="string">''</span>,</span><br><span class="line">  d: <span class="string">''</span>,</span><br><span class="line">  end:<span class="string">''</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第四个对象可以在函数内部声明一个对象实现，也可以直接改造第二个对象，添加一个是否遍历的属性。</p>
<p>构造数据结构完成之后，来实现<code>dijkstra</code>算法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到开销最小的，并且没有遍历过的节点</span></span><br><span class="line"><span class="keyword">const</span> findLowestCostNode = <span class="function">(<span class="params">costs, processed</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 筛选出没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">const</span> unProcessed = <span class="built_in">Object</span>.keys(costs).filter(<span class="function"><span class="params">key</span> =&gt;</span> !processed[key]);</span><br><span class="line">  <span class="comment">// 如果存在没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">if</span> (unProcessed &amp;&amp; unProcessed.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 找出开销最小的节点</span></span><br><span class="line">    <span class="keyword">return</span> unProcessed.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> costs[a] - costs[b])[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在没有遍历过的节点时</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成加权图中的最短路径</span></span><br><span class="line"><span class="keyword">const</span> getFullPath = <span class="function"><span class="params">parents</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> key = <span class="string">'end'</span>;</span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (key !== <span class="string">'start'</span>) &#123;</span><br><span class="line">    path.unshift(key);</span><br><span class="line">    key = parents[key];</span><br><span class="line">  &#125;</span><br><span class="line">  path.unshift(<span class="string">'start'</span>);</span><br><span class="line">  <span class="keyword">return</span> path.join(<span class="string">'→'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪科特斯拉算法</span></span><br><span class="line"><span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, costs, parents</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录所有遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> processed = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 找到开销最小的，并且没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> node = findLowestCostNode(costs, processed);</span><br><span class="line">  <span class="comment">// while 循环在所有节点都遍历过后结束</span></span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 找到当前节点的所有相邻节点</span></span><br><span class="line">    <span class="keyword">let</span> neighbors = graph[node];</span><br><span class="line">    <span class="comment">// 找到到达当前节点的开销</span></span><br><span class="line">    <span class="keyword">let</span> cost = costs[node];</span><br><span class="line">    <span class="comment">// 对所有相邻节点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> neighborNode <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">      <span class="comment">// for...in 的安全性检查</span></span><br><span class="line">      <span class="keyword">if</span> (neighbors.hasOwnProperty(neighborNode)) &#123;</span><br><span class="line">        <span class="comment">// 找出新的到达相邻节点的开销</span></span><br><span class="line">        <span class="keyword">const</span> newCost = cost + neighbors[neighborNode];</span><br><span class="line">        <span class="comment">// 如果计算出的新的开销小于已记录的开销，则进行更新</span></span><br><span class="line">        <span class="keyword">if</span> (newCost &lt; costs[neighborNode]) &#123;</span><br><span class="line">          <span class="comment">// 更新开销</span></span><br><span class="line">          costs[neighborNode] = newCost;</span><br><span class="line">          <span class="comment">// 更新父节点</span></span><br><span class="line">          parents[neighborNode] = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前节点标记为已经处理过</span></span><br><span class="line">    processed[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 找出接下来要处理的节点，并循环，直到所有节点都被处理过</span></span><br><span class="line">    node = findLowestCostNode(costs, processed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终的开销和路径</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    cost: costs[<span class="string">'end'</span>],</span><br><span class="line">    path: getFullPath(parents),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>计算结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">cost</span>: <span class="number">8</span>, <span class="attr">path</span>: <span class="string">'start→a→d→end'</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="第八章-贪婪算法"><a href="#第八章-贪婪算法" class="headerlink" title="第八章 贪婪算法"></a>第八章 贪婪算法</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p>教室调度问题可以采用贪婪算法，具体做法如下：</p>
<ol>
<li>选出最早结束的课</li>
<li>选择第一堂课结束后的，并且结束最早的课</li>
<li>重复上面的步骤</li>
</ol>
<p>贪婪算法很简单：<strong>每一步都采取最优的做法</strong>。每步都选择局部最优解，最终得到的就是全局最优解。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>对于背包问题，贪婪算法显然不能获得最优解。些时只需要找到一个能够大致解决问题的算法，此时贪婪算法刚好可以派上用场，因为它们实现起来很容易，得到的结果由于正确结果相当接近。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法求解背包问题近似解</span></span><br><span class="line"><span class="keyword">const</span> knapsackProblem = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bagSize = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'sound'</span>, <span class="attr">size</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'laptop'</span>, <span class="attr">size</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'guitar'</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">1500</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'iphone'</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> names = [];</span><br><span class="line">  <span class="keyword">let</span> remainSize = bagSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从价值最大的开始装，能装多少算多少</span></span><br><span class="line">  items.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.value - a.value).forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.size &lt;= remainSize) &#123;</span><br><span class="line">      value += v.value;</span><br><span class="line">      names.push(v.name);</span><br><span class="line">      remainSize = remainSize - v.size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value, names</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h3><p>假设需要将一个广播节目让全美50个州的听众都收听得到，需要在尽可能少的广播台播出，这就是集合覆盖问题。</p>
<p>解决覆盖问题非常难，具体方法如下：</p>
<ol>
<li>列出每个可能的广播台的集合，被称为幂集，可能的子集有<code>$O(2^n)$</code>个</li>
<li>在这些集合中，选出覆盖全部50个州的最小集合</li>
</ol>
<p>运行时间为<code>$O(2^n)$</code>，需要一种近似算法</p>
<h3 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h3><p><strong>使用贪婪算法可以得到非常近似的解</strong>：</p>
<ol>
<li>选出这样一个广播台，它覆盖了最多的未覆盖州（即便这个广播台覆盖了一些已覆盖的州，也没有关系）</li>
<li>重复第一步，直到覆盖了所有的州</li>
</ol>
<p>这是一种近似算法，在获得精确解需要的时间太长时，可以使用近似算法。判断近似算法优劣的标准如下：</p>
<ol>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度</li>
</ol>
<p>这个例子的贪婪算法的时间复杂度为<code>$O(n^2)$</code>，其中<code>n</code>是广播台的数量。</p>
<p>这种算法的关键是求出<code>statesNeeded</code>（需要覆盖的州）和<code>stateForStation</code>（电台能够覆盖的州）的交集，求出的就是当前广播电台覆盖的所有还未覆盖的州。</p>
<p>在所有没有选择的电台中进行比那里，找出上面提到的交集最大的电台。不断重复这个过程，直到所有的州都被覆盖为止。</p>
<h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>为了解决集合覆盖问题，你必须计算每个可能的集合，这与旅行商问题相似，需要计算每条可能的路径。</p>
<ul>
<li>当有<code>1</code>个城市时，可能的路线有<code>1</code>条</li>
<li>当有<code>2</code>个城市时，可能的路由先<code>2</code>条</li>
<li>当有<code>3</code>个城市时，可能的路由先<code>6</code>条</li>
<li>当有<code>4</code>个城市时，可能的路由先<code>24</code>条</li>
</ul>
<p>规律就是，每增加一个城市，需要计算的路线数都将增加，可以认为增加一个城市，可能的路径就以任何一个城市为起点（<code>n</code>）个，重复前一种情况的可能的路径数，也就是说当有<code>5</code>个城市时，任选一个作为起点，有<code>5</code>种情况，都是「当有<code>4</code>个城市时」的路径树<code>24</code>，也就是<code>24</code>重复了<code>5</code>遍，也就是<code>120</code>条</p>
<p>这是阶乘函数，如果涉及到的城市非常多，根本就无法找出旅行商问题的正确解。</p>
<p>旅行商问题和集合覆盖问题有一些共同之处：需要计算所有的解，并从中选出最小/最短的那一个。这两个问题都属于NP完全问题。</p>
<p>旅行商问题的近似求解：随便选择出发城市，然后选择要去的下一个城市时，都选择还没去的最近的城市。选择的路径可能不是最短的，但是也比较接近了。</p>
<h3 id="如何识别NP完全问题"><a href="#如何识别NP完全问题" class="headerlink" title="如何识别NP完全问题"></a>如何识别NP完全问题</h3><p>判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。可以通过以下几点来判断NP完全问题：</p>
<ul>
<li>元素较少时算法的运行速度非常快，但随着元素数量增加，速度会变得非常慢</li>
<li>涉及“所有组合”的问题通常是NP完全问题</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题</li>
<li>如果问题涉及序列（如旅行商问题的城市序列）且难以解决，它可能就是NP完全问题</li>
<li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题</li>
<li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题</li>
</ul>
<h2 id="第九章-动态规划"><a href="#第九章-动态规划" class="headerlink" title="第九章 动态规划"></a>第九章 动态规划</h2><p>动态规划可以在给定约束条件下找到最优解。<strong>在问题可以分解为彼此独立且离散的子问题</strong>时，就可以使用动态规划来解决。</p>
<p><strong>为动态规划问题建模时的小窍门</strong>：</p>
<ul>
<li>每种动态规划解决方案都涉及网格</li>
<li>单元格中的值通常就是要优化的值</li>
<li>每个单元格都是一个子问题</li>
</ul>
<p>在绘制网格时，需要回答如下问题：</p>
<ul>
<li>单元格中的值是什么</li>
<li>如何将这个问题划分为子问题</li>
<li>网格的坐标轴是什么</li>
</ul>
<p>要注意，最终答案不一定在最后一个单元格中。</p>
<h3 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题就是典型的动态规划的应用之一。</p>
<p><strong>动态规划先解决子问题，在逐步解决大问题</strong>。每个动态规划算法都从一个网格开始，背包问题的网格如下：</p>
<p><img src="http://image.oldzhou.cn/Fmr34MFG0USbDmNqmNeNu45ywTW4" alt=""></p>
<p>填充的过程是逐行进行的，原则是<strong>保证当前单元格的值为此列的最大值</strong>。如果装入当前单元格的物品后，重量有剩余，则回退一行，找到剩余重量对应的最大值。</p>
<p>使用的公式为：</p>
<p><img src="http://image.oldzhou.cn/FmOxsuyNafgyhDN69YCLJ8YC1Msi" alt=""></p>
<p><strong>通过表格求解子问题，可以合并两个子问题的解来得到更大问题的解</strong>。</p>
<p>下面编写代码：</p>
<p>（感觉这个代码是为了这个算法生凑出来的，其实关键点把握住就行了，一是上面的公式，而是通过求解子问题，然后通过合并来求解更大问题）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> knapsackProblem = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bagSize = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'sound'</span>, <span class="attr">size</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'laptop'</span>, <span class="attr">size</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'guitar'</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">1500</span>&#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储结果的表格</span></span><br><span class="line">  <span class="keyword">const</span> cell = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空格子</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CellClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.names = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外层遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 声明新的一行</span></span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="comment">// 针对的物品</span></span><br><span class="line">    <span class="keyword">const</span> item = items[i];</span><br><span class="line">    <span class="comment">// 当前商品的价值</span></span><br><span class="line">    <span class="keyword">const</span> currentValue = item.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层遍历重量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">      <span class="comment">// 当前格子装入物品后的剩余空间</span></span><br><span class="line">      <span class="keyword">const</span> remainSize = j - item.size;</span><br><span class="line">      <span class="comment">// 上一个单元格</span></span><br><span class="line">      <span class="keyword">const</span> lastCell = (cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j]) ? cell[i - <span class="number">1</span>][j] : <span class="keyword">new</span> CellClass();</span><br><span class="line">      <span class="comment">// 上一个单元格的值（之前的最大值）</span></span><br><span class="line">      <span class="keyword">const</span> lastCellValue = lastCell.value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果能装下这个物品</span></span><br><span class="line">      <span class="keyword">if</span> (remainSize &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 剩余空间对应的单元格</span></span><br><span class="line">        <span class="keyword">const</span> remainCell = (cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][remainSize]) ?cell[i - <span class="number">1</span>][remainSize]: <span class="keyword">new</span> CellClass();</span><br><span class="line">        <span class="comment">// 剩余空间的价值</span></span><br><span class="line">        <span class="keyword">const</span> remainValue = remainCell.value;</span><br><span class="line">        <span class="comment">// 预期的最大值</span></span><br><span class="line">        <span class="keyword">const</span> currentMaxValue = currentValue + remainValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果预期的最大值更大</span></span><br><span class="line">        <span class="keyword">if</span> (currentMaxValue &gt; lastCellValue) &#123;</span><br><span class="line">          cell[i][j] = &#123;<span class="attr">value</span>: currentMaxValue, <span class="attr">names</span>: [item.name, ...remainCell.names]&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cell[i][j] = &#123;<span class="attr">value</span>: lastCellValue, <span class="attr">names</span>: lastCell.names&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 装不下这个物品则取上一个单元格</span></span><br><span class="line">        cell[i][j] = lastCell</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(cell);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cell[items.length - <span class="number">1</span>][bagSize]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可以偷商品的一部分吗"><a href="#可以偷商品的一部分吗" class="headerlink" title="可以偷商品的一部分吗"></a>可以偷商品的一部分吗</h3><p>偷商品的一部分，不能使用动态规划处理。动态规划只能处理要么拿走整件商品，要么就不拿的情况，没法判断该不该拿走商品的一部分。</p>
<p>这种情况应该使用贪婪算法来处理，首先尽可能多的拿价值高的商品，如果拿光了在尽可能拿价值次高的商品，以此类推。</p>
<h3 id="可以相互依赖吗"><a href="#可以相互依赖吗" class="headerlink" title="可以相互依赖吗"></a>可以相互依赖吗</h3><p>如果各个项目之间有依赖情况，那么是没有办法使用动态规划来建模的。</p>
<p>动态规划算法能够解决子问题，并且使用这些答案来解决大问题。但是<strong>仅当每个子问题都是离散的，即不依赖于其他子问题时</strong>，动态规划才管用。</p>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>在填充表格时，没有找出计算公式的简单办法，必须通过尝试才能找出有效的公式。<strong>有些算法并非精确的解决步骤，而是帮助你理清思路的框架</strong>。</p>
<p>在计算<code>FISH</code>和<code>HISH</code>的最大公共子串时，填写出来的表格和计算公式是：</p>
<p><img src="http://image.oldzhou.cn/FvFXMVoXNM9W8GcvZsU1Avfj7a79" alt=""></p>
<p>实现的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSubstring = <span class="function">(<span class="params">string1, string2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    string: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> cell = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string1.length; i++) &#123;</span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; string2.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (string1[i] === string2[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        cell[i][j] = &#123;</span><br><span class="line">          value: lastCell ? lastCell.value + <span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">          string: lastCell ? lastCell.string + string1[i] : string1[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cell[i][j] = &#123;<span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">''</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result.value &lt; cell[i][j].value) &#123;</span><br><span class="line">        result.value = cell[i][j].value;</span><br><span class="line">        result.string = cell[i][j].string;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以用这个算法来解决之前遇到过的<a href="https://duola8789.github.io/2018/12/04/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0/%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A010%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%92%8C/" target="_blank" rel="noopener">《前端练习10 连续子串最大和</a>》的问题，具体分析过程看那篇笔记吧。</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>与最长公共子串不同，最长公共子序列不需要是连续的，比如<code>FOSH</code>与<code>FISH</code>的最长公共子串是<code>SH</code>，长度是<code>2</code>，而最长公共子序列是<code>FSH</code>，长度是<code>3</code></p>
<p>这个问题在计算单元格数据时使用的公式与最长子串不同：</p>
<p><img src="http://image.oldzhou.cn/FvvBFCu23aMo0xK9UVTAsMvc_Xby" alt=""></p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长公共子序列</span></span><br><span class="line"><span class="keyword">const</span> maxSubsequence = <span class="function">(<span class="params">string1, string2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    string: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cell = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string1.length; i++) &#123;</span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; string2.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (string1[i] === string2[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        cell[i][j] = &#123;</span><br><span class="line">          value: lastCell ? (lastCell.value + <span class="number">1</span>) : <span class="number">1</span>,</span><br><span class="line">          string: lastCell ? (lastCell.string + string1[i]) : string1[i],</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        <span class="keyword">if</span>(cell[i][j].value &gt; result.value) &#123;</span><br><span class="line">          result = cell[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> lastRowCell = cell[i] &amp;&amp; cell[i][j - <span class="number">1</span>] || &#123; <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">''</span>,&#125;;</span><br><span class="line">        <span class="keyword">const</span> lastColCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j]|| &#123; <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">''</span>,&#125;;</span><br><span class="line">        <span class="keyword">if</span> (lastRowCell.value &gt; lastColCell.value) &#123;</span><br><span class="line">          cell[i][j] = &#123;</span><br><span class="line">            value: lastRowCell.value,</span><br><span class="line">            string: lastRowCell.string,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cell[i][j] = &#123;</span><br><span class="line">            value: lastColCell.value,</span><br><span class="line">            string: lastColCell.string,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>需要在给定约束条件下优化某种指标时，动态规划很有用</li>
<li>问题可以分解为离散的子问题时，可以使用动态规划来解决</li>
<li>每种动态规划解决方案都涉及网格</li>
<li>单元格中的值通常是你要优化的值</li>
<li>每个单元格都是一个子问题，需要考虑如何将问题分解为子问题</li>
<li>没有放之四海而皆准的计算动态规划解决方案的公式</li>
</ul>
<h2 id="第十章-K最近邻算法"><a href="#第十章-K最近邻算法" class="headerlink" title="第十章 K最近邻算法"></a>第十章 K最近邻算法</h2><p>K最近邻算法（k-nearest neighbours, KNN）简单的说就是在对一个事物分类时，如果自身没有准确的特征值用来分类，就可以看距离它最近的邻居，借此对目标分类。</p>
<h3 id="创建推荐系统"><a href="#创建推荐系统" class="headerlink" title="创建推荐系统"></a>创建推荐系统</h3><p>（1）特征抽取</p>
<p>要比较推荐系统的用户，就需要以某种方式将他们放到图表中，需要将每个用户转换为这一组坐标，然后就可以计算他们的距离了。</p>
<p>特征抽取就是将物品转换为一系列可比较的数字。</p>
<p>一种抽取特征值的方法：</p>
<p><img src="http://image.oldzhou.cn/FiYMEKJtqo2zeAaW1G5q6k44cnSk" alt=""></p>
<p>通过这些特征值可以计算距离：</p>
<p><img src="http://image.oldzhou.cn/Fhi7juYF5NjIkAhkjGLRyRJmjXEW" alt=""></p>
<p>（2）回归</p>
<p>所谓回归，就是使用KNN来做两项基本工作：分类和回归：</p>
<ul>
<li>分类就是编组</li>
<li>回归就是预测结果（比如一个数字）</li>
</ul>
<p>比如，找出与目标最接近的5个邻居，求这些人的平均分，就是回归。</p>
<p>可以使用余弦相似度来代替距离公式，能够更准确的找出相似的邻居。</p>
<p>（3）挑选合适的特征值没有通用的准则，必须考虑各种需要考虑的因素</p>
<p>能够挑选合适的特征事关KNN算法的成败。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>刚才的推荐系统实际上就是一个机器学习的例子，还有其他机器学习的例子</p>
<p>（1）OCR，光学字符识别，要自动识别字符，可以使用KNN</p>
<ul>
<li>浏览大量的图像，将这些数字的特征提取出来（也就是训练）</li>
<li>遇到新图像时提取该图像的特征，再找出它最近的邻居</li>
</ul>
<p>大多数及其学习算法都包含训练的步骤，要让计算机完成任务，必须先训练它</p>
<p>（2）垃圾邮件过滤器</p>
<p>垃圾邮件过滤器使用了一种简单算法：朴素贝叶斯分类器，用数据对分类器进行训练后，收到新的邮件，分析邮件中每个单词在垃圾邮件中出现的概率是多少</p>
<h2 id="第十一章-接下来如何做"><a href="#第十一章-接下来如何做" class="headerlink" title="第十一章 接下来如何做"></a>第十一章 接下来如何做</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>二叉树查找（binary search tree，BST）的特征：</p>
<ol>
<li>左子树的所有节点的值都小于或等于它的根节点的值</li>
<li>右子树上所有节点的值均大于或等于它的根节点的值</li>
</ol>
<p>下面就是一棵典型的二叉查找树：</p>
<p><img src="http://image.oldzhou.cn/Fr0lFaLA3xhe7OYIv4ryvWPnq4dc" alt=""></p>
<p>在利用二叉查找树查找节点时的思想就是<strong>二分法查找</strong>的思想，平均运行时间为<code>$O(\log n)$</code>，最糟的情况下所需的时间为<code>$O(n)$</code>。在有序数组中查找时即便是最糟情况下所需的时间也只有<code>$O(\log n)$</code>，但这不意味着有序数组比二叉查找树更佳，因为二叉查找树的插入和删除操作的速度快的多：</p>
<p><img src="http://image.oldzhou.cn/FlF6aYs9sjSCCiJCpvBzZJ9C-WN-" alt=""></p>
<p>二叉树的查找的最大次数等同于二叉查找树的高度。</p>
<p>二叉查找树也有一些缺点：不能随机访问，并且如果二叉查找树处于失衡状态下，查找的性能会大打折扣，几乎变成了线性查找：</p>
<p><img src="http://image.oldzhou.cn/FiWlG9ksWIX1G_3GvJoiB8Ktmkxc" alt=""></p>
<p>如何解决二叉树多次插入新节点而导致的不平衡呢？可以使用红黑树来解决，红黑树（Red Black Tree）是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征之外，还有一系列的附加特性，通过每次插入新节点后的处理（变色、反转）来保证自身符合红黑树的附加特性，实现了自平衡</p>
<p><img src="http://image.oldzhou.cn/Fn_k5y9H71yf44EpwYgcjm95SYIp" alt=""></p>
<p><a href="https://zhuanlan.zhihu.com/p/31805309" target="_blank" rel="noopener">知乎这篇文章</a>讲解二叉查找树和红黑树讲的很好，通俗易懂。</p>
<h3 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h3><p>搜索引擎的工作原理就是使用反向索引这种数据结构：一个散列表，将单词映射到包含它的页面</p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>（1）傅立叶级数</p>
<p>傅立叶级数实际上就是把<code>$f(x)$</code>看作是圆周运动的组合。只是<code>$x$</code>是不断变大的，而不是绕着圆变换的，所以就画出了函数曲线：</p>
<p><img src="http://image.oldzhou.cn/Fqtw8x2bLAZf3bInFWPOy-ZLZwd6" alt=""></p>
<p>不断增大的<code>$x$</code>就好像是时间流逝，永不回头，所以我们也称为“时域”。</p>
<p>时域是现实存在的，频域却是生造的了，理解起来更加抽象。但频域是傅立叶级数（变换）更本质的内容。</p>
<p>傅里叶技术的一个典型应用就是图像压缩，哪些基上的坐标值特别小，就可以丢掉，这样就可以压缩图像，JPG就是利用傅里叶进行图片压缩的</p>
<p>（2）傅里叶变换</p>
<p>傅立叶级数是基于周期函数的，如果将周期推广到<code>$\infty$</code>，那么也就变为了非周期函数，这就是傅里叶变换</p>
<p>这部分的内容可以参考<a href="https://www.matongxue.com/madocs/473.html/" target="_blank" rel="noopener">如何通俗地理解傅立叶变换？</a>和<a href="https://www.matongxue.com/madocs/619.html" target="_blank" rel="noopener">如何理解傅立叶级数公式？</a></p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce是一种流行的分布式算法，可以通过流行的开源工具Apache Hadoop来是实现它。</p>
<blockquote>
<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。 </p>
<p>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p>
</blockquote>
<p>分布式算法非常实用用于在短时间内完成海量工作，其中的MapReduce基于两个简单的历年：映射（map）函数和归并（reduce）函数</p>
<p>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。映射函数是将一个数组转换为另一个数组。而归并函数的理念是将很多项归并为一项，将一个数组转换为一个函数</p>
<p>MapReduce是第一代计算引擎，Tez和Spark是第二代。MapReduce的设计，采用了很简化的计算模型，只有Map和Reduce两个计算过程（中间用Shuffle串联），用这个模型，已经可以处理大数据领域很大一部分问题了。</p>
<p>关于MapReduce的介绍可以看<a href="https://www.jianshu.com/p/094c5aab1fdb" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="布隆过滤器和HyperLogLog"><a href="#布隆过滤器和HyperLogLog" class="headerlink" title="布隆过滤器和HyperLogLog"></a>布隆过滤器和HyperLogLog</h3><p>布隆过滤器是为了解决在海量数据中查找某个键是否存在的技术，它是一种概率性型数据结构，提供的答案有可能不对，但很可能是正确的。</p>
<p>判断网页以前是否已搜集，可以不适用散列表，而是用布隆过滤器，它的优点在于占用的存储空间少，非常适合于不要求答案绝对准确的情况。</p>
<p>关于布隆过滤器的原理可以参考<a href="https://zhuanlan.zhihu.com/p/43263751/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>HyperLoglog是一种类似于布隆过滤器的算法。可以近似地计算集合中不同的元素数，提供不精确的去重计数，它也不能给出准确的答案，但是八九不离十，而占用的内存空间却少得多。关于HypoerLogLog的解释可以阅读<a href="https://juejin.im/post/5c7900bf518825407c7eafd0" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>上面的这两种都是概率算法，都要求允许统计巨量数据面前的误差范围可以接受。</p>
<h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>SHA函数（secure hash algorightm）是一种安全散列算（也就是哈希算法），给定一个字符串，SHA返回其散列值。</p>
<p>有两种应用：</p>
<p>（1）比较文件</p>
<p>对于不同的字符串，SHA生成的散列值不同，可以利用SHA来判断两个文件是否相同，在比较超大型文件时很有用，可以计算文件的SHA散列值，再对结果进行比较。</p>
<p>（2）检查密码</p>
<p>SHA能在不知道原始字符串的情况下进行比较，进行密码登陆时，不会直接存储密码，而是比较散列值。网站保存的不是原始密码，而是密码的散列值。</p>
<p>SHA散列算法是单项的，可以根据字符串计算散列值，但是无法根据散列值推出原始字符串。</p>
<p>SHA实际上是一系列散发：SHA-0/SHA-1/SHA-2/SHA-3，SHA-0和SHA-1被发现存在一些缺陷，应该使用SHA-2和SHA-3来计算密码散列值，最安全的散列函数是bcrypt。</p>
<p>关于各种散列算法的介绍可以阅读<a href="https://www.zhihu.com/appview/p/37165658" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="局部明暗的散列算法"><a href="#局部明暗的散列算法" class="headerlink" title="局部明暗的散列算法"></a>局部明暗的散列算法</h3><p>SHA算法是局部不敏感的，对一个字符串，如果只改动了其中一个字符，得到的两个散列值是完全不同的，这就让攻击者无法通过比较散列值是否类似来破解密码。</p>
<p>如果希望散列函数是局部明暗的，可以使用Simhash，对字符串进行细微的修改，Simhash生成的散列值也只存在细微的差别。这就可以通过比较散列值来比较两个字符串的相似程度，应用：</p>
<ul>
<li>Google来判断网页是否被收集</li>
<li>论文查重/资源查重</li>
</ul>
<p>需要检查两项内容的相似程度时，可以使用Simhash。</p>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换解决了两个问题：</p>
<ol>
<li>双方无序知道加密算法，不必会面协商使用的加密算法</li>
<li>破解加密非常困难</li>
</ol>
<p>使用了两个密钥：公钥和私钥。它的替代者是RSA，被广泛使用。</p>
<h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><p>线性规划用于在给定约束条件下最大限度的改善指定的指标。</p>
<p>所有的图算法都可以使用线性规划来实现，图问题知识线性规划的一个子集。</p>
<p>线性规划使用Simplex算法。</p>

      
    </div>

    
      


    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
  <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.jpg" alt="哆啦斯基周 wechat" style="width: 200px; max-width: 100%;">
  <div>我的公众号，看心情更新，欢迎订阅！</div>
</div>

      </div>
    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/19/01 前端笔记/07 零散专题/零散专题37 前端代码异常监控/" rel="next" title="零散专题37 前端代码异常监控">
                <i class="fa fa-chevron-left"></i> 零散专题37 前端代码异常监控
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/17/01 前端笔记/04 Vue/04 Vue Router/VueRouter02 导航守卫/" rel="prev" title="VueRouter02 导航守卫">
                VueRouter02 导航守卫 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar3.png" alt="哆啦斯基周">
            
              <p class="site-author-name" itemprop="name">哆啦斯基周</p>
              <p class="site-description motion-element" itemprop="description">一个大龄前端程序员的技术博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">142</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">195</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/duola8789" title="GitHub &rarr; https://github.com/duola8789" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:duola8789@126.com" title="E-Mail &rarr; mailto:duola8789@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://weibo.com/zhouhaozhouhao" title="Weibo &rarr; https://weibo.com/zhouhaozhouhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/duola8789" title="CSDN &rarr; https://blog.csdn.net/duola8789" rel="noopener" target="_blank"><i class="fa fa-fw fa-rss-square"></i></a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-算法简介"><span class="nav-number">1.</span> <span class="nav-text">第一章 算法简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">1.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时间"><span class="nav-number">1.2.</span> <span class="nav-text">运行时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大O表示法"><span class="nav-number">1.3.</span> <span class="nav-text">大O表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-选择排序"><span class="nav-number">2.</span> <span class="nav-text">第二章 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存的工作原理"><span class="nav-number">2.1.</span> <span class="nav-text">内存的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">2.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在中间插入元素"><span class="nav-number">2.4.</span> <span class="nav-text">在中间插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">2.5.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组和链表的比较"><span class="nav-number">2.6.</span> <span class="nav-text">数组和链表的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Facebook存储用户信息的方法"><span class="nav-number">2.7.</span> <span class="nav-text">Facebook存储用户信息的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">2.8.</span> <span class="nav-text">选择排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-递归"><span class="nav-number">3.</span> <span class="nav-text">第三章 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基线条件和递归条件"><span class="nav-number">3.1.</span> <span class="nav-text">基线条件和递归条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">3.2.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-快速排序"><span class="nav-number">4.</span> <span class="nav-text">第四章 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分治法"><span class="nav-number">4.1.</span> <span class="nav-text">分治法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">4.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再谈大-O-表示法"><span class="nav-number">4.3.</span> <span class="nav-text">再谈大$O$表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-散列表"><span class="nav-number">5.</span> <span class="nav-text">第五章 散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#散列函数"><span class="nav-number">5.1.</span> <span class="nav-text">散列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#散列表"><span class="nav-number">5.2.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">5.3.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-广度优先搜索（BFS"><span class="nav-number">6.</span> <span class="nav-text">第六章 广度优先搜索（BFS)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图算法"><span class="nav-number">6.1.</span> <span class="nav-text">图算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先搜索"><span class="nav-number">6.2.</span> <span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">6.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现算法"><span class="nav-number">6.4.</span> <span class="nav-text">实现算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时间-1"><span class="nav-number">6.5.</span> <span class="nav-text">运行时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-迪克斯特拉算法"><span class="nav-number">7.</span> <span class="nav-text">第七章 迪克斯特拉算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用迪克斯特拉算法"><span class="nav-number">7.1.</span> <span class="nav-text">使用迪克斯特拉算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负权边"><span class="nav-number">7.2.</span> <span class="nav-text">负权边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迪克斯特拉算法的实现"><span class="nav-number">7.3.</span> <span class="nav-text">迪克斯特拉算法的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-贪婪算法"><span class="nav-number">8.</span> <span class="nav-text">第八章 贪婪算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#教室调度问题"><span class="nav-number">8.1.</span> <span class="nav-text">教室调度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">8.2.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合覆盖问题"><span class="nav-number">8.3.</span> <span class="nav-text">集合覆盖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#近似算法"><span class="nav-number">8.4.</span> <span class="nav-text">近似算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NP完全问题"><span class="nav-number">8.5.</span> <span class="nav-text">NP完全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何识别NP完全问题"><span class="nav-number">8.6.</span> <span class="nav-text">如何识别NP完全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-动态规划"><span class="nav-number">9.</span> <span class="nav-text">第九章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题-1"><span class="nav-number">9.1.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以偷商品的一部分吗"><span class="nav-number">9.2.</span> <span class="nav-text">可以偷商品的一部分吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以相互依赖吗"><span class="nav-number">9.3.</span> <span class="nav-text">可以相互依赖吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子串"><span class="nav-number">9.4.</span> <span class="nav-text">最长公共子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">9.5.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">9.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十章-K最近邻算法"><span class="nav-number">10.</span> <span class="nav-text">第十章 K最近邻算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建推荐系统"><span class="nav-number">10.1.</span> <span class="nav-text">创建推荐系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习"><span class="nav-number">10.2.</span> <span class="nav-text">机器学习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十一章-接下来如何做"><span class="nav-number">11.</span> <span class="nav-text">第十一章 接下来如何做</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">11.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反向索引"><span class="nav-number">11.2.</span> <span class="nav-text">反向索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#傅里叶变换"><span class="nav-number">11.3.</span> <span class="nav-text">傅里叶变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce"><span class="nav-number">11.4.</span> <span class="nav-text">MapReduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布隆过滤器和HyperLogLog"><span class="nav-number">11.5.</span> <span class="nav-text">布隆过滤器和HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SHA算法"><span class="nav-number">11.6.</span> <span class="nav-text">SHA算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部明暗的散列算法"><span class="nav-number">11.7.</span> <span class="nav-text">局部明暗的散列算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diffie-Hellman密钥交换"><span class="nav-number">11.8.</span> <span class="nav-text">Diffie-Hellman密钥交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性规划"><span class="nav-number">11.9.</span> <span class="nav-text">线性规划</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">哆啦斯基周</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>








        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  




  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function (item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'Fg5UsXV9f7m1xb1SioXny6QN-gzGzoHsz',
    appKey: 'DLV7a4oTpQynJCIelKn3L7Ja',
    placeholder: '大侠留步，请留下您宝贵的意见',
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>



  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
