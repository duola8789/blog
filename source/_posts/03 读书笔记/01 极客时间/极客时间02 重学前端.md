---
title: 《重学前端》的学习笔记
top: false
date: 2019-01-18 10:41:13
tags:
- 极客时间
- 成长
categories: 读书笔记
---


极客时间的专栏[《重学前端》](https://time.geekbang.org/column/154)的学习笔记，持续更新中。

<!-- more -->


## 开篇词 | 从今天起，重新理解前端

前端开发之痛：散点自学 + 基础不牢，对于前端的知识体系和底层原理没有真正系统地理解

关于前端工程师成长需要两个视角：

（1）立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；

（2）放眼团队，从业务和工程角度思考前端团队的价值和发展需要。

除此之外，前端工程师还需要了解程序员通用的编程能力和架构能力。

## 01 | 明确你的前端学习路线与方法

两个前端学习方法：

（1）建立知识架构

将零散的知识组织起来，也能帮助我们发现知识上的误区

（2）追本溯源

关注某个知识点背后的体系

## 03 | HTML语义：div和span不是够用了吗？

语义类标签的特点是在视觉表现上都差不多，主要区别在于表示了不同的语义。

语义标签的好处：（1）增强网页结构可读性；（2）更适合SEO和读屏软件

语义标签用不好会造成大量的冗余标签，所以“用对”比“不用”好，“不用”比“用错”好

比较重要的语义标签适用场景：

（1）作为自然语言延伸的语义类标签，例如`<ruby>`、`<rt>`、`<rp>`

（2）作为消除歧义的标签，例如表示重音的`<em>`

（3）作为标题摘要的标签，例如`<h1>`、`<hgroup>`、`<section>`

（4）作为整体结构的语义类标签。例如`<header>`、`<footer>`、`<aside>`、`<address>`

```HTML
<body>
  <header>……</header>
  <article>
    <header>……</header>
    <section>……</section>
    <section>……</section>
    <section>……</section>
    <footer>……</footer>
  </article>
  <article>……</article>
  <article>……</article>
  <footer>
    <address></address>
  </footer>
</body>
```
## 04 | HTML语义：如何运用语义类标签来呈现Wiki网页？

用Wiki的[一个页面](https://en.wikipedia.org/wiki/World_Wide_Web)举例，学习了语义化标签的使用。

这一节介绍到的语义化标签有：

- `aside`，导航性质的工具内容
- `article`，有明确独立性的主体部分
- `hgroup`/`h1`/`h2`，一个标题组中的各级标题
- `abbr`，缩写的词语都应该使用`abbr`标签
- `hr`，横向分割线，但是表示故事走向或话题的转变，如果是单纯的视觉效果不应该使用这个标签
- `strong`，强调的
- `blockquote`，段逻辑的引述内容
- `q`，行内的引述内容
- `cite`，引述的作品名
- `time`，日期，让机器阅读更方便
- `figure`/`figcaption`，与著文章先骨干的、有一定自包含性的内容，都可以用`figure`包裹，可以是图片、表格、代码等，`figcaption`是这些内容的标题
- `dfn`，包裹被定义的名字，例如：`<dfn>程序员</dfn>就是写程序的人`
- `nav`，目录导航
- `ol`/`ul`，二者的区别是内容是否有顺序关系，不要因为视觉表现夏鸥改变语义
- `pre`，表示其中的内容是预先经过排版的，不需要浏览器干预排版（保留了原来的缩进格式）
- `samp`：计算机程序的实例输出
- `code`：代码，和`samp`一样，一般都是包裹在`pre`之中

还有一些其他的标签：
- `date`，类似于`time`，给及其阅读的内容
- `sub`/`sup`，下标/上标，多用于数学、物理、化学领域
- `menu`，`ul`的变体，用于功能菜单使用
- `main`，整个页面出现一个，表示页面的主要内容，可以理解为特殊的`div`

语义化标签非常多，并且不像严谨的编程语言一样，有一条非此即彼的线。一些语义的引入会带来争议，所以应该尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签，保证语义不被滥用，不带来更多问题。

## 05 | JavaScript类型的细节

### 类型

JavaScript中定义了7种类型：

- Undefined
- Null
- String
- Number
- Boolean
- Symbol
- Object

#### Undefined/Null

JavaScript中的`undefined`是一个变量，而非一个关键字。任何变量在赋值之前都是Undefined类型，值为`undefined`，是一个全局变量，所以有：

```JS
undefined === undefined; // true

let a;
let b;
a === b; // true
```

`void`运算的作用是将一个表达式变为`undefined`：

```JS
let a = void 0;
a; // undefined

let b = void {};
b; // undefined
```

一般不会将变量赋值为`undefined`，保证所有值为`undefined`的变量都是从未赋值的自然状态

Null类型也只有一个值`null`，所以有：

```JS
null === null; // true
```
Null语义是定义了，但是为空，这与Undefined是不同的

#### String

String的最大长度是`2^53-1`，这个长度指的不是字符数，而是字符串的编码长度

字符串操作`charAt`、`charCodeAt`、`length`针对的都是UTF16编码

UTF是Unicode的编码方式，一个Unicode码点表示一个字符，通常用`U+????`来表示，其中`????`是十六进制的码点值，0-65536（`U+0000`-`U+FFFF`的码点被称为基本字符区域

在JavaScript中的表示：

```JS
'\u0031'; // 1
```
JavaScript字符串把每个UTF16单元当做一个字符串来处理，所以处理超出自己字符区域的字符时需要格外小心。

感觉[阮一峰关于字符编码的知识](http://www.ruanyifeng.com/blog/2014/12/unicode.html)讲的更加详细。

#### Number

Number类型符合IEEE754-2008规定的双精度浮点数规则，但是为了表达几个额外的语言场景，规定了几个例外情况

- `NaN`
- `Infinity`，无穷大
- `-Infinity`，负无穷大

`Infinity`和`-Infinity`是为了不让除以`0`出错而引入的

JavaScript中有`0`和`-0`的区别，加法类运算没有区别，除法场合需要留意区分，区分的方式就是检测用作除数的结果，是`Infinity`还是`-Infinity`

```JS
1/-0 ===-Infinity; // true
1/0 ===Infinity; // true
```

由于浮点数运算的精度问题，导致非整数得Number不能直接比较：

```JS
0.1 + 0.2 === 0.3 // false
```
正确的比较方法是使用JavaScript提供的最小精度之`Number.EPSILION`

```JS
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILION // ture
```
==检查等式左右两边的差是否小于最小精度==，才是正确的比较浮点数的方法。

#### Symbol

Symbol是一切非字符串的类型`key`的集合，使用全局的`Symbol`函数创建Symbol

```JS
var mySymbol = Symbol("my symbol");
```
一些特殊的属性可以在全局的Symbol函数的属性中找到，比如可迭代对象的迭代器就定义在了`Symbol.iterator`属性上

```JS
let o = {};

o[Symbol.iterator] = function* () {
  let index = 0;
  while(index < 10) {
    yield index++
  }
};

for(let i of o) {
  console.log(i)
}
// 0 1 2 3 ... 9
```
更多的内容需要专门学习。

#### Object

提出了一个问题，为什么给对象添加的方法能够用在基本类型上？


```JS
Number.prototype.say = function () {
  console.log(123)
};
(123).say(); // 123
```
==这是因为`.`运算符提供了封箱操作，它会根据基本类型构造一个临时对象，使得我们能够在基本类型上调用对应的对象的方法。==

### 类型转换

#### 封箱转换

把基本类型转换为对应的对象，装箱独享都有私有的`Class`属性，可以用`Object.prototype.toString`来获取。

JavaScript中没有任何办法可以更改私有的`class`属性，因此`Object.prototype.toString`是可以准确识别对象对应的基本类型的方法

#### 拆箱转换

`ToPrimitive`函数是对象类型到基本类型的转换，对象到String和Number的转换都遵循“先拆箱再转换”的规则，拆箱转换会调用`valueOf`和`toString`类获得拆箱后的基本类型

转换为数字时首先调用`valueOf`，转换为字符串时首先调用`toString`

ES6中可以通过显示指定`Symbol.toPrimitive`来覆盖原有行为

