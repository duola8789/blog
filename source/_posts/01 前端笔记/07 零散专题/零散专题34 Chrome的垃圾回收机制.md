---
title: 零散专题34 Chrome的垃圾回收机制
top: false
date: 2019-07-03 10:47:00
updated: 2019-07-03 10:47:00
tags: 
- Chrome
- 垃圾回收
categories: 零散专题
---

Chrome的垃圾回收机制，学习笔记。

<!-- more -->

## 手动回收？

ECMAScript没有暴露任何垃圾回收期的接口，所以开发者没有办法手动进行强制的垃圾回收，也没有办法干预内存管理。

在多达数情况下，开发者也没有必要手动解除对象的引用，只要简单地把变量放在他们应该的地方（局部变量），垃圾就能正确被回收

## V8的内存分配

当声明变量并赋值时，V8就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量，V8就会继续申请，直到堆的大小到了V8的内存上限为止。

堆内存分为两种分配方式：

1. 静态分配，全局变量、函数之类的分配方式，它们在页面没有关闭之前，是不会被清除的
2. 动态分配，使用`new`创建出来的，主动要求给分配空间的


## 经验法则

为了使Chrome的垃圾回收器不保留不再需要的对象，有几点需要牢记：

1. 在恰当的作用域中使用变量，尽量在函数作用于中声明变量，尽量声明局部变量，尽量避免全局变量
2. 确保移除不再需要的事件监听器，比如即将被移除的DOM对象所绑定的事件
3. 避免缓存大量不会被重用的数据
4. 少用闭包

## 常驻内存的写法

（1）全局变量，全局变量会常驻内存，除非刷新页面、离开页面时才会被清理

（2）对象引用

```JS
function ob(){
  var bar  = new largeObject(); //很大一个对象\变量\字符串
  bar.someCall();
  return bar;
}

var a = new ob();
```
现在有一个指向`bar`对象的引用，当`ob`调用结束后，`bar`对象不会被回收，直到变量`a`分配其他引用（或者`a`超出了作用域范围）。

（3）DOM事件，即使DOM元素被移除，其绑定的事件不会被回收，除非使用`removeEventListener`显式的移除事件

（4）定时器，除非显式的清楚定时器

## 参考

- [chrome v8引擎以及垃圾回收机制（原创）@掘金](https://juejin.im/post/5abb637f5188255c620f23ac)
